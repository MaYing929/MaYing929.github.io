<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>DomContentLoaded 与 load</title>
    <url>/2018/03/30/DomContentLoaded%20%E4%B8%8E%20load/</url>
    <content><![CDATA[<h2 id="浏览器渲染原理"><a href="#浏览器渲染原理" class="headerlink" title="浏览器渲染原理"></a>浏览器渲染原理</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">当我们在浏览器地址输入url时，浏览器会发送请求到服务器，服务器将请求的html文档发送回浏览器，浏览器将文档下载下来后 便开始从上到下解析，解析完成后 会生成dom，如果页面中有css 会根据css的内容 形成cssdom 然后 dom和css会生成一个渲染树 最后浏览器会根据渲染树的内容计算出各个节点在页面中的确切大小和位置，并将其绘制在浏览器上</span><br></pre></td></tr></tbody></table></figure>
<p><img src="http://oucjferwh.bkt.clouddn.com/746387-20170407181220066-2064922697.png"></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">在解析html的过程中 有时候解析会被中断，这是因为javascript会阻塞dom的解析 当解析过程中遇到script标签的时候 便会停止解析过程 抓转而去处理脚本 如果脚本是内联的 浏览器会先去执行这段内联的脚本，如果脚本是外链的  那么先去加载脚本 然后执行 在处理完脚本之后  浏览器便继续解析html文档</span><br></pre></td></tr></tbody></table></figure>
<h3 id="如何计算DomContentLoaded-加载时间"><a href="#如何计算DomContentLoaded-加载时间" class="headerlink" title="如何计算DomContentLoaded 加载时间"></a>如何计算 DomContentLoaded 加载时间</h3><p>当文档中没有脚本时 浏览器解析完成文档便能触发 DomContentLoaded 事件 如果文档包含脚本 则脚本会阻塞文档的解析 而脚本需要等位于前面的 css 加载完才能执行 在任何情况下  DomContentLoaded 的触发不需要等待图片等其他资源加载完成</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">DOMContentLoaded不同的浏览器对其支持不同，所以在实现的时候我们需要做不同浏览器的兼容。</span><br><span class="line"></span><br><span class="line">1）支持DOMContentLoaded事件的，就使用DOMContentLoaded事件；</span><br><span class="line"></span><br><span class="line">2）IE6、IE7不支持DOMContentLoaded，但它支持onreadystatechange事件，该事件的目的是提供与文档或元素的加载状态有关的信息。</span><br><span class="line"></span><br><span class="line">1) 更低的ie还有个特有的方法doScroll， 通过间隔调用：document.documentElement.doScroll("left");</span><br><span class="line">可以检测DOM是否加载完成。 当页面未加载完成时，该方法会报错，直到doScroll不再报错时，就代表DOM加载完成了。该方法更接近DOMContentLoaded的实现。</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h3 id="如何计算load-加载时间"><a href="#如何计算load-加载时间" class="headerlink" title="如何计算load 加载时间"></a>如何计算 load 加载时间</h3><p>页面上所有的资源（图片，音频，视频等）被加载以后才会触发 load 事件，简单来说，页面的 load 事件会在 DOMContentLoaded 被触发之后才触发。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">window.onload = function(){</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="我们为什么一再强调将CSS放在头部-将js放在尾部"><a href="#我们为什么一再强调将CSS放在头部-将js放在尾部" class="headerlink" title="我们为什么一再强调将CSS放在头部 将js放在尾部"></a>我们为什么一再强调将 CSS 放在头部 将 js 放在尾部</h3><p>因为浏览器生成 Dom 树的时候是一行一行读 html 代码的  script 标签放在最后面就不会影响前面的页面渲染，那么问题来了<br>既然 Dom 树完全生成好页面才能渲染出来 浏览器又必须读完全部的 html 才能生成完成的 dom 树 script 标签放不放在底部是不是也一样 因为 dom 树的生成需要整个文档解析完成</p>
<p><font color="red">chrome 页面渲染过程中 会有 firstpaint 的概念，现代浏览器为了更好的用户体验，渲染引擎将尝试尽快在屏幕上显示的内容 他不会等到所有的 html 解析完成才开始构建和布局 dom 树 部分的内容被解析并展示 也就是说 浏览器能够渲染不完整的 dom 树和 cssdom 尽快的减少白屏时间<br></font></p>
<p>假如我们将 js 放在 header js 将会阻塞解析 dom dom 的内容会影响到 firstpaint 导致 firstpaint 延后 所以说我们会将 js 放在后面 以减少 firstpaint 时间但是不会减少 DomContentLoaded 被触发的时间</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title>Express 框架系列 (一) 之概述</title>
    <url>/2017/04/17/Express%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97(%E4%B8%80)%E4%B9%8B%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>参考文档：<a href="http://javascript.ruanyifeng.com/nodejs/express.html">http://javascript.ruanyifeng.com/nodejs/express.html</a><br>Express 是目前最流行的基于 Node.js 的 Web 开发框架，可以快速地搭建一个完整功能的网站。</p>
<p>创建测试项目<br><code>mkdir hello-world</code></p>
<p>进入该目录，新建一个 package.json 文件，内容如下。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">  "name": "hello-world",</span><br><span class="line">  "description": "hello world test app",</span><br><span class="line">  "version": "0.0.1",</span><br><span class="line">  "private": true,</span><br><span class="line">  "dependencies": {</span><br><span class="line">    "express": "4.x"</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>安装 express<br><code>npm install</code><br>执行上面的命令以后，在项目根目录下，新建一个启动文件，假定叫做 <code>index.js。</code></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var express = require('express');</span><br><span class="line">var app = express();</span><br><span class="line"></span><br><span class="line">app.use(express.static(__dirname + '/public'));</span><br><span class="line"></span><br><span class="line">app.listen(8080);</span><br></pre></td></tr></tbody></table></figure>
<p>运行启动脚本<br><code>node index</code><br>访问 <a href="http://localhost:8080/">http://localhost:8080</a><br>它会在浏览器中打开当前目录的 <strong>public</strong> 子目录（严格来说，是打开 public 目录的 index.html 文件）。如果 public 目录之中有一个图片文件 my_image.png，那么可以用 <a href="http://localhost:8080/my_image.png%E8%AE%BF%E9%97%AE%E8%AF%A5%E6%96%87%E4%BB%B6%E3%80%82">http://localhost:8080/my_image.png 访问该文件。</a></p>
<p>目录结构<br><img src="media/14906850474605/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-28%20%E4%B8%8B%E5%8D%883.55.13.png" alt="屏幕快照 2017-03-28 下午3.55.13"></p>
<p>执行结果<br><img src="media/14906850474605/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-28%20%E4%B8%8B%E5%8D%883.54.14.png" alt="屏幕快照 2017-03-28 下午3.54.14"><br>也可以 <a href="http://localhost:8080/WX.jpeg">http://localhost:8080/WX.jpeg</a></p>
<p>也可以生成动态网页</p>
<figure class="highlight plain"><figcaption><span>express </span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">var app = express();</span><br><span class="line">app.get('/', function (req, res) {</span><br><span class="line">  res.send('Hello world!');</span><br><span class="line">});</span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></tbody></table></figure>
<p> 运行启动脚本<br><code>node index</code></p>
<p><img src="media/14906850474605/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-28%20%E4%B8%8B%E5%8D%883.57.07.png" alt="屏幕快照 2017-03-28 下午3.57.07"></p>
<p>启动脚本 index.js 的 <strong>app.get</strong> 方法，用于指定不同的访问路径所对应的回调函数，这叫做 “<strong>路由</strong>”（routing）。上面代码只指定了根目录的回调函数，因此只有一个路由记录。实际应用中，可能有多个路由记录。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">比如：</span><br><span class="line">var express = require('express');</span><br><span class="line">var app = express();</span><br><span class="line"></span><br><span class="line">app.get('/', function (req, res) {</span><br><span class="line">  res.send('Hello world!');</span><br><span class="line">});</span><br><span class="line">app.get('/customer', function(req, res){</span><br><span class="line">  res.send('customer page');</span><br><span class="line">});</span><br><span class="line">app.get('/admin', function(req, res){</span><br><span class="line">  res.send('admin page');</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">app.listen(3000);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>比较庞大的时候可以单独存放<br>eg：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// routes/index.js</span><br><span class="line"></span><br><span class="line">module.exports = function (app) {</span><br><span class="line">  app.get('/', function (req, res) {</span><br><span class="line">    res.send('Hello world');</span><br><span class="line">  });</span><br><span class="line">  app.get('/customer', function(req, res){</span><br><span class="line">    res.send('customer page');</span><br><span class="line">  });</span><br><span class="line">  app.get('/admin', function(req, res){</span><br><span class="line">    res.send('admin page');</span><br><span class="line">  });</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>原先的 index 引入</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// index.js</span><br><span class="line">var express = require('express');</span><br><span class="line">var app = express();</span><br><span class="line">var routes = require('./routes')(app);</span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建服务器亲自体验跨域</title>
    <url>/2019/01/18/COR/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>跨域这两个字就像狗皮膏药一样儿粘在每一个前端 er 身上 我遇见了很多开发者一般都是为了应付面试 随便背几个方案 知道概念 但是不知道为什么要这么干<br>到了真正的工作 开发环境有 <code>webpack-dev-server </code>搞定 线上有运维大哥会配好，配什么我不管 反正不会跨域就是了<br>但是.. 这样儿混日子 你的良心不会痛吗？</p>
<p>痛定思痛 决心不定时更新 不要再问我 XX 的问题系列 之 <font color="red">不要再问我跨域的问题了</font></p>
<p>其实团队的小伙伴分享过类似的 但是不动手试一下 跟你面试前的死记硬背本质上没有任何区别</p>
<a id="more"></a>
<h2 id="你需要了解的几个概念"><a href="#你需要了解的几个概念" class="headerlink" title="你需要了解的几个概念"></a>你需要了解的几个概念</h2><ul>
<li>什么是跨域？</li>
</ul>
<p><strong>官方解释</strong><br>跨域资源共享 (CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器  让运行在一个 origin (domain) 上的 Web 应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。</p>
<p>比如，站点 <a href="http://domain-a.com/">http://domain-a.com</a> 的某 HTML 页面通过 <img> 的 src 请求 <a href="http://domain-b.com/image.jpg%E3%80%82%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E8%AE%B8%E5%A4%9A%E9%A1%B5%E9%9D%A2%E9%83%BD%E4%BC%9A%E5%8A%A0%E8%BD%BD%E6%9D%A5%E8%87%AA%E4%B8%8D%E5%90%8C%E5%9F%9F%E7%9A%84CSS%E6%A0%B7%E5%BC%8F%E8%A1%A8%EF%BC%8C%E5%9B%BE%E5%83%8F%E5%92%8C%E8%84%9A%E6%9C%AC%E7%AD%89%E8%B5%84%E6%BA%90%E3%80%82">http://domain-b.com/image.jpg。网络上的许多页面都会加载来自不同域的 CSS 样式表，图像和脚本等资源。</a></p>
<ul>
<li>为什么会产生跨域？</li>
</ul>
<p><font color="red">出于安全原因，浏览器限制从脚本内发起的跨源 HTTP 请求（也可能跨站请求可以正常发起，但是返回结果被浏览器拦截了）</font></p>
<p>跨域的产生来源于现代浏览器所通用的<code>同源策略</code>，所谓同源是指 <code>"协议+域名+端口"</code> 三者相同的情况下，才允许访问相同的 <code>cookie</code>、<code>localStorage</code> 或是发送 <code>Ajax</code> 请求等等</p>
<p><strong>常见的跨域场景</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">URL                                      说明                    是否允许通信</span><br><span class="line">http://www.domain.com/a.js</span><br><span class="line">http://www.domain.com/b.js         同一域名，不同文件或路径           允许</span><br><span class="line">http://www.domain.com/lab/c.js</span><br><span class="line"></span><br><span class="line">http://www.domain.com:8000/a.js</span><br><span class="line">http://www.domain.com/b.js         同一域名，不同端口                不允许</span><br><span class="line"> </span><br><span class="line">http://www.domain.com/a.js</span><br><span class="line">https://www.domain.com/b.js        同一域名，不同协议                不允许</span><br><span class="line"> </span><br><span class="line">http://www.domain.com/a.js</span><br><span class="line">http://192.168.4.12/b.js           域名和域名对应相同ip              不允许</span><br><span class="line"> </span><br><span class="line">http://www.domain.com/a.js</span><br><span class="line">http://x.domain.com/b.js           主域相同，子域不同                不允许</span><br><span class="line">http://domain.com/c.js</span><br><span class="line"> </span><br><span class="line">http://www.domain1.com/a.js</span><br><span class="line">http://www.domain2.com/b.js        不同域名                         不允许</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>现代的跨域解决方案</li>
</ul>
<ol>
<li>通过 jsonp 跨域</li>
<li> document.domain + iframe 跨域</li>
<li> location.hash + iframe</li>
<li>window.name + iframe 跨域</li>
<li> postMessage 跨域</li>
<li><font color="red">跨域资源共享（CORS）</font></li>
<li>nginx 代理跨域</li>
<li> nodejs 中间件代理跨域</li>
<li> WebSocket 协议跨域</li>
</ol>
<h2 id="搭建服务尝试还原跨域过程"><a href="#搭建服务尝试还原跨域过程" class="headerlink" title="搭建服务尝试还原跨域过程"></a>搭建服务尝试还原跨域过程</h2><p><strong>通过 koa 搭建两个本地 server 两个 server 都定义了一个 GET 请求接口 /ajax。除监听 port 不同外，app.js 还设置了静态服务。</strong></p>
<p><img src="/images/cors/koa1.png" alt="koa1"></p>
<p><strong>app.js port:8000</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const Koa = require('koa');</span><br><span class="line">const app = new Koa();</span><br><span class="line">const index = require('./routes/index')</span><br><span class="line">const views = require('koa-views')</span><br><span class="line">const serve = require('koa-static');</span><br><span class="line">const path = require('path');</span><br><span class="line"></span><br><span class="line">// 引入静态资源</span><br><span class="line">const staticPath = path.resolve(__dirname, '/public');</span><br><span class="line"></span><br><span class="line">// 设置静态服务</span><br><span class="line">const staticServe = serve(staticPath, {</span><br><span class="line">  setHeaders: (res, path, stats) =&gt; {</span><br><span class="line">    if (path.indexOf('jpg') &gt; -1) {</span><br><span class="line">      res.setHeader('Cache-Control', ['private', 'max-age=60']);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">app.use(staticServe);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 增加模版引擎 默认直接渲染html文件</span><br><span class="line">app.use(views(__dirname + '/views'));</span><br><span class="line">// 引入路由配置文件</span><br><span class="line">app.use(index.routes(), index.allowedMethods())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">router.get('/ajax', async (ctx, next) =&gt; {</span><br><span class="line">  console.log('get request', ctx.request.header.referer);</span><br><span class="line">  ctx.body = 'received';</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">app.listen(8000,()=&gt;{</span><br><span class="line">     console.log('app1 server is listening port 8000');</span><br><span class="line">});</span><br><span class="line">console.log('demo in run.....')</span><br><span class="line"></span><br><span class="line">// route.js</span><br><span class="line"></span><br><span class="line"> router.get('/ajax', async (ctx, next) =&gt; {</span><br><span class="line">    console.log('get request', ctx.request.header.referer);</span><br><span class="line">    ctx.body = 'received';</span><br><span class="line">  });</span><br><span class="line">  </span><br></pre></td></tr></tbody></table></figure>
<p><strong>app2.js port:3000</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const koa = require('koa');</span><br><span class="line">const app = new koa();</span><br><span class="line">const app2Route = require('./routes/app2Route')</span><br><span class="line">const cors = require('koa2-cors');</span><br><span class="line"></span><br><span class="line">app.use(app2Route.routes(), app2Route.allowedMethods())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const main = async function(ctx,next) {</span><br><span class="line">    ctx.response.body = '3000端口';</span><br><span class="line">await next();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">app.use(main)</span><br><span class="line"></span><br><span class="line">app.listen(3000);</span><br><span class="line">console.log('app2 server is listening port 3000');</span><br><span class="line"></span><br><span class="line">// route.js</span><br><span class="line"></span><br><span class="line"> router.get('/ajax', async (ctx, next) =&gt; {</span><br><span class="line">    console.log('get request', ctx.request.header.referer);</span><br><span class="line">    ctx.body = 'received';</span><br><span class="line">  });</span><br></pre></td></tr></tbody></table></figure>
<p><strong>前端模版</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang="en"&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset="UTF-8"&gt;</span><br><span class="line">  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;</span><br><span class="line">  &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;</span><br><span class="line">  &lt;title&gt;cross-origin test&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body style="width: 600px; margin: 200px auto; text-align: center"&gt;</span><br><span class="line">  &lt;button onclick="getAjax()"&gt;GET 简单请求&lt;/button&gt;</span><br><span class="line">  &lt;button onclick="getJsonP()"&gt;JSONP&lt;/button&gt;</span><br><span class="line">  &lt;button onclick="corsWithJson()"&gt;POST 非简单请求&lt;/button&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script src="http://code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type="text/javascript"&gt;</span><br><span class="line"></span><br><span class="line">  var baseUrl = 'http://localhost:3000';</span><br><span class="line">function getAjax() {</span><br><span class="line">    var xhr = new XMLHttpRequest();            </span><br><span class="line">    xhr.open('GET',  baseUrl + '/ajax', true);</span><br><span class="line">    xhr.onreadystatechange = function() {</span><br><span class="line">      // readyState == 4说明请求已完成</span><br><span class="line">      if (xhr.readyState == 4 &amp;&amp; xhr.status == 200 || xhr.status == 304) { </span><br><span class="line">        // 从服务器获得数据  </span><br><span class="line">        alert(xhr.responseText);</span><br><span class="line">      } else {</span><br><span class="line">        console.log(xhr.status);</span><br><span class="line">      }</span><br><span class="line">    };</span><br><span class="line">    xhr.send();</span><br><span class="line">  }</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>很简单 大概长这样儿</p>
<p><img src="/images/cors/koa2.png" alt="koa2"></p>
<p><strong>AJAX</strong></p>
<p>测试 case</p>
<ol>
<li><p>同域下请求 ajax 不涉及跨域</p>
<p>请求接口：<code>baseUrl = 'http://localhost:8000';</code><br>测试结果👇<br><img src="/images/cors/koa3.png" alt="koa3"></p>
</li>
</ol>
<ol start="2">
<li>跨域 ajax 请求<br>请求接口：<code>baseUrl = 'http://localhost:3000';</code><br>测试结果👇<br><img src="/images/cors/koa4.png" alt="koa4"><br>很明显 跨域了</li>
</ol>
<h3 id="针对浏览器的Ajax请求跨域的主要解决方案有：JSONP、CORS。"><a href="#针对浏览器的Ajax请求跨域的主要解决方案有：JSONP、CORS。" class="headerlink" title="针对浏览器的Ajax请求跨域的主要解决方案有：JSONP、CORS。"></a>针对浏览器的 Ajax 请求跨域的主要解决方案有：JSONP、CORS。</h3><ul>
<li><p><strong>JSONP</strong></p>
<p>  <font color="red">原理</font></p>
<p>  虽然浏览器同源策略限制了 XMLHttpRequest 请求不同域上的数据。但是，在页面上引入不同域的 js 脚本是可以的，而且 script 元素请求的脚本会被浏览器直接运行</p>
<p>  <font color="red">测试</font></p>
<p>  <code>origin.html</code> 添加</p>
</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">  function getJsonP() {</span><br><span class="line">    var script = document.createElement('script');</span><br><span class="line">    script.src = baseUrl + '/jsonp?type=json&amp;callback=onBack';</span><br><span class="line">    document.head.appendChild(script);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">function onBack(res) {</span><br><span class="line">    alert('JSONP CALLBACK:  ' + JSON.stringify(res) + ''); </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>getJsonP 方法会在当前页面添加一个 script，src 属性指向跨域的 GET 请求<br>通过 query 格式带上请求的参数。callback 是关键，用于定义跨域请求回调的函数名称，这个值必须后台和脚本保持一致</p>
<p>在 <code>app2.js</code> 添加路由</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">router.get('/jsonp', async (ctx, next) =&gt; {</span><br><span class="line">  const req = ctx.request.query;</span><br><span class="line">  console.log(req);</span><br><span class="line">  const data = {</span><br><span class="line">    data: req.type</span><br><span class="line">  }</span><br><span class="line">  ctx.body = req.callback + '('+ JSON.stringify(data) +')';</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">app.use(router.routes());</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>针对 jsonp 请求，后台要做的是：</p>
<p>获取请求参数中的 callback 值，如本例中的 onBack<br>将 callback 的值以 function (args) 的格式作为 response。</p>
<p>重启服务 触发页面的 <code>JSONP</code>🔘<br><img src="/images/cors/koa5.png" alt="koa5"></p>
<p><font color="red">优点</font><br>JSONP 方案的兼容性好，IE 浏览器也支持。</p>
<p><font color="red">缺点</font></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">因为是利用的&lt;script&gt;元素，所以只支持GET请求。</span><br><span class="line">缺乏错误处理机制</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>CORS</li>
</ul>
<p>CORS 即跨域资源分享，是 W3C 制定的标准。</p>
<ol>
<li>特性<br>CORS 需要浏览器和服务器同时支持。</li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">大多主流浏览器都支持，IE 10以下不支持。</span><br><span class="line">只要服务器端实现了CORS接口，浏览器就能自动实现基于CORS的跨域请求。</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li>两种请求</li>
</ol>
<p>浏览器将 CORS 请求分成两类：简单请求和非简单请求。</p>
<ul>
<li>简单请求<br>满足条件：请求类型为 <font color="red"><code>HEAD，GET，POST之一</code></font>；<br>请求头信息不超出以下几种：</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Accept</span><br><span class="line">Accept-Language</span><br><span class="line">Content-Language</span><br><span class="line">Last-Event-ID</span><br><span class="line">Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</span><br></pre></td></tr></tbody></table></figure>
<p>对于简单请求，浏览器会直接发出，同时在请求头中添加 Origin 字段。</p>
<p>Origin 用来说明请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。<br>如果 Origin 指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含 Access-Control-Allow-Origin 字段（详见下文），就知道出错了，从而抛出一个错误，被 XMLHttpRequest 的 onerror 回调函数捕获。注意，这种错误无法通过状态码识别，因为 HTTP 回应的状态码有可能是 200。</p>
<p>回顾下直接 Ajax 测试跨域的请求报文：</p>
<p><img src="/images/cors/koa6.png" alt="koa6"><br>浏览器为这个简单的 GET 请求添加了 Origin，而响应头信息中没有 Access-Control-Allow-Origin，浏览器判断请求跨域，给出错误提示。</p>
<ul>
<li>非简单请求</li>
</ul>
<p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是 PUT 或 DELETE，或者 Content-Type 字段的类型是 application/json。</p>
<p>非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为” 预检” 请求（preflight）。</p>
<p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的 XMLHttpRequest 请求，否则就报错。</p>
<p>在<font color="red"> origin.html</font> 中添加一个 post 请求：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">function corsWithJson() {</span><br><span class="line">    $.ajax({</span><br><span class="line">      url: baseUrl + '/cors',</span><br><span class="line">      type: 'post',</span><br><span class="line">      contentType: 'application/json',</span><br><span class="line">      data: {</span><br><span class="line">        type: 'json',</span><br><span class="line">      },</span><br><span class="line">      success: function(data) {</span><br><span class="line">        console.log(data);</span><br><span class="line">      }</span><br><span class="line">    })</span><br><span class="line">  }</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>通过设置 Content-Type 为 appliaction/json 使其成为非简单请求：</p>
<p>启动服务<br><img src="/images/cors/koa7.png" alt="koa7"><br>“预检” 请求的方法为 OPTIONS，服务器判断 Origin 为跨域</p>
<p>除了 Origin 字段，” 预检” 请求的头信息包括两个特殊字段。</p>
<p>（1）<strong>Access-Control-Request-Method</strong><br>该字段是必须的，用来列出浏览器的 CORS 请求会用到哪些 HTTP 方法，上例是 PUT。<br>（2）<strong>Access-Control-Request-Headers</strong><br>该字段是一个逗号分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段，上例是 content-type。</p>
<p><font color="red">服务端设置 CORS</font></p>
<p>在 app2.js 引入 koa2-cors：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">app.use(cors({</span><br><span class="line">  origin: function (ctx) {</span><br><span class="line">      if (ctx.url === '/cors') {</span><br><span class="line">          return "*"; // 允许来自所有域名请求</span><br><span class="line">      }</span><br><span class="line">      return 'http://localhost:3201';</span><br><span class="line">  },</span><br><span class="line">  exposeHeaders: ['WWW-Authenticate', 'Server-Authorization'],</span><br><span class="line">  maxAge: 5,</span><br><span class="line">  credentials: true,</span><br><span class="line">  allowMethods: ['GET', 'POST', 'DELETE'], //设置允许的HTTP请求类型</span><br><span class="line">  allowHeaders: ['Content-Type', 'Authorization', 'Accept'],</span><br><span class="line">}));</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>重启服务后，浏览器重新发送 POST 请求。可以看到浏览器发送了两次请求。</p>
<p><img src="/images/cors/koa8.png" alt="koa8"></p>
<p>（1）<strong>Access-Control-Allow-Methods</strong><br>该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次” 预检” 请求。<br>（2）<strong>Access-Control-Allow-Headers</strong><br>如果浏览器请求包括 Access-Control-Request-Headers 字段，则 Access-Control-Allow-Headers 字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在” 预检” 中请求的字段。<br>（3）<strong>Access-Control-Allow-Credentials</strong><br>该字段可选。它的值是一个布尔值，表示是否允许发送 Cookie。默认情况下，Cookie 不包括在 CORS 请求之中。设为 true，即表示服务器明确许可，Cookie 可以包含在请求中，一起发给服务器。这个值也只能设为 true，如果服务器不要浏览器发送 Cookie，删除该字段即可。<br>（4）<strong>Access-Control-Max-Age</strong><br>该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是 20 天（1728000 秒），即允许缓存该条回应 1728000 秒（即 20 天），在此期间，不用发出另一条预检请求。</p>
<p>现在为止 默认你已经完全理解跨域了哦</p>
<p>示例中的源代码</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>CORS</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6 系列 (一)</title>
    <url>/2017/04/20/ES6/</url>
    <content><![CDATA[<p><strong>数组的扩展</strong><br>Array.form () 将两类对象转换为数组<br>1. 类似数组的对象<br>2. 可遍历的对象</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">let arrayLike = {</span><br><span class="line">'0':'a',</span><br><span class="line">'1':'b',</span><br><span class="line">'2':'c',</span><br><span class="line">'3':'d'</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>ES5 写法</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var arr1 = [].slice.call(arrayLike)</span><br></pre></td></tr></tbody></table></figure>
<p>ES6 写法</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">let arr2 = Array.form(arrayLike)</span><br></pre></td></tr></tbody></table></figure>

<p>任何有 length 属性的对象，都可以通过 Array.from 方法转为数组，而此时扩展运算符就无法转换。</p>
<p>值得提醒的是，扩展运算符（…）也可以将某些数据结构转为数组。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// arguments对象</span><br><span class="line">function foo() {</span><br><span class="line">  var args = [...arguments];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// NodeList对象</span><br><span class="line">[...document.querySelectorAll('div')]</span><br><span class="line"></span><br><span class="line">Array.from还可以接受第二个参数，作用类似于数组的map方法</span><br><span class="line"></span><br><span class="line">Array.from(arrayLike, x =&gt; x * x);</span><br><span class="line">// 等同于</span><br><span class="line">Array.from(arrayLike).map(x =&gt; x * x);</span><br><span class="line"></span><br><span class="line">Array.of()</span><br><span class="line">Array.of方法用于将一组值，转换为数组。</span><br><span class="line"></span><br><span class="line">Array.of(3, 11, 8) // [3,11,8]</span><br><span class="line">Array.of(3) // [3]</span><br><span class="line">Array.of(3).length // 1</span><br><span class="line"></span><br><span class="line">[1, 5, 10, 15].find(function(value, index, arr) {</span><br><span class="line">  return value &gt; 9;</span><br><span class="line">}) // 10</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>fill 方法使用给定值，填充一个数组。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">['a', 'b', 'c'].fill(7)</span><br></pre></td></tr></tbody></table></figure>

<p>ES6 提供三个新的方法 ——<strong>entries()**，</strong>keys() <strong>和</strong> values ()**—— 用于遍历数组</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[1, 2, 3].includes(2);     // true</span><br></pre></td></tr></tbody></table></figure>
<p><strong>for of 循环</strong></p>
<p>ES6 引入 rest 参数（形式为 “… 变量名”），用于获取函数的多余参数</p>
<p>扩展运算符（spread）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。<br>console.log(…[1, 2, 3])<br>// 1 2 3</p>
<p>函数的 name 属性，返回该函数的函数名。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">function foo() {}</span><br><span class="line">foo.name // "foo"</span><br></pre></td></tr></tbody></table></figure>



<p><font face="STCAIYUN" color="red" size="4">（1）函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。</font></p>
<p>对象的扩展<br>var bax= {bac} = var baz = {bac:bac}</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var o = {</span><br><span class="line">method:function(){}</span><br><span class="line">} ==</span><br><span class="line">var o = {</span><br><span class="line"> method(){}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>let propKey = ‘foo’;</p>
<p>let obj = {<br>  [propKey]: true,<br>  [‘a’ + ‘bc’]: 123<br>};</p>
<p>const person = {<br>  sayName() {<br>    console.log(‘hello!’);<br>  },<br>};</p>
<p>person.sayName.name   // “sayName”</p>
<p>Object.is（）用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Object.is('foo', 'foo')</span><br><span class="line">// true</span><br><span class="line">Object.is({}, {})</span><br><span class="line">// false</span><br><span class="line"></span><br><span class="line">不同之处只有两个：一是+0不等于-0，二是NaN等于自身</span><br></pre></td></tr></tbody></table></figure>


<p><font face="STCAIYUN" color="green" size="4">Object.is(+0, -0) // false<br></font></p>
<p><font face="STCAIYUN" color="blue" size="4">Object.is(NaN, NaN) // true<br></font></p>
<p>Object.assign () 实行的是<font face="STCAIYUN" color="red" size="4">浅拷贝不是深拷贝<br></font><br><strong>如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</strong></p>
<p>例子</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var obj1 = {a: {b: 1}};</span><br><span class="line">var obj2 = Object.assign({}, obj1);</span><br><span class="line"></span><br><span class="line">obj1.a.b = 2; 如果值更改 则拷贝之后的值也是变化的</span><br><span class="line">obj2.a.b // 2</span><br><span class="line"></span><br><span class="line">如果该参数不是对象，则会先转成对象，然后返回。</span><br><span class="line"></span><br><span class="line">typeof Object.assign(2) // "object"</span><br><span class="line"></span><br><span class="line">Object.assign可以用来处理数组，但是会把数组视为对象。</span><br><span class="line"></span><br><span class="line">Object.assign([1, 2, 3], [4, 5])</span><br><span class="line">// [4, 5, 3]</span><br><span class="line"></span><br><span class="line">Object.assign(someClass.prototype,{</span><br><span class="line">someMethod(){</span><br><span class="line">...</span><br><span class="line">},</span><br><span class="line">antherMethod(){</span><br><span class="line">...</span><br><span class="line">}</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">===</span><br><span class="line">// 等同于下面的写法</span><br><span class="line">SomeClass.prototype.someMethod = function (arg1, arg2) {</span><br><span class="line">  ···</span><br><span class="line">};</span><br><span class="line">SomeClass.prototype.anotherMethod = function () {</span><br><span class="line">  ···</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong>克隆对象</strong><br>只能可通他自身的值而不能可通它继承的值</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">function clone(origin){</span><br><span class="line"> return Object.assign({},origin)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">function clone(origin) {</span><br><span class="line">  let originProto = Object.getPrototypeOf(origin);</span><br><span class="line">  return Object.assign(Object.create(originProto), origin);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Object.getOwnPropertyDescriptor 获取该属性的描述对象</span><br><span class="line">let obj = { foo: 123 };</span><br><span class="line">Object.getOwnPropertyDescriptor(obj, 'foo')</span><br><span class="line">//  {</span><br><span class="line">//    value: 123,</span><br><span class="line">//    writable: true,</span><br><span class="line">//    enumerable: true,</span><br><span class="line">//    configurable: true</span><br><span class="line">//  }</span><br></pre></td></tr></tbody></table></figure>

<p>Object.keys 方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var obj = { foo: 'bar', baz: 42 };</span><br><span class="line">Object.keys(obj)</span><br><span class="line">// ["foo", "baz"]</span><br></pre></td></tr></tbody></table></figure>
<p><img src="media/14879652049673/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-25%20%E4%B8%8B%E5%8D%8812.58.09.png" alt="屏幕快照 2017-02-25 下午12.58.09"></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var obj = { foo: 'bar', baz: 42 };</span><br><span class="line">Object.values(obj)</span><br><span class="line">// ["bar", 42]</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var obj = { foo: 'bar', baz: 42 };</span><br><span class="line">Object.entries(obj)</span><br><span class="line">// [ ["foo", "bar"], ["baz", 42] ]</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong>ES6 中遍历对象的属性</strong></p>
<p><font face="STCAIYUN" color="red" size="4">for…in </font>循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）<br> <font face="STCAIYUN" color="red" size="4">Object.keys</font> 返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）。<br> <font face="STCAIYUN" color="red" size="4">Object.getOwnPropertyNames</font> 返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）<br> <font face="STCAIYUN" color="red" size="4">Object.getOwnPropertySymbols</font> 返回一个数组，包含对象自身的所有 Symbol 属性。</p>
<p><font face="STCAIYUN" color="red" size="4">__proto__属性（前后各两个下划线）</font>，用来读取或设置当前对象的 prototype 对象。目前，所有浏览器（包括 IE11）都部署了这个属性。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// es6的写法</span><br><span class="line">var obj = {</span><br><span class="line">  method: function() { ... }</span><br><span class="line">};</span><br><span class="line">obj.__proto__ = someOtherObj;</span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">let proto = {};</span><br><span class="line">let obj = { x: 10 };</span><br><span class="line">Object.setPrototypeOf(obj, proto);</span><br><span class="line"></span><br><span class="line">proto.y = 20;</span><br><span class="line">proto.z = 40;</span><br><span class="line"></span><br><span class="line">obj.x // 10</span><br><span class="line">obj.y // 20</span><br><span class="line">obj.z // 40</span><br><span class="line">上面代码将proto对象设为obj对象的原型，所以从obj对象可以读取proto对象的属性。</span><br></pre></td></tr></tbody></table></figure>


<p><strong>ES6 引入的原始类型 “</strong><br><font face="STCAIYUN" color="red" size="4">Symbol</font><br>凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。<br>Symbol 函数前<font face="STCAIYUN" color="red" size="4">不能使用 new 命令</font>，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象<br>由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。<br>Symbol 值不能与其他类型的值进行运算，会报错。<br>但是，Symbol 值可以显式转为字符串。<br>另外，Symbol 值也可以转为布尔值，但是不能转为数值。</p>
<p>let s = Symbol();</p>
<p>typeof s</p>
<p><strong>数组去重</strong></p>
<p>新增的数据结构 <font face="STCAIYUN" color="red" size="4">Set Map </font></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const s = new Set();</span><br><span class="line">[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var set = new Set([1, 2, 3, 4, 4]);</span><br><span class="line">[...set]</span><br></pre></td></tr></tbody></table></figure>

<p>// 去除数组的重复成员<br>在 Set 内部，两个 NaN 是相等。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[...new Set(array)]</span><br><span class="line">var set = new Set([1,1,2,2,3,4,5,5,6])</span><br><span class="line">[...set]</span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">let map = new Map([</span><br><span class="line">  ['F', 'no'],</span><br><span class="line">  ['T',  'yes'],</span><br><span class="line">]);</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">for (let key of map.keys()) {</span><br><span class="line">  console.log(key);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><font face="STCAIYUN" color="red" size="4">Proxy（代理器） 元编程（对编程语言进行编程）</font></p>
<p><strong>在目标对象之前设置一层拦截 外界对它的访问必须先通过这一层拦截</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var obj = new Proxy({}, {</span><br><span class="line">  get: function (target, key, receiver) {</span><br><span class="line">    console.log(`getting ${key}!`);</span><br><span class="line">    return Reflect.get(target, key, receiver);</span><br><span class="line">  },</span><br><span class="line"></span><br><span class="line">  set: function (target, key, value, receiver) {</span><br><span class="line">    console.log(`setting ${key}!`);</span><br><span class="line">    return Reflect.set(target, key, value, receiver);</span><br><span class="line">  }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>
<p>重写了 get 和 set 方法</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var proxy = new Proxy(target, handler);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var proxy = new Proxy({}, {</span><br><span class="line">  get: function(target, property) {</span><br><span class="line">    return 35;</span><br><span class="line">  }</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">proxy.time // 35</span><br><span class="line">proxy.name // 35</span><br><span class="line">proxy.title // 35</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><font face="STCAIYUN" color="red" size="4">Promise (承诺)</font></p>
<p>所谓 Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var promise = new Promise(function(resolve,reject){</span><br><span class="line"></span><br><span class="line">if('异步操作成功'){</span><br><span class="line">resolve(value)</span><br><span class="line">}else{</span><br><span class="line">reject(error)</span><br><span class="line">}</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">promise.then(function(value){</span><br><span class="line">成功</span><br><span class="line">},function(error){</span><br><span class="line">失败</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p>遍历器对象本质上，就是一个指针对象。</p>
<p>回调函数<br>事件监听<br>发布 / 订阅<br>Promise 对象</p>
<p>Generator 函数<br>yield 表示执行到此处执行权将交给其它协程也就是说 yield 命令部两个阶段的分界线</p>
<p>Generator 函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">function* gen(x){</span><br><span class="line"> try{</span><br><span class="line"> var y = yield x +2;</span><br><span class="line"> }catch(e){</span><br><span class="line"> console.log(e)</span><br><span class="line"> }</span><br><span class="line"> return y</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>




<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var fetch = require('node-fetch');</span><br><span class="line"></span><br><span class="line"> function* gen(){</span><br><span class="line"> var url = 'http://api.github.com/users/github';</span><br><span class="line"> var result = yield fetch (url);</span><br><span class="line"> console.log('ds')</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>

<p> Thunk 函数是自动执行 generator 函数的一种方法</p>
<p> 传名调用</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"> f(x + 5)</span><br><span class="line">// 传名调用时，等同于</span><br><span class="line">f(x + 5)</span><br></pre></td></tr></tbody></table></figure>

<p> 传值调用</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"> f(x + 5)</span><br><span class="line">// 传值调用时，等同于</span><br><span class="line">f(6)</span><br></pre></td></tr></tbody></table></figure>

<p><font face="STCAIYUN" color="red" size="4">Thunk 是传名调用的实现</font>，将参数放到一个临时的函数中，再将这个临时函数传入函数体</p>
<p>这个临时函数叫做 <strong>Thunk</strong> 函数</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var x = 1;</span><br><span class="line">function f(m){</span><br><span class="line"> return m*2;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">f(x+5)</span><br><span class="line"></span><br><span class="line">等同于</span><br><span class="line"></span><br><span class="line">var thunk = function(){</span><br><span class="line">  return x+5</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">function (thunk){</span><br><span class="line">return thunk()*2</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p><font face="STCAIYUN" color="red" size="4">async ：Generator 函数的语法糖</font></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var asyncReadFile = async function () {</span><br><span class="line">  var f1 = await readFile('/etc/fstab');</span><br><span class="line">  var f2 = await readFile('/etc/shells');</span><br><span class="line">  console.log(f1.toString());</span><br><span class="line">  console.log(f2.toString());</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p><strong>async 🌧️generator 比较</strong></p>
<ol>
<li>async 有内置执行器 不需要调用 next 方法<br>拥有更好的语义（比起星号和 yield 语义更清楚了）</li>
<li>async 函数返回的是 promise 对象比 Generator 函数返回值是 Iterator 对象方便多了 可以用 then 方法指定下一步操作</li>
</ol>
<p><strong>async 和 await</strong></p>
<ul>
<li>  async 表示函数中有异步操作</li>
<li>  await 表示紧跟在后面的表达式需要等待结果</li>
<li>  async 函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而 await 命令就是内部 then 命令的语法糖。</li>
<li> async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。当函数执行的时候，一旦遇到 await 就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</li>
</ul>
<p>错误处理</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">async function f() {</span><br><span class="line">  await new Promise(function (resolve, reject) {</span><br><span class="line">    throw new Error('出错了');</span><br><span class="line">  });</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">async function main() {</span><br><span class="line">  try {</span><br><span class="line">    var val1 = await firstStep();</span><br><span class="line">    var val2 = await secondStep(val1);</span><br><span class="line">    var val3 = await thirdStep(val1, val2);</span><br><span class="line"></span><br><span class="line">    console.log('Final: ', val3);</span><br><span class="line">  }</span><br><span class="line">  catch (err) {</span><br><span class="line">    console.error(err);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">async function myFunction() {</span><br><span class="line">  try {</span><br><span class="line">    await somethingThatReturnsAPromise();</span><br><span class="line">  } catch (err) {</span><br><span class="line">    console.log(err);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h3 id="class"><a href="#class" class="headerlink" title="class"></a>class</h3><p><strong>基本形式</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">class Point{</span><br><span class="line"></span><br><span class="line">constructor(x,y){</span><br><span class="line"></span><br><span class="line">this.x = x;</span><br><span class="line">this.y = y</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">toString(){</span><br><span class="line"> return  '(' + this.x + ', ' + this.y + ')';</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Class 不存在变量提升（hoist），这一点与 ES5 完全不同。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const MyClass = class Me {</span><br><span class="line">  getClassName() {</span><br><span class="line">    return Me.name;</span><br><span class="line">  }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>类名是 MyClass 而不是 me Me 只在 Class 的内部代码可用，指代当前类。</p>
<p>const MyClass = class { /* … */ };</p>
<p><strong>模块加载方案</strong></p>
<ul>
<li><p> CommonJs 应用于服务器</p>
</li>
<li><p>AMD 应用于浏览器</p>
<p>ES6 提供模块功能 尽量的静态化)</p>
</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">import {stat，exut，readFile} from 'fs'</span><br></pre></td></tr></tbody></table></figure>
<p> Es6 模块是编译时加载<br> ES6 的模块自动采用严格模式</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">function  f(){}</span><br><span class="line"> export {f}</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">import {lastName as surname} from './profile'</span><br><span class="line">import命令具有提升效果</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">导出</span><br><span class="line">export default</span><br><span class="line"></span><br><span class="line">引入</span><br><span class="line">import * as circle from './circle'; 模块的整体加载</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>使用 import 命令的时候用户不需要知道所加载的变量名或者函数名 用这个语法可以为模块指定默认输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">export default function (){</span><br><span class="line"> console.log('foo')</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>
<p> 引入的时候 import 可以为该匿名函数指定任意的名字，这个时候 import 的后面不使用大括号</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">import customName from  ..</span><br><span class="line"></span><br><span class="line"> export default function ee (){</span><br><span class="line"> console.log('foo')</span><br><span class="line">}</span><br><span class="line">==</span><br><span class="line"></span><br><span class="line">function foo (){</span><br><span class="line">console.log('ee')</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">export default foo;</span><br></pre></td></tr></tbody></table></figure>

<p> foo 的函数名 foo 在模块外部时无效的 视同匿名函数加载</p>
<p> 使用 export 时，对应的 import 语句需要使用大括号。</p>
<p> 使用 export default  对应的 import 语句不需要大括号</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"> // 第一组</span><br><span class="line">export default function crc32() { // 输出</span><br><span class="line">  // ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">import crc32 from 'crc32'; // 输入</span><br><span class="line"></span><br><span class="line">import { default as xxx } from 'modules';</span><br><span class="line"></span><br><span class="line">// 第二组</span><br><span class="line">export function crc32() { // 输出</span><br><span class="line">  // ...</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">import {crc32} from 'crc32'; // 输入</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>本质上，export default 就是输出一个叫做 default 的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。</p>
<p>import { default as xxx } from ‘modules’</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">export {add as default};</span><br></pre></td></tr></tbody></table></figure>
<p>// 等同于</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// export default add;</span><br></pre></td></tr></tbody></table></figure>

<p>ES6 模块</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;script type="module" src="foo.js"&gt;&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了<script>标签的defer属性。</p>
<p>拷贝数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const itemCopy &#x3D; [];</span><br><span class="line">const item &#x3D; [1,2,3]</span><br><span class="line">itemCopy &#x3D; [...item]</span><br><span class="line">console.log(itemCopy)</span><br></pre></td></tr></table></figure>
</script></p>]]></content>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>Express 框架系列 (三) 之方法</title>
    <url>/2018/04/18/Express%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97(%E4%B8%89)%E4%B9%8B%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="all方法和HTTP动词方法"><a href="#all方法和HTTP动词方法" class="headerlink" title="all方法和HTTP动词方法"></a>all 方法和 HTTP 动词方法</h3><p>针对不同的请求，Express 提供了 use 方法的一些别名。比如，上面代码也可以用别名的形式来写。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var express = require("express");</span><br><span class="line">var http = require("http");</span><br><span class="line">var app = express();</span><br><span class="line"></span><br><span class="line">app.all("*", function(request, response, next) {</span><br><span class="line">  response.writeHead(200, { "Content-Type": "text/plain" });</span><br><span class="line">  next();</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">app.get("/", function(request, response) {</span><br><span class="line">  response.end("Welcome to the homepage!");</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">app.get("/about", function(request, response) {</span><br><span class="line">  response.end("Welcome to the about page!");</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">app.get("*", function(request, response) {</span><br><span class="line">  response.end("404!");</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">http.createServer(app).listen(1337);</span><br></pre></td></tr></tbody></table></figure>
<p>除了 get 方法以外，Express 还提供 post、put、delete 方法，即 HTTP 动词都是 Express 的方法，express 允许模式匹配</p>
<h3 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set 方法</h3><p>用于指定变量的值</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">app.set('views',_dirname+'/views')</span><br><span class="line">app.set("view engine", "jade");</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h3 id="response-对象"><a href="#response-对象" class="headerlink" title="response 对象"></a>response 对象</h3><p>response.redirect () 允许网址的重定向<br><code>response.redirect("/hello/anime");</code></p>
<p>response.sendFile () 用于发送文件<br><code>response.sendFile("/path/to/anime.mp4")</code></p>
<p>response.render () 用于渲染网页模版</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">app.get("/", function(request, response) {</span><br><span class="line">  response.render("index", { message: "Hello World" });</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>
<p>使用 render 方法，将 message 变量传入 index 模版，渲染成 HTML 网页</p>
<h3 id="request对象"><a href="#request对象" class="headerlink" title="request对象"></a>request 对象</h3><p>request.ip: 用于获取 HTTP 请求的 IP 地址<br>request.files 用于获取上传的文件</p>
<h3 id="搭建HTTPS服务器"><a href="#搭建HTTPS服务器" class="headerlink" title="搭建HTTPS服务器"></a>搭建 <a href="http://baike.baidu.com/link?url=RDLn4MhlPev2MMCPjJvGa0aEf2Fg2DzGyz-Eqo7AwmYdYDjPTvyZuku-svVMjAlHcvsZm9PQ4bGPcjFW7VPcDK">HTTPS</a> 服务器</h3><p>使用 express 搭建 https 加密服务器</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var fs = require('fs');</span><br><span class="line">var options = {</span><br><span class="line">  key: fs.readFileSync('E:/ssl/myserver.key'),</span><br><span class="line">  cert: fs.readFileSync('E:/ssl/myserver.crt'),</span><br><span class="line">  passphrase: '1234'</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">var https = require('https');</span><br><span class="line">var express = require('express');</span><br><span class="line">var app = express();</span><br><span class="line"></span><br><span class="line">app.get('/', function(req, res){</span><br><span class="line">  res.send('Hello World Expressjs');</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">var server = https.createServer(options, app);</span><br><span class="line">server.listen(8084);</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>Express 框架系列 (二) 之运行原理</title>
    <url>/2017/04/18/Express%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97(%E4%BA%8C)%E4%B9%8B%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="底层HTTP模块"><a href="#底层HTTP模块" class="headerlink" title="底层HTTP模块"></a>底层 HTTP 模块</h3><p>Express 框架建立在 node.js 内置的 http 模块上，<strong>框架的核心是对 HTTP 模块的再包装</strong><br>http 模块生成服务器的原始代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var http = require("http");</span><br><span class="line"></span><br><span class="line">var app = http.createServer(function(request, response) {</span><br><span class="line">  response.writeHead(200, {"Content-Type": "text/plain"});</span><br><span class="line">    response.end(" express hahahah");</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">app.listen(4040, "localhost");</span><br></pre></td></tr></tbody></table></figure>
<p>上面的代码关键是 http 模块的 <strong>createServer</strong> 方法，表示生成一个 http 服务器实例，该方法接受一个回调函数，回调函数的两个参数分别代表 HTTP 请求和 HTTP 响应的 <strong>request</strong> 对象和 <strong>response</strong> 对象</p>
<p><img src="http://oucjferwh.bkt.clouddn.com/node2-1.png"></p>
<p>上面的代码用 Express 改写如下</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var express = require('express');</span><br><span class="line">var app = express();</span><br><span class="line"></span><br><span class="line">app.get('/', function (req, res) {</span><br><span class="line">  res.send('Hello world!');</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">app.listen(7000);</span><br></pre></td></tr></tbody></table></figure>
<p><img src="http://oucjferwh.bkt.clouddn.com/node2-2.png"></p>
<p>可以发现两端代码特别相似，原来是用 http.createServer 方法新建一个 app 实例，现在则是用 Express 的构造方法，生成一个 Epress 实例，两种方法的回调函数都是相同的，<br>Express 等于在 HTTP 模块之上，加了一个<strong>中间层</strong></p>
<h3 id="什么是中间件"><a href="#什么是中间件" class="headerlink" title="什么是中间件"></a>什么是中间件</h3><p>中间件就是处理 HTTP 请求的函数，<br>特点：一个中间件处理完再传递给下一个中间件，APP 实例在运行中会调用一系列的中间件</p>
<p>每个中间件可以从 APP 实例接收三个参数 request (代表 HTTP 请求)，response (代表 HTTP 响应),next 回调函数 (代表下一个中间件)，每一个中间件都可以对 HTTP 请求 (request 对象) 进行加工，并且决定是否调用 next 方法，将 request 对象再传给下一个中间件</p>
<p>最简单的中间件</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">function uselessMiddleware(req,res,next){</span><br><span class="line">next()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">上面代码的next就是下一个中间件。如果它带有参数，则代表抛出一个错误，参数为错误文本。</span><br><span class="line"></span><br><span class="line">function uselessMiddleware(req, res, next) {</span><br><span class="line">  next('出错了！');</span><br><span class="line">}</span><br><span class="line">抛出错误以后，后面的中间件将不再执行，直到发现一个错误处理函数为止。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h5 id="use方法"><a href="#use方法" class="headerlink" title="use方法"></a>use 方法</h5><p>use 是 express 注册中间件的方法，使用 app.use 方法，注册了两个中间件，收到 HTTP 请求后，先调用第一个中间件，根据 next () 确定是否把 request 对象传递到下一个中间件</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var express = require("express");</span><br><span class="line">var http = require("http");</span><br><span class="line"></span><br><span class="line">var app = express();</span><br><span class="line"></span><br><span class="line">app.use(function(request, response, next) {</span><br><span class="line">  console.log("In comes a " + request.method + " to " + request.url);</span><br><span class="line">  next();</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">app.use(function(request, response) {</span><br><span class="line">  response.writeHead(200, { "Content-Type": "text/plain" });</span><br><span class="line">  response.end("Hello world!\n");</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">http.createServer(app).listen(1337);</span><br></pre></td></tr></tbody></table></figure>
<p>use 方法内部通过 <code>request.url</code> 的属性可以根据访问路径进行判断，据此就能实现简单的路由，</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var express = require("express");</span><br><span class="line">var http = require("http");</span><br><span class="line">var app = express();</span><br><span class="line"></span><br><span class="line">app.use(function(request,response,next){</span><br><span class="line">     if(request.url == "/"){</span><br><span class="line">    response.writeHead(200, { "Content-Type": "text/plain" });</span><br><span class="line">    response.end("Welcome to the homepage!\n");</span><br><span class="line">     }else{</span><br><span class="line">     next();</span><br><span class="line">     }</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">app.use(function(request, response, next) {</span><br><span class="line">  if (request.url == "/about") {</span><br><span class="line">    response.writeHead(200, { "Content-Type": "text/plain" });</span><br><span class="line">  } else {</span><br><span class="line">    next();</span><br><span class="line">  }</span><br><span class="line">});</span><br><span class="line">app.use(function(request, response) {</span><br><span class="line">  response.writeHead(404, { "Content-Type": "text/plain" });</span><br><span class="line">  response.end("404 error!\n");</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">http.createServer(app).listen(1337);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>另外一种比较清晰的方式（上面代码表示，只对根目录的请求，调用某个中间件。<br>）<br><code>app.use('/path', someMiddleware);</code><br>按照这个思想，改造中间件</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var express = require("express");</span><br><span class="line">var http = require("http");</span><br><span class="line"></span><br><span class="line">var app = express();</span><br><span class="line"></span><br><span class="line">app.use("/home", function(request, response, next) {</span><br><span class="line">  response.writeHead(200, { "Content-Type": "text/plain" });</span><br><span class="line">  response.end("Welcome to the homepage!\n");</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">app.use("/about", function(request, response, next) {</span><br><span class="line">  response.writeHead(200, { "Content-Type": "text/plain" });</span><br><span class="line">  response.end("Welcome to the about page!\n");</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">app.use(function(request, response) {</span><br><span class="line">  response.writeHead(404, { "Content-Type": "text/plain" });</span><br><span class="line">  response.end("404 error!\n");</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">http.createServer(app).listen(1337);</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>前后端分离的演进</title>
    <url>/2019/03/05/FrontBackSeparation/</url>
    <content><![CDATA[<p>有幸参与了所在项目的架构升级，初次接触到了 <code>SSR</code> 的概念，就越发感兴趣 我们站在巨人的肩膀上一边享受社区红利，一边躁动不安</p>
<p><strong>鲁迅先生说过</strong></p>
<blockquote>
<p>技术上的问题总有技术去解决<br>没错 比如我现在就学会问 <code>为什么</code><br>为什么会如此发展？为什么会有这个概念？它能解决什么问题？它从哪里来.. 又要到哪里去..emm..</p>
</blockquote>
<hr>
<p>事实上，任何一项技术的发展 都是由<strong>问题</strong>推动的，所以 <code>trouble is friends</code>！</p>
<p>工作时间不短不长，刚好经历了几个阶段.</p>
<a id="more"></a>

<h3 id="第一阶段（静态页面万岁）"><a href="#第一阶段（静态页面万岁）" class="headerlink" title="第一阶段（静态页面万岁）"></a>第一阶段（静态页面万岁）</h3><p>两年前入职的时候，就用的如此神奇的技术，当时 <code>react、vue</code> 等已经热火朝天了，我表示很惊讶，因为刚毕业就加入 <code>react</code> 大军了，当时还用的是蚂蚁金服还在 <code>degugger</code> 阶段的 <code>dva</code>, 对于当时的我来讲，这种歌神奇的技术第一次真正接触，写好页面，就扔给后端小哥哥了，还真的不习惯，比较闹心的一点是 没有 bug 还好，一旦需要调试，会跟后端小哥哥一起看，是真的浪费时间，重点是效率也贼低.</p>
<p>其实现在看来 ，这大概是最初的前后端分离<br>前端负责静态页面和交互，后端可能就要负责数据处理并返回完整的页面<br>一旦涉及到诸如 JSP、PHP smarty 模版的编写，就容易职责不清了.. 以至于互相甩锅！</p>
<p><strong>缺点明显：</strong></p>
<ol>
<li>前后端分工不明，难以实现效率最大化</li>
<li>前端会极度依赖后端环境，数据格式的沟通成本过高</li>
<li>不利于前端技术的发展</li>
</ol>
<h3 id="第二阶段（AJAX时代）"><a href="#第二阶段（AJAX时代）" class="headerlink" title="第二阶段（AJAX时代）"></a>第二阶段（AJAX 时代）</h3><p>随着前端技术的发展，尤其是 AJAX 和 Node.js 的出现，一种前后端分离的架构模式应运而生，极大的缓解了前后端 RD 会互相撕逼的 bug，前后端分工变得清晰，以 AJAX 接口当作桥梁，各取所需（😂）</p>
<p>emm.. 徒手画的还不是特别准确的图来意会一下用户请求页面的过程<br><img src="/images/cache/ssr1.jpeg" alt="cache_detai"></p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li>分工明确，前后端各司其职，后端专注业务逻辑和功能的实现，前端专注页面设计。</li>
<li>接口明确，并行开发，在后端接口没有实现好之前，前端完全可以自己通过 Node.js 的的 Web 框架模拟接口<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4></li>
<li>数据请求，处理扽好复杂逻辑被移植到浏览器端，js 脚本越来越复杂</li>
<li>不利于 <strong>SEO</strong>（后面会解释）存在性能问题</li>
<li>这种模式下，用户必须等待 js 脚本加载完成，真正执行时发数据请求，等数据返回，脚本完成页面的渲染，才能看到页面，导致<strong>首屏展现时间拉长，特别是在移动互联网下，对首屏加载性能的影响很大</strong></li>
</ol>
<h3 id="第三阶段（SPA）"><a href="#第三阶段（SPA）" class="headerlink" title="第三阶段（SPA）"></a>第三阶段（SPA）</h3><p><strong>SPA</strong>（single page application）：是一种 网络应用程序 (WebApp) 模型<br>在传统的网站中，不同的页面之间的切换都是直接从服务器加载一整个新的页面，而 SPA 是通过动态重写页面的部分与用户交互，从而避免了过多的数据交换，响应速度更快</p>
<h4 id="目前常见的SPA框架"><a href="#目前常见的SPA框架" class="headerlink" title="目前常见的SPA框架"></a>目前常见的 SPA 框架</h4><ul>
<li>AngularJS</li>
<li>React</li>
<li>Vue.js</li>
</ul>
<p>任何技术架构的升级都不可能脱离时代永远存在，技术的演进一定会随着发展愈演愈烈</p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ol>
<li>前后端分离的优点它都有除此之外，它页面之间的切换很快<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4></li>
<li>首屏打开速度很慢，因为用户首次加载需要先下载 SPA 框架及应用程序的代码，然后再渲染页面</li>
<li>不利于 <strong>SEO</strong></li>
</ol>
<p><strong>为什么 SPA 不利于 SEO？</strong><br>目前而言，部分搜索引擎如 Google、bing 等，它们的爬虫虽然已经支持执行 JS 甚至是通过 AJAX 获取数据了，但是对于异步数据的支持也还不足 (也可能是搜索引擎提供商觉得没必要)<br>SPA 应用中，通常通过 AJAX 获取数据，而这里就难以保证我们的页面能被搜索引擎正常收录到。并且有一些搜索引擎不支持执行 JS 和通过 AJAX 获取数据，那就更不用提 SEO 了</p>
<h3 id="第四阶段（服务端渲染SSR）"><a href="#第四阶段（服务端渲染SSR）" class="headerlink" title="第四阶段（服务端渲染SSR）"></a>第四阶段（服务端渲染 SSR）</h3><h4 id="什么是服务端渲染？"><a href="#什么是服务端渲染？" class="headerlink" title="什么是服务端渲染？"></a>什么是服务端渲染？</h4><p>服务端渲染会把数据请求过程放在服务端，相对于前后端分离的方式，获取数据提前，页面模版结合数据的渲染处理也会在服务端完成</p>
<h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol>
<li>当浏览器初次请求页面后，用户第一次拿到的 HTML 文档已经进行了初步的内容渲染，<strong>利于 SEO 优化 也解决了首屏的性能问题</strong></li>
<li>总的请求数并没有变，只是把浏览器的一部分数据请求转移到了服务器上 事实上 <strong>服务端进行数据拉取的成本要小于浏览器端，传输更加高效，这也是性能提升的关键</strong></li>
<li>更快的响应时间，不用等待所有的 JS 都下载完成，浏览器便能显示比较完整的页面了</li>
<li>更好的 SEO，我们可以将 SEO 的关键信息直接在后台就渲染成 HTML，而保证搜索引擎的爬虫都能爬取到关键数据<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4></li>
<li>相对于仅仅需要提供静态文件的服务器，SSR 中使用的渲染程序自然会占用更多的 CPU 和内存资源</li>
<li>一些常用的浏览器 API 可能无法正常使用，比如 window、docment 和 alert 等，如果使用的话需要对运行的环境加以判断</li>
<li>服务器端渲染的结果与浏览器端的结果不一致</li>
</ol>
<p>技术的历史总是惊人的相似，这里的服务端渲染和开始的 <code>smarty</code> 等模版渲染并没有本质上的区别，当然了这并不是倒退，实际开发项目中，依赖 react 实现的服务端渲染并不是简单的渲染内容，也可以实现前后端代码复用 -&gt; <font color="red">同构</font></p>
<h3 id="第五阶段（SPA-SSR-同构）"><a href="#第五阶段（SPA-SSR-同构）" class="headerlink" title="第五阶段（SPA+ SSR 同构）"></a>第五阶段（SPA+ SSR 同构）</h3><h4 id="何为同构？"><a href="#何为同构？" class="headerlink" title="何为同构？"></a>何为同构？</h4><p>服务端渲染出最核心，最基本的信息，浏览器端针对交互完成进一步的渲染，事件绑定等增强功能</p>
<p><strong>但是 两端渲染必定有很对冗余代码逻辑（都有 fetch 数据的过程）</strong></p>
<p>同构：就是前后端共用一套代码逻辑，它就像是服务端与客户端渲染的交集，弥补了服务端和浏览器端的差异</p>
<p>好像很高级的样子</p>
<p>但是优劣也比较明显</p>
<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ol>
<li>更好的性能 渲染更加迅速 首屏展现的时间更快</li>
<li> SEO 优化支持，服务端收到请去后 会返回一个相对完整，包含 html 的文档，所以更有利于搜索引擎爬虫获取信息，同时，更快的加载时间也有利于搜索结果展现排名的提升</li>
<li>实现灵活，服务端渲染做客户端渲染的后续的工作，实现代码复用</li>
<li>可维护性更强（同一套代码逻辑维护成本低）</li>
<li>对于低端机型友好，因为页面内容是在服务端渲染的 不至于出现白屏</li>
<li>弱网有好 不会再等 js 执行完毕再去呈现页面</li>
<li>更好的用户体验 可以将最重要的先渲染次重要的后渲染</li>
</ol>
<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>服务端逻辑增多</li>
<li>服务端无法完全复用浏览器端代码</li>
<li>增加了服务器的 TTFB（time to frist byte）时间</li>
</ol>
<hr>
<p>总结</p>
<p>合理利用 SSR 结合 SPA 实现同构应用 是我们日后重心<br>下一篇将动手写个同构的 demo</p>
<p>就这样。</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title>React 陷阱</title>
    <url>/2017/07/02/React%E9%99%B7%E9%98%B1/</url>
    <content><![CDATA[<ul>
<li>不要改变 props</li>
</ul>
<p>错误例子：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var component = &lt;Component /&gt;;</span><br><span class="line">component.props.foo = x; // bad</span><br><span class="line">component.props.bar = y; // also bad</span><br></pre></td></tr></tbody></table></figure>

<p>这样写是错误的，因为我们手动直接添加的属性 React 后续没办法检查到属性类型错误，也就是说，当我们手动添加的属性发生类型错误时，在控制台是看不到错误信息的</p>
<p>在 React 的设定中，初始化完 props 后，props 是不可变的。改变 props 会引起无法想象的后果</p>
<p>正确写法：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var props = {};</span><br><span class="line">props.foo = x;</span><br><span class="line">props.bar = y;</span><br><span class="line">var component = &lt;Component {...props} /&gt;;</span><br></pre></td></tr></tbody></table></figure>

<p>当需要拓展我们的属性的时候，定义个一个属性对象，并通过 {…props} 的方式引入，React 会帮我们拷贝到组件的 props 属性中。<br>重要的是 — 这个过程是由 React 操控的，不是手动添赋值的属性</p>
<p>需要覆盖的时候可以这么写</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var props = { foo: 'default' };</span><br><span class="line">var component = &lt;Component {...props} foo={'override'} /&gt;;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>


<ul>
<li>React 默认会进行 HTML 的转义如下</li>
</ul>
<p>输入：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var content='&lt;strong&gt;content&lt;/strong&gt;';</span><br><span class="line"></span><br><span class="line">React.render(</span><br><span class="line">    &lt;div&gt;{content}&lt;/div&gt;,</span><br><span class="line">    document.body</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;stonrg&gt;content&lt;/strong&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>避免转义：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var content='&lt;strong&gt;content&lt;/strong&gt;';    </span><br><span class="line"></span><br><span class="line">React.render(</span><br><span class="line">    &lt;div dangerouslySetInnerHTML={{__html: content}}&gt;&lt;/div&gt;,</span><br><span class="line">    document.body</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>如果在编写时使用了 react 自定义属性  react 是不会渲染的</li>
</ul>
<p>错误做法：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">React.render(</span><br><span class="line">    &lt;div dd='xxx'&gt;content&lt;/div&gt;,</span><br><span class="line">    document.body</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>

<p>正确做法：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">React.render(</span><br><span class="line">    &lt;div data-dd='xxx' aria-dd='xxx'&gt;content&lt;/div&gt;,</span><br><span class="line">    document.body</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>你不知道的 JS 系列 - 作用域、变量提升、闭包</title>
    <url>/2019/03/25/actionScope/</url>
    <content><![CDATA[<p>来看几个既基本又重要的概念查漏补缺</p>
<a id="more"></a>


<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>几乎所有编程语言最基础的功能之一 就是存储变量当中的值，并能在之后对这个值进行访问和修改<br>引出下面两个问题</p>
<ul>
<li>那这些变量存储在哪里？</li>
<li>程序需要的时候 如何找到他们？</li>
</ul>
<p>我们需要一套设计良好的规则来存储变量，并且之后可以方便的找到这些变量，它叫 <font color="red">作用域</font></p>
<h3 id="js程序编译原理"><a href="#js程序编译原理" class="headerlink" title="js程序编译原理"></a>js 程序编译原理</h3><p>js 是一门编译语言，但是与传统的编译语言不同，他不是提前编译的</p>
<p>js 引擎进行编译的步骤和传统的编译语言非常相似，但是某些环节会更加复杂 例如：在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素的优化</p>
<ul>
<li>分词 / 词法分析</li>
<li>解析 / 语法分析 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">将词法单元流（数组）转化为AST（抽象语法树）</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>代码生成 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">将AST转化为可执行代码</span><br></pre></td></tr></tbody></table></figure>

<p>js 引擎执行一段可执行代码时，会创建对应的执行上下文，对于每个执行上下文，都有三个重要属性：</p>
<ul>
<li><p>变量对象</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">每一个执行上下文都会分配一个变量对象，变量对象的属性由变量和函数声明构成，在函数上下文的情况下，参数列表也会被加入到变量对象作为属性,不同作用域的变量对象互不相同，它保存了当前作用域的所有函数和变量</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>作用域链</p>
</li>
<li><p>this 指向</p>
<p>当你看到 <code>var a = 2</code> 程序内部的工作过程</p>
</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">编译器将这端程序分解成词法单元 var a, a=2 然后将词法单元解析成一个树结构</span><br><span class="line"></span><br><span class="line">1.遇到var a 编译器会询问作用域是否已经有该变量的名称存在于同一个作用域中,如果是，编译器忽略该声明 否则会要求作用域在当前作用域的集合中声明一个新的变量 命名为a</span><br><span class="line">2.当为引擎生成运行时所需要的代码 a=2 js引擎运行时会询问作用域，当前作用域的集合中是否存在a 存在 就是用 不存在就继续查找 如果还是找不到 就抛出异常</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>总结：变量的赋值操作会执行两个过程</p>
<ul>
<li>编译器会在当前作用域中生成一个变量（之前没有生成过）这会在代码执行前进行</li>
<li>运行时 js 引擎会在作用域中查找（LHS 查询）该变量能找到就给他赋值</li>
</ul>
<h4 id="js引擎是如何查找变量的？"><a href="#js引擎是如何查找变量的？" class="headerlink" title="js引擎是如何查找变量的？"></a>js 引擎是如何查找变量的？</h4><p>LHS 查询 （赋值操作的目标是谁）<br>RHS 查询 （谁是赋值操作的源头）</p>
<h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><p>大部分的标准语言编译器的第一个工作就叫词法化<br>词法化的过程会对源代码进行检查<br>词法作用域就是定义在词法阶段的作用域<br>词法作用域意味着作用域是由书写代码时函数声明的位置决定的</p>
<h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><p>函数是 js 中最常见的作用域单元 声明在一个函数内部的变量或函数会在所处的作用域中隐藏起来 这符合最小授权（暴露）原则</p>
<h4 id="最小授权（暴露）原则的好处？"><a href="#最小授权（暴露）原则的好处？" class="headerlink" title="最小授权（暴露）原则的好处？"></a>最小授权（暴露）原则的好处？</h4><ol>
<li>隐藏内部实现 API 友好</li>
<li>规避冲突 （同名标识符之间的冲突）</li>
</ol>
<h3 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h3><p>块作用域是指变量和函数不仅可以属于所处的作用域也可以属于某个代码块儿 {…}<br>ES3 开始 try/catch 结构在 catch 分句中具有块作用域<br>ES6 引入了 let const 可以用在循环中 会将当前的值重新绑定到了循环的每一个迭代中</p>
<hr>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>作用域是一套规则，用于确定在何处以及如何查找变量，如果查找的目的是对变量进行赋值，那么就会使用 LHS 查询，如果目的是为了获取变量的值 那就进行 RHS 查询 赋值操作会导致 LHS 查询</li>
<li> LHS 与 RHS 查询都会从当前作用域中开始，如果有需要就会向上级作用域继续查找目标标识符。这样儿每次上升一级作用域，最后抵达迁居作用域 无论找到没找到都会停止</li>
<li>不成功的 RHS 引用会抛出异常 不成功的 RHS 引用会导致自动隐式创建一个全局变量</li>
<li>词法作用域意味着作用域是由书写代码时函数声明的位置决定的。编译的词法分析阶段基本能够知道全部标识符在哪里以及如何声明的，从而能够在执行过程中如何对他们进行查找</li>
<li> eval () 与 with () 可以扩充词法作用域 但是会有性能问题</li>
<li>函数是常见但不是唯一的作用域单元，函数作用域与块作用域的行为是一样儿的 任何声明在某个作用域内的变量都将附属于这个作用域</li>
<li> ES6 中引入了 let 关键字 用来在任意代码块中声明变量</li>
</ul>
<h2 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h2><ul>
<li>先有声明 后有赋值</li>
<li>只有声明本身会被提升，而赋值等其他运行逻辑会留在原地，提升不会改变代码的执行顺序</li>
<li>注意避免重复声明</li>
<li>每个作用域都会进行提升操作</li>
<li>函数声明会被提升，函数表达式不会被提升</li>
<li>函数提升优先于变量提升</li>
<li>一个普通块内部的函数声明通常会被提升到所在作用域的顶部</li>
<li>无论作用域中的声明出现在什么地方，都将会在代码本身被执行前首先被处理（所有的变量声明和函数声明）都会被移动到各自作用域的最顶端</li>
</ul>
<hr>
<h2 id="作用域闭包"><a href="#作用域闭包" class="headerlink" title="作用域闭包"></a>作用域闭包</h2><ul>
<li>闭包无处不在 你需要的是识别并且拥抱它</li>
<li>闭包是基于词法作用域书写代码时产生的自然结果</li>
<li>当函数可以记住并访问所在的词法作用域时就产生了闭包 即使函数是在当前词法作用域之外执行</li>
<li>闭包可以使得函数可以继续访问定义时的词法作用域</li>
<li>如果将函数当作第一级的值类型并到处传递 就会看到闭包在这些函数中的应用</li>
<li>在定时器，事件监听器 ajax 请求 或者任何其他的异步任务重 之要使用了回调函数 实际上就是在使用闭包</li>
<li>闭包 就是关于如何在函数作为值按需传递的词法环境中书写代码的</li>
</ul>
<h3 id="循环与闭包"><a href="#循环与闭包" class="headerlink" title="循环与闭包"></a>循环与闭包</h3><p>块作用域和闭包联手便可天下无敌</p>
<p>使用 IIFE（自执行函数）</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">for(var i =1; i&lt;=5;i++){</span><br><span class="line">  (function(j){</span><br><span class="line">    setTimeout(function timer(){</span><br><span class="line">    console.log('j',j);</span><br><span class="line">  },i*100)</span><br><span class="line">  })(i);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">let用来劫持块作用域 并且在这个块作用域中声明一个变量</span><br><span class="line"></span><br><span class="line">for(var i =1; i&lt;=5;i++){</span><br><span class="line">  let j = i</span><br><span class="line">  setTimeout(function timer(){</span><br><span class="line">    console.log(j);</span><br><span class="line">  },i*100)</span><br><span class="line">}</span><br><span class="line">for循环头部的let声明 每次迭代都会声明</span><br><span class="line">for(let i =1; i&lt;=5;i++){</span><br><span class="line">  setTimeout(function timer(){</span><br><span class="line">    console.log(i);</span><br><span class="line">  },i*100)</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>







]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>作用域</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟实现 apply 和 call 方法</title>
    <url>/2019/03/13/apply-call/</url>
    <content><![CDATA[<h2 id="先来通过MDN认识下call和apply"><a href="#先来通过MDN认识下call和apply" class="headerlink" title="先来通过MDN认识下call和apply"></a>先来通过 MDN 认识下 call 和 apply</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p><code>func.apply(thisArg, [argsArray])</code></p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p><strong>thisArg</strong>：可选的，<code>func</code> 函数运行的时使用的 <code>this</code> 值</p>
<a id="more"></a>
<p>⚠️ </p>
<ul>
<li>如果这个函数处于<font color="red">非严格模式下</font> 指定其为 <code>null</code> 或者 <code>undefined</code> 时 this 绑定会应用<code>默认规则</code>（<font color="red">这在<a href="http://maying.ink/2019/03/11/this/#more">分析 js 指向问题</a>时有提到</font>）</li>
<li>如果 thisArg 是原始值会被包装称对象 <code>.apply(2)</code> 会被包装成<code>.apply(Number(2))</code></li>
</ul>
<hr>
<p><strong>argsArray</strong>：可选的。一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 func 函数。如果该参数的值为 null 或  undefined，则表示不需要传入任何参数。从 ECMAScript 5 开始可以使用类数组对象</p>
<hr>
<p><strong>返回值</strong>：<br>调用有指定 this 值和参数的函数的结果</p>
<hr>
<p>几个有用的例子感受下 apply 的魔力</p>
<p><strong>求数组最大最小值</strong></p>
<p>聪明的 apply 用法允许你在某些本来需要写成遍历数组变量的任务中使用内建的函数</p>
<p>使用 <code>Math.max/Math.min</code> 来找出一个数组中的最大 / 最小值</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var numbers = [5, 6, 2, 3, 7];</span><br><span class="line">var max = Math.max.apply(null, numbers);</span><br><span class="line">console.log(max);</span><br><span class="line"></span><br><span class="line">var min = Math.min.apply(null, numbers);</span><br><span class="line">console.log(min);</span><br></pre></td></tr></tbody></table></figure>

<p><strong>apply 设置的 this 值</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var doSth = function(a, b){</span><br><span class="line">    console.log(this);</span><br><span class="line">    console.log([a, b]);</span><br><span class="line">}</span><br><span class="line">doSth.apply(null, [1, 2]); // this是window  // [1, 2]</span><br><span class="line">doSth.apply(0, [1, 2]); // this 是 Number(0) // [1, 2]</span><br><span class="line">doSth.apply(true); // this 是 Boolean(true) // [undefined, undefined]</span><br><span class="line">doSth.call(undefined, 1, 2); // this 是 window // [1, 2]</span><br></pre></td></tr></tbody></table></figure>
<p><strong>用 apply 将一个数组添加到另一个数组</strong></p>
<p>如果我们传递一个数组来推送，它实际上会将该数组作为单个元素添加，而不是单独添加元素，因此我们最终得到一个数组内的数组<br><code>concat</code> 确实具有我们想要的行为，但它实际上并不附加到现有数组，而是创建并返回一个新数组<br>用 <code>apply</code> 就能简单实现</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var array = ['a', 'b'];</span><br><span class="line">var elements = [0, 1, 2];</span><br><span class="line">array.push.apply(array,elements) //&nbsp;["a", "b", 0, 1, 2]</span><br><span class="line">//array.push(elements) //)&nbsp;["a", "b", 0, 1, 2, Array(3)]</span><br><span class="line">console.log(array);</span><br></pre></td></tr></tbody></table></figure>



<p>call () 与 apply () 非常相似</p>
<p><code>fun.call(thisArg, arg1, arg2, ...)</code></p>
<p><strong>call 和 apply 的不同点</strong></p>
<ul>
<li><code>apply</code> 只接收两个参数，第二个参数可以是<code>数组</code>也可以是<code>类数组</code>，其实也可以是对象，后续的参数忽略不计</li>
<li><code>call</code> 接收第二个及以后一系列的参数</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>重新认识了 call 和 apply 会发现<br>它们作用都是一样的，改变函数里的 this 指向为第一个参数 <code>thisArg</code>，如果明确有多少参数，那可以用 <code>call</code>，不明确则可以使用 <code>apply</code>。也就是说完全可以不使用 <code>call</code>，而使用 <code>apply</code> 代替，我们只需要模拟实现 <code>apply</code>，<code>call</code> 可以根据参数个数都放在一个数组中，给到 <code>apply</code> 即可</p>
<hr>
<h2 id="模拟实现的准备工作"><a href="#模拟实现的准备工作" class="headerlink" title="模拟实现的准备工作"></a>模拟实现的准备工作</h2><p>模拟之前 我们先得看看 <a href="http://yanhaijing.com/es5/#book">ES5 规范</a> 关于 apply 摘抄以下几条</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Function.prototype.apply (thisArg, argArray)</span><br><span class="line"></span><br><span class="line">当以 thisArg 和 argArray 为参数在一个 func 对象上调用 apply 方法，采用如下步骤：</span><br><span class="line"></span><br><span class="line">1.如果 IsCallable(func) 是 false, 则抛出一个 TypeError 异常。</span><br><span class="line"></span><br><span class="line">2.如果 argArray 是 null 或 undefined, 则返回提供 thisArg 作为 this 值并以空参数列表调用 func 的 [[Call]] 内部方法的结果。</span><br><span class="line"></span><br><span class="line">3.返回提供 thisArg 作为 this 值并以空参数列表调用 func 的 [[Call]] 内部方法的结果。</span><br><span class="line"></span><br><span class="line">4.如果 Type(argArray) 不是 Object, 则抛出一个 TypeError 异常。</span><br><span class="line">...</span><br><span class="line">9.提供 thisArg 作为 this 值并以 argList 作为参数列表，调用 func 的 [[Call]] 内部方法，返回结果。</span><br><span class="line"></span><br><span class="line">apply 方法的 length 属性是 2。</span><br><span class="line"></span><br><span class="line">10.在外面传入的 thisArg 值会修改并成为 this 值。thisArg 是 undefined 或 null 时它会被替换成全局对象，所有其他值会被应用 ToObject 并将结果作为 this 值，这是第三版引入的更改</span><br></pre></td></tr></tbody></table></figure>
<p>结合上文和规范 ，明确了要解决的问题，<strong>我们如何将函数里的 this（一般指向 window）指向第一个参数 thisArg 呢</strong><br>不由得想起来了<a href="http://maying.ink/2019/03/11/this/">介绍 this 指向那一篇文章</a><br>那就采用隐式绑定呀，也就是说 既然他现有的上下文环境是 window（全局作用域）, 那我们就手动给他创建一个<code>非全局上下文</code></p>
<p>看看这个熟悉的例子</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var doSth = function(){</span><br><span class="line">    console.log(this);</span><br><span class="line">    console.log(this.name);</span><br><span class="line">    console.log(arguments);</span><br><span class="line">}</span><br><span class="line">var student = {</span><br><span class="line">    name: 'yishu',</span><br><span class="line">    doSth: doSth,</span><br><span class="line">};</span><br><span class="line">student.doSth(1, 2); // this === student // true // 'yishu' // [1, 2]</span><br><span class="line"></span><br><span class="line">doSth.apply(student, [1, 2]); // this === student // true // 'yishu' // [1, 2]</span><br></pre></td></tr></tbody></table></figure>
<p>你能看出来什么？<br> 在对象 <code>student</code> 上加一个函数 doSth，再执行这个函数，这个函数里的 <code>this</code> 就指向了这个对象</p>
<p> 那我们就模拟这个对象，给他添加一个函数，使用函数调用之后再删除它</p>
<p> 第一版本</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 浏览器环境 非严格模式</span><br><span class="line">function getGlobalObject(){</span><br><span class="line">    return this;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Function.prototype.applyFn = function apply(thisArg,argsArray){</span><br><span class="line">   // 1.如果 `IsCallable(func)` 是 `false`, 则抛出一个 `TypeError` 异常。</span><br><span class="line">  if(typeof this !='function'){</span><br><span class="line">    throw new TypeError(this + 'is not function')</span><br><span class="line">  }</span><br><span class="line">  // 1.如果 `IsCallable(func)` 是 `false`, 则抛出一个 `TypeError` 异常。</span><br><span class="line">  if(typeof argsArray === 'undefined' || argsArray === null){</span><br><span class="line">    argsArray = [];</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  //3.如果 Type(argArray) 不是 Object, 则抛出一个 TypeError 异常 .</span><br><span class="line">   if(argsArray !== new Object(argsArray)){</span><br><span class="line">        throw new TypeError('CreateListFromArrayLike called on non-object');</span><br><span class="line">    }</span><br><span class="line">  //4.改变this的指向 在外面传入的 thisArg 值会修改并成为 this 值 如果传入的是 undefined或者null 则this指向应用默认绑定</span><br><span class="line">    if(typeof thisArg === 'undefined' || thisArg === null){</span><br><span class="line">        // ES3: thisArg 是 undefined 或 null 时它会被替换成全局对象 浏览器里是window</span><br><span class="line">        thisArg = getGlobalObject();</span><br><span class="line">    }</span><br><span class="line">    //开始表演</span><br><span class="line">    thisArg = new Object(thisArg);</span><br><span class="line">    thisArg.fn = this;</span><br><span class="line">    //接收返回值</span><br><span class="line">    var fnResult = thisArg.fn(...argsArray);</span><br><span class="line">    delete thisArg.fn;</span><br><span class="line">    return fnResult;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var doSth = function(){</span><br><span class="line">    console.log(this);</span><br><span class="line">    console.log(this.name);</span><br><span class="line">    console.log(arguments);</span><br><span class="line">}</span><br><span class="line">var student = {</span><br><span class="line">    name: '马小莹',</span><br><span class="line">    //doSth: doSth, //我们主要模拟了这个函数</span><br><span class="line">};</span><br><span class="line">doSth.applyFn(student, [1, 2]); </span><br><span class="line"></span><br><span class="line">// {name: "马小莹", doSth: ƒ, fn: ƒ}</span><br><span class="line">// 马小莹</span><br><span class="line">// Arguments(2)&nbsp;[1, 2, callee: ƒ, Symbol(Symbol.iterator): ƒ]</span><br></pre></td></tr></tbody></table></figure>
<p>看起来很完美，那它有没有问题呢？ 其实是有的</p>
<p><strong>.fn 函数同名覆盖问题，<code>thisArg</code> 对象上有 <code>fn</code>，那就被覆盖了然后被删除了</strong></p>
<p>那我们就找一个唯一值的函数名</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">thisArg = new Object(thisArg);</span><br><span class="line">var _fn = '__fn' + new Date().getTime();</span><br><span class="line">thisArg[_fn] = this;</span><br><span class="line">//接收返回值</span><br><span class="line">var fnResult = thisArg[_fn](...argsArray);</span><br><span class="line">delete thisArg[_fn];</span><br><span class="line">return fnResult;</span><br></pre></td></tr></tbody></table></figure>
<p>到现在 简单版本的 <code>apply</code> 已经实现了，现实业务场景不需要去模拟实现 <code>call和apply</code>, 毕竟是 <code>ES3</code> 就提供的方法</p>
<p>既然实现了 <code>apply</code>,<code>call</code> 也就简单了，<strong>原理就是</strong>拿到 <code>call</code> 的参数 转换成数组，然后调用 <code>applyFn</code></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">Function.prototype.applyFn = function apply(thisArg){</span><br><span class="line">  var argsArray = [];</span><br><span class="line">  var argumentsLength = arguments.length;</span><br><span class="line">  for(var i = 0; i &lt; argumentsLength - 1; i++){</span><br><span class="line">    argsArray.push(arguments[i + 1]);</span><br><span class="line">    }</span><br><span class="line">    return this.applyFn(thisArg, argsArray);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>通过 MDN 认识 call 和 apply，阅读 ES5 规范，到模拟实现 apply，再实现 call</li>
</ol>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>call</tag>
        <tag>apply</tag>
      </tags>
  </entry>
  <entry>
    <title>实现一个 SSR 同构应用</title>
    <url>/2019/03/06/SSRDemo/</url>
    <content><![CDATA[<p>纸上得来终觉浅，我们来实现一个简易的服务端渲染流程，意在体会 SSR 带来的红利</p>
<a id="more"></a>
<p>页面源码来自 <a href="">React 状态管理与同构实战</a></p>
<h2 id="几个重要的概念"><a href="#几个重要的概念" class="headerlink" title="几个重要的概念"></a>几个重要的概念</h2><p>实现 <code>SSR</code> 是依靠 <code>React</code> 提供的 <code>ReactDomServer</code> 对象</p>
<p>它主要提供了只能在服务端使用的 <code>renderToString()</code> 与 <code>renderToStaticMarkup()</code> 方法</p>
<h3 id="renderToString-renderToStaticMarkup"><a href="#renderToString-renderToStaticMarkup" class="headerlink" title="renderToString()/renderToStaticMarkup()"></a>renderToString()/renderToStaticMarkup()</h3><p><strong>使用方法：</strong> <code>ReactDomServer.renderTostring(element)</code>/<br><code>ReactDomServer.renderToStaticMarkup(element)</code></p>
<h4 id="共同点："><a href="#共同点：" class="headerlink" title="共同点："></a>共同点：</h4><ul>
<li>都接收一个 React Element 并<strong>将此 Element 转化为 HTML 字符串，通过浏览器返回</strong>，实现了在服务端将页面拼接字符串插入 HTML 文档中并返回给浏览器 完成初步服务端渲染的目的</li>
</ul>
<h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><ul>
<li>renderToString(<font color="red">注：React 15</font>) 生成的 HTML 字符串的每个 Dom 节点都有 <code>data-react-id</code> 属性，根节点会有一个 <code>data-react-checkSum</code> 属性</li>
<li> renderToStaticMarkup 不带 <code>data-react-checkSum</code> 属性 浏览器渲染时必会重新渲染组件</li>
</ul>
<hr>
<p><font color="red">关于 data-react-checkSum</font>：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">如果两个组件有相同的props和Dom结构，这个值是一样的</span><br><span class="line"></span><br><span class="line">我们知道 服务端渲染完页面内容难过之后，浏览器端也会渲染以完成组件的交互等能力，浏览器端会生成组件的data-react-checkSum值 然后跟服务端渲染组件的值做对比，如果相等，则不再重复渲染</span><br></pre></td></tr></tbody></table></figure>

<p>这里有一张草图能大概描述这个过程嘤嘤嘤.<br><img src="/images/ssr/ssrcc.png" alt="cache_detai"></p>
<hr>
<h3 id="ReactDom-hydrate"><a href="#ReactDom-hydrate" class="headerlink" title="ReactDom.hydrate()"></a>ReactDom.hydrate()</h3><p>React 16 以后通过<br><code>renderToString</code> 渲染的组件不再带有 <code>data-react-*</code> 属性，因此浏览器端的渲染方式无法简单通过 <code>data-react-checksum</code> 来判断是否需要重新渲染</p>
<p>基于这样儿的背景下 <code>ReactDom</code> 提供了一个新的 API <code>ReactDom.hydrate()</code> 用法同 <code>render()</code> 在浏览器端渲染组件</p>
<p>当然，react 是向下兼容的，浏览器端在渲染组件时使用 render () 仍然没有问题，但不论是面向未来，还是基于性能的考虑，都应该采用更好的模式</p>
<hr>
<h3 id="renderToNodeStream-renderToStaticNodeStream"><a href="#renderToNodeStream-renderToStaticNodeStream" class="headerlink" title="renderToNodeStream()/renderToStaticNodeStream()"></a>renderToNodeStream()/renderToStaticNodeStream()</h3><p><font color="red">React 16 </font>为了优化页面的初始加载速度缩短 TTFB 时间，提供了这两个方法</p>
<p><strong>概念</strong><br>该方法持续产生子节流 返回 <code>Readable stream</code> 最终<strong>通过流形式返回的 HTML 字符串</strong><br>这样 服务端处理内容时是实时向浏览器端传输数据而不是一次性处理完成后才开始返回结果的</p>
<p><code>renderToStaticNodeStream</code> 之于 <code>renderToNodeStream</code> 也是不会产生 <code>data-react-*</code> 属性，对于静态页面 可以采用此方法。</p>
<h2 id="实际开发中可能存在的问题"><a href="#实际开发中可能存在的问题" class="headerlink" title="实际开发中可能存在的问题"></a>实际开发中可能存在的问题</h2><ol>
<li>服务端不存在支持组件挂载的浏览器环境，所以 react 组件只有 <code>componentDidMount</code> 之前的生命周期方法有效，所以在其之前的生命周期方法中不能用到浏览器的特性，比如 <code>window、localStorage</code>.</li>
<li> 双端可能都有拉取数据的需求，所以为了实现代码的复用，一种典型的做法就是把请求数据的逻辑放到 React 组件的静态方法中 然后双端共用，双端请求方法不一致的问题可以通过服务端与浏览器端的判断来封装一下 <strong>比如根据 window 是浏览器特有对象</strong></li>
</ol>
<h2 id="React-16-在服务端渲染上的惊喜"><a href="#React-16-在服务端渲染上的惊喜" class="headerlink" title="React 16 在服务端渲染上的惊喜"></a>React 16 在服务端渲染上的惊喜</h2><p>前面也有混杂说过，在此总结一下</p>
<ul>
<li>在浏览器渲染组件需要配合服务端使用 <code>hydrate</code> 方法</li>
<li>提供了 <code>stream</code> 方式的接口</li>
<li>与浏览器的新特性相似，除了能处理 <code>React Element</code> 也能处理别的类型，比如<code> string number</code></li>
<li>因为在返回结果 Dom 中废除了 <code>data-react-checksum</code> 等属性，所以服务端生成 HTML 更加高效</li>
<li>允许在渲染 Dom 中加入非标准 Dom 属性</li>
</ul>
<hr>
<p>好了 测试一下，基于 Node.js 实现一个小 demo</p>
<p><code>Express4.15.3 进行服务端处理</code></p>
<p><img src="/images/ssr/ssrvs1.png" alt="ssrvs1"><br>browser: 浏览器端渲染<br>server：服务端逻辑<br>share：同构的部分</p>
<p>运行效果：<br><img src="/images/ssr/ssrvs100.png" alt="ssr"><br><strong>share/app.js</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">import React, { Component } from "react";</span><br><span class="line">import logo from "./logo.svg";</span><br><span class="line">import "./App.css";</span><br><span class="line"></span><br><span class="line">class App extends Component {</span><br><span class="line">  constructor(props) {</span><br><span class="line">    super(props);</span><br><span class="line">    this.handleClick = this.handleClick.bind(this);</span><br><span class="line">  }</span><br><span class="line">  handleClick() {</span><br><span class="line">    alert('我被触发辣')</span><br><span class="line">  }</span><br><span class="line">  render() {</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className="App"&gt;</span><br><span class="line">        &lt;div className="App-header"&gt;</span><br><span class="line">          &lt;img src={logo} className="App-logo" alt="logo" /&gt;</span><br><span class="line">          &lt;h2&gt;Welcome to React in the Server&lt;/h2&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;p className="App-intro"&gt;点击按钮体验&lt;/p&gt;</span><br><span class="line">        &lt;button onClick={e =&gt; this.handleClick()}&gt; 我是按钮 &lt;/button&gt;  </span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></tbody></table></figure>
<p><strong>browser/index.js</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">import React from "react";</span><br><span class="line">import { hydrate } from "react-dom";</span><br><span class="line">import App from "../shared/App";</span><br><span class="line"></span><br><span class="line">hydrate(&lt;App /&gt;, document.getElementById("root"));</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong>server/index.js</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">import express from "express";</span><br><span class="line">import React from "react";</span><br><span class="line">import { renderToString } from "react-dom/server";</span><br><span class="line">import App from "../shared/App";</span><br><span class="line"></span><br><span class="line">const app = express();</span><br><span class="line"></span><br><span class="line">app.use(express.static("public"));</span><br><span class="line"></span><br><span class="line">app.get("*", (req, res) =&gt; {</span><br><span class="line">  const htmlMarkup = renderToString(&lt;App /&gt;);</span><br><span class="line">  res.send(`</span><br><span class="line">      &lt;!DOCTYPE html&gt;</span><br><span class="line">      &lt;head&gt;</span><br><span class="line">        &lt;title&gt;Universal Reacl&lt;/title&gt;</span><br><span class="line">        &lt;link rel="stylesheet" href="/css/main.css"&gt;</span><br><span class="line">        &lt;script src="/bundle.js" defer&gt;&lt;/script&gt;</span><br><span class="line">      &lt;/head&gt;</span><br><span class="line"></span><br><span class="line">      &lt;body&gt;</span><br><span class="line">        &lt;div id="root"&gt;${htmlMarkup}&lt;/div&gt;</span><br><span class="line">      &lt;/body&gt;</span><br><span class="line">    &lt;/html&gt;</span><br><span class="line">  `);</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">app.listen(process.env.PORT || 3000, () =&gt; {</span><br><span class="line">  console.log("Server is listening");</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>


<p><strong>server 端：</strong>使用 <code>renderToString</code> 生成的字符串，使用 <code>res.send</code> 发送给浏览器<br><strong>client 端：</strong> id 为 root 的 Dom 节点就来自服务端返回的结果，用了 <code>React.hydrate</code> 完成了浏览器端的逻辑处理部分</p>
<h3 id="假设一-client端渲染仍然使用render"><a href="#假设一-client端渲染仍然使用render" class="headerlink" title="假设一 client端渲染仍然使用render()"></a>假设一 client 端渲染仍然使用 render ()</h3><p><strong>测试</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">import React from "react";</span><br><span class="line">import {render } from "react-dom";</span><br><span class="line">import App from "../shared/App";</span><br><span class="line"></span><br><span class="line">render(&lt;App /&gt;, document.getElementById("root"));</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong>结果</strong><br>由于实现了向下兼容，所以是可以的，但是会给如下警告⚠️<br><img src="/images/ssr/hydrate_to_render.png" alt="hydrate_to_rende"></p>
<p><strong>结论</strong> 尽量使用新特性</p>
<hr>
<h3 id="假设二-完全依赖服务端渲染会发生什么"><a href="#假设二-完全依赖服务端渲染会发生什么" class="headerlink" title="假设二 完全依赖服务端渲染会发生什么"></a>假设二 完全依赖服务端渲染会发生什么</h3><p><strong>测试</strong><br>将 <code>browser/index.js</code> 代码注释掉<br><strong>结果</strong><br>页面正常显示，但是点击按钮没有不会弹窗<br><strong>结论</strong> 需要双端一起完成页面的展示与交互</p>
<hr>
<h3 id="假设三-使用React-16-renderToNodeStream渲染"><a href="#假设三-使用React-16-renderToNodeStream渲染" class="headerlink" title="假设三 使用React 16 renderToNodeStream渲染"></a>假设三 使用 React 16 renderToNodeStream 渲染</h3><p><strong>测试 更改 server/index.js</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">import express from "express";</span><br><span class="line">import React from "react";</span><br><span class="line">import { renderToNodeStream } from "react-dom/server";</span><br><span class="line">import App from "../shared/App";</span><br><span class="line"></span><br><span class="line">const app = express();</span><br><span class="line"></span><br><span class="line">app.use(express.static("public"));</span><br><span class="line"></span><br><span class="line">app.get("*", (req, res) =&gt; {</span><br><span class="line">  res.write(`</span><br><span class="line">      &lt;!DOCTYPE html&gt;</span><br><span class="line">      &lt;head&gt;</span><br><span class="line">        &lt;meta http-equiv="content-type" content="text/html; charset=utf-8"&gt;</span><br><span class="line">        &lt;title&gt;Universal Reacl&lt;/title&gt;</span><br><span class="line">        &lt;link rel="stylesheet" href="/css/main.css"&gt;</span><br><span class="line">        &lt;script src="/bundle.js" defer&gt;&lt;/script&gt;</span><br><span class="line">      &lt;/head&gt;`</span><br><span class="line">  );</span><br><span class="line">  res.write("&lt;div id='root'&gt;"); </span><br><span class="line">  const stream = renderToNodeStream(&lt;App/&gt;);</span><br><span class="line">  stream.pipe(res, { end: false });</span><br><span class="line">  stream.on('end', () =&gt; {</span><br><span class="line">    res.write("&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;");</span><br><span class="line">    res.end();</span><br><span class="line">  });</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>
<p><strong>说明：</strong> 为了配合返回一个流，使用 <code>res.write</code> 方法代替先前的 <code>res.end</code></p>
<p><strong>好处</strong><br>使用 <code>renderToString </code>页面 TTFB 时间</p>
<p><img src="/images/ssr/TTFB2.png" alt="TTFB2"><br>使用 <code>renderToNodeStream </code>页面 TTFB 时间</p>
<p><img src="/images/ssr/TTFB1.png" alt="TTFB1"></p>
<p><strong>结论</strong><br>采用渐进式流渲染可以最大限度的缩短服务器响应水间，从而使浏览器可以更快的接收到信息</p>
<hr>
<h3 id="假设三-同构应用与浏览器渲染优势对比"><a href="#假设三-同构应用与浏览器渲染优势对比" class="headerlink" title="假设三 同构应用与浏览器渲染优势对比"></a>假设三 同构应用与浏览器渲染优势对比</h3><p>浏览器渲染：<br><img src="/images/ssr/client_render.png" alt="client_rende"></p>
<p>同构应用：<br><img src="/images/ssr/ssr.png" alt="ss"></p>
<hr>
<h3 id="假设三-react16比react15渲染更加高效"><a href="#假设三-react16比react15渲染更加高效" class="headerlink" title="假设三 react16比react15渲染更加高效"></a>假设三 react16 比 react15 渲染更加高效</h3><p>React 15<br><img src="/images/ssr/react15_render.png" alt="react15_rende"><br>React 16<br><img src="/images/ssr/react16.png" alt="react16"></p>
<h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><ol>
<li>鉴于 <code>renderToNodeStream()/renderToStaticNodeStream()</code> 与<br><code>renderToString()/renderToStaticMarkup()</code><br>React 16 之后都不存在 <code>data-react-*</code> 了 双方还有什么区别？</li>
<li>react 16 之后 如何做双端对比？ 官方说是根据 <code>ReactDom.hydrate()</code> 与 <code>renderToString()</code> 结合判断.. 一脸懵逼</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>你不知道的 JS 系列 - 理解 JS 中 赋值，浅拷贝，深拷贝</title>
    <url>/2019/03/25/clone/</url>
    <content><![CDATA[<h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>又回到了这个老生常谈，新生绝望的问题上，通常遇到这种大家都比较熟悉的问题，反而不知道怎么列大纲，怕不够深入也怕脱离主题～<br>emm..<br>此文系 不要再问我 XX 系列之 <font color="red">不要再问我 JS Clone 的问题了</font></p>
<a id="more"></a>

<h2 id="为什么会存在这三种情况？三者有何差异"><a href="#为什么会存在这三种情况？三者有何差异" class="headerlink" title="为什么会存在这三种情况？三者有何差异"></a>为什么会存在这三种情况？三者有何差异</h2><p><code>clone</code> 本来很简单，只是因为 JS 中不同的数据类型存储方式 (<strong>堆和栈</strong>) 的差异，我们才会觉得它貌似有点‘复杂’</p>
<p><img src="/images/clone/clone1.png" alt="clone1"></p>
<p>基本类型和引用类型的差异如上图所示了<br>它们共同的目标就是<font color="red">以一个对象为原型 clone 出另外一个新对象，因为自身的问题产生一些副作用，三者的差异其实就体现在副作用的差异上</font></p>
<h3 id="差异（堆和栈）"><a href="#差异（堆和栈）" class="headerlink" title="差异（堆和栈）"></a>差异（堆和栈）</h3><ul>
<li>栈（stack）为自动分配的内存空间，它由系统自动释放</li>
<li>而堆（heap）则是动态分配的内存，大小不定也不会自动释放</li>
</ul>
<hr>
<p><font color="red">基础类型：</font> 值存放在栈中，<strong>比较是值的比较</strong><br><font color="red">引用类型：</font> 值存放在堆中，变量实际上是一个存放在栈内存的指针，这个指针指向堆内存中的地址。每个空间大小不一样，要根据情况开进行特定的分配，<strong>引用类型的比较是引用的比较</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var person1 = [1,2,3];</span><br><span class="line">var person2 = [1,2,3];</span><br><span class="line">console.log(a === b); // false</span><br></pre></td></tr></tbody></table></figure>


<h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>赋值的概念 即使刚入行也不陌生，每天都在用的<code>'='</code></p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul>
<li>基本类型：在内存中新开辟一段栈内存，然后再把再将值赋值到新的栈中，是两个独立相互不影响的变量</li>
<li>引用类型：赋值是传址，是对象保存在栈中的地址的赋值，这样的话两个变量就指向堆内存的同一个对象，因此两者之间操作互相有影响</li>
</ul>
<h4 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var obj1 = {</span><br><span class="line">  name:'maying',</span><br><span class="line">  age:22,</span><br><span class="line">  sex:'女',</span><br><span class="line">  language : [1,[2,3],[4,5],[9,0]]</span><br><span class="line">}</span><br><span class="line">var sringD = 'pre';</span><br><span class="line">var obj3 = sringD;</span><br><span class="line">sringD = 'post';</span><br><span class="line"></span><br><span class="line">var obj2 = obj1;</span><br><span class="line">obj1.name = 'gaile',</span><br><span class="line">obj1.language[0] = 'jjj'</span><br><span class="line">console.log('obj1',obj1)</span><br><span class="line">       /*</span><br><span class="line">        {</span><br><span class="line">            age: 22</span><br><span class="line">            language: (4) ["jjj", Array(2), Array(2), Array(2)]</span><br><span class="line">            name: "gaile"</span><br><span class="line">            sex: "女"</span><br><span class="line">        }</span><br><span class="line">       */</span><br><span class="line">console.log('obj2',obj2)</span><br><span class="line">        /*</span><br><span class="line">            age: 22</span><br><span class="line">            language: (4) ["jjj", Array(2), Array(2), Array(2)]</span><br><span class="line">            name: "gaile"</span><br><span class="line">            sex: "女"</span><br><span class="line">        */</span><br><span class="line">console.log('sringD',sringD) //post</span><br><span class="line">console.log('obj3',obj3) //pre</span><br></pre></td></tr></tbody></table></figure>

<h3 id="理解浅拷贝"><a href="#理解浅拷贝" class="headerlink" title="理解浅拷贝"></a>理解浅拷贝</h3><p>之前的很多年，我认为<strong>赋值差不多等于浅拷贝</strong><br>写个小 demo 发现它们之间的差异</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var obj2 = obj1;</span><br><span class="line">var obj3 = {...obj1};</span><br><span class="line">obj1.name = 'gaile',</span><br><span class="line">obj1.language[0] = 'jjj'</span><br><span class="line">console.log('obj1',obj1)</span><br><span class="line">console.log('obj2',obj2)</span><br><span class="line">console.log('obj3',obj3)</span><br></pre></td></tr></tbody></table></figure>
<p><img src="/images/clone/qiankaobei2.png" alt="qiankaobei2"><br>赋值对象，是将对象指针直接赋值给另一个变量<br>浅拷贝，是重新创建了新对象，所以你更改 <code>obj1.name</code> 的时候不会影响到它，但是改变引用类型时就不能幸免了</p>
<p><strong>所谓的浅拷贝就是：</strong></p>
<ul>
<li>当对简单的数据类型进行赋值的时候，其实就是直接在栈中新开辟一个地方专门来存储一样的值</li>
<li>当对引用类型进行浅拷贝，后面的对象和前面的对象在第一层数据结构中指向同一个堆地址，但是如果前面的数据不止有一层（<font color="red">属性值是一个指向对象的引用只拷贝那个引用值</font>），类似 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">language : [1,[2,3],[4,5],[9,0]]</span><br></pre></td></tr></tbody></table></figure>
<p><strong>内部的子对象的指针还是同一个地址</strong></p>
<p>如果要实现一直往下复制 就引出了接下来要说的<font color="red">深拷贝</font></p>
<p><strong>结论：浅复制要比复制来的深刻一点，至少它开辟了一个新对象，一块儿新的堆内存</strong></p>
<h4 id="目前可行的实现方式"><a href="#目前可行的实现方式" class="headerlink" title="目前可行的实现方式"></a>目前可行的实现方式</h4><p>站在巨人的肩膀上，我们可以轻松实现浅拷贝</p>
<ul>
<li>数组的浅拷贝 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1. b = [...a]</span><br><span class="line">2. b = a.slice(0) / [].slice.call(a,0)</span><br><span class="line">3. b = a.concat() / [].concat.call(a)</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>对象的浅拷贝 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1. b = Object.assign({},a)</span><br><span class="line">2. b = {...a}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="如果要你自己实现呢"><a href="#如果要你自己实现呢" class="headerlink" title="如果要你自己实现呢"></a>如果要你自己实现呢</h4><p>原理：遍历对象的每个属性进行逐个拷贝</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">function copy(obj) {</span><br><span class="line">  if (!obj || typeof obj !== 'object') {</span><br><span class="line">    return</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  var newObj = obj.constructor === Array ? [] : {}</span><br><span class="line">  for (var key in obj) {</span><br><span class="line">       if(obj.hasOwnProperty(key)){</span><br><span class="line">          newObj[key] = obj[key]</span><br><span class="line">        }</span><br><span class="line">  }</span><br><span class="line">  return newObj</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="理解深拷贝"><a href="#理解深拷贝" class="headerlink" title="理解深拷贝"></a>理解深拷贝</h3><p>深拷贝的意义，就是完全复制，如果你读了上文，应该就没有什么疑问了</p>
<p>将 a 对象复制一份给对象 b，不管 a 中的数据结构嵌套有多深，当改变 a 对象中的任意深度的某个值后，b 中的该值不会受任何影响</p>
<h4 id="目前可行的实现方式-1"><a href="#目前可行的实现方式-1" class="headerlink" title="目前可行的实现方式"></a>目前可行的实现方式</h4><ul>
<li><code>JSON.stringify()``和JSON.parse()</code> 的混合配对使用 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var obj4 = JSON.parse(JSON.stringify(obj1)) </span><br><span class="line"></span><br><span class="line">obj1.name='yishu',</span><br><span class="line"></span><br><span class="line">obj1.language[1] = ["二","三"];</span><br><span class="line">obj4.language[2] = ["四","五"];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.log(obj1);   </span><br><span class="line">console.log(obj4); </span><br></pre></td></tr></tbody></table></figure>
<p><img src="/images/clone/deepclone.png" alt="deepclone"><br><code>obj1</code>,<code>obj4</code> 是两个独立的对象，更改数据互不影响，达到了我们要的目的</p>
<p><strong>它粗暴，有用，但是也有缺点</strong></p>
<ol>
<li><code>在JSON.stringify()</code> 做序列化时，<code>undefined</code>、<code>function</code> 以及 <code>symbol</code> 值，会被忽略</li>
</ol>
<p>例如</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var obj = {</span><br><span class="line">  a: {b: 'old'}, </span><br><span class="line">  c:undefined, </span><br><span class="line">  d: function () {},</span><br><span class="line">  e:  Symbol('')</span><br><span class="line"> }</span><br><span class="line">var newObj = JSON.parse(JSON.stringify(obj))</span><br><span class="line">newObj.a.b = 'new'</span><br><span class="line">console.log(obj)</span><br><span class="line">console.log(newObj)</span><br></pre></td></tr></tbody></table></figure>
<p>结果<br><img src="/images/clone/jsonquedian.png" alt="jsonquedian"></p>
<h4 id="如果要你自己实现呢-1"><a href="#如果要你自己实现呢-1" class="headerlink" title="如果要你自己实现呢"></a>如果要你自己实现呢</h4><p>原理：使用递归，遍历每一个对象属性进行拷贝</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var obj = {</span><br><span class="line">  a: {b: 'old'}, </span><br><span class="line">  c:undefined, </span><br><span class="line">  d: function () {},</span><br><span class="line">  e:  Symbol('')</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function copy(obj) {</span><br><span class="line">  if (!obj || typeof obj !== 'object') {</span><br><span class="line">    return</span><br><span class="line">  }</span><br><span class="line">  var newObj = obj.constructor === Array ? [] : {}</span><br><span class="line">  for (var key in obj) {</span><br><span class="line">    if (obj.hasOwnProperty(key)) {</span><br><span class="line">      if (typeof obj[key] === 'object' &amp;&amp; obj[key]) {</span><br><span class="line">        newObj[key] = copy(obj[key])</span><br><span class="line">      } else {</span><br><span class="line">        newObj[key] = obj[key]</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  return newObj</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var newObj = copy(obj)</span><br><span class="line">newObj.a.b = 'new'</span><br><span class="line">console.log(obj)</span><br><span class="line">console.log(newObj)</span><br></pre></td></tr></tbody></table></figure>
<p><img src="/images/clone/jsonquedian.png" alt="jsonquedian"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>赋值：引用复制 执向同一个对象</li>
<li>浅拷贝 ：生成一个新对象，只能拷贝一层，当属性值是一个指向对象的引用只拷贝那个引用值</li>
<li>深拷贝：完全拷贝，前后对象没有任何关系</li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.zhihu.com/question/23031215">https://www.zhihu.com/question/23031215</a><br><a href="https://segmentfault.com/a/1190000018204798">https://segmentfault.com/a/1190000018204798</a></p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>clone</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟实现 JS 的 bind 方法</title>
    <url>/2019/03/13/bind/</url>
    <content><![CDATA[<h2 id="为什么要实现一个bind函数？"><a href="#为什么要实现一个bind函数？" class="headerlink" title="为什么要实现一个bind函数？"></a>为什么要实现一个 bind 函数？</h2><p><code>bind()</code> 函数在 <code>ECMA-262 第五版</code>才被加入<br>它可能无法在所有浏览器上运行，为了世界和平，必要的时候我们要手动实现它</p>
<a id="more"></a>
<h2 id="现有bind函数的功能？"><a href="#现有bind函数的功能？" class="headerlink" title="现有bind函数的功能？"></a>现有 bind 函数的功能？</h2><p>改造之前要清楚现有 <code>bind()</code> 函数做了哪些事儿</p>
<p>从 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">MDN</a> 上找到一些关于它的定义</p>
<p>bind () 方法创建一个新的函数，在调用时设置 this 关键字为提供的值。并在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项</p>
<p><strong>语法</strong> <code>function.bind(thisArg[, arg1[, arg2[, ...]]])</code></p>
<p>函数会创建一个新绑定函数，它包装了原函数对象<br><code>ceshiFn.bind(myObject)</code></p>
<p>绑定函数也可以使用 <code>new</code> 运算符构造，此时提供的 <code>this</code> 值会被忽略，但前置参数（arg1,arg2）仍会提供给模拟函数</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var Fn = ceshiFn.bind(myObject,1,2)</span><br><span class="line">new Fn() </span><br></pre></td></tr></tbody></table></figure>
<p>此时 <code>myObject</code> 被忽略 但是 参数依然会传递给 <code>ceshiFn</code> 令其初始化</p>
<p><strong>参数：</strong></p>
<ul>
<li><font color="red">thisArg</font>：当被绑定的函数被调用时，将它的 <code>this</code> 关键字设置为 <code>thisArg</code></li>
<li><font color="red">arg1，arg2</font>: 被调用时，这些参数将传递给被绑定的方法</li>
</ul>
<p><strong>返回值：</strong><br>指定的 <code>this</code> 值和初始化参数改造过原函数拷贝</p>
<h3 id="继续探索bind函数的功能"><a href="#继续探索bind函数的功能" class="headerlink" title="继续探索bind函数的功能"></a>继续探索 bind 函数的功能</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var obj = {};</span><br><span class="line">console.log('obj',obj)</span><br><span class="line">console.log(typeof Function.prototype.bind)  // bind</span><br><span class="line">console.log(typeof Function.prototype.bind()) //bind</span><br><span class="line">console.log(Function.prototype.bind.name) //bind</span><br><span class="line">console.log(Function.prototype.bind().name) // bound</span><br></pre></td></tr></tbody></table></figure>
<p>由此我们可以得到得出以下结论</p>
<ol>
<li><code>bind</code> 是 <code>Function</code> 原型链中 <code>Function.prototype</code> 的一个属性，每个函数都可以调用它</li>
<li><code>bind</code> 本身是一个函数名为 <code>bind</code> 的函数，返回值是一个名为 <code>bound</code> 的函数</li>
</ol>
<p>下面这个例子</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var obj = {</span><br><span class="line">    name: 'yishu',</span><br><span class="line">};</span><br><span class="line">function original(a, b){</span><br><span class="line">    console.log(this.name);</span><br><span class="line">    console.log([a, b]);</span><br><span class="line">    return false;</span><br><span class="line">}</span><br><span class="line">var bound = original.bind(obj, 1);</span><br><span class="line">var boundResult = bound(2); // 'yishu', [1, 2]</span><br><span class="line"></span><br><span class="line">console.log(boundResult); // false</span><br><span class="line">console.log(original.bind.name); // 'bind'</span><br><span class="line">console.log(original.bind.length); // 1</span><br><span class="line">console.log(original.bind().length); // 2 返回original函数的形参个数</span><br><span class="line">console.log(bound.name); // 'bound original'</span><br><span class="line">console.log((function(){}).bind().name); // 'bound '</span><br><span class="line">console.log((function(){}).bind().length); // 0</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li><code>bind</code> 是函数可被传参数，返回值 <code>bound</code> 也是函数，也可以传参数</li>
<li>被 <code>bind()</code> 绑定的函数的 this 关键字是 <code>bind()</code> 的第一个参数</li>
<li>传递 <code>bind</code> 的其他参数被接收处理了，<code>bind()</code> 之后返回的函数 <code>bound</code> 函数的参数也被接收处理了，也就是说被合并处理了</li>
<li>并且 <code>bind()</code> 后的 <code>name</code> 为 <code>bound + 空格 + 调用bind的函数名</code>。如果是匿名函数则是 <code>bound + 空格</code></li>
<li>bind 后的返回值函数 <code>bound</code>，执行后返回值是原函数（original）的返回值</li>
<li> bind 函数形参（即函数的 length）是 1。bind 后返回的 bound 函数形参根据绑定的函数原函数（original）形参个数确定</li>
</ol>
<p>到这里 我们根据得出的结论 就可以模拟一个简单版本的 bind 函数了</p>
<h3 id="核心功能的bindFn函数"><a href="#核心功能的bindFn函数" class="headerlink" title="核心功能的bindFn函数"></a>核心功能的 bindFn 函数</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Function.prototype.bindFn = function(thisArg){</span><br><span class="line"></span><br><span class="line">  //保证是一个函数调用了bindFn函数</span><br><span class="line">  if (typeof this != 'function'){</span><br><span class="line">    throw new TypeError(this + 'must be a function');</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  //保存除了thisArg之外的其他形参 转成数组</span><br><span class="line">  console.log('bindFn',arguments)</span><br><span class="line">    let arg = [].slice.call(arguments ,1);</span><br><span class="line">   var self = this;</span><br><span class="line"></span><br><span class="line">   var bound = function(){</span><br><span class="line">        // bind返回的函数 的参数转成数组</span><br><span class="line">        var boundArgs = [].slice.call(arguments);</span><br><span class="line">        // apply修改this指向，把两个函数的参数合并传给self函数，并执行self函数，返回执行结果</span><br><span class="line">        return self.apply(thisArg, arg.concat(boundArgs));</span><br><span class="line">    }</span><br><span class="line">    return bound;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 测试</span><br><span class="line">var obj = {</span><br><span class="line">    name: 'yishu',</span><br><span class="line">    age:18</span><br><span class="line">};</span><br><span class="line">function original(){</span><br><span class="line">  console.log([].slice.call(arguments))</span><br><span class="line">}</span><br><span class="line">var bound = original.bindFn(obj,3,4,5)</span><br><span class="line">bound(7); // [3, 4, 5, 7]</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>到这里基本上把 bind 的核心功能写完了，也能够适用大部分场景了 <code>bindFn</code> 只能能做到的只是永久地绑定指定的 <code>this</code> ，但是我们发现 <code>MDN</code> 上关于 <code>bind函数</code>描述 还有一种情况，那就是<font color="red">当你使用 <code>new操作符</code>调用绑定函数时</font><br>是这么说的</p>
<blockquote>
<p>thisArg：当使用 new 操作符调用绑定函数时，该参数无效。<br>一个绑定函数也能使用 new 操作符创建对象：这种行为就像把原函数当成构造器。提供的 <code>this</code> 值被忽略，同时调用时的参数被提供给模拟函数</p>
</blockquote>
<p>我们可以通过一个实例来看原生的 bind 对于使用 new 的情况是怎么样的</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var obj = {</span><br><span class="line">    name: 'yishu',</span><br><span class="line">};</span><br><span class="line">function original(){</span><br><span class="line">    console.log('this', this.name,[].slice.call(arguments));</span><br><span class="line">}</span><br><span class="line">var bound = original.bind(obj,1);</span><br><span class="line">bound(2,3) //this yishu (3)&nbsp;[1, 2, 3]</span><br><span class="line">new bound(2,3) //this undefined (3)&nbsp;[1, 2, 3]s</span><br></pre></td></tr></tbody></table></figure>
<p>此时 <code>this</code> 指向了 <code>new bound()</code> 生成的新对象，所以找不到 <code>name</code> 为 <code>yishu</code> 的值了，但是参数依然传递的</p>
<p><strong>结论</strong></p>
<ul>
<li><code>bind</code> 原先指向 <code>obj</code> 的失效了，其他参数有效。</li>
<li><code>new bound</code> 的返回值是以 <code>original</code> 原函数构造器生成的新对象。<code>original</code> 原函数的 <code>this</code> 指向的就是这个新对象</li>
</ul>
<p>我们看到 又涉及到 <code>new</code> 操作了，<a href="http://maying.ink/2019/03/13/new/">写过关于模拟 new 的文章</a><br>简单摘要 new 做了什么</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1.创建了一个全新的对象。</span><br><span class="line">2.这个对象会被执行[[Prototype]]（也就是__proto__）链接。</span><br><span class="line">3.生成的新对象会绑定到函数调用的this。</span><br><span class="line">4.通过new创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上。</span><br><span class="line">5.如果函数没有返回对象类型Object(包含Functoin, Array, Date, RegExg, Error)，那么new表达式中的函数调用会自动返回这个新的对象。</span><br></pre></td></tr></tbody></table></figure>
<p>所以 ，当使用 <code>new</code> 调用的时候，<code>bind</code> 的返回值函数 <code>bound</code> 内部要模拟实现 <code>new</code> 实现的操作，似曾相识了</p>
<h3 id="bindFn函数的升级"><a href="#bindFn函数的升级" class="headerlink" title="bindFn函数的升级"></a>bindFn 函数的升级</h3><p>区分是否是 new 调用 当使用 new 调用需要在 bind 函数返回值函数里实现模拟 <code>new</code> 的操作</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Function.prototype.bindFn = function bind(thisArg){</span><br><span class="line">    if(typeof this !== 'function'){</span><br><span class="line">        throw new TypeError(this + ' must be a function');</span><br><span class="line">    }</span><br><span class="line">    // 存储调用bind的函数本身</span><br><span class="line">    var self = this;</span><br><span class="line">    // 去除thisArg的其他参数 转成数组</span><br><span class="line">    var args = [].slice.call(arguments, 1);</span><br><span class="line">    var bound = function(){</span><br><span class="line">        // bind返回的函数 的参数转成数组</span><br><span class="line">        var boundArgs = [].slice.call(arguments);</span><br><span class="line">        var finalArgs = args.concat(boundArgs);</span><br><span class="line">        // new 调用时，其实this instanceof bound判断也不是很准确。es6 new.target就是解决这一问题的。</span><br><span class="line">        //new.target属性允许你检测函数或构造方法是否是通过new运算符被调用的</span><br><span class="line">        if(new.target){ //检测函数或构造方法是否是通过new运算符被调用的</span><br><span class="line">            // 这里是实现上文描述的 new 的第 1, 2, 4 步</span><br><span class="line">            // 1.创建一个全新的对象</span><br><span class="line">            // 2.并且执行[[Prototype]]链接</span><br><span class="line">            // 4.通过`new`创建的每个对象将最终被`[[Prototype]]`链接到这个函数的`prototype`对象上。</span><br><span class="line">            // self可能是ES6的箭头函数，没有prototype，所以就没必要再指向做prototype操作。</span><br><span class="line">            if(self.prototype){</span><br><span class="line">                // ES5 提供的方案 Object.create()</span><br><span class="line">                // bound.prototype = Object.create(self.prototype);</span><br><span class="line">                // 但既然是模拟ES5的bind，那浏览器也基本没有实现Object.create()</span><br><span class="line">                // 所以采用 MDN ployfill方案 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create</span><br><span class="line">                function Empty(){}</span><br><span class="line">                Empty.prototype = self.prototype;</span><br><span class="line">                bound.prototype = new Empty();</span><br><span class="line">            }</span><br><span class="line">            // 这里是实现上文描述的 new 的第 3 步</span><br><span class="line">            // 3.生成的新对象会绑定到函数调用的`this`。</span><br><span class="line">            var result = self.apply(this, finalArgs);</span><br><span class="line">            // 这里是实现上文描述的 new 的第 5 步</span><br><span class="line">            // 5.如果函数没有返回对象类型`Object`(包含`Functoin`, `Array`, `Date`, `RegExg`, `Error`)，</span><br><span class="line">            // 那么`new`表达式中的函数调用会自动返回这个新的对象。</span><br><span class="line">            var isObject = typeof result === 'object' &amp;&amp; result !== null;</span><br><span class="line">            var isFunction = typeof result === 'function';</span><br><span class="line">            if(isObject || isFunction){</span><br><span class="line">                return result;</span><br><span class="line">            }</span><br><span class="line">            return this;</span><br><span class="line">        }</span><br><span class="line">        else{</span><br><span class="line">           //不使用new操作符时</span><br><span class="line">            // apply修改this指向，把两个函数的参数合并传给self函数，并执行self函数，返回执行结果</span><br><span class="line">            return self.apply(thisArg, finalArgs);</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    return bound;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>bind 是 Function 原型链中的 Function.prototype 的一个属性，它是一个函数，修改 this 指向，合并参数传递给原函数，返回值是一个新的函数。</li>
<li>bind 返回的函数可以通过 new 调用，这时提供的 this 的参数被忽略，指向了 new 生成的全新对象。内部模拟实现了 new 操作符。</li>
<li>bindFn</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 最终版 删除注释 详细注释版请看上文</span><br><span class="line">Function.prototype.bind = Function.prototype.bind || function bind(thisArg){</span><br><span class="line">    if(typeof this !== 'function'){</span><br><span class="line">        throw new TypeError(this + ' must be a function');</span><br><span class="line">    }</span><br><span class="line">    var self = this;</span><br><span class="line">    var args = [].slice.call(arguments, 1);</span><br><span class="line">    var bound = function(){</span><br><span class="line">        var boundArgs = [].slice.call(arguments);</span><br><span class="line">        var finalArgs = args.concat(boundArgs);</span><br><span class="line">        if(new.target){</span><br><span class="line">            if(self.prototype){</span><br><span class="line">                function Empty(){}</span><br><span class="line">                Empty.prototype = self.prototype;</span><br><span class="line">                bound.prototype = new Empty();</span><br><span class="line">            }</span><br><span class="line">            var result = self.apply(this, finalArgs);</span><br><span class="line">            var isObject = typeof result === 'object' &amp;&amp; result !== null;</span><br><span class="line">            var isFunction = typeof result === 'function';</span><br><span class="line">            if(isObject || isFunction){</span><br><span class="line">                return result;</span><br><span class="line">            }</span><br><span class="line">            return this;</span><br><span class="line">        }</span><br><span class="line">        else{</span><br><span class="line">            return self.apply(thisArg, finalArgs);</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    return bound;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>


]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>bind</tag>
      </tags>
  </entry>
  <entry>
    <title>Dom 操作成本 浏览器的重排和重绘</title>
    <url>/2018/05/16/dom%E6%93%8D%E4%BD%9C%E6%88%90%E6%9C%AC/</url>
    <content><![CDATA[<p>操作 Dom 的成本很高 不要轻易去操作 Dom 这句话从开始入门就听说，那么这里说的成本是指什么？<br>由此引出今天的问题</p>
<p>首先我们要清楚几个概念</p>
<h3 id="什么是DOM？"><a href="#什么是DOM？" class="headerlink" title="什么是DOM？"></a>什么是 DOM？</h3><ul>
<li>DOM 全称 Document Object Model 文档对象模型</li>
<li>它是为 HTML（XML）提供的 API</li>
<li>HTML 是一种标记语言 HTML 在 DOM 模型标准中被视为对象</li>
<li> DOM 只提供编程接口却无法实际操作 HTML 里面的内容 </li>
<li>在浏览器中 前端工程师可以通过脚本语言（js）通过 DOM 去操作 HTML 内容<br>（不只 js 能调用 DOM 这个 API Python 也可以）</li>
<li> ps：也存在 CSSOM：CSS Object Model 浏览器将 CSS 代码解析成树形的数据结构与 DOM 是两个独立的数据机构</li>
</ul>
<h3 id="浏览器渲染过程"><a href="#浏览器渲染过程" class="headerlink" title="浏览器渲染过程"></a>浏览器渲染过程</h3><p>讨论 DOM 操作成本 首先要了解下该成本的来源 那么就离不开浏览器渲染<br>浏览器渲染前需要先构建 DOM 和 CSS 树 因此我们需要尽快将 HTML 和 CSS 都提供给浏览器</p>
<p>这里只讨论浏览器拿到 HTML 之后开始解析 渲染 </p>
<p><font color="red">之前的一些另开一篇</font></p>
<ol>
<li>解析 HTML 构建 DOM 树 （这里遇到外链 会发起请求）</li>
<li>解析 CSS 生成 CSS 规则树</li>
<li>合并 DOM 树和 CSS 规则 生成 render（渲染）树</li>
<li>布局 render 树（Layout/reflow）负责各元素的尺寸，位置的计算</li>
<li>绘制 render 树（paint）绘制页面像素信息</li>
<li>浏览器会将各层的信息发送给 GPU GPU 将各层合成 (composite) 显示在屏幕上<h5 id="构建DOM树"><a href="#构建DOM树" class="headerlink" title="构建DOM树"></a>构建 DOM 树</h5><font color="red">HTML 标记转换成文档对象模型 (DOM)</font><br>DOM 树构建过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点<h5 id="构建CSSOM树"><a href="#构建CSSOM树" class="headerlink" title="构建CSSOM树"></a>构建 CSSOM 树</h5><font color="red">CSS 标记转换成 CSS 对象模型 (CSSOM)</font><br>在最终计算各个 2 节点的样式时 浏览器都会先从该节点的普遍属性（比如全局样式）开始  再去应用该节点的具体属性</li>
</ol>
<p>每个浏览器都有自己的默认样式表因此很多时候这颗 CSSOM 树只是对这张默认样式表的部分替换</p>
<p>DOM 和 CSSOM 都要经过<br><code>Bytes→characters→tokens→nodes→objectmodel</code> 这个过程<br>DOM 和 CSSOM 是独立的数据结构<br>此处需要一张图片</p>
<h5 id="生成render（渲染）树-由此-浏览器中会解析并生成两个内部数据结构"><a href="#生成render（渲染）树-由此-浏览器中会解析并生成两个内部数据结构" class="headerlink" title="生成render（渲染）树 由此 浏览器中会解析并生成两个内部数据结构"></a>生成 render（渲染）树 由此 浏览器中会解析并生成两个内部数据结构</h5><ul>
<li>Dom 树表示页面结构</li>
<li> DOM 树和 CSSOM 合并生成 render 树（渲染树），渲染树表示 Dom 节点在页面中如何显示（宽高 位置等）</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">在dom树中每一个需要显示的节点在渲染树种至少存在一个对应的节点 渲染树中的节点被称之为“帧”或者“盒” 符合css模型的定义 一旦Dom树和渲染树构建完成  浏览器就开始 显示（绘制paint）页面元素</span><br></pre></td></tr></tbody></table></figure>


<p>简单描述下 render 的过程</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">DOM树从根节点开始遍历可见节点</span><br><span class="line">设置了类似 display：none （则该节点不可见） 在render过程中是被跳过的</span><br><span class="line">visibility:hidden; opacity:0 这种仍旧占据空间的节点不会被跳过render  保存各个节点的样式信息及其余节点的从属关系</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Layout布局</span><br><span class="line">有了各个节点的信息属性 但不知道各个节点的确切位置和大小 所以要通过布局将样式信息和属性转换为实际可视窗口的相对大小和位置</span><br><span class="line">（DOM 树捕获文档标记的属性和关系，但并未告诉我们元素在渲染后呈现的外观。那是 CSSOM 的责任）</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Paint绘制</span><br><span class="line">最后只要将确定好位置大小的各节点通过GPU渲染到屏幕的实际像素</span><br></pre></td></tr></tbody></table></figure>

<p>TIPS：</p>
<ul>
<li>在上述渲染过程中 前三点可能要多次执行 比如 js 脚本去操作 DOM 更改 CSS 样式 浏览器又要重新构建 DOM CSSOM 树 重新 render 重新 layout paint</li>
<li> 因为 layout 在 paint 之前 因此每次 layput 重新布局（reflow 回流）后都要重新触发 paint 渲染 这时又要去消耗 GPU</li>
<li>paint 不一定会触发 layout 比如改个颜色改个背景（repaint 重绘）</li>
<li>图片下载完也会重新触发 Layout 和 paint</li>
</ul>
<h5 id="何时触发reflow（重排）和repaint（重绘）"><a href="#何时触发reflow（重排）和repaint（重绘）" class="headerlink" title="何时触发reflow（重排）和repaint（重绘）"></a>何时触发 reflow（重排）和 repaint（重绘）</h5><p><font color="red">reflow (重排)：</font>当 dom 树的变化影响了元素的集合属性 =》 意味着元素的内容，结构 位置或者尺寸发生了变化，同样其他元素的集合属性和位置也会因此受到影响，浏览器会使渲染树（render 树）中受到影响的部分失效  需要重新计算样式和渲染树，这个过程称为重排（reflow）</p>
<p><font color="red">repaint (重绘)：</font> 意味着元素发生的改变只你影响了节点的一些样式（背景色 边框颜色 文字元素等）只需要应用新样式绘制这个元素就可以了 （完成重排后 浏览器会重新绘制受影响的部分到屏幕中 这个过程叫做重绘）</p>
<p>并不是所有的 dom 辩护都会影响几何属性 例如  改变元素的背景色不会影响 宽和高 这种情况下 只会发生一次重绘（不需要重排）因为元素的布局没有改变</p>
<p><font color="red">重排一定会引起浏览器的重绘 重绘则不一定伴随重排</font></p>
<p><font color="red">重排</font>的成本开销要高于<font color="red">重绘</font>一个节点的重排往往导致子节点以及同级节点的重排</p>
<h6 id="触发重排的情况"><a href="#触发重排的情况" class="headerlink" title="触发重排的情况"></a>触发重排的情况</h6><p>当页面布局的几何属性改变时就需要重排 下列情况会导致重排</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">页面第一次渲染（初始化）</span><br><span class="line"></span><br><span class="line">DOM树变化（如：增删节点）</span><br><span class="line">元素位置改变</span><br><span class="line">元素尺寸改变（外边距 内边距 边框厚度 宽度 高度等）</span><br><span class="line">Render树变化（如：padding改变）</span><br><span class="line">浏览器窗口resize</span><br><span class="line">获取元素的某些属性：</span><br><span class="line">当滚动条出现时，会触发整个页面的重排</span><br></pre></td></tr></tbody></table></figure>

<p>由于每次重排都会产生计算消耗，大多数浏览器通过队列化修改并批量执行来优化重排的过程</p>
<p>但是  我们经常会不知不觉强制刷新队列并要求计划任务立即执行<br>获取布局信息的操作会到最后队列刷新  比如</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">offsetTop , offsetLeft , offsetWidth , offsetHeight</span><br><span class="line"></span><br><span class="line">scrollTop , scrollLeft , scrollWidth , scrollHeight</span><br><span class="line"></span><br><span class="line">clientTop , clientLeft , clientWidth , clientHeight</span><br><span class="line"></span><br><span class="line">getComputedStyle() ( currentStyle in IE )</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>当获取以上的属性和方法时 浏览器为了获取最新的布局信息 不得不立即触发重排以返回正确的值</p>
<h6 id="最小化重绘和重排"><a href="#最小化重绘和重排" class="headerlink" title="最小化重绘和重排"></a>最小化重绘和重排</h6><p>重绘和重排代价很昂贵 因此一个号的提高程序响应熟读的策略就是减少此类操作的发生</p>
<h6 id="优化方式"><a href="#优化方式" class="headerlink" title="优化方式"></a>优化方式</h6><ol>
<li>合并多次对样式属性的操作 </li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">思考</span><br><span class="line">var el = document.getElementById('mydiv');</span><br><span class="line">el.style.borderLeft = '1px';</span><br><span class="line">el.style.borderRight = '2px';</span><br><span class="line">el.style.padding = '5px';</span><br><span class="line"></span><br><span class="line">即使有浏览器有重排机制优化 但最坏的情况也是进行三次重排</span><br><span class="line"></span><br><span class="line">修改后</span><br><span class="line"></span><br><span class="line">var el = document.getElementById('mydiv');</span><br><span class="line">el.style.cssText = 'border-left: 1px; border-right: 2px; padding: 5px;';</span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">var el = document.getElementById('mydiv');</span><br><span class="line">el.className = 'active';</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<ol start="2">
<li>批量修改 dom<br>当需要对 dom 元素进行一系列的操作时候 可以通过以下的步骤来减少重绘和重排的次数</li>
</ol>
<p><font color="green"> * 使元素脱离文本流</font><br><font color="green"> * 操作元素</font><br><font color="green"> * 操作完成后 将元素带回文档中</font><br>这样儿 只有第一步和第三部触发两次重排</p>
<p>有三种方式可以实现上面的步骤</p>
<p><font color="red"> 1. 隐藏元素（display:none）操作元素 重新展示</font></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var ul = document.getElementById('mylist');</span><br><span class="line">ul.style.display = 'none';</span><br><span class="line">appendDataToElement(ul, data);</span><br><span class="line">ul.style.display = 'block';</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><font color="red"> 2. 使用文档片段（document fragment）在当前 DOM 之外构建一个子树，再把它拷贝回文档<br></font></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"> var fragment = document.createDocumentFragment();</span><br><span class="line">appendDataToElement(fragment, data);</span><br><span class="line">document.getElementById('mylist').appendChild(fragment);   </span><br></pre></td></tr></tbody></table></figure>
<p><font color="red"> 3. 将原始元素拷贝到一个脱离文档的节点中，修改副本，完成后再替换原始元素<br></font></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var old = document.getElementById('mylist');</span><br><span class="line">var clone = old.cloneNode(true);</span><br><span class="line">appendDataToElement(clone, data);</span><br><span class="line">old.parentNode.replaceChild(clone, old); </span><br></pre></td></tr></tbody></table></figure>
<p><strong>总结：</strong>推荐尽可能的使用文档片段（第二个方案），因为它们所产生的 DOM 遍历和重排次数最少。唯一潜在的问题是文档片段未被充分利用，很多人可能并不熟悉这项技术。</p>
<ol start="3">
<li>缓存布局信息 </li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">浏览器获取元素的offsetLeft等属性值时会导致重排 将需要获取的保护局信息的属性值 赋值给变量 然后再操作变量</span><br></pre></td></tr></tbody></table></figure>
<ol start="4">
<li>定位 </li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">将需要多次重排的元素，position 属性设置为 absolute 或 fixed，这样元素就脱离了文档流，它的变化不会影响到其他元素。例如有动画效果的元素就最好设置为绝对定位。</span><br></pre></td></tr></tbody></table></figure>

<p><font color="red">操作 DOM 具体的成本，说到底是造成浏览器重排和重绘，从而消耗 GPU 资源</font></p>
<p>s</p>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>React diff 算法</title>
    <url>/2019/04/01/diff/</url>
    <content><![CDATA[<p>理解 react 的 diff 算法</p>
<a id="more"></a>

<p><img src="/images/passive/diff.png" alt="jsworke"></p>
<h2 id="同级节点的移动-增加-删除的具体实现"><a href="#同级节点的移动-增加-删除的具体实现" class="headerlink" title="同级节点的移动 增加 删除的具体实现"></a>同级节点的移动 增加 删除的具体实现</h2><h3 id="场景一-新旧集合中存在相同节点但位置不同时，如何移动节点"><a href="#场景一-新旧集合中存在相同节点但位置不同时，如何移动节点" class="headerlink" title="场景一 新旧集合中存在相同节点但位置不同时，如何移动节点"></a>场景一 新旧集合中存在相同节点但位置不同时，如何移动节点</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">旧  a b c d</span><br><span class="line">新  b a d c</span><br></pre></td></tr></tbody></table></figure>

<p>React 先从新组合中取得 b，然后判断旧中是否存在相同节点 b，当发现存在节点 b 后，就去判断是否移动 b<br>涉及到两个变量 index 和 lastIndex</p>
<ul>
<li>index:b 在集合里下标 此时 index = 1</li>
<li>lastIndex：类似于一个 map 的索引，一开始默认值是 0，它会与 map 中的元素进行比较，比较完后，更新当前的值（取 index 和 lastIndex 的较大数）</li>
</ul>
<h4 id="比较规则："><a href="#比较规则：" class="headerlink" title="比较规则："></a>比较规则：</h4><p>如果 index &lt; lastIndex 那此元素就需要移动<br>在旧组合里将该元素移动到下标为 lastIndex 的位置</p>
<p>具体的计算过程看下图</p>
<p><img src="/images/passive/diff2.jpeg" alt="jsworke"></p>
<h3 id="场景一-新集合中有新加入的节点，旧集合中有删除的节点"><a href="#场景一-新集合中有新加入的节点，旧集合中有删除的节点" class="headerlink" title="场景一 新集合中有新加入的节点，旧集合中有删除的节点"></a>场景一 新集合中有新加入的节点，旧集合中有删除的节点</h3><p>规则同上</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">旧  a b c d</span><br><span class="line">新  b e c a</span><br></pre></td></tr></tbody></table></figure>
<p>比较 b 此时 index = 1 lastindex = 0  1&gt;0 b 不移动 更新 lastindex 为 1<br>当比较到 e 的时候，发现旧组合中不存在，故在旧组合下标为 1 的位置 创建 E，更新 lastIndex=1<br>…<br>对比到 a 因为是最后一个 所以 diff 操作结束</p>
<p>新组合对比完成后 再去对旧集合遍历 判断新集合没有，但旧集合有的元素（如 d），删除 d，diff 操作结束</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title>js 冷知识</title>
    <url>/2018/01/16/javascript%E5%86%B7%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<!-- <blockquote class="blockquote-center">blah blah blah</blockquote> -->
<ol>
<li><p><strong>去除 input [type=’number’] 时的右侧上下箭头</strong></p>
<p>   / <em>在 chrome 下：</em>/</p>
<pre><code> input::-webkit-outer-spin-button,
 input::-webkit-inner-spin-button{
     -webkit-appearance: none !important;
     margin: 0;
     padding-left:5px;
 }

 /*Firefox下：*/
 input[type="number"]{-moz-appearance:textfield;}</code></pre>
</li>
</ol>
<ol start="2">
<li><p><strong>判断小数不能大于两位</strong></p>
<pre><code>   var hopePriceLength = hopePrice.toString().split(".")[1].length;
     if(hopePriceLength&gt;2){
         notify('请输入正数，最多两位小数','error');
         $(`#${mid}jp-hope-price`).focus();
         return false;
     }</code></pre>
</li>
</ol>
<a id="more"></a>

<p>3. <strong>去掉 ios 手机上 tap 时的黑色背景</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">a,img,button,input,textarea</span><br><span class="line">{-webkit-tap-highlight-color:rgba(255,255,255,0);}</span><br><span class="line"></span><br><span class="line">2.另外，如何去掉textarea,input的默认样式：</span><br><span class="line">input,textarea{-webkit-appearance:none;}</span><br></pre></td></tr></tbody></table></figure>


<p>4. <strong>判断数据的类型</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var isType = function( type ){</span><br><span class="line">    return function( obj ){</span><br><span class="line">          return Object.prototype.toString.call( obj ) === '[object '+ type +']';</span><br><span class="line">     }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"> var isString = isType( 'String' );</span><br><span class="line"> var isArray = isType( 'Array' );</span><br><span class="line"> var isNumber = isType( 'Number' );</span><br><span class="line">console.log( isArray( [ 1, 2, 3 ] ) );</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>4.<strong>HTML5 去除 input [type=search] 的默认边框和删除按钮</strong></p>
<p> x-webkit-speech  属性：在 GOOGLE 浏览器上  还会显示一个小话筒<br> autocomplete=”off”  属性  关闭浏览器自动记录之前输入的值</p>
<p>webkit 内核浏览器里 input 框类型如果是 type=”search”<br>那么将会有边框问题，border:0px 也不能起到作用；</p>
<p>解决方案</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">input[type="search"]{-webkit-appearance:none;}</span><br></pre></td></tr></tbody></table></figure>
<p>移除 重置默认的 Webkit 引擎下的 Input 样式</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">input[type=search] {</span><br><span class="line">-webkit-appearance: textfield;</span><br><span class="line">-webkit-box-sizing: content-box;</span><br><span class="line">font-family: inherit;</span><br><span class="line">font-size: 100%;</span><br><span class="line">}</span><br><span class="line">input::-webkit-search-decoration,</span><br><span class="line">input::-webkit-search-cancel-button {</span><br><span class="line">display: none;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>5. 禁止 ios 和 android 用户选中文字</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">css{-webkit-touch-callout: none}</span><br></pre></td></tr></tbody></table></figure>



]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>issue</tag>
      </tags>
  </entry>
  <entry>
    <title>你不知道的 JS 系列 - 细说 JS 继承</title>
    <url>/2019/03/15/jsIInheritance/</url>
    <content><![CDATA[<p>面向对象语言支持两种继承方式：接口继承（只继承方法签名）和实现继承（继承实际的方法）由于函数没有签名，ECMAScript 只支持实现继承，而实现继承主要是依靠原型链实现的</p>
<p>下面就当下几种继承方式做一个对比参考</p>
<a id="more"></a>

<h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><p><font color="red">核心思想：</font>利用原型让一个引用类型继承另一个引用类型的属性和方法（将父类的实例作为子类的原型）</p>
<hr>
<h3 id="举个🌰"><a href="#举个🌰" class="headerlink" title="举个🌰"></a>举个🌰</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">function SuperType(){</span><br><span class="line">  this.name = 'yishu';</span><br><span class="line">}</span><br><span class="line">SuperType.prototype.sayName = function(){</span><br><span class="line">  return this.name</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">function SubType (){</span><br><span class="line">  this.age = 25;</span><br><span class="line">} </span><br><span class="line"> //原型链继承</span><br><span class="line"> SubType.prototype = new SuperType();</span><br><span class="line"></span><br><span class="line"> SubType.prototype.sayAge = function(){</span><br><span class="line">  return this.age</span><br><span class="line"> }</span><br><span class="line"> </span><br><span class="line">  var instance = new SubType(); //原型链继承</span><br><span class="line">  console.log('age',instance.age) // 25</span><br><span class="line">  console.log('name',instance.name) //yishu</span><br><span class="line">  console.log('sayName',instance.sayName()) //yishu</span><br><span class="line">  console.log('sayAge',instance.sayAge()) //25</span><br><span class="line">  console.log(' instance.toString()', instance.toString()) //[object Object]</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>纯粹的继承关系，实例是子类的实例，也是父类的实例</li>
<li>父类新增原型方法 / 原型属性，子类都能访问到</li>
<li>简单 易于实现</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>无法实现多继承</li>
<li>创建子类型的实例时，不能向超类型的构造函数中传递参数</li>
<li><strong>包含引用类型值的原型会被所有的实例共享</strong>，通过原型来实现继承的时候，原型实际上会变成另一个类型的实例，于是原来的实例属性也就变成了现在的原型属性了 (<font color="red">来自原型对象的所有属性被所有实例共享</font>)</li>
<li> 想要为子类添加属性或方法 只能在 <code>new SubType()</code> 之后</li>
</ul>
<hr>
<p>推荐指数：❤️ （3，4 问题比较致命）</p>
<h2 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h2><p><font color="red">核心思想：</font>使用父类的构造函数来增强子类实例，相当于复制父类的实例属性给子类（没用到原型） （<strong>不涉及到原型</strong>）</p>
<p><font color="red">技术原理：</font><br>在子类型构造函数的内部调用超类型构造函数</p>
<p>** 插播:** 函数只不过是在特定环境中执行代码的对象，因此 你可以通过使用 <code>apply</code> 或者 <code>call</code> 方法也可以在将来新创建的对象上执行构造函数</p>
<p>举个🌰</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">function SuperType(){</span><br><span class="line">this.colors = ['red','blue'];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">function SubType(){</span><br><span class="line">SuperType.call(this) //继承了SuperType</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var instance1 = new SubType();</span><br><span class="line">instance1.colors.push('black')</span><br><span class="line">console.log(instance1.colors) //["red", "blue", "black"]</span><br><span class="line"></span><br><span class="line">var instance2 = new SubType();</span><br><span class="line">console.log(instance2.colors) &nbsp;//["red", "blue"]</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul>
<li>解决实例共享问题 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">这样儿会在`SubType`对象上执行`SuperType`函数中定义的所有对象初始化代码，`SubType`的每个实例就都会具有自己`colors`属性的副本了</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>解决传递参数的问题 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">function SuperType(name){</span><br><span class="line">this.name= name</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">function SubType(name,age){</span><br><span class="line">SuperType.call(this,name) //继承了SuperType 同时传递了参数</span><br><span class="line">this.age = age;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var instance = new SubType('yishu',18);</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>可以实现多继承（call 多个父类对象）</li>
</ul>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>只能继承父类的实例属性和方法，不能继承原型属性和方法</li>
<li>无法实现函数复用，每个子类都有父类实例函数的副本，影响性能</li>
</ul>
<hr>
<p>推荐指数：❤️❤️（缺点 2 比较致命）</p>
<h2 id="组合继承（最常用的继承模式）"><a href="#组合继承（最常用的继承模式）" class="headerlink" title="组合继承（最常用的继承模式）"></a>组合继承（最常用的继承模式）</h2><p><font color="red">核心思想：</font>将原型链和构造函数的技术组合到一起 从而发挥二者之长</p>
<p><font color="red">技术原理：</font><br>使用原型链实现对原型属性和方法的继承<br>使用构造函数来实现对实例属性的继承<br>这样能实现<strong>在原型上定义方法实现了函数的服用又能保证每个实例有它自己的属性</strong></p>
<h3 id="举个🌰-1"><a href="#举个🌰-1" class="headerlink" title="举个🌰"></a>举个🌰</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">function SuperType(name){</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.colors = ['red','blue','green']</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = function(){</span><br><span class="line">  return this.name</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">function SubType (name,age){</span><br><span class="line">  SuperType.call(this,name); //继承实例属性 （第二次调用SuperType()）</span><br><span class="line">  this.age = age;</span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"> SubType.prototype = new SuperType(); //继承原型属性和方法（第一次调用SuperType()）</span><br><span class="line"> SubType.prototype.sayAge = function(){</span><br><span class="line">  return this.age;</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line">var instance1 = new SubType('yishu',25);</span><br><span class="line">instance1.colors.push('yellow');</span><br><span class="line">console.log('instance1.colors',instance1.colors); // ["red", "blue", "green", "yellow"]</span><br><span class="line">console.log('instance1.name',instance1.sayName()); //yishu</span><br><span class="line">console.log('instance1.age',instance1.sayAge());//25</span><br><span class="line"></span><br><span class="line">var instance2 = new SubType('Grei',29);</span><br><span class="line"> console.log('instance2.colors',instance2.colors); //["red", "blue", "green"]</span><br><span class="line">console.log('instance2.name',instance2.sayName());//Grei</span><br><span class="line">console.log('instance2.age',instance2.sayAge());//29</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ul>
<li>可以继承实例属性 / 方法，也可以继承原型属性 / 方法</li>
<li>不存在引用属性共享问题</li>
<li>可传参</li>
<li>函数可复用</li>
</ul>
<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><p>调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">具体的过程</span><br><span class="line"></span><br><span class="line">第一次调用的时候 SubType.prototype 会得到两个属性  name和colors  他们都来自于 SuperType 但是现在位于 SubType的原型中 当调用SubType构造函数时 又会调用一次</span><br><span class="line">SuperType的构造函数 这一次又在新对象SubType上创建了实例属性 name和colors  于是这两个属性屏蔽了原型中同名属性</span><br></pre></td></tr></tbody></table></figure>
<hr>
<p>推荐指数：❤️❤️❤️❤️（仅仅多消耗了一点内存）</p>
<h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><p><font color="red">核心原理：</font>借助原型可以基于已有的对象创建新的对象 同时还不必因此创建自定义类型</p>
<p><strong>ES5 以前</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">function ObjectCreate(o){</span><br><span class="line">  function F(){} //创建了一个临时性的构造函数</span><br><span class="line">  F.prototype = o;//将传入的对象当作这个构造函数的原型</span><br><span class="line">  return new F(); //返回这个临时类型的新实例</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ObjectCreate 方法本质上对传入其中的对象执行了一次浅复制</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var person = {</span><br><span class="line">  name:'yishu',</span><br><span class="line">  friends:['xiaohong','xiaoming']</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var instance1 = ObjectCreate(person);</span><br><span class="line">instance1.age = 45;</span><br><span class="line">instance1.friends.push('xiaolan');</span><br><span class="line">console.log('instance1',instance1.age); //45</span><br><span class="line">console.log('instance1',instance1.friends);//&nbsp;["xiaohong", "xiaoming", "xiaolan"]</span><br><span class="line">console.log('person.friends',person.friends)//["xiaohong", "xiaoming", "xiaolan"]</span><br><span class="line">console.log('person.age',person.age)//undefined</span><br><span class="line"></span><br><span class="line">var instance2 = ObjectCreate(person);</span><br><span class="line">console.log('instance2',instance2.age); //undefined</span><br><span class="line">console.log('instance2',instance2.friends);//["xiaohong", "xiaoming", "xiaolan"]</span><br></pre></td></tr></tbody></table></figure>



<p><strong>ES5 以后</strong></p>
<p>通过新增 <code>Object.create(obj1，obj2)</code> 规范化了原型式继承</p>
<ul>
<li>obj1：用做新对象原型的对象</li>
<li> obj2（可选）为新对象定义额外属性的对象 在传入一个参数的情况下与 <code>ObjectCreate</code> 函数功能相同 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var person = {</span><br><span class="line">  name:'yishu',</span><br><span class="line">  friends:['xiaohong','xiaoming']</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var otherPerson = Object.create(person);</span><br><span class="line"></span><br><span class="line">otherPerson.name='maying';</span><br><span class="line">otherPerson.friends.push('wqs');</span><br><span class="line">console.log('otherPerson',otherPerson.name) // maying</span><br><span class="line">console.log('otherPerson',otherPerson.friends) //&nbsp;["xiaohong", "xiaoming", "wqs"]</span><br><span class="line"></span><br><span class="line">var otherPerson1 = Object.create(person,{name:{value:'dsdd'}});</span><br><span class="line">console.log('otherPerson1',otherPerson1.name) //dsdd</span><br><span class="line">console.log('otherPerson1',otherPerson1.friends)//&nbsp;["xiaohong", "xiaoming", "wqs"]</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<hr>
<h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>不是类式继承，而是原型式基础，缺少了类的概念</li>
<li>对于引用类型值的属性依然是 共享状态的，这相当于创建了两个 person 的副本</li>
</ul>
<h2 id="寄生式组合继承（最理想的继承范式）"><a href="#寄生式组合继承（最理想的继承范式）" class="headerlink" title="寄生式组合继承（最理想的继承范式）"></a>寄生式组合继承（最理想的继承范式）</h2><p><font color="red">核心原理：</font><br>借用构造函数来继承属性<br>通过原型链的<strong>混成形式</strong>来继承方法</p>
<p><font color="red">技术原理：</font> 不必为了指定子类型的原型而调用超类型的构造函数 我们所需要的无非就是超类型原型的一个副本而已（使用寄生式来继承超类型的原型 然后再将结果指定给子类型的原型 ）</p>
<p>举个🌰</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">function inhertPrototype(SubType, SuperType){</span><br><span class="line"></span><br><span class="line">  var prototype = Object.create(SuperType.prototype); //创建对象</span><br><span class="line">  prototype.constructor = SubType; //如果你创建了一个新对象并替换了函数默认的.prototype对象引用,那么新对象不会自动获得.constructor属性</span><br><span class="line">  SubType.prototype = prototype;//指定对象</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">function SuperType(name){</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.colors = ['red','blue','green'];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = function(){</span><br><span class="line">  alert(this.name);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function SubType(name,age){</span><br><span class="line">  SuperType.call(this, name);//第二次调用SuperType()</span><br><span class="line">  this.age = age;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">inhertPrototype(SubType, SuperType);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SubType.prototype.sayAge = function(){</span><br><span class="line">  alert(this.age);         </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var dd = new SubType('yishu',22);</span><br><span class="line">dd.colors.push('gold');</span><br><span class="line">console.log('dd',dd.colors);  //["red", "blue", "green", "gold"]</span><br><span class="line">dd.sayAge(); //22</span><br><span class="line">dd.sayName(); //yishu</span><br><span class="line"></span><br><span class="line">var cc = new SubType('xiaogou',10);</span><br><span class="line"></span><br><span class="line">console.log('cc',cc.colors); ["red", "blue", "green"]</span><br><span class="line">cc.sayAge(); //10</span><br><span class="line">cc.sayName();//xiaogou</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h3><p>完美</p>
<ul>
<li>它只调用了一次构造函数 避免了在 SubType.prototype 上创建不必要的属性 与此同时 原型链还能保持不变<h3 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h3></li>
<li>实现不如组合式继承简单</li>
</ul>
<hr>
<p>推荐指数：❤️❤️❤️❤️（复杂度扣掉一颗心）</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ECMAscript 支持面向对象编程 但是不使用类或者接口 对象可以在代码执行过程中创建或增强 因此具有动态性而非严格定义的实体 在没有类的情况下 可以采用下列模式创建对象</p>
<ul>
<li>工厂模式 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">使用简单的函数创建对象 为对象天假属性和方法 然后返回对象被构造函数模式取代</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>构造函数模式 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">可以创建自定义引用类型 </span><br><span class="line">可以像创建内置对象实例一样使用new</span><br><span class="line"></span><br><span class="line">缺点：成员无法复用 包括函数</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>原型模式 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">使用构造函数的prototype属性来指定那些应该共享的属性和方法</span><br><span class="line"></span><br><span class="line">组合使用 构造函数模式和原型模式 分别定义属性和方法</span><br></pre></td></tr></tbody></table></figure>

<p>js 主要通过原型链实现继承 原型链的构建是通过<strong>将一个类型的实例复制给另一个构造函数的原型</strong>实现的，这样子类型就能访问到超类型所有的属性和方法 这一点与基于类的继承很相似。</p>
<p>原型链的问题是<strong>对象实例共享所有的属性和方法</strong> 因此不适合单独使用<br>解决这个问题的技术是借助构造函数 （在子类型构造函数中的内部调用超类型的构造函数） 这样就能做到每个实例具有自己的属性 同时还能保证只使用构造函数模式来定义类型</p>
<p>使用最多的继承模式是<strong>组合继承</strong><br>通过原型链继承共享的属性和方法<br>而通过借用构造函数继承实例属性</p>
<p>还有其他继承模式</p>
<ul>
<li>原型式继承 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">可以在不必预先定义构造函数的情况下实现继承 本质是执行对给定对象的浅复制 而复制的副本还可以进行进一步的加强 改造</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>寄生式继承 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">与 原型式继承相似</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>寄生组合式继承 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">集寄生式继承和组合继承的优点与一身</span><br><span class="line">是实现基于类型继承的最有效的方式</span><br></pre></td></tr></tbody></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>JavaScript 高级程序设计（第三版）</p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>js 模块化编程系列（二）</title>
    <url>/2017/04/24/js%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89require.js/</url>
    <content><![CDATA[<p><strong>require.js</strong></p>
<p>出现背景：所有的 javascript 代码都在一个文件中，代码越来越多时必须分成多个文件，依次加载，问题：加载 js 的时候浏览器停止渲染，加载文件越多，网页的响应时间就越长，由于 js 之间有依赖关系，因此必须严格保证加载顺序，当依赖关系变的复杂时，代码的编写和维护都会变的异常困难</p>
<ol>
<li> 加载 require.js</li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;script src="js/require.js" defer async='true'&gt;&lt;/script&gt;</span><br><span class="line">async   表明这个文件需要异步加载</span><br><span class="line">在require.js的基础上加载自己的 main.js</span><br><span class="line">&lt;script src="require.js" data-main="js/main"&gt;&lt;/script&gt;</span><br><span class="line">ata-main:指定程序的主模块，这个人间会第一个被require.js加载，由于require.js默认的文件后缀名是js，所以可以把main.js 简写成main</span><br><span class="line"></span><br><span class="line">//main.js</span><br><span class="line"></span><br><span class="line">require(['moduleA', 'moduleB', 'moduleC'],   function (moduleA, moduleB, moduleC){</span><br><span class="line">　　　　// some code here</span><br><span class="line">　　})``</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li>模块的加载<br>当加载不同路径下的模块可以使用 require.config () 可以对模块的加载进行自定义， require.config () 就写在主模块 (main.js) 的头部，参数就是一个对象，这个对象的 path 属性指定各个模块的加载路径 </li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">　　require.config({</span><br><span class="line">　　　　paths: {</span><br><span class="line">　　　　　　"jquery": "lib/jquery.min",</span><br><span class="line">　　　　　　"underscore": "lib/underscore.min",</span><br><span class="line">　　　　　　"backbone": "lib/backbone.min"</span><br><span class="line">　　　　}</span><br><span class="line">　　});</span><br><span class="line">　　</span><br><span class="line">　　另一种形式</span><br><span class="line">　　</span><br><span class="line">　　　require.config({</span><br><span class="line">　　　　baseUrl: "js/lib",</span><br><span class="line">　　　　paths: {</span><br><span class="line">　　　　　　"jquery": "jquery.min",</span><br><span class="line">　　　　　　"underscore": "underscore.min",</span><br><span class="line">　　　　　　"backbone": "backbone.min"</span><br><span class="line">　　　　}</span><br><span class="line">　　});</span><br><span class="line">　　</span><br><span class="line">　　再或者</span><br><span class="line">　　　require.config({</span><br><span class="line">　　　　paths: {</span><br><span class="line">　　　　　　"jquery": "https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min"</span><br><span class="line">　　　　}</span><br><span class="line">　　});</span><br></pre></td></tr></tbody></table></figure>

<ol start="3">
<li>AMD 模块的写法<br>require.js 加载的模块采用 AMD 规范<br>具体来说，就是模块必须采用特定的 define () 函数来定义，如果一个模块不依赖其他模块，那么可以直接定义在 define 函数中 </li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">//math.js 定义了一个math模块</span><br><span class="line">define(function(){</span><br><span class="line">var add = function(){</span><br><span class="line">   return x+y;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">return {</span><br><span class="line"> add:add</span><br><span class="line">}</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">加载方法：</span><br><span class="line"></span><br><span class="line">// main.js</span><br><span class="line">　　require(['math'], function (math){</span><br><span class="line">　　　　alert(math.add(1,1));</span><br><span class="line">　　});</span><br><span class="line">　　</span><br><span class="line">　　如果这个模块还依赖其他模块，那么那么define()函数的第一个参数，必须是一个数组，指明该模块的依赖性。</span><br><span class="line">　　　define(['myLib'], function(myLib){</span><br><span class="line">　　　　function foo(){</span><br><span class="line">　　　　　　myLib.doSomething();</span><br><span class="line">　　　　}</span><br><span class="line">　　　　return {</span><br><span class="line">　　　　　　foo : foo</span><br><span class="line">　　　　};</span><br><span class="line">　　});</span><br><span class="line">　　当require()函数加载上面这个模块的时候，就会先加载myLib.js文件。</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<ol start="3">
<li>AMD 模块的写法<br>加载非规范的模块<br>理论上 require.js 加载的模块，必须是按照 AMD 规范、用 define () 函数定义的模块<br>加载非规范模块，必须先用 require.config () 方法定义它们的一些特征 </li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">eg：加载非AMD规范模块 underscore，backbone</span><br><span class="line">　　require.config({</span><br><span class="line">　　　　shim: {</span><br><span class="line"></span><br><span class="line">　　　　　　'underscore':{</span><br><span class="line">　　　　　　　　exports: '_'</span><br><span class="line">　　　　　　},</span><br><span class="line">　　　　　　'backbone': {</span><br><span class="line">　　　　　　　　deps: ['underscore', 'jquery'],</span><br><span class="line">　　　　　　　　exports: 'Backbone'</span><br><span class="line">　　　　　　}</span><br><span class="line">　　　　}</span><br><span class="line">　　});</span><br><span class="line">　　</span><br><span class="line">　　shim属性：专门用来配置不兼容的模块。具体来说，每个模块要定义</span><br><span class="line">　　（1）exports值（输出的变量名），表明这个模块外部调用时的名称；</span><br><span class="line">　　（2）deps数组，表明该模块的依赖性。</span><br><span class="line">　　</span><br><span class="line">　　eg：</span><br><span class="line">　　   jQuery的插件可以这样定义：</span><br><span class="line">　　　　shim: {</span><br><span class="line">　　　　'jquery.scroll': {</span><br><span class="line">　　　　　　deps: ['jquery'],</span><br><span class="line">　　　　　　exports: 'jQuery.fn.scroll'</span><br><span class="line">　　　　}</span><br><span class="line">　　}</span><br></pre></td></tr></tbody></table></figure>

<ol start="4">
<li><p>require 插件<br>domready 插件，可以让回调函数在页面 DOM 结构加载完成后再运行。</p>
<p>　</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">require(['domready!'], function (doc){</span><br><span class="line">　　　　// called once the DOM is ready</span><br><span class="line">　　});</span><br><span class="line">　　</span><br></pre></td></tr></tbody></table></figure>


</li>
</ol>
<p>text 和 image 插件，则是允许 require.js 加载文本和图片文件。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">define([</span><br><span class="line">　　　　'text!review.txt',</span><br><span class="line">　　　　'image!cat.jpg'</span><br><span class="line">　　　　],</span><br><span class="line"></span><br><span class="line">　　　　function(review,cat){</span><br><span class="line">　　　　　　console.log(review);</span><br><span class="line">　　　　　　document.body.appendChild(cat);</span><br><span class="line">　　　　}</span><br><span class="line">　　);</span><br></pre></td></tr></tbody></table></figure>


<p>类似的插件还有 json 和 mdown，用于加载 json 文件和 markdown 文件</p>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>js 模块化编程系列（一）</title>
    <url>/2017/04/23/js%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<ol>
<li>原始写法 </li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">function m1(){}</span><br><span class="line">function m2(){}</span><br></pre></td></tr></tbody></table></figure>
<p> 缺点：污染了全局变量，容易与其它模块发生命名冲突，而且模块之间看不出直接关系</p>
<ol start="2">
<li>对象写法 </li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var moudle = new Object({</span><br><span class="line"> _count = 0;</span><br><span class="line"> m1:function(){},</span><br><span class="line"> m2:function(){}</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>
<p>缺点：会暴露所有模块成员，内部状态可以被外部改写</p>
<ol start="3">
<li>立即执行函数的写法 (达到不暴露私有成员的目的)</li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var moudle1 = (function(){</span><br><span class="line">var count = 0;</span><br><span class="line">var m1 = function(){</span><br><span class="line">//...</span><br><span class="line">};</span><br><span class="line">var m2 = function(){</span><br><span class="line">//...</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">return {</span><br><span class="line">         m1:m1,</span><br><span class="line">         m2:m2</span><br><span class="line">       }</span><br><span class="line">})();</span><br></pre></td></tr></tbody></table></figure>

<p> moudle1 就是 javascript 模块的基本写法</p>
<ol start="4">
<li>放大模式<br>背景：如果一个模块很大必须分为几个部分，或者一个模块需要继承另外一个模块时 </li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var moudle1 = (function(mod){</span><br><span class="line">   mod.m3 = function(){</span><br><span class="line">   //...</span><br><span class="line">   }</span><br><span class="line">   return mod;</span><br><span class="line">  })(moudle1);</span><br></pre></td></tr></tbody></table></figure>

<p>  上面的代码为 moudle1 添加了一个新方法 m3，然后返回新的 moudle1 模块</p>
<ol start="5">
<li>宽放大模式<br>背景：在浏览器环境中，模块的各个部分都是从网上获取的，有时候无法知道哪个部分会先加载，如果单纯采用放大模式，第一个执行的 部分有可能加载一个不存在的空对象 </li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var moudle1 = (function(mod){</span><br><span class="line">  mod.m3 = function(){</span><br><span class="line">  //...</span><br><span class="line">  }</span><br><span class="line">  return mod;</span><br><span class="line"> })(window.moudle1 || {});</span><br></pre></td></tr></tbody></table></figure>

<ol start="6">
<li>输入全局变量<br>背景：保持模块独立性，内部最好不要与程序的其他部分直接交互 </li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var moudle1 = (function($,YAHOO){</span><br><span class="line">      //...</span><br><span class="line">  })(jQuery, YAHOO);</span><br></pre></td></tr></tbody></table></figure>
<p>  保持独立的同时，模块的依赖关系变的更明显</p>
<ol start="7">
<li>模块的规范<br>CommonJS 和 AMD<br>CommonJS：nodejs 的模块系统，是参照 CommonJS 规范实现的，在 CommonJS 中，有一个全局方法 require ()，用于加载模块 </li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">eg:</span><br><span class="line">var math = require('math');</span><br><span class="line">  调用math模块提供的方法：</span><br><span class="line">  math.add(2,3); // 5</span><br></pre></td></tr></tbody></table></figure>

<ol start="8">
<li>浏览器环境<br>局限使 CommonJS 规范不适用于浏览器环境 </li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var math = require('math');</span><br><span class="line">math.add(2,3); // 5</span><br></pre></td></tr></tbody></table></figure>
<p>  在浏览器中运行，第二行在第一行之后运行，也就是说必须得等到 math 模块加载完成，如果加载时间很长，整个应用都会停在那里等，对于服务器端来说，所有模块都放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间，但是对于浏览器，这就是致命的问题，取决于网速，<br>  所以，浏览器端的模块不能采用同步加载，要采用<strong>异步加载</strong></p>
<ol start="9">
<li>AMD<br>‘异步模块定义’，采用异步方式加载模块，所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，回调函数才执行<br>AMD 也采用 require () 语句加载模块，不同于 CommonJS，它要求两个参数
　</li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">require([module], callback)</span><br><span class="line">require(['math'], function (math) {</span><br><span class="line">　　　　math.add(2, 3);</span><br><span class="line">　　});</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>js 面向对象</title>
    <url>/2017/04/21/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p><strong>工厂模式</strong><br>解决了重复实例化的问题</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">function createObject(name,age){</span><br><span class="line">var obj = new Object();</span><br><span class="line">obj.name= name;</span><br><span class="line">obj.age = age;</span><br><span class="line">obj.run = function(){</span><br><span class="line"> return this.name + this.age + '运行中'</span><br><span class="line">}</span><br><span class="line">return obj;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var box1 = createObject（‘lee’,100）</span><br><span class="line">var box2 = createObject（‘jack’,200）</span><br></pre></td></tr></tbody></table></figure>

<p>工厂模式的缺点：<br>无法区分实例是哪个对象的实例</p>
<p><strong>构造函数模式</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">function Box(name,age){</span><br><span class="line"> this.name= name;</span><br><span class="line"> this.age = age;</span><br><span class="line"> this.run = function(){</span><br><span class="line">  return this.name + this.age + '运行中'</span><br><span class="line"> }</span><br><span class="line">}</span><br><span class="line">var box3 = new Box（‘lee’,100）</span><br><span class="line">var box4 = new Box（‘jack’,200）</span><br></pre></td></tr></tbody></table></figure>
<p>如何识别了对象？<br>构造函数没有 new Object，但是它后台回自动 var obj = new Object ();<br>this 指的就是 obj<br>没有返回值</p>
<p>console.log(box4 instanceof Box)</p>
<p><strong>对象冒充</strong><br>把 o 冒充成 box 对象</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var  o = new Object();</span><br><span class="line">Box.call(o,'Lee',100)</span><br></pre></td></tr></tbody></table></figure>


<p><strong>原型</strong></p>
<p>prototype 原型属性是一个对象</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">function Box(){}</span><br></pre></td></tr></tbody></table></figure>
<p> 这里如果有属性或者方法 叫做实例属性和实例方法</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Box.prototypr.name 原型属性</span><br><span class="line">Box.prototypr.run=function(){} 原型方法</span><br></pre></td></tr></tbody></table></figure>

<p><strong>_proto_：</strong> 实际上是一个指向原型对象的一个指针，它的作用就是指向构造函数的原型属性 constructor</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var box1 = new Box()</span><br><span class="line">box1.constructor 指向构造函数</span><br><span class="line">box1._proto_指向原型对象</span><br></pre></td></tr></tbody></table></figure>

<p>判断一个对象实例是不是指向了对象的原型对象，实例化之后是自动指向的</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Box.prototype.isPrototypeOf(box1)</span><br></pre></td></tr></tbody></table></figure>

<p><strong>什么叫闭包？ 有什么用</strong></p>
<p>闭包是指有权访问另一个作用域中的变量和函数，常见的形式是在<font face="STCAIYUN" color="red" size="4">某个作用域中定义的函数</font></p>
<p>闭包的作用域链包括三部分：</p>
<ol>
<li>函数本身作用域</li>
<li>闭包定义的作用域</li>
<li>全局作用域</li>
</ol>
<p><font face="STCAIYUN" color="green" size="4">闭包的常见用途？</font></p>
<ol>
<li>读取函数内部的变量</li>
<li>将变量始终保持在内存中</li>
<li>模拟面向对象的代码风格</li>
</ol>
<p><strong>匿名执行函数</strong></p>
<p>不加 <strong>var</strong> 关键字 默认回呗添加到全局对象的属性中去，类似的临时变量的属性加入全局对象有很多坏处<br>比如：<br>别的函数可能误用这些变量 造成全局变量过于庞大，影响访问速度（因为变量的取值是需要从圆形链上遍历的）</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var datamodel = {    </span><br><span class="line">    table : [],    </span><br><span class="line">    tree : {}    </span><br><span class="line">};    </span><br><span class="line"></span><br><span class="line">(function(dm){    </span><br><span class="line">    for(var i = 0; i &lt; dm.table.rows; i++){    </span><br><span class="line">       var row = dm.table.rows[i];    </span><br><span class="line">       for(var j = 0; j &lt; row.cells; i++){    </span><br><span class="line">           drawCell(i, j);    </span><br><span class="line">       }    </span><br><span class="line">    }    </span><br><span class="line"></span><br><span class="line">    //build dm.tree      </span><br><span class="line">})(datamodel);  </span><br><span class="line"></span><br><span class="line">创建了一个匿名的函数并立即执行它，由于外部无法引用它内部的变量，因此在执行之后很快就会被释放 不会污染全局对象</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>


<p><strong>缓存</strong></p>
<p>设想我们有一个处理过程很耗时的函数对象，每次调用都会花费很长时间，<br>那么我们就需要将计算出来的值存储起来，当调用这个函数的时候，首先在缓存中查找，如果找不到，则进行计算，然后更新缓存并返回值，如果找到了，直接返回查找到的值即可。闭包正是可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得以保留。</p>
<p><strong>实现封装</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var person = function(){    </span><br><span class="line">    //变量作用域为函数内部，外部无法访问    </span><br><span class="line">    var name = "default";       </span><br><span class="line"></span><br><span class="line">    return {    </span><br><span class="line">       getName : function(){    </span><br><span class="line">           return name;    </span><br><span class="line">       },    </span><br><span class="line">       setName : function(newName){    </span><br><span class="line">           name = newName;    </span><br><span class="line">       }    </span><br><span class="line">    }    </span><br><span class="line">}();    </span><br><span class="line"></span><br><span class="line">print(person.name);//直接访问，结果为undefined    </span><br><span class="line">print(person.getName());    </span><br><span class="line">person.setName("abruzzi");    </span><br><span class="line">print(person.getName());   </span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟实现 JS 的 new 操作符</title>
    <url>/2019/03/13/new/</url>
    <content><![CDATA[<p><code>JS</code> 中 <code>new</code> 关键字用来实例化构造函数，那么它背后到底做了什么，能否被模拟实现<br>答案是肯定的</p>
<h2 id="new关键字做了什么"><a href="#new关键字做了什么" class="headerlink" title="new关键字做了什么"></a>new 关键字做了什么</h2><p>你一定从别的文章或者在实际开发中感受到 <code>new</code> 的妙处，不错，总结下来它主要支持了四个功能</p>
<a id="more"></a>
<ol>
<li>创建了一个全新的对象</li>
<li>这个对象会被执行 [[prototype]]（也就是__proto__）链接</li>
<li>生成的新对象会绑定到函数调用的 this</li>
<li> 通过 <code>new</code> 创建的每个对象将最终被来接到这个函数的 prototype 对象上</li>
<li>如果函数没有返回对象类型 Object (包含 Functoin, Array, Date, RegExg, Error)，那么 new 表达式中的函数调用会自动返回这个新的对象</li>
</ol>
<h2 id="模拟实现new"><a href="#模拟实现new" class="headerlink" title="模拟实现new"></a>模拟实现 new</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">function newOperator(ctor){</span><br><span class="line">    if(typeof ctor !== 'function'){</span><br><span class="line">      throw 'newOperator function the first param must be a function';</span><br><span class="line">    }</span><br><span class="line">    // ES6 new.target 是指向构造函数</span><br><span class="line">    newOperator.target = ctor;</span><br><span class="line">    // 1.创建一个全新的对象，</span><br><span class="line">    // 2.并且执行[[Prototype]]链接</span><br><span class="line">    // 4.通过`new`创建的每个对象将最终被`[[Prototype]]`链接到这个函数的`prototype`对象上。</span><br><span class="line">    var newObj = Object.create(ctor.prototype);</span><br><span class="line">    // ES5 arguments转成数组 当然也可以用ES6 [...arguments], Aarry.from(arguments);</span><br><span class="line">    // 除去ctor构造函数的其余参数</span><br><span class="line">    var argsArr = [].slice.call(arguments, 1);</span><br><span class="line">    // 3.生成的新对象会绑定到函数调用的`this`。</span><br><span class="line">    // 获取到ctor函数返回结果</span><br><span class="line">    var ctorReturnResult = ctor.apply(newObj, argsArr);</span><br><span class="line">    // 小结4 中这些类型中合并起来只有Object和Function两种类型 typeof null 也是'object'所以要不等于null，排除null</span><br><span class="line">    var isObject = typeof ctorReturnResult === 'object' &amp;&amp; ctorReturnResult !== null;</span><br><span class="line">    var isFunction = typeof ctorReturnResult === 'function';</span><br><span class="line">    if(isObject || isFunction){</span><br><span class="line">        return ctorReturnResult;</span><br><span class="line">    }</span><br><span class="line">    // 5.如果函数没有返回对象类型`Object`(包含`Functoin`, `Array`, `Date`, `RegExg`, `Error`)，那么`new`表达式中的函数调用会自动返回这个新的对象。</span><br><span class="line">    return newObj;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="实例验证"><a href="#实例验证" class="headerlink" title="实例验证"></a>实例验证</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">function Student(name, age){</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    // this.doSth();</span><br><span class="line">    // return Error();</span><br><span class="line">}</span><br><span class="line">Student.prototype.doSth = function() {</span><br><span class="line">    console.log(this.name);</span><br><span class="line">};</span><br><span class="line">var student1 = newOperator(Student, '轩辕', 18);</span><br><span class="line">var student2 = newOperator(Student, 'Rowboat', 18);</span><br><span class="line">// var student1 = new Student('轩辕');</span><br><span class="line">// var student2 = new Student('Rowboat');</span><br><span class="line">console.log(student1, student1.doSth()); // {name: '轩辕'} '轩辕'</span><br><span class="line">console.log(student2, student2.doSth()); // {name: 'Rowboat'} 'Rowboat'</span><br><span class="line"></span><br><span class="line">student1.__proto__ === Student.prototype; // true</span><br><span class="line">student2.__proto__ === Student.prototype; // true</span><br><span class="line">// __proto__ 是浏览器实现的查看原型方案。</span><br><span class="line">// 用ES5 则是：</span><br><span class="line">Object.getPrototypeOf(student1) === Student.prototype; // true</span><br><span class="line">Object.getPrototypeOf(student2) === Student.prototype; // true</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>模拟 <code>new</code> 最大的功臣当属于 <code>Object.create()</code> 这个 ES5 提供的 API</p>
<p><code>Object.create(proto, [propertiesObject]) </code>方法创建一个新对象，使用现有的对象来提供新创建的对象的<code>__proto__</code> 它接收两个参数，不过第二个可选参数是属性描述符（不常用，默认是 <code>undefined</code>）</p>
<p>对于不支持 ES5 的浏览器，MDN 上提供了 ployfill 方案。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">if (typeof Object.create !== "function") {</span><br><span class="line">    Object.create = function (proto, propertiesObject) {</span><br><span class="line">        if (typeof proto !== 'object' &amp;&amp; typeof proto !== 'function') {</span><br><span class="line">            throw new TypeError('Object prototype may only be an Object: ' + proto);</span><br><span class="line">        } else if (proto === null) {</span><br><span class="line">            throw new Error("This browser's implementation of Object.create is a shim and doesn't support 'null' as the first argument.");</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        if (typeof propertiesObject != 'undefined') throw new Error("This browser's implementation of Object.create is a shim and doesn't support a second argument.");</span><br><span class="line"></span><br><span class="line">        function F() {}</span><br><span class="line">        F.prototype = proto;</span><br><span class="line">        return new F();</span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>## 总结</p>
<p>模拟 new 洁净版</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 去除了注释</span><br><span class="line">function newOperator(ctor){</span><br><span class="line">    if(typeof ctor !== 'function'){</span><br><span class="line">      throw 'newOperator function the first param must be a function';</span><br><span class="line">    }</span><br><span class="line">    newOperator.target = ctor;</span><br><span class="line">    var newObj = Object.create(ctor.prototype);</span><br><span class="line">    var argsArr = [].slice.call(arguments, 1);</span><br><span class="line">    var ctorReturnResult = ctor.apply(newObj, argsArr);</span><br><span class="line"></span><br><span class="line">    var isObject = typeof ctorReturnResult === 'object' &amp;&amp; ctorReturnResult !== null;</span><br><span class="line">    var isFunction = typeof ctorReturnResult === 'function';</span><br><span class="line">    if(isObject || isFunction){</span><br><span class="line">        return ctorReturnResult;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return newObj;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>





]]></content>
  </entry>
  <entry>
    <title>Node.js 系列 (一) 之安装</title>
    <url>/2017/04/13/nodeJs%E7%B3%BB%E5%88%97%E4%B8%80/</url>
    <content><![CDATA[<h2 id="node简介"><a href="#node简介" class="headerlink" title="node简介"></a>node 简介</h2><p>node 是 javascript 语言的服务器运行环境<br>所谓的运行环境有两层意思：</p>
<ol>
<li>javascript 语言通过 node 在服务器运行，在这个意义上，node 是 <strong>javascriprt 的虚拟机</strong></li>
<li> node 提供大量的工具库，使得 javascript 语言与操作系统互动（比如读写文件，新建子进程），在这个意义上，node 又是 <strong>javascrip 的工具库</strong><br>Node 内部采用 <a href="http://baike.baidu.com/link?url=1kFBYYp0gB7_P6YD0d1s3sqF64zK41APPhCywsEG9qTKgguFTwwYPZTohqZzd82j">Google 公司的 V8 引擎</a>，作为 JavaScript 语言解释器；通过自行开发的 libuv 库，调用操作系统资源。<h2 id="什么是Google-V8-JavaScript引擎"><a href="#什么是Google-V8-JavaScript引擎" class="headerlink" title="什么是Google V8 JavaScript引擎"></a>什么是 Google V8 JavaScript 引擎</h2>V8 是一个由丹麦 Google 开发的开源 JavaScript 引擎，V8 就是 chrome 浏览器用的 js 解释引擎，主要是 C 编写的<br>V8 在执行之前将 JavaScript 编译成了机器码，而非位元组码或是直译它，以此提升效能。更进一步，有了这些功能，JavaScript 程序与 V8 引擎的速度媲美二进制编译。[4]<h2 id="安装相关"><a href="#安装相关" class="headerlink" title="安装相关"></a>安装相关</h2>访问官方网站 nodejs.org<br>安装完成查看 node 版本 </li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ node --version</span><br><span class="line"> 或者</span><br><span class="line">$ node -v</span><br></pre></td></tr></tbody></table></figure>
<p><img src="http://oucjferwh.bkt.clouddn.com/node1-1.png" alt="wunai"></p>
<p>更新 node 版本，可以通过 node.js 的 n 模块完成，<br>更新为最新发布的稳定版。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ sudo npm install n -g</span><br><span class="line">$ sudo n stable</span><br></pre></td></tr></tbody></table></figure>
<p><img src="http://oucjferwh.bkt.clouddn.com/node1-2.png" alt="node-1-2"></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ sudo n 0.10.21</span><br></pre></td></tr></tbody></table></figure>
<h3 id="安装版本管理工具nvm"><a href="#安装版本管理工具nvm" class="headerlink" title="安装版本管理工具nvm"></a>安装版本管理工具 nvm</h3><p>如果想在同一台机器同时安装多个版本的 node，就需要用到嗯本管理工具 nvm，nvm 全称 <strong>Node Version Manager</strong>，它与 n 的实现方式不同，其是通过 shell 脚本实现的。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ git clone https://github.com/creationix/nvm.git ~/.nvm</span><br><span class="line">$ source ~/.nvm/nvm.sh</span><br></pre></td></tr></tbody></table></figure>
<p><img src="http://oucjferwh.bkt.clouddn.com/node1-3.png" alt="node-1-3"></p>
<h6 id="安装最新版本"><a href="#安装最新版本" class="headerlink" title="安装最新版本"></a>安装最新版本</h6><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ nvm install node</span><br></pre></td></tr></tbody></table></figure>
<p><img src="http://oucjferwh.bkt.clouddn.com/node1-4.png" alt="node-1-4"></p>
<h6 id="安装指定版本"><a href="#安装指定版本" class="headerlink" title="安装指定版本"></a>安装指定版本</h6><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ nvm install 0.12.1</span><br></pre></td></tr></tbody></table></figure>

<p>###### 使用已安装的最新版本</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ nvm use node</span><br></pre></td></tr></tbody></table></figure>

<h6 id="使用指定版本的node"><a href="#使用指定版本的node" class="headerlink" title="使用指定版本的node"></a>使用指定版本的 node</h6><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ nvm use 0.12</span><br></pre></td></tr></tbody></table></figure>
<h6 id="查看本地安装的所有版本"><a href="#查看本地安装的所有版本" class="headerlink" title="查看本地安装的所有版本"></a>查看本地安装的所有版本</h6><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ nvm ls</span><br></pre></td></tr></tbody></table></figure>
<p><img src="http://oucjferwh.bkt.clouddn.com/node1-5.png" alt="node-1-5"></p>
<h6 id="退出已经激活的nvm，使用deactivate命令。"><a href="#退出已经激活的nvm，使用deactivate命令。" class="headerlink" title="退出已经激活的nvm，使用deactivate命令。"></a>退出已经激活的 nvm，使用 deactivate 命令。</h6><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ nvm deactivate</span><br></pre></td></tr></tbody></table></figure>
<p>###### 卸载 nvm</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">rm -rf ~/.nvm</span><br></pre></td></tr></tbody></table></figure>
<p>###### 查看 nvm 帮助</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">nvm -h</span><br></pre></td></tr></tbody></table></figure>
<p>详细文档请参考官方文档<br><a href="https://github.com/creationix/nvm">https://github.com/creationix/nvm</a></p>
]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>addEventListener 中的 passive 用法</title>
    <url>/2018/12/21/passive/</url>
    <content><![CDATA[<h2 id="引出问题"><a href="#引出问题" class="headerlink" title="引出问题"></a>引出问题</h2><p>一个很简单的需求 页面有一张小图 点击是个 swiper 实现的图集 同时有一个灰色的蒙层 蒙层底部页面不可滑动 关闭蒙层 页面可恢复正常</p>
<p>实现方式</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">function bodyScroll(event){</span><br><span class="line">    event.preventDefault();</span><br><span class="line">}</span><br><span class="line">function _switchTag(type) {</span><br><span class="line">    if (type === 'on') {</span><br><span class="line">        window.addEventListener('touchmove', bodyScroll);</span><br><span class="line">    } else {</span><br><span class="line">        window.removeEventListener('touchmove', bodyScroll);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">_switchTag(on) 页面不可滑动</span><br><span class="line">_switchTag(off) 页面恢复滑动</span><br></pre></td></tr></tbody></table></figure>
<p>移动端的效果如下<br>android<br><img src="/images/passive/passive1.gif" alt="jsworke"></p>
<p>ios<br><img src="/images/passive/iOSqian.gif" alt="jsworke"></p>
<p>我不知道为什么无效 直到我在模拟器上看到了</p>
<p><img src="/images/passive/webqian.gif" alt="jsworke"></p>
<p>啊哦 报错了🦢</p>
<p><font color="red">Unable to preventDefault inside passive event listener due to target being treated as passive</font><br>来自 google 的解释 <a href="https://developers.google.com/web/updates/2017/01/scrolling-intervention">https://developers.google.com/web/updates/2017/01/scrolling-intervention</a></p>
<p>大概的意思是说</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">由于浏览器必须要在执行事件处理函数之后，才能知道有没有调用过 preventDefault() ，这就导致了浏览器不能及时响应滚动，略有延迟。</span><br><span class="line"></span><br><span class="line">所以为了让页面滚动的效果如丝般顺滑，从 chrome56 开始，在 window、document 和 body 上注册的 touchstart 和 touchmove 事件处理函数，会默认为是 passive: true。浏览器忽略 preventDefault() 就可以第一时间滚动了。</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">wnidow.addEventListener('touchmove', func) 效果和下面一句一样</span><br><span class="line">wnidow.addEventListener('touchmove', func, { passive: true })</span><br></pre></td></tr></tbody></table></figure>
<p>这就导致了这个问题</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">如果在以上这 3 个元素的 touchstart 和 touchmove 事件处理函数中调用 e.preventDefault() ，会被浏览器忽略掉，并不会阻止默认行为</span><br></pre></td></tr></tbody></table></figure>
<p>所以出现了以上视频中问题</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>那么我们如何来解决这个问题 即不要让浏览器忽略掉 e.preventDefault ()？</p>
<ol>
<li>window.addEventListener(‘touchmove’, func, { passive: false })</li>
</ol>
<p>设置 passive: false 之后的结果<br>android<br><img src="/images/passive/androdhou.gif" alt="jsworke"><br>ios<br><img src="/images/passive/iOShou.gif" alt="jsworke"><br>浏览器<br><img src="/images/passive/webhou.gif" alt="jsworke"><br>问题完美解决</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">你看到这里可以结束了 如果你还想再了解一点点</span><br><span class="line">👇👇👇👇</span><br><span class="line"></span><br><span class="line">#### 你可能不知道的addEventListener</span><br><span class="line"></span><br><span class="line">很久之前addEventListener的参数是这样儿的</span><br><span class="line">`addEventListener(type, listener, useCapture)`</span><br><span class="line"></span><br><span class="line">后来也就是控制监听器是在捕获阶段执行还是在冒泡阶段执行的 useCapture 参数，变成了可选参数</span><br><span class="line">`addEventListener(type, listener [,useCapture])`</span><br><span class="line"></span><br><span class="line">再后来 DOM 规范做了修订addEventListener() 的第三个参数可以是个对象值了，也就是说第三个参数现在可以是两种类型的值了 变成这样儿式儿的</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>addEventListener(type, listener[, useCapture ])<br>addEventListener(type, listener[, options ])</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">扩展新的选项，从而自定义更多的行为，目前规范中 options 对象可用的属性有三个：</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>addEventListener(type, listener, {<br>    capture: false, 等价于 useCapture 默认值 false<br>    passive: false, 是否让阻止默认事件失效 true: 失效 false：不失效<br>    once: false // 表明该监听器是一次性的，执行一次后就被自动 removeEventListener 掉，还没有浏览器实现它 默认值 false<br>})</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">还想再说一点 那我设置了 passive的事件 这么移除呢 这里给出了方法</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>你可以直接省略第三个参数<br>window.removeEventListener(‘touchmove’, func)</p>
<p>如果添加了 第一个参数 capture 可以这样移除</p>
<p>window.removeEventListener(‘touchmove’, func, true)<br>window.removeEventListener(‘touchmove’, func, {capture :true})</p>
<h3 id="为什么会有-passive这个概念"><a href="#为什么会有-passive这个概念" class="headerlink" title="为什么会有 passive这个概念"></a>为什么会有 passive 这个概念</h3><p>像这样儿的代码</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">document.addEventListener("touchstart", function(e){</span><br><span class="line">    ... // 浏览器不知道这里会不会有 e.preventDefault()</span><br><span class="line">})</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>由于 touchstart 事件对象的 cancelable 属性为 true，也就是说它的默认行为可以被监听器通过 preventDefault () 方法阻止，那它的默认行为是什么呢，通常来说就是滚动当前页面（还可能是缩放页面），如果它的默认行为被阻止了，页面就必须静止不动。但浏览器无法预先知道一个监听器会不会调用 preventDefault ()，它能做的只有等监听器执行完后再去执行默认行为，而监听器执行是要耗时的，有些甚至耗时很明显，这样就会导致页面卡顿。视频里也说了，即便监听器是个空函数，也会产生一定的卡顿，毕竟空函数的执行也会耗时。</p>
<p>有 80% 的滚动事件监听器是不会阻止默认行为的，也就是说大部分情况下，浏览器是白等了。所以，passive 监听器诞生了，passive 的意思是 “顺从的”，表示它不会对事件的默认行为说 no，浏览器知道了一个监听器是 passive 的，它就可以在两个线程里同时执行监听器中的 JavaScript 代码和浏览器的默认行为了</p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>一个问题引出的 pushState 用法</title>
    <url>/2018/11/27/pushState/</url>
    <content><![CDATA[<h3 id="引出问题"><a href="#引出问题" class="headerlink" title="引出问题"></a>引出问题</h3><p>为什么有这篇文章.<br>最近的开发中遇到这么一个问题<br>如下图<br><img src="/images/pushState/pushState1.gif" alt="gifqian"><br>扫码进入网页 点击弹出覆盖整个手机屏幕的层 此时点击浏览器的返回 会直接回退到之前扫码页面<br>其实 这个逻辑很合理 因为它没有历史记录 没有所谓的上一个页面 程序上是合理的<br>但用户体验无疑是差到极致<br>对于用户来讲 可能我只是想把当前的弹层关掉而不是退出网页</p>
<p>那么如何解决呢？</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>没有历史记录 那我们就手动造出来一条 “历史记录”，让程序的返回时 能够有迹可循<br>最终效果<br><img src="/images/pushState/pushState2.gif" alt="gifqian"></p>
<p>相关代码</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"> componentDidMount(){</span><br><span class="line">        //监听popstate事件</span><br><span class="line">        window.addEventListener('popstate',() =&gt; {</span><br><span class="line">            this.navLeftClick();</span><br><span class="line">        })    </span><br><span class="line">    }</span><br><span class="line">   //弹层的返回按钮</span><br><span class="line">   navLeftClick = () =&gt; {</span><br><span class="line">       this.setState({</span><br><span class="line">           showBrandContainer: false</span><br><span class="line">       })</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">componentWillUnmount() {</span><br><span class="line">    // 离开页面的时候取消监听popstate</span><br><span class="line">   window.removeEventListener('popstate',(state) =&gt; {</span><br><span class="line">       this.back();</span><br><span class="line">   }) </span><br><span class="line">}</span><br><span class="line">    </span><br><span class="line">    selectBrand = () =&gt; {</span><br><span class="line">        window.history.pushState({page: 1}, "title 1", "?page=1"); //向history对象push一条state</span><br><span class="line"></span><br><span class="line">          &lt;!-- 实现参数透传----</span><br><span class="line">        let search = window.location.search;</span><br><span class="line">        window.history.pushState({ page: 1 }, "", search);</span><br><span class="line">        实现参数透传---- --&gt;</span><br><span class="line">        </span><br><span class="line">        this.setState({</span><br><span class="line">            showBrandContainer: true //开启弹层</span><br><span class="line">        })</span><br><span class="line">    }</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="History"><a href="#History" class="headerlink" title="History"></a>History</h3><p>DOM 中的 window 对象通过 window.history 方法提供了对浏览器历史记录的读取，让你可以在用户的访问记录中前进和后退<br>从 HTML5 开始，我们可以开始操作这个历史记录堆栈<br><strong>前进</strong>  <code>window.history.forward();</code><br><strong>后退</strong> <code>window.history.back();</code><br><strong>向前移动 N 页</strong> <code>window.history.go(-N);</code><br><strong>向后移动 N 页</strong> <code>window.history.go(N);</code><br>你甚至可以通过检查浏览器历史记录的 length 属性来找到历史记录堆栈中的页面总数<br><code>window.history.length</code></p>
<h4 id="HTML5-history新特性pushState、replaceState"><a href="#HTML5-history新特性pushState、replaceState" class="headerlink" title="HTML5 history新特性pushState、replaceState"></a>HTML5 history 新特性 pushState、replaceState</h4><p>HTML5 引入了 histtory.pushState () 和 history.replaceState () 这两个方法，他们允许添加和修改 history 实体。同时，这些方法会和 window.onpostate 事件一起工作，关于 window.popstate 可参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/onpopstate">window.popstate</a><br>pushState：向 history 添加当前页面的记录 使用 history.pushState () 方法来修改 referrer<br>replaceState：和 pushState 的用法完全一样，区别就是它用于修改当前页面在 history 中的记录 </p>
<p>一个🌰</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">假设http://10.70.134.53:3000/opt/financial 控制台执行了JS</span><br><span class="line">var stateObj = { foo: "test" }; history.pushState(stateObj, "page 2","test.html");</span><br><span class="line">url地址栏变为 http://10.70.134.53:3000/opt/test.html，但浏览器不会加载bar.html页面，即使这个页面存在也不会加载。</span><br><span class="line">此时 如果你点击浏览器的返回 浏览器就貌似有了前一页</span><br><span class="line">如下图：</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><img src="/images/pushState/pushState3.gif" alt="gifqian"></p>
<p>总结：</p>
<p>关于 popstate 事件 需要注意的几点</p>
<ul>
<li>调用 history.pushState () 或者 history.replaceState () 不会触发 popstate 事件.</li>
<li>popstate 事件只会在浏览器某些行为下触发，比如点击后退、前进按钮 (或者在 JavaScript 中调用 history.back ()、history.forward ()、history.go () 方法).</li>
</ul>
<p>也就是说 要触发该事件 你需要两步</p>
<ol>
<li>添加并激活一个历史记录条目 (history.pushState)</li>
<li>. 改变历史记录条目 (用户行为，比如后退，前进)</li>
</ol>
]]></content>
      <categories>
        <category>react</category>
      </categories>
  </entry>
  <entry>
    <title>重构前端体系系列 - 构建前端知识架构</title>
    <url>/2020/03/12/relearning_front-end/</url>
    <content><![CDATA[<h2 id="重新理解前端"><a href="#重新理解前端" class="headerlink" title="重新理解前端"></a>重新理解前端</h2><p>前端工程师已经成为研发体系中重要的岗位，但与此相对是大部分前端工程师的知识其实都是来自于实践和工作中零散的学习，这个现状就引发了一系列的问题</p>
<ul>
<li>前端的基础知识薄弱：散点自学 + 基础不牢 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">基础知识的欠缺会让你束手束脚，更限制你解决问题的思路</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>技术上存在短板，就会导致前端开发者的上升通道不甚顺畅 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">小公司的程序员，只能靠自己摸索，这样就很容易陷入重复性劳动的陷阱，最终耽误自己的职业发展</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>前端工程师也会面临技术发展问题带来的挑战 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">前端社区高度活跃，前端标准也在快速更新，这样蓬勃发展对技术来说无疑是好事，但是副作用也显而易见，它使得前端工程师的学习压力变得很大。</span><br></pre></td></tr></tbody></table></figure>

<p>大部分人学前端的方式是 “土法学前端”，他们对于知识的理解基本都停留在点上，从来没有大范围把这些点串成线，形成自己的知识体系，因此才会出现遗漏和盲点</p>
<a id="more"></a>
<h3 id="前端工程师的成长视角"><a href="#前端工程师的成长视角" class="headerlink" title="前端工程师的成长视角"></a>前端工程师的成长视角</h3><ul>
<li>是立足标准，系统性总结和整理前端知识，建立自己的认知和方法论</li>
<li>是放眼团队，从业务和工程角度思考前端团队的价值和发展需要。只有这样做，才能够持续发展，在高速发展的技术和工程浪潮中稳稳立足</li>
<li>以完备、体系化的方式理解和思考前端的基础知识和工程实践</li>
</ul>
<p>事实上，前端的能力可以带来更多的业务场景，这些有待于我们去发掘<br>建立自己的知识体系和方法论，才能够保持领先优势</p>
<h2 id="明确前端的学习路线和方法"><a href="#明确前端的学习路线和方法" class="headerlink" title="明确前端的学习路线和方法"></a>明确前端的学习路线和方法</h2><h3 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h3><ul>
<li>摸索出适合你自己的前端学习方法</li>
<li>帮助建立前端技术的知识架构</li>
<li>理解前端技术背后的核心思想</li>
</ul>
<h3 id="前端学习方法"><a href="#前端学习方法" class="headerlink" title="前端学习方法"></a>前端学习方法</h3><h4 id="建立知识架构"><a href="#建立知识架构" class="headerlink" title="建立知识架构"></a>建立知识架构</h4><ul>
<li>学习的过程实际上就是知识架构不断进化的过程</li>
<li>通过知识架构的自然延伸，我们可以更轻松地记忆一些原本难以记住的点，还可以发现被忽视的知识盲点</li>
<li>建立知识架构同样利于面试</li>
</ul>
<h4 id="追本溯源"><a href="#追本溯源" class="headerlink" title="追本溯源"></a>追本溯源</h4><ul>
<li>有一些知识，背后有一个很大的体系</li>
<li>关注技术提出来的背景，找到知识的源头</li>
<li>关注原始的论文或者文章，关注作者说的话</li>
</ul>
<p>比如 关注 scheme，Java 与 JS 语言的异同</p>
<h2 id="前端知识图谱"><a href="#前端知识图谱" class="headerlink" title="前端知识图谱"></a>前端知识图谱</h2><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>用一定的词法和语法，表达一定语义，从而操作运行时</p>
<p>所以分为以下三个部分</p>
<ul>
<li>运行时</li>
<li>文法</li>
<li>语义</li>
</ul>
<p><img src="http://cdn.anruence.com/js%E5%9B%BE.png" alt="image"></p>
<h3 id="HTML-和-CSS"><a href="#HTML-和-CSS" class="headerlink" title="HTML 和 CSS"></a>HTML 和 CSS</h3><p>HTML 的功能主要由标签来承担，所以我们首先会把标签做一些分类</p>
<ul>
<li>文档元信息：通常是出现在 head 标签中的元素，包含了描述文档自身的一些信息；</li>
<li>语义相关：扩展了纯文本，表达文章结构、不同语言要素的标签；</li>
<li>链接：提供到文档内和文档外的链接；</li>
<li>替换型标签：引入声音、图片、视频等外部元素替换自身的一类标签；</li>
<li>表单：用于填写和提交信息的一类标签</li>
<li>表格：表头、表尾、单元格等表格的结构</li>
</ul>
<p><img src="http://cdn.anruence.com/html%E5%9B%BE.png" alt="image"></p>
<h3 id="浏览器的实现原理和-API"><a href="#浏览器的实现原理和-API" class="headerlink" title="浏览器的实现原理和 API"></a>浏览器的实现原理和 API</h3><p><img src="http://cdn.anruence.com/liulanqi.png" alt="image"></p>
<h3 id="前端工程实践"><a href="#前端工程实践" class="headerlink" title="前端工程实践"></a>前端工程实践</h3><p><img src="http://cdn.anruence.com/qianduangongcheng.jpg" alt="image"></p>
<h3 id="前端知识架构"><a href="#前端知识架构" class="headerlink" title="前端知识架构"></a>前端知识架构</h3><p><img src="http://cdn.anruence.com/qiandaunzhishikuangjia.png" alt="image"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>建立一个理解前端的全景图<br>这样，任何时候都能够体系地思考问题，分析问题，解决问题！</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端体系</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Node.js 逐步建立多路复用的 RPC 通道</title>
    <url>/2020/03/23/rpc/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>依托 Nodejs 使用 <code>Buffer</code>  <code>net</code> 等模块逐步构建满足应用场景的 RPC 通道</p>
<h1 id="1-RPC调用"><a href="#1-RPC调用" class="headerlink" title="1. RPC调用"></a>1. RPC 调用</h1><p>RPC</p>
<p>全称 <code>Remote Procedure Call</code> 翻译成中文：远程过程调用</p>
<p>emm.. 我只是个小前端..</p>
<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1584877960225&amp;di=1beedaa2bf83dbc8d438dc36164af7d3&amp;imgtype=0&amp;src=http://img3.cache.netease.com/photo/0005/2013-02-20/8O5Q4R5K0AI90005.jpg" alt="image"></p>
<h2 id="1-1-如何通俗的解释是RPC？"><a href="#1-1-如何通俗的解释是RPC？" class="headerlink" title="1.1 如何通俗的解释是RPC？"></a>1.1 如何通俗的解释是 RPC？</h2><h3 id="1-1-1-本地过程调用"><a href="#1-1-1-本地过程调用" class="headerlink" title="1.1.1 本地过程调用"></a>1.1.1 本地过程调用</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">我现在在家里，我需要洗衣服，就把衣服扔到洗衣机洗了</span><br></pre></td></tr></tbody></table></figure>

<h3 id="1-1-2-远程过程调用-RPC"><a href="#1-1-2-远程过程调用-RPC" class="headerlink" title="1.1.2 远程过程调用(RPC)"></a>1.1.2 远程过程调用 (RPC)</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">我现在在逛街，我需要洗衣服，于是给在家里的男票打个哥电话，他把衣服扔到洗衣机洗了</span><br><span class="line"></span><br><span class="line">那么我就实现了RPC调用！！</span><br></pre></td></tr></tbody></table></figure>
<a id="more"></a>
<h2 id="1-2-从前端的角度上来理解RPC调用？"><a href="#1-2-从前端的角度上来理解RPC调用？" class="headerlink" title="1.2 从前端的角度上来理解RPC调用？"></a>1.2 从前端的角度上来理解 RPC 调用？</h2><p>从我们熟悉的 Ajax 入手，它与 RPC 调用类似，我们来对比一下</p>
<h3 id="1-2-1-相同点"><a href="#1-2-1-相同点" class="headerlink" title="1.2.1 相同点"></a>1.2.1 相同点</h3><h4 id="1-2-1-1-都是两个计算机之间的网络通信"><a href="#1-2-1-1-都是两个计算机之间的网络通信" class="headerlink" title="1.2.1.1 都是两个计算机之间的网络通信"></a>1.2.1.1 都是两个计算机之间的网络通信</h4><ul>
<li>Ajax：客户端和服务端的通信</li>
<li> PRC：服务器和另外一台服务器的通信</li>
</ul>
<p>看图说话</p>
<p><img src="http://cdn.anruence.com/rpc.png" alt="image"></p>
<h4 id="1-2-1-2-需要双方约定一个数据格式"><a href="#1-2-1-2-需要双方约定一个数据格式" class="headerlink" title="1.2.1.2 需要双方约定一个数据格式"></a>1.2.1.2 需要双方约定一个数据格式</h4><h3 id="1-2-2-不同点"><a href="#1-2-2-不同点" class="headerlink" title="1.2.2 不同点"></a>1.2.2 不同点</h3><h4 id="1-2-2-1-不一定使用DNS作为寻址服务"><a href="#1-2-2-1-不一定使用DNS作为寻址服务" class="headerlink" title="1.2.2.1 不一定使用DNS作为寻址服务"></a>1.2.2.1 不一定使用 DNS 作为寻址服务</h4><ul>
<li>Ajax 是发一个 HTTP 请求，使用 DNS 进行寻址服务</li>
</ul>
<p>请求过程<br><img src="http://cdn.anruence.com/dns.png" alt="image"></p>
<ul>
<li>RPC 通信一般是在内网进行请求，使用特有的服务（比如 id）<br>请求过程<br><img src="http://cdn.anruence.com/rpcxunzhi.png" alt="image"></li>
</ul>
<h4 id="1-2-2-2-应用层协议一般不使用HTTP"><a href="#1-2-2-2-应用层协议一般不使用HTTP" class="headerlink" title="1.2.2.2 应用层协议一般不使用HTTP"></a>1.2.2.2 应用层协议一般不使用 HTTP</h4><p>Ajax：使用 HTTP 文本协议（html,json）<br>RPC: 服务端之间的通信，对效率要求更高所以使用一些二进制协议取代 HTTP，二进制协议性能上存在优势</p>
<ul>
<li>更小的数据包</li>
<li>更快的编码速率</li>
</ul>
<h4 id="1-2-2-3-基于TCP-UDP协议"><a href="#1-2-2-3-基于TCP-UDP协议" class="headerlink" title="1.2.2.3 基于TCP/UDP协议"></a>1.2.2.3 基于 TCP/UDP 协议</h4><ul>
<li>浏览器调用（Ajax）使用 TCP 是遵循 HTTP 的规范</li>
<li> RPC 调用使用了 TCP 多种通信方式<ol>
<li>  单工通信（独木桥）</li>
</ol>
</li>
</ul>
<p>类比独木桥，两岸同一时间内只能有一方通过<br><img src="http://cdn.anruence.com/dangong.png" alt="image"><br>    1.   半双工通信（轮番单工通信，独木桥）</p>
<p><img src="http://cdn.anruence.com/banshuanggongtongxin.png" alt="image"><br>    1.   全双工通信<br><img src="http://cdn.anruence.com/quanshuanggongtongxiin.png" alt="image"></p>
<h2 id="2-使用Buffter编解码二进制数据包"><a href="#2-使用Buffter编解码二进制数据包" class="headerlink" title="2. 使用Buffter编解码二进制数据包"></a>2. 使用 Buffter 编解码二进制数据包</h2><p>用来处理 TCP 链接中的流以及文件系统中的数据</p>
<p><a href="http://nodejs.cn/api/buffer.html">Buffer 官方介绍</a></p>
<h3 id="2-1-buffter创建"><a href="#2-1-buffter创建" class="headerlink" title="2.1 buffter创建"></a>2.1 buffter 创建</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const buffter1 = Buffer.from('yishu')</span><br><span class="line">const buffter2 = Buffer.alloc(20)</span><br><span class="line">console.log(buffter1)</span><br><span class="line">console.log(buffter2)</span><br><span class="line"></span><br><span class="line">&lt;Buffer 79 69 73 68 75&gt;</span><br><span class="line">&lt;Buffer 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00&gt;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-2-buffter读写"><a href="#2-2-buffter读写" class="headerlink" title="2.2 buffter读写"></a>2.2 buffter 读写</h3><p>二进制协议：不同字段塞在二进制流中的不同位置</p>
<p>基本操作</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">buffter2.writeInt8(12,1)</span><br></pre></td></tr></tbody></table></figure>

<p>图示编码二进制包<br><img src="http://cdn.anruence.com/lll.png" alt="image"></p>
<p><strong>图解：</strong><br>前三位代表一个字段，中间代表一个字段，后面又代表一个字段<br>所以，编码二进制包的时候，我们需要执行三次 write 写操作</p>
<p>看起来还是稍许麻烦嗷</p>
<p><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=908304341,3029384854&amp;fm=26&amp;gp=0.jpg" alt="image"></p>
<p>有木有像 Json 格式化方式如此简单的编码方式</p>
<p>答案：有！</p>
<p><a href="https://www.npmjs.com/package/protocol-buffers">protocol-buffers-npm 包</a></p>
<p>使用示例</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">test.proto</span><br><span class="line"></span><br><span class="line">message Test {</span><br><span class="line">  required int32 id  = 1;</span><br><span class="line">  required string payload = 2;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>index.js</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const fs = require('fs');</span><br><span class="line">var protobuf = require('protocol-buffers')</span><br><span class="line"></span><br><span class="line">// pass a proto file as a buffer/string or pass a parsed protobuf-schema object</span><br><span class="line">var messages = protobuf(fs.readFileSync(__dirname + '/test.proto','utf-8'))</span><br><span class="line">var buf = messages.Test.encode({</span><br><span class="line">  id: 42,</span><br><span class="line">  payload: 'hello world'</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">console.log(buf) // should print a buffer</span><br><span class="line">{/* &lt;Buffer 08 2a 12 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64&gt; */}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.log(messages.Test.decode(buf))</span><br><span class="line">// { id: 42, payload: 'hello world' }</span><br></pre></td></tr></tbody></table></figure>

<p>明显发现</p>
<ul>
<li>更直观</li>
<li>更好维护</li>
<li>更便于合作</li>
</ul>
<p>正是所期盼的这样鸭～<br><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1584891026316&amp;di=474986ffbe473f99d8664a54b1f89076&amp;imgtype=0&amp;src=http://p5.pccoo.cn/winccoo/20170317/2017031716023399665328.gif" alt="image"></p>
<h2 id="3-建立多路复用的RPC通道"><a href="#3-建立多路复用的RPC通道" class="headerlink" title="3. 建立多路复用的RPC通道"></a>3. 建立多路复用的 RPC 通道</h2><h3 id="3-1-需求1-实现单工通信通道"><a href="#3-1-需求1-实现单工通信通道" class="headerlink" title="3.1 需求1 实现单工通信通道"></a>3.1 需求 1 实现单工通信通道</h3><p>client.js</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const net = require('net');</span><br><span class="line">const socket  = new net.Socket({});</span><br><span class="line"></span><br><span class="line">socket.connect({</span><br><span class="line">    host:'127.0.0.1',</span><br><span class="line">    port:6002</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">socket.write('good!maying')  //单工通信</span><br></pre></td></tr></tbody></table></figure>
<p>server.js</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const net = require('net');</span><br><span class="line"></span><br><span class="line">net.createServer((socket)=&gt;{</span><br><span class="line">    socket.on('data',function(buffer){</span><br><span class="line">        console.log('buffer',buffer,buffer.toString())</span><br><span class="line">    })</span><br><span class="line">})</span><br><span class="line">.listen(6002)</span><br></pre></td></tr></tbody></table></figure>
<p>得到结果</p>
<p><img src="http://cdn.anruence.com/goodmoring.png" alt="image"></p>
<p>这里实现了 TCP 通信方式之一 <font color="red">单工通信</font></p>
<h3 id="3-1-需求2-实现半双工通信通道"><a href="#3-1-需求2-实现半双工通信通道" class="headerlink" title="3.1 需求2 实现半双工通信通道"></a>3.1 需求 2 实现半双工通信通道</h3><h4 id="3-1-1-客户端和服务器有来有回"><a href="#3-1-1-客户端和服务器有来有回" class="headerlink" title="3.1.1 客户端和服务器有来有回"></a>3.1.1 客户端和服务器有来有回</h4><ul>
<li>客户端请求一个正常数据</li>
<li>服务端返回一个相应的数据</li>
</ul>
<h4 id="3-1-2-重点逻辑"><a href="#3-1-2-重点逻辑" class="headerlink" title="3.1.2 重点逻辑"></a>3.1.2 重点逻辑</h4><p>在单工通信模式下</p>
<ul>
<li>client 端：发请求数据，等到服务器端返回结果之后，再次请求</li>
<li> server 端：接收到请求后，匹配返回</li>
</ul>
<h4 id="3-1-3-代码"><a href="#3-1-3-代码" class="headerlink" title="3.1.3 代码"></a>3.1.3 代码</h4><p>client.js</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const net = require('net');</span><br><span class="line"></span><br><span class="line">// 创建socket</span><br><span class="line">const socket = new net.Socket({});</span><br><span class="line"></span><br><span class="line">// 连接服务器</span><br><span class="line">socket.connect({</span><br><span class="line">    host: '127.0.0.1',</span><br><span class="line">    port: 6002</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const lessonids = [</span><br><span class="line">    "136797",</span><br><span class="line">    "136798",</span><br><span class="line">    "136799",</span><br><span class="line">    "136800",</span><br><span class="line">    "136801",</span><br><span class="line">    "136803",</span><br><span class="line">    "136804",</span><br><span class="line">    "136806",</span><br><span class="line">    "136807",</span><br><span class="line">    "136808",</span><br><span class="line">    "136809",</span><br><span class="line">    "141994",</span><br><span class="line">    "143517",</span><br><span class="line">    "143557",</span><br><span class="line">    "143564",</span><br><span class="line">    "143644",</span><br><span class="line">    "146470",</span><br><span class="line">    "146569",</span><br><span class="line">    "146582"</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">let id = Math.floor(Math.random() * lessonids.length);</span><br><span class="line"></span><br><span class="line">// 往服务器传数据</span><br><span class="line">socket.write(encode(id));</span><br><span class="line"></span><br><span class="line">socket.on('data', (buffer) =&gt; {</span><br><span class="line">    console.log(buffer.toString())</span><br><span class="line"></span><br><span class="line">    // 接收到数据之后，按照半双工通信的逻辑，马上开始下一次请求</span><br><span class="line">    id = Math.floor(Math.random() * lessonids.length);</span><br><span class="line">    socket.write(encode(id));</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">// 把编码请求包的逻辑封装为一个函数</span><br><span class="line">function encode(index) {</span><br><span class="line">    buffer = Buffer.alloc(4);</span><br><span class="line">    buffer.writeInt32BE(</span><br><span class="line">        lessonids[index]</span><br><span class="line">    );</span><br><span class="line">    return buffer;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>server.js</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const net = require('net');</span><br><span class="line"></span><br><span class="line">// 创建tcp服务器</span><br><span class="line">const server = net.createServer((socket) =&gt; {</span><br><span class="line"></span><br><span class="line">    socket.on('data', function(buffer) {</span><br><span class="line">        // 从传来的buffer里读出一个int32</span><br><span class="line">        const lessonid = buffer.readInt32BE();</span><br><span class="line"></span><br><span class="line">        // 50毫秒后回写数据</span><br><span class="line">        setTimeout(()=&gt; {</span><br><span class="line">            socket.write(</span><br><span class="line">                Buffer.from(data[lessonid])</span><br><span class="line">            );</span><br><span class="line">        }, 50)</span><br><span class="line">    })</span><br><span class="line"></span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">// 监听端口启动服务</span><br><span class="line">server.listen(6002);</span><br><span class="line"></span><br><span class="line">const data = {</span><br><span class="line">    136797: "01 | 课程介绍",</span><br><span class="line">    136798: "02 | 内容综述",</span><br><span class="line">    136799: "03 | Node.js是什么？",</span><br><span class="line">    136800: "04 | Node.js可以用来做什么？",</span><br><span class="line">    136801: "05 | 课程实战项目介绍",</span><br><span class="line">    136803: "06 | 什么是技术预研？",</span><br><span class="line">    136804: "07 | Node.js开发环境安装",</span><br><span class="line">    136806: "08 | 第一个Node.js程序：石头剪刀布游戏",</span><br><span class="line">    136807: "09 | 模块：CommonJS规范",</span><br><span class="line">    136808: "10 | 模块：使用模块规范改造石头剪刀布游戏",</span><br><span class="line">    136809: "11 | 模块：npm",</span><br><span class="line">    141994: "12 | 模块：Node.js内置模块",</span><br><span class="line">    143517: "13 | 异步：非阻塞I/O",</span><br><span class="line">    143557: "14 | 异步：异步编程之callback",</span><br><span class="line">    143564: "15 | 异步：事件循环",</span><br><span class="line">    143644: "16 | 异步：异步编程之Promise",</span><br><span class="line">    146470: "17 | 异步：异步编程之async/await",</span><br><span class="line">    146569: "18 | HTTP：什么是HTTP服务器？",</span><br><span class="line">    146582: "19 | HTTP：简单实现一个HTTP服务器"</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><img src="http://cdn.anruence.com/half.gif" alt="image"></p>
<h3 id="3-2-需求1-实现全双工通信通道"><a href="#3-2-需求1-实现全双工通信通道" class="headerlink" title="3.2 需求1 实现全双工通信通道"></a>3.2 需求 1 实现全双工通信通道</h3><p>client 端自由发送数据包，无需等待 server 端返回</p>
<h4 id="3-2-1-解决半双工通信的问题"><a href="#3-2-1-解决半双工通信的问题" class="headerlink" title="3.2.1 解决半双工通信的问题"></a>3.2.1 解决半双工通信的问题</h4><ul>
<li>半双工通信进行并发容易导致请求包和响应包时序错乱</li>
</ul>
<p>看图解释一下</p>
<p><img src="http://cdn.anruence.com/qwwqw.png" alt="image"></p>
<ol>
<li>client 同时发送 id1，id2 的请求</li>
<li> server 端处理…</li>
<li>server 返回 id2 的处理结果</li>
<li> server 返回 id1 的处理结果</li>
</ol>
<p>client 端如何将两个请求和返回数据对应呢？</p>
<p>如果根据返回的时间来进行匹配，就会造成错乱</p>
<p><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2814248882,3142720346&amp;fm=26&amp;gp=0.jpg" alt="image"></p>
<p><font color="red">如何解决？</font></p>
<p>这正是全双工通信模式要解决的问题</p>
<p>将请求包和返回包都加上一个序号</p>
<p>就像下图这样</p>
<p><img src="http://cdn.anruence.com/sasasas.png" alt="image"></p>
<h4 id="3-2-2-重点逻辑"><a href="#3-2-2-重点逻辑" class="headerlink" title="3.2.2 重点逻辑"></a>3.2.2 重点逻辑</h4><p>在半双工通信模式下 </p>
<ul>
<li>client 端：增加 seq，为数据包绑定特有的 id buffer</li>
<li>server 端：在返回的数据包里绑定 id buffer</li>
</ul>
<h4 id="3-2-3-代码"><a href="#3-2-3-代码" class="headerlink" title="3.2.3 代码"></a>3.2.3 代码</h4><p>client.js</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">const net = require('net');</span><br><span class="line">const socket  = new net.Socket({});</span><br><span class="line">let seq =  0;</span><br><span class="line">socket.connect({</span><br><span class="line">    host:'127.0.0.1',</span><br><span class="line">    port:6002</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">const LESSON_IDS = [</span><br><span class="line">    "136797",</span><br><span class="line">    "136798",</span><br><span class="line">    "136799",</span><br><span class="line">    "136800",</span><br><span class="line">    "136801",</span><br><span class="line">    "136803",</span><br><span class="line">    "136804",</span><br><span class="line">    "136806",</span><br><span class="line">    "136807",</span><br><span class="line">    "136808",</span><br><span class="line">    "136809",</span><br><span class="line">    "141994",</span><br><span class="line">    "143517",</span><br><span class="line">    "143557",</span><br><span class="line">    "143564",</span><br><span class="line">    "143644",</span><br><span class="line">    "146470",</span><br><span class="line">    "146569",</span><br><span class="line">    "146582"</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let index = Math.floor(Math.random() * LESSON_IDS.length);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">socket.on('data',(buffer)=&gt;{</span><br><span class="line">    const seqBuffer = buffer.slice(0,2);</span><br><span class="line">    const titleBuffer = buffer.slice(2);</span><br><span class="line"></span><br><span class="line">    console.log(seqBuffer.readInt16BE(),titleBuffer.toString())</span><br><span class="line">    // 请求回来之后再次发送</span><br><span class="line">    index = Math.floor(Math.random() * LESSON_IDS.length);</span><br><span class="line">    socket.write(encode(index));</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">function encode(index){</span><br><span class="line">    buffer = Buffer.alloc(6);</span><br><span class="line">    buffer.writeInt16BE(seq)</span><br><span class="line">    buffer.writeInt32BE(</span><br><span class="line">        LESSON_IDS[index],2</span><br><span class="line">    )</span><br><span class="line">    console.log('发包',seq,LESSON_IDS[index])</span><br><span class="line">    seq++;</span><br><span class="line">    return buffer;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">setInterval(() =&gt; {</span><br><span class="line">    index = Math.floor(Math.random() * LESSON_IDS.length);</span><br><span class="line">    socket.write(encode(index));</span><br><span class="line">}, 50);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// for(let k = 0;k&lt; 100; k++){</span><br><span class="line">//     index = Math.floor(Math.random() * LESSON_IDS.length);</span><br><span class="line">//     socket.write(encode(index));</span><br><span class="line">// }</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>server.js</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const net = require('net');</span><br><span class="line"></span><br><span class="line">net.createServer((socket)=&gt;{</span><br><span class="line">    // socket.write</span><br><span class="line">    socket.on('data',function(buffer){</span><br><span class="line">        // console.log('buffer',buffer)</span><br><span class="line">        const seqBuffer = buffer.slice(0,2);</span><br><span class="line">        const lessonId = buffer.readInt32BE(2);</span><br><span class="line">        setTimeout(function(){</span><br><span class="line">        let buffer = Buffer.concat([</span><br><span class="line">            seqBuffer,</span><br><span class="line">            Buffer.from(LESSON_DATA[lessonId])</span><br><span class="line">        ])</span><br><span class="line">        socket.write(buffer)</span><br><span class="line">    },10+Math.random() * 1000)</span><br><span class="line">    })</span><br><span class="line">})</span><br><span class="line">.listen(6002)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 假数据</span><br><span class="line">const LESSON_DATA = {</span><br><span class="line">    136797: "01 | 课程介绍",</span><br><span class="line">    136798: "02 | 内容综述",</span><br><span class="line">    136799: "03 | Node.js是什么？",</span><br><span class="line">    136800: "04 | Node.js可以用来做什么？",</span><br><span class="line">    136801: "05 | 课程实战项目介绍",</span><br><span class="line">    136803: "06 | 什么是技术预研？",</span><br><span class="line">    136804: "07 | Node.js开发环境安装",</span><br><span class="line">    136806: "08 | 第一个Node.js程序：石头剪刀布游戏",</span><br><span class="line">    136807: "09 | 模块： CommonJS规范",</span><br><span class="line">    136808: "10 | 模块：使用模块规范改造石头剪刀布游戏",</span><br><span class="line">    136809: "11 | 模块：npm",</span><br><span class="line">    141994: "12 | 模块：Node.js内置模块",</span><br><span class="line">    143517: "13 | 异步：非阻塞I/O",</span><br><span class="line">    143557: "14 | 异步：异步编程之callback",</span><br><span class="line">    143564: "15 | 异步：事件循环",</span><br><span class="line">    143644: "16 | 异步：异步编程之Promise",</span><br><span class="line">    146470: "17 | 异步：异步编程之async/await",</span><br><span class="line">    146569: "18 | HTTP：什么是HTTP服务器？",</span><br><span class="line">    146582: "19 | HTTP：简单实现一个HTTP服务器"</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>得到结果</p>
<p><img src="http://cdn.anruence.com/gif5%E6%96%B0%E6%96%87%E4%BB%B6.gif" alt="image"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们在大量前置知识的基础上，一步步推导出了全双工通道的搭建，当然了，这是不完整的，还有一些情况需要处理<br>回顾一下全双工通道搭建过程</p>
<ul>
<li>关键在于应用层协议需要有标记包号的字段✅</li>
<li>处理以下情况，需要有标记包长的字段<ul>
<li>出现原因：TCP 底层优化机制，把同时发的一些包拼起来</li>
<li>粘包❎</li>
<li>不完整包❎</li>
</ul>
</li>
<li>错误处理<ul>
<li>网络等 </li>
</ul>
</li>
</ul>
<p>希望读完本文，你会对 RPC 通道有些粗浅的认识</p>
<p>未完待续..</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 下的 setTimeout (fn,0) 意味着什么？[转]</title>
    <url>/2018/01/16/setTimeout(fn,0)/</url>
    <content><![CDATA[<p>近期在研究异步编程的我对于 setTimeout 之类的东西异常敏感。在 SegmentFault 上看到了一个问题《关于 SetTimeout 时间设为 0 时》：提问者读了一篇文章，原文解释 setTimeout 延迟时间为 0 时会发生的事情，提问者提出了几个文章中的几个疑点。读了那篇文章之后发现原文的作者对于 setTimeout 的理解和自己的认知有点出入，于是编写了相关测试的代码以求答案。最终编写了这篇文章。</p>
<p>本文内容如下：</p>
<p>起因<br>单线程的 JavaScript<br>setTimeout 背后意味着什么</p>
<a id="more"></a>
<p>起因<br>上午在 SegmentFault 上看到了这个问题《关于 SetTimeout 时间设为 0 时》（注：SegmentFault 正在调整备案，如不能访问，请点击这里），原提问者注明了问题来源：《JS setTimeout 延迟时间为 0 的详解》。这个问题来源也是转载的，我后来找到了出处。<br>在问题来源的那篇的文章中（后者），讲述了 JS 是单线程引擎：它把任务放到队列中，不会同步去执行，必须在完成一个任务后才开始另外一个任务。<br>而后，转载的那篇文章列出并补充了原文的栗子：</p>



    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>setTimeout</title>
    <script type="text/javascript">
        function get(id) {
            return document.getElementById(id);
        }
        window.onload = function () {
            //第一个例子：未使用setTimeout
            get('makeinput').onmousedown = function () {
                var input = document.createElement('input');
                input.setAttribute('type', 'text');
                input.setAttribute('value', 'test1');
                get('inpwrapper').appendChild(input);
                input.focus();
                input.select();
            }
            //第二个例子：使用setTimeout
            get('makeinput2').onmousedown = function () {
                var input = document.createElement('input');
                input.setAttribute('type', 'text');
                input.setAttribute('value', 'test1');
                get('inpwrapper2').appendChild(input);
                //setTimeout
                setTimeout(function () {
                    input.focus();
                    input.select();
                }, 0);
            }
            //第三个例子，onkeypress输入的时候少了一个值
            get('input').onkeypress = function () {
                get('preview').innerHTML = this.value;
            }
        }
    </script>


    <h1><code>setTimeout</code></h1>
    <h2>1、未使用 <code>setTimeout</code></h2>
    <button id="makeinput">生成 input</button>
    <p id="inpwrapper"></p>


<pre><code>&lt;h2&gt;2、使用 &lt;code&gt;setTimeout&lt;/code&gt;&lt;/h2&gt;
&lt;button id="makeinput2"&gt;生成 input&lt;/button&gt;
&lt;p id="inpwrapper2"&gt;&lt;/p&gt;


&lt;h2&gt;3、另一个例子&lt;/h2&gt;
&lt;p&gt;
    &lt;input type="text" id="input" value="" /&gt;&lt;span id="preview"&gt;&lt;/span&gt;
&lt;/p&gt;</code></pre>


代码运行实例请戳这里。
原文中有这么一段话，描述的有点抽象：

<p>JavaScript 引擎在执行 onmousedown 时，由于没有多线程的同步执行，不可能同时去处理刚创建元素的 focus 和 select 方法，由于这两个方法都不在队列中，在完成 onmousedown 后，JavaScript 引擎已经丢弃了这两个任务，正如第一种情况。而在第二种情况中，由于 setTimeout 可以把任务从某个队列中跳脱成为新队列，因而能够得到期望的结果。</p>
<p>我看到这里就觉得非常不对劲了。因为按照这种任务会被丢弃的说法，那么只要在事件触发的函数中再触发其他的事件都会被丢弃，浏览器是绝对不会这么做的，于是我编写了测试代码：</p>
<pre><code>window.onload = function () {
    //第一个例子：未使用setTimeout
    get('makeinput').onmousedown = function () {
        var input = document.createElement('input');
        input.setAttribute('type', 'text');
        input.setAttribute('value', 'test1');
        get('inpwrapper').appendChild(input);
        //按照文中的理论，这里的click不会被触发，但它却成功触发了
        get('inpwrapper').click();//触发了inpwrapper的onclick事件
    }
    get('inpwrapper').onclick = function () {
        alert('linkFly');
    };
}</code></pre>
<p>下面的 onclick () 最终是执行了：弹出了”linkFly”。</p>
<p>而在转载的文中为了引人深思，又提出了第三个例子：</p>
<p>在此，你可以看看例子 3，它的任务是实时更新输入的文本，现在请试试，你会发现预览区域总是落后一拍，比如你输 a, 预览区并没有出现 a, 在紧接输入 b 时，a 才不慌不忙地出现。</p>
<p>而文中最后留给大家的思考的问题，解决方案就是使用 setTimeout 再次调整浏览器的代码任务运行队列。</p>
<pre><code>var domInput = get('input');
domInput.onkeypress = function () {
    setTimeout(function () {
        //第三个例子的问题就这样就会被解决
        get('preview').innerHTML = domInput.value;
    })
}</code></pre>
<p>原文和转载的文章中都对 setTimeout (fn,0) 进行了思考，但原文指出的问题本质漏洞百出，所以才出了这篇文章，我们的正文，现在开始。</p>
<p>单线程的 JavaScript<br>首先我们来看浏览器下的 JavaScript：</p>
<ul>
<li>javascriipt 引擎线程</li>
<li> GUI 渲染线程</li>
<li>浏览器事件触发线程</li>
</ul>
<p>javascript 引擎是基于事件驱动单线程执行的，JS 引擎一直等待着任务队列中任务的到来，然后加以处理，浏览器无论什么时候都只有一个 JS 线程在运行 JS 程序。<br>GUI 渲染线程负责渲染浏览器界面，当界面需要重绘（Repaint）或由于某种操作引发回流 (reflow) 时，该线程就会执行。但需要注意 GUI 渲染线程与 JS 引擎是互斥的，当 JS 引擎执行时 GUI 线程会被挂起，GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行。<br>事件触发线程，当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理。这些事件可来自 JavaScript 引擎当前执行的代码块如 setTimeOut、也可来自浏览器内核的其他线程如鼠标点击、AJAX 异步请求等，但由于 JS 的单线程关系所有这些事件都得排队等待 JS 引擎处理。（当线程中没有执行任何同步代码的前提下才会执行异步代码）<br>js 的单线程在这一段面试代码中尤为明显（理解即可，请不要尝试… 浏览器会假死的）：</p>
<pre><code>    var isEnd = true;
    window.setTimeout(function () {
        isEnd = false;//1s后，改变isEnd的值
    }, 1000);
    //这个while永远的占用了js线程，所以setTimeout里面的函数永远不会执行
    while (isEnd);
    //alert也永远不会弹出
    alert('end');</code></pre>
<p>在我工作中对 js 的认识，个人认为 js 的任务单位是函数。即，一个函数表示着一个任务，这个函数没有执行结束，则在浏览器中当前的任务即没有结束。<br>上面的代码中，当前任务因为 while 的执行而造成永远无法执行，所以后面的 setTimeout 也永远不会被执行。它在浏览器的任务队列中如图所示：</p>
<p>Browser Event</p>
<p>setTimeout 背后意味着什么<br>这篇文章一直在使用 setTimeout 为我们展现和理解 js 单线程的设计，只是它错误的使用了 Event 来进行演示，并过度解读了 Event。<br>这里原文和转载的文章忽略了这些基础的事件触发，而且也偏偏挑了两套本身设计就比较复杂的 API：onmouseXXX 系和 onkeyXXX 系。</p>
<p>onKeyXXX 系的 API 触发顺序如图：</p>
<p>onKeyXXX</p>
<p>而我个人所理解它们对应的功能：</p>
<p>onkeydown - 主要获取和处理当前按下按键，例如按下 Enter 后进行提交。在这一层，并没有更新相关 DOM 元素的值。<br>onkeypress - 主要获取和处理长按键，因为 onkeypress 在长按键盘的情况下会反复触发直到释放，这里并没有更新相关 DOM 元素的值，值得注意的是：keypress 之后才会更新值，所以在长按键盘反复触发 onkeypress 事件的时候，后一个触发的 onkeypress 能得到上一个 onkeypress 的值。所以出现了 onkeypress 每次取值都会是上一次的值而不是最新值。<br>onkeyup - 触发 onkeyup 的 DOM 元素的值在这里已经更新，可以拿到最新的值，所以这里主要处理相关 DOM 元素的值。<br>流程就是上面的图画的那样：</p>
<p>onkeydown =&gt; onkeypress =&gt; onkeyup</p>
<p>使用了 setTimeout 之后，流程应该是下面这样子的：</p>
<p>onkeydown =&gt; onkeypress =&gt; function =&gt; onkeyup</p>
<p>使用 setTimeout (fn,0) 之后，在 onkeypress 后面插入了我们的函数 function。上面所说，浏览器在 onkeypress 之后就会更新相关 DOM 元素的状态（input [type=text] 的 value），所以我们的 function 里面可以拿到最新的值。<br>所以我们在 onkeypress 里面挂起 setTimeout 能拿到正确的值，下面的代码可以测试使用 setTimeout (fn,0) 之后的流程：</p>
<pre><code>window.onload = function () {
    var domInput = get('input'), view = get('preview');
    //onkeypress兼容性和说明：http://www.w3school.com.cn/jsref/jsref_events.asp
    domInput.onkeypress = function () {
        setTimeout(function () {
            //这个函数在keypress之后，keyup之前执行
            console.log('linkFly');
        });
    };
    domInput.onkeyup = function () {
        console.log('up');
    };
};</code></pre>
<p>然后我们再来谈谈原代码中的示例 1 和示例 2，示例 1 和示例 2 的区别在这里：</p>
<pre><code>    //示例1
    input.focus();
    input.select();

    //示例2
    setTimeout(function () {
        input.focus();
        input.select();
    }, 0);</code></pre>
<p>原文章中说示例 1 的 focus () 和 select () 在 onmousedown 事件中被丢弃，从而导致了没有选中，但原文的作者忽略了他注册的事件是：onmousedown。<br>我们暂且不讨论 onmouseXXX 系的其他 API，我们仅关注和点击相关的，它们的执行顺序是：</p>
<p>mousedown - 鼠标按钮按下<br>mouseup - 鼠标按钮释放<br>click - 完成单击<br>我们在 onmousedown 里面新建了 input，并且选中 input 的值（调用了 input.focus (),input.select ()）。<br>那么为什么没有被选中呢？这样，我们来做一次测试，看看我们的 onfocus 到底是被丢弃了，还是触发了。我们把原文的代码进行改写：</p>
<pre><code>window.onload = function () {
    var makeBtn = get('makeinput');
    //观察onmouseXXX系完成整个单击的顺序
    makeBtn.onmousedown = function (e) {
        console.log(e.type);
        var input = document.createElement('input');
        input.setAttribute('type', 'text');
        input.setAttribute('value', 'test1');
        get('inpwrapper').appendChild(input);
        input.onfocus = function () {//观察我们新生成的input什么时候获取焦点的，或者它有没有像原文作者说的那样被丢弃了
            console.info('input focus');
        };
        input.focus();
        input.select();
    }
    makeBtn.onclick = function (e) {
        console.log(e.type);
    };
    makeBtn.onmouseup = function (e) {
        console.log(e.type);
    };
    makeBtn.onfocus = function () {//观察我们生成按钮什么时候获取焦点的
        console.log('makeBtn focus');
    }
};</code></pre>
<p>代码运行的结果是这样的：<br>onmouseXXX &amp; focus</p>
<p>我们的 input focus 执行了 —— 那么它为什么没有获取到焦点呢？我们再看看后面执行的函数：我们点击的按钮，在 mousedown 之后，才获得焦点，也就是说：我们的 input 本来已经得到了 focus ()，但在 onmousedown 之后，我们点击的按钮才迟迟触发了自己的 onfocus ()，导致我们的 input 被覆盖。<br>我们再加上 setTimeout 进行测试：</p>
<pre><code>window.onload = function () {
    var makeBtn = get('makeinput');
    makeBtn.onmousedown = function (e) {
        console.log(e.type);
        var input = document.createElement('input');
        input.setAttribute('type', 'text');
        input.setAttribute('value', 'test1');
        get('inpwrapper').appendChild(input);
        input.onfocus = function () {
            console.info('input focus');
        };
        //我们加上setTimeout，看看会发生什么
        setTimeout(function () {
            input.focus();
            input.select();
        });
    }
    makeBtn.onclick = function (e) {
        console.log(e.type);
    };
    makeBtn.onmouseup = function (e) {
        console.log(e.type);
    };
    makeBtn.onfocus = function () {
        console.log('makeBtn focus');
    }
};</code></pre>
<p>执行结果是这样：<br>onmouseXXX and settimeout</p>
<p>可以看见当我们点击” 生成” 按钮的时候，按钮的 focus 正确的执行了，然后才执行了 input focus。<br>在示例 1 中，我们在 onmousedown () 中执行了 input.focus () 导致 input 得到焦点，而 onmousedown 之后，我们点击的按钮才迟迟得到了自己的焦点，造成了我们 input 刚拿到手还没焐热的焦点被转移。<br>而示例 2 中的代码，我们延迟了焦点，当按钮获得焦点之后，我们的 input 再把焦点抢过来，所以，使用 setTimeout (fn,0) 之后，我们的 input 可以得到焦点并选中文本。<br>这里值得思考的 focus () 的执行时机，根据这次测试观察，发现 focus 事件好像挂载在 mousedown 之内的最后面，而不是直接挂在 mousedown 的后面。它和 mousedown 仿佛是一体的。<br>我们使用 setTimeout 之前的任务流程是这样的（-&gt; 表示在上一个任务中，=&gt; 表示在上一个任务后）：</p>
<p><code>onmousedown -&gt; onmousedown中执行了input.focus() -&gt; button.onfocus =&gt; onmouseup =&gt; onclick</code></p>
<p>onmouseXXX 事件流程</p>
<p>而我们使用了 setTimeout 之后的任务流程是这样的：</p>
<p><code>onmousedown -&gt; button.onfocus =&gt; input.focus =&gt; onmouseup =&gt; onclick</code></p>
<p>onmouseXXX+setTimeout 事件流程</p>
<p>而从上面的流程上我们得知了另外的消息，我们还可以把 input.focus 挂在 mouseup 和 click 下，因为在这些事件之前，我们的按钮已经得到过焦点了，不会再抢我们的焦点了。</p>
<pre><code>    makeBtn.click = function (e) {
        console.log(e.type);
        var input = document.createElement('input');
        input.setAttribute('type', 'text');
        input.setAttribute('value', 'test1');
        get('inpwrapper').appendChild(input);
        input.onfocus = function () {//观察我们新生成的input什么时候获取焦点的
            console.info('input focus');
        };
        input.focus();
        input.select();
    }</code></pre>
<p>我们应该认识到，利用 setTimeout (fn,0) 的特性，可以帮助我们在某些极端场景下，修正浏览器的下一个任务</p>
<p>总结：<br><strong>意思就是说 input 的 focus 有执行， 只是被 button 的 mouseup 影响了，所以要要把 focus () 放到后面执行<br>页面上只有一个元素能获得焦点，就这样而已。。</strong></p>
<p>参考和引用<br>JavaScript 异步机制<br>什么是 Event Loop<br>javascript 线程解释<br>JavaScript - 前端开发交流群：377786580</p>
<p>作者：linkFly<br>原文：<a href="http://www.cnblogs.com/silin6/p/4333999.html">http://www.cnblogs.com/silin6/p/4333999.html</a><br>出处：<a href="http://www.cnblogs.com/silin6/">www.cnblogs.com/silin6/</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>你不知道的 JS 系列 - this 指向</title>
    <url>/2019/03/26/this/</url>
    <content><![CDATA[<p>this 是 js 中最复杂的机制之一</p>
<blockquote>
<p>任何足够先进的技术都和魔法无异  - Arthur C.Clarke</p>
</blockquote>
<a id="more"></a>
<p>但其实 this 机制并没有那么先进，是我们的臆想把它想复杂了，在缺乏认知的情况下，this 对你来说就是魔法</p>
<h3 id="为什么要使用this？"><a href="#为什么要使用this？" class="headerlink" title="为什么要使用this？"></a>为什么要使用 this？</h3><p>它提供了一种更优雅的方式来隐式传递一个对象引用，因此可以将 API 设计得更加简洁并且易于使用</p>
<h3 id="对于this的误解"><a href="#对于this的误解" class="headerlink" title="对于this的误解"></a>对于 this 的误解</h3><ol>
<li>指向函数自身 </li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">常见需要指向自身的场景是递归</span><br><span class="line">匿名的函数无法指向自身</span><br><span class="line">传统的arguments.callee已经弃用</span><br></pre></td></tr></tbody></table></figure>
<ol start="2">
<li>指向函数的词法作用域 </li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">this在任何情况下都不指向函数的词法作用域，在js内部作用域和对象相似，可见的标识符都是它的属性,但是作用域“对象”无法通过js代码访问，它存在于JS引擎内部</span><br></pre></td></tr></tbody></table></figure>
<h3 id="this到底是什么？"><a href="#this到底是什么？" class="headerlink" title="this到底是什么？"></a>this 到底是什么？</h3><p>this 是运行时进行绑定的 并不是在编写时绑定的 它的上下文取决于函数调用时的各种条件 this 绑定和函数声明的位置没有任何关系 只取决于函数的调用方式</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">当一个函数调用时 会创建一个活动记录（执行上下文）这个记录会包含函数在哪里被调用（调用栈）函数的调用方法 传入的参数等 this就是记录的其中一个属性会在函数执行的过程中用到</span><br><span class="line"></span><br><span class="line">this时函数被调用时发生的绑定 指向什么完全取决于函数在哪里被调用</span><br></pre></td></tr></tbody></table></figure>
<h4 id="调用位置"><a href="#调用位置" class="headerlink" title="调用位置"></a>调用位置</h4><p>寻找” 函数被调用的位置”<br>需要分析调用栈（为了到达当前执行位置所调用的所有函数）</p>
<h4 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h4><p>找到调用位置 然后按照结论中的四条规则判断</p>
<h4 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h4><p>独立函数调用时，如果在严格模式下，就绑定到 undefined 否则绑定到全局对象 </p>
<h4 id="隐式绑定-对象上的函数调用"><a href="#隐式绑定-对象上的函数调用" class="headerlink" title="隐式绑定(对象上的函数调用)"></a>隐式绑定 (对象上的函数调用)</h4><p>当函数引用有上下文对象时 隐式绑定规则会把函数中的 this 绑定到这个上下文对象</p>
<p><strong>对象属性引用链中只有最顶层或者说最后一层会影响调用位置</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">function foo(){</span><br><span class="line">  console.log(this.a)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var obj2 = {</span><br><span class="line">  a:42,</span><br><span class="line">  foo:foo</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">var obj1 = {</span><br><span class="line">  a:2,</span><br><span class="line">  obj2:obj2</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">obj1.obj2.foo(); //42</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var a = 20;</span><br><span class="line">var obj = {</span><br><span class="line">    a: 10,</span><br><span class="line">    c: this.a + 20,</span><br><span class="line">    fn: function () {</span><br><span class="line">        return this.a;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">console.log(obj.c); //40</span><br><span class="line">console.log(obj.fn()); //10</span><br></pre></td></tr></tbody></table></figure>
<p>单独的 {} 是不会形成新的作用域的，因此这里的 <code>this.a</code>，由于并没有作用域的限制，所以它仍然处于全局作用域之中。所以这里的 <code>this</code> 其实是指向的 <code>window</code> 对象。</p>
<p><strong>被隐式绑定的函数会丢失绑定对象而执行默认绑定规则 下面是两个场景</strong></p>
<p>1.</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">function foo(){</span><br><span class="line">  console.log(this.a)</span><br><span class="line">}</span><br><span class="line">var obj1 = {</span><br><span class="line">  a:2,</span><br><span class="line">  foo:foo</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var bar = obj1.foo; //函数别名</span><br><span class="line">var a = "global"; //全局属性a</span><br><span class="line">bar(); //bar引用的是foo本身 因此此时的bar其实是一个不带任何修饰符的函数调用 因此使用了默认绑定</span><br></pre></td></tr></tbody></table></figure>
<p><strong>2. 当传入回调函数时 使用默认绑定规则</strong></p>
<p>参数传递就是一种隐式赋值，因此我们传入函数时也会被隐式赋值</p>
<p>如果把函数传入语言内置函数 结果也是一样的</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">function foo(){</span><br><span class="line">  console.log(this.a)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">function dofoo(fn){</span><br><span class="line">  fn();</span><br><span class="line">}</span><br><span class="line">var obj1 = {</span><br><span class="line">  a:2,</span><br><span class="line">  foo:foo</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var a = "global mama"; //全局属性a</span><br><span class="line"></span><br><span class="line">dofoo(obj1.foo) //global mama</span><br><span class="line"></span><br><span class="line">setTimeout(obj1.foo,100) //global mama 将函数传入语言内置的函数</span><br><span class="line">相当于</span><br><span class="line">function setTimeout(fn,delay){</span><br><span class="line">//等待delay之后</span><br><span class="line">fn() </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="显式绑定-使用call-apply-bind"><a href="#显式绑定-使用call-apply-bind" class="headerlink" title="显式绑定(使用call apply bind)"></a>显式绑定 (使用 call apply bind)</h4><p>通过固定 this 来修复，可以在某个对象上强制调用函数<br><code>使用 call apply 或者bind</code></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">他们的第一个参数式对象，它们会把这个对象绑定到this，接着在调用函数时指定这个this 因为你可以直接指定this的绑定对象 因此我们称之为显式绑定</span><br></pre></td></tr></tbody></table></figure>

<p>如果 foo.call (1) // 一个原始值当作对象 这个原始值会转换成它的对象形式 (装箱)</p>
<p><strong>可惜，显示绑定无法解决丢失绑定的问题</strong></p>
<p>但是显示绑定的一个变种 “硬绑定” 可以解决这个问题</p>
<p><strong>硬绑定</strong>：无论何时调用函数 bar 它总会手动在 obj 调用 foo 这种绑定是一种显式的强制绑定</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">function foo(){</span><br><span class="line">  console.log(this.a)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var obj1 = {</span><br><span class="line">  a:2</span><br><span class="line">}</span><br><span class="line">var obj2 = {</span><br><span class="line">  a:4</span><br><span class="line">}</span><br><span class="line">var bar = function(){</span><br><span class="line">  foo.call(obj1)</span><br><span class="line">}</span><br><span class="line">bar(); //2</span><br><span class="line">setTimeout(bar,100) //2</span><br><span class="line">bar.call(obj2) // 2 硬绑定的bar不可能再修改它的this</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>由于硬绑定是一种常用的模式，所以 ES5 提供了内置的方法<br><code>Function.prototype.bind</code></p>
<p>了解了用法 我们来看一个 demo</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">let a = {};</span><br><span class="line">let fn = function(){</span><br><span class="line">  console.log(this)</span><br><span class="line">}</span><br><span class="line">fn.bind().bind(a)() // ?</span><br></pre></td></tr></tbody></table></figure>
<p>答案应该是 <code>window</code> 你回答对了吗</p>
<p>事实上 我么可以改写一下</p>
<p>它类似于</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var a = {};</span><br><span class="line">let fn = function(){console.log(this)}</span><br><span class="line">let fn2 = function fn1(){</span><br><span class="line">  return function(){</span><br><span class="line">    return fn.apply();</span><br><span class="line">  }.apply(a)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">fn2() //window</span><br></pre></td></tr></tbody></table></figure>

<p>这样儿结果能猜到了吗</p>
<p>fn 中的 this 永远由<code>第一个bind</code> 决定 所以 结果永远是 window</p>
<h4 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new 绑定</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">js中的构造函数只是一些使用new操作符时被调用的函数 他们不并不属于某个类也不会去实例化一个类 他们只是被new操作符调用的普通函数</span><br><span class="line"></span><br><span class="line">插播new调用的时候会自动执行下面的操作</span><br><span class="line">1. 创建（构造一个全新的对象）</span><br><span class="line">2. 这个对象会被执行原型链接</span><br><span class="line">3. 这个信贷想回绑定到函数调用的this</span><br><span class="line">4. 如果函数没有返回其他对象那么new表达式中的函数调用会自动返回这个新对象</span><br></pre></td></tr></tbody></table></figure>
<p>由此可以知道 new 操作符调用时，this 指向生成的新对象<br>⚠️new 调用时的返回值，如果没有显式返回对象或者函数，才会返回新对象<br>关于这一点</p>
<p><a href="">这应该是一篇关于模拟实现 JS 的 new 操作符的文章</a></p>
<h4 id="绑定优先级"><a href="#绑定优先级" class="headerlink" title="绑定优先级"></a>绑定优先级</h4><p>new 调用 &gt; 显示绑定 (apply,call,bind) &gt; 隐式绑定（对象上的函数调用） &gt; 默认绑定</p>
<h4 id="绑定例外"><a href="#绑定例外" class="headerlink" title="绑定例外"></a>绑定例外</h4><p>规则总有例外，这里也一样</p>
<p>当你把 <code>null</code> 或者 <code>undefined</code> 作为 <code>this</code> 的绑定对象传入 <code>call apply</code> 或者 <code>bind</code> 这些在调用时候会被忽略应用默认规则<br>应用场景：当你要传入参数时候 如果函数不关心 this 的话 你可以传入 null 当作一个占位值 但是这种方式不可取 绑定 this 可能会引起副作用</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">function foo(){</span><br><span class="line">  console.log(this.a)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var obj = {</span><br><span class="line">  a:2</span><br><span class="line">}</span><br><span class="line">var a = 3</span><br><span class="line">foo.call(null)</span><br></pre></td></tr></tbody></table></figure>

<p>一种更安全的 this</p>
<p><code>Object.create(null) </code>创建的空对象不会创建 <code>object.prototype</code> 比 <code>{}</code> 更空 比 <code>null</code> 的语义更清楚</p>
<p>代码如下</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">function foo(a,b){</span><br><span class="line">  console.log(a,b)</span><br><span class="line">}</span><br><span class="line">var w = Object.create(null);</span><br><span class="line"></span><br><span class="line">foo.apply(w,[2,3])</span><br><span class="line"></span><br><span class="line">//使用bind()进行柯里化</span><br><span class="line">var bar = foo.bind(w,2)</span><br><span class="line">bar(3)</span><br></pre></td></tr></tbody></table></figure>
<p><strong>间接引用</strong><br>你会有意无意的创建一个函数的间接引用，在这种情况下，调用这个函数会应用默认规则<br><strong>它最容易在赋值时产生</strong><br>类似这样儿的</p>
<p><code>(p.foo = o.foo)();</code> 它的返回值是目标函数的引用，因此调用的位置是 <code>foo()</code> 而不是 <code>p.foo()</code> 或者 <code>o.foo()</code> 所以使用默认绑定</p>
<h4 id="箭头函数调用模式"><a href="#箭头函数调用模式" class="headerlink" title="箭头函数调用模式"></a>箭头函数调用模式</h4><p>先看箭头函数和普通函数的重要区别：</p>
<ol>
<li>没有自己的 this、super、arguments 和 new.target 绑定。</li>
<li>不能使用 new 来调用。</li>
<li>没有原型对象。</li>
<li>不可以改变 this 的绑定。</li>
<li>形参名称不能重复。</li>
</ol>
<hr>
<p>箭头函数中没有 <code>this</code> 绑定，必须通过查找作用域链来决定其值。<br>如果箭头函数被非箭头函数包含，则 <code>this</code> 绑定的是最近一层非箭头函数的 <code>this</code>，否则 <code>this</code> 的值则被设置为全局对象。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var name = 'window';</span><br><span class="line">var student = {</span><br><span class="line">    name: 'ma',</span><br><span class="line">    doSth: function(){</span><br><span class="line">        // var self = this;</span><br><span class="line">        var arrowDoSth = () =&gt; {</span><br><span class="line">            // console.log(self.name);</span><br><span class="line">            console.log(this.name);</span><br><span class="line">        }</span><br><span class="line">        arrowDoSth();</span><br><span class="line">    },</span><br><span class="line">    arrowDoSth2: () =&gt; {</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">student.doSth(); // 'ma'</span><br><span class="line">student.arrowDoSth2(); // 'window'</span><br></pre></td></tr></tbody></table></figure>



<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul>
<li> this 不指向函数自身</li>
<li> this 不指向函数的词法作用域，当你想要把 this 和词法作用域查找混合使用时，一定要提醒自己 这是无法实现的</li>
<li> this 实际上是在函数被调用时发生绑定的，指向什么完全取决于函数在哪里被调用</li>
<li> 如果要判断一个运行中函数的 this 绑定 就需要找到这个函数的直接调用位置 找到之后按照下面这四条规则判断 this 的绑定对象 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1.由new调用？绑定到新创建的对象</span><br><span class="line">2.由call或apply或bind调用(显示绑定)？绑定到指定的对象</span><br><span class="line">3.由上下文对象调用（隐式绑定）？绑定到上下文对象</span><br><span class="line">4.如果都不是的话 使用默认绑定，如果在严格模式下，就绑定到undefined 否则绑定到全局对象 </span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>ES6 中的箭头函数不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定 this, 它会继承外层函数调用的 this 绑定 (无论 this 绑定到什么), 这跟 ES6 之前代码中的 <code>self=this</code> 机制一样（实际上箭头函数将程序猿们常犯的一个错误：<font color="red">混淆 this 绑定规则和词法作用域规则 </font>给标准化了，这点容易造成误解）</li>
<li>DOM 事件函数：一般指向绑定事件的 DOM 元素，但有些情况绑定到全局对象（比如 IE6~IE8 的 attachEvent）</li>
</ul>
<p>检验一下学习成果</p>
<p><a href="https://www.cnblogs.com/xxcanghai/p/5189353.html">小小沧海：一道常被人轻视的前端 JS 面试题</a><br><a href="https://segmentfault.com/a/1190000010981003">从这两套题，重新认识 JS 的 this、作用域、闭包、对象</a></p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title>写在入职两周年</title>
    <url>/2019/03/22/twoYears/</url>
    <content><![CDATA[<p>博客计划</p>
]]></content>
  </entry>
  <entry>
    <title>函数节流与防抖</title>
    <url>/2019/02/19/throttleAnddebounce/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>博客中的大部分文章 大部分都有一个引子，要说明的通常是一些零零碎碎或者大多耳熟能详的 “知识点”</p>
<p>我认为遇到了问题 解决了问题 然后才会形成一个知识点而不是为了应用某个知识点去搭建场景，否则 真的是过目即忘<br>解决最近一个问题之前 并没有计划写关于防抖和节流的问题，问题引导你说 需要重视这一块儿了</p>
<p>此文系 不要再问我 XX 系列之 <font color="red">不要再问我函数节流和防抖了</font></p>
<a id="more"></a>

<h3 id="引出问题"><a href="#引出问题" class="headerlink" title="引出问题"></a>引出问题</h3><p>需求：记录用户的浏览深度</p>
<p><img src="/images/throllte/scroll.gif" alt="---"></p>
<p>一旦你使用了类似 <code>scroll</code> 的浏览器事件，触发频率比较高，若稍处理函数微复杂，需要较多的运算执行时间，响应速度跟不上触发频率，往往会出现延迟，会出现卡顿甚至引发假死</p>
<p>在资源有限的情况下 我们可以想办法只响应部分请求，事实上某些场景下的密集性请求，并不是我们需要的</p>
<p>此时 我并不知道 需要用 “防抖” 这个晦涩的结论去解决，只知道目的是只是在<strong>浏览到</strong>这辆车的时候打点</p>
<hr>
<p><strong>那程序中要怎么体现<font color="red">我浏览到</font>这个概念呢？</strong></p>
<p>先要约定一件事<br>假设用户浏览到某一辆车之后停顿了超过你预设的时间值 就认为是浏览了</p>
<p>利用 <code>setTimeout</code> 实现</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">window.addEventListener('scroll', function(){</span><br><span class="line">        var timeout = null;   </span><br><span class="line">        return function() {        </span><br><span class="line">            clearTimeout(timeout);</span><br><span class="line">            timeout = setTimeout(fn,200);</span><br><span class="line">}, false);</span><br></pre></td></tr></tbody></table></figure>
<p>通过闭包保存一个定时器的标记 <code>timeout</code>，再次执行的时候 clear 掉之前的，又重新计时 这就保证了 触发非常频繁的 <code>scroll</code> 事件合并成一次执行。当调用动作过 n 毫秒后，才会执行该动作，若在这 n 毫秒内又调用此动作则将重新计算执行时间 所以短时间内的连续动作永远只会触发一次，比如说用手指一直按住一个弹簧，它将不会弹起直到你松手为止</p>
<p>现在的效果</p>
<p><img src="/images/throllte/fangdou111.gif" alt="fangdou111"></p>
<p>好像受控制了 滑动过程中不会执行，一旦我们停下超过 n 毫秒，会执行一次<br>由此得到一个结论<br><font color="red">处理此类问题就是要保证函数在特定的时间内（你设置的延迟时间）不被再调用后执行</font></p>
<p>我们的问题解决了，上网随便一搜，它是一类<code>知识点</code>，越发感兴趣惹</p>
<hr>
<h3 id="得出结论-引出-防抖-与-节流"><a href="#得出结论-引出-防抖-与-节流" class="headerlink" title="得出结论 引出 防抖 与 节流"></a>得出结论 引出 防抖 与 节流</h3><p>所以说我们直接接触到了 <code>函数防抖</code>，在此之前 我觉得它是晦涩难懂的，现在越发清晰了<br>说到这儿 不得不提另一个兄弟 <code>函数节流</code>，因为应用场景相似而不相同，所以经常会被拿来比较</p>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>网上有很多关于两者的概念<br>简单来讲：<br><strong>函数节流</strong>：指定时间间隔内只会执行一次任务</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">🌰1</span><br><span class="line">一个比较形象的例子是如果将水龙头拧紧直到水是以水滴的形式流出，那你会发现每隔一段时间，就会有一滴水流出</span><br><span class="line">🌰2</span><br><span class="line">地铁闸机，每个人进入后3秒后门关闭，等待下一个人进入。</span><br></pre></td></tr></tbody></table></figure>


<p><strong>函数防抖</strong>：任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行 （当一个动作连续触发，只执行最后一次）</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">🌰</span><br><span class="line">用手指一直按住一个弹簧，它将不会弹起直到你松手为止</span><br></pre></td></tr></tbody></table></figure>
<p>看下图 感受一下三种环境对于 <code>mousemove</code> 事件回调的执行情况<br><img src="/images/throllte/fn_dou.png" alt="fn_dou"></p>
<p>竖线的疏密程度代表事件之行的频繁程度<br><strong>可以得到</strong>：</p>
<ul>
<li>正常情况下 函数执行的非常频繁</li>
<li>去抖之后很稀疏 只有当鼠标停止移动时才会执行一次</li>
<li>节流分布的比较均匀 每隔一段时间就会执行一次</li>
</ul>
<hr>
<h4 id="demo示例"><a href="#demo示例" class="headerlink" title="demo示例"></a>demo 示例</h4><p>原生 scroll</p>
<p><img src="/images/throllte/scrolldemo.gif" alt="scrolldemo"></p>
<p>函数去抖</p>
<p><img src="/images/throllte/debouce.gif" alt="debouce"></p>
<p>函数节流<br><img src="/images/throllte/throllte.gif" alt="throllte"></p>
<p>我们在真实场景中可以感受到无论采取哪种方案都会明显减少了回调的执行，得到了 都是用来控制某个函数在一定时间内执行次数的多少以优化高频率执行 js 代码的一种技巧，两者相似而又不同的结论</p>
<p>那么 我们 如何选择这两种方案？</p>
<h4 id="优化方案的应用场景"><a href="#优化方案的应用场景" class="headerlink" title="优化方案的应用场景"></a>优化方案的应用场景</h4><p>选择哪个 取决于应用场景</p>
<hr>
<p><strong>函数防抖</strong></p>
<p>如果你的需求是连续的时间只需要触发一次回调</p>
<p>比如：</p>
<ol>
<li>搜索框输入 可能需要等到用户最后一次输入完 再去发送请求</li>
<li>手机号，邮箱等输入检测</li>
<li>浏览器窗口的 <code>resize</code> 你肯定要等到窗口调整完成后再进行渲染</li>
<li> scroll 事件等</li>
</ol>
<p><strong>函数节流</strong></p>
<p>固定时间间隔执行的</p>
<p>比如：</p>
<ol>
<li>滚动加载 常常需要滚动到底部加载下一页</li>
<li>表单的重复提交</li>
<li>进度条的更新</li>
<li>高频的点击（比如抽奖）</li>
<li>高频的鼠标移动，游戏射击类的</li>
</ol>
<p>哦 理解了如何选择 下一个问题就是如何用</p>
<hr>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>引出问题模块 其实我们已经做到了 <code>防抖</code></p>
<p><strong>函数防抖（debounce）简单实现</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">window.addEventListener('scroll', this.debounce(this.scrollListener, 500), false);</span><br><span class="line">   </span><br><span class="line">  debounce = (fn, wait) =&gt; {  </span><br><span class="line">        var timeout = null;   </span><br><span class="line">        return function() {        </span><br><span class="line">            if(timeout !== null){</span><br><span class="line">                clearTimeout(timeout);</span><br><span class="line">            }; </span><br><span class="line">            timeout = setTimeout(fn, wait);</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>
<p>函数防抖在第一次执行时，有 500ms 的延迟。再次执行时，若前一个定时任务未执行完，则 clear 掉定时任务，重新定时</p>
<hr>
<p><strong>函数节流（throttle）</strong></p>
<p>定时器版本实现</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const _.throttle = (func, wait) =&gt; {</span><br><span class="line">  let timer;</span><br><span class="line"></span><br><span class="line">  return () =&gt; {</span><br><span class="line">    if (timer) {</span><br><span class="line">     // 判断是否已空闲，如果在执行中，则直接return</span><br><span class="line">      return;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    timer = setTimeout(() =&gt; {</span><br><span class="line">      func();</span><br><span class="line">      timer = null;</span><br><span class="line">    }, wait);</span><br><span class="line">  };</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>函数节流的目的，是为了限制函数一段时间内<strong>只能执行一次</strong> 使用 <code>setTimeout</code> 执行。在延时的时间内，方法若被触发，则直接退出方法。从而达到函数一段时间内只执行一次的目的</p>
<p>时间戳版简单实现</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const throttle = (func, wait) =&gt; {</span><br><span class="line">  let last = 0;</span><br><span class="line">  return () =&gt; {</span><br><span class="line">    const current_time = +new Date();</span><br><span class="line">    if (current_time - last &gt; wait) {</span><br><span class="line">      func.apply(this, arguments);</span><br><span class="line">      last = +new Date();</span><br><span class="line">    }</span><br><span class="line">  };</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>其实现原理，通过比对上一次执行时间与本次执行时间的时间差与间隔时间的大小关系，来判断是否执行函数。若时间差大于间隔时间，则立刻执行一次函数。并更新上一次执行时间。</p>
<hr>
<h4 id="函数节流与函数防抖异同"><a href="#函数节流与函数防抖异同" class="headerlink" title="函数节流与函数防抖异同"></a>函数节流与函数防抖异同</h4><p>其实到这里应该比较能清晰的理解甚至选择适合真实场景的优化方案了</p>
<p><strong>相同点</strong></p>
<ul>
<li>都可以通过延时器实现</li>
<li>目的都是 降低回调执行频率 节约计算机资源</li>
</ul>
<p><strong>不同点</strong></p>
<ul>
<li><p>其实从两者的概念也能看出来</p>
</li>
<li><p>函数防抖：关注一定时间连续触发，只在最后执行一次</p>
</li>
<li><p>函数节流：一段时间内只执行一次。</p>
</li>
</ul>
<h3 id="写在最后的话"><a href="#写在最后的话" class="headerlink" title="写在最后的话"></a>写在最后的话</h3><p>很多时候 带着问题来验证结论 更能把自己置身到场景中考虑</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://jinlong.github.io/2016/04/24/Debouncing-and-Throttling-Explained-Through-Examples/">https://jinlong.github.io/2016/04/24/Debouncing-and-Throttling-Explained-Through-Examples/</a><br><a href="https://github.com/hanzichi/underscore-analysis/issues/20">https://github.com/hanzichi/underscore-analysis/issues/20</a><br><a href="https://segmentfault.com/a/1190000008768202">https://segmentfault.com/a/1190000008768202</a></p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>一个页面从输入 url 到加载完成 这个过程发生了什么</title>
    <url>/2019/03/31/urlrender/</url>
    <content><![CDATA[<h4 id="先来了解以下-五层因特尔协议栈"><a href="#先来了解以下-五层因特尔协议栈" class="headerlink" title="先来了解以下 五层因特尔协议栈"></a>先来了解以下 五层因特尔协议栈</h4><ul>
<li>应用层（dns http） DNS 解析成 ip 并完成 http 请求发送</li>
<li>传输层（tcp udp）三次握手四次挥手建立 tcp 链接</li>
<li>网络层 （ip ARP） IP 寻址</li>
<li>数字链路层 将请求数据封装成帧</li>
<li>物理层 利用物理介质传输比特流</li>
</ul>
<a id="more"></a>
<h4 id="简介版本"><a href="#简介版本" class="headerlink" title="简介版本"></a>简介版本</h4><ol>
<li>浏览器根据请求的 url 交给 DNS 解析 找到这真实 IP 向服务器发起请求</li>
<li>服务器交给后台处理完成后返回数据，浏览器接收文件（html,css javascript) 等</li>
<li>浏览器对加载到的资源进行语法解析，构建相应的内部数据结构（Dom 树 css 树 render 树等）</li>
<li>载入解析到的资源文件渲染页面完成</li>
</ol>
<h4 id="详细版本"><a href="#详细版本" class="headerlink" title="详细版本"></a>详细版本</h4><ol>
<li>浏览器开启一个线程来处理这个请求，对 url 进行判断，如果是 http 协议，则就按照 web 的方式来处理</li>
<li>浏览器解析 url，一般我么输入的都是服务器域名，我们会先查找对应的 ip</li>
<li> 首先会查看浏览器的 DNS 缓存，如果存在，则域名解析到此完成</li>
<li>如果浏览器自身的缓存没有找到相应的条目，就会尝试读取操作系统的 host 文件来看时都存在对应的映射关系</li>
<li>如果 host 文件没有，继续查找本地的域名服务器</li>
<li>如果本地的域名服务器还没有找到的话 ，它就会向跟服务器发出请求，进行递归查询</li>
<li>查到了 IP 地址，会将记录存储在本地缓存，此时网络层便会通过 ip 地址寻得对应服务器的物理地址</li>
<li>寻得服务器的地址 客户端在网络传输层便可以和服务器通过三次握手建立 TCPIP 链接 </li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">TCPIP请求</span><br><span class="line"></span><br><span class="line">http的本质就是TCP/IP请求</span><br><span class="line">需要经历三次握手建立链接 4次挥手断开连接</span><br><span class="line">TCP将http长报文划分为短报文，通过三次握手与服务器建立链接进行可靠传输</span><br><span class="line"></span><br><span class="line">三次握手</span><br><span class="line"></span><br><span class="line">1. 客户端：你是XX服务器吗</span><br><span class="line">2. 服务端：我是XX服务器，你是客户端吗？</span><br><span class="line">3. 客户端：是的 我是客户端</span><br><span class="line">成功 </span><br><span class="line"></span><br><span class="line">四次挥手</span><br><span class="line">主动方：我已经关闭了向你那边的信息发送通道，只能被动接受信息了</span><br><span class="line">被动方：收到通道关闭信息</span><br><span class="line">被动方：我现在也关闭了</span><br><span class="line">主动方：收到消息 连接断开 之后双方无法通信</span><br><span class="line"></span><br><span class="line">TCPIP请求：浏览器在同一个域名下并发的TCP链接是有限制的（2-10个）</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<ol start="9">
<li>链接成功后 链路层将请求数据封装成帧</li>
<li>最后物理层通过物理介质进行传输</li>
<li>到了服务器就会通过相反的方式将数据一层一层的还原回去</li>
<li>请求到了后端服务器一般都会有统一的验证 如安全验证，跨域验证等，验证未通过就直接返回相应的 http 报文</li>
<li>验证通过后就会进入后台代码 此时程序收到请求执行相应的操作（如查询数据库等）</li>
<li>如果浏览器访问过 且缓存上有相应的资源便会与服务器最后的修改时间对比，一致便返回 304 告诉浏览器可以使用本地缓存</li>
<li>前端浏览器接收到响应成功的报文便开始下载网页<br>下载完的网页交给浏览器的内核（渲染进程）进行处理 </li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">* 根据顶部定义的DTD类型进行相应的解析方式</span><br><span class="line">* 渲染进程内部是多线程的 网页的解析会被交给内部的GUI渲染进程处理</span><br><span class="line">* 首先渲染进程中的html解释器将html网页和资源从字节流解释转化为字符流</span><br><span class="line">* 再通过词法分析器将字符流解释成词语</span><br><span class="line">* 之后通过语法分析器根据词语构成节点，最后通过这些节点组建一个DOM树</span><br><span class="line">* 这个过程中 如果遇到的DOM节点是js代码，就会调用js引擎对js代码进行解释执行。此时由于js引擎和GUI渲染进程的互斥，GUI渲染就会被挂起，渲染过程停止；如果js代码的运行中对dom树进行了修改，那么都没树的构建需要重新开始</span><br><span class="line">* 如果节点需要依赖其他资源（图片 css）便会调用网络模块的资源去加载它们，但他们是异步的所以不会阻塞当前dom树的构建</span><br><span class="line">* 如果遇到的是js资源url（没有标记异步）则需要停止当前dom的构建 直到js的资源加载并被js引擎执行后才继续构建dom</span><br><span class="line">* 对于css css解释器会将css文件解释成内部表示结构（同html解析 子节流-&gt;字符流-&gt;词语-&gt;节点），生成css规则树</span><br><span class="line">* 然后合并css树和dom树，生成render渲染树</span><br><span class="line">* 最后对render树进行布局和绘制，并将结果通过IO线程传递给Browser控制进程（浏览器主进程）进行显示</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>





]]></content>
  </entry>
  <entry>
    <title>viewports 剖析一</title>
    <url>/2017/08/03/viewports%E5%89%96%E6%9E%90%E4%B8%80/</url>
    <content><![CDATA[<p>因为工作的原因，很少有机会接触移动 web 开发，一直都还挺遗憾的，偶尔写几个页面也都是 “按照套路” 出牌，最近终于有空了解一些概念性的东西，记录一下<br>文中的图片为了说明问题均为<code>盗图</code>，具体出处会在文末注明</p>
<p>本文大概将以下几个概念以做对比</p>
<ul>
<li>PC<ul>
<li><a href="#line1"> <font face="STCAIYUN" size="3" color="blueGreen"> 设备的 pixels 和 CSS 的 pixels</font></a></li>
<li><a href="#line2"> <font face="STCAIYUN" size="3" color="blueGreen"> 所谓的 100% 缩放</font></a></li>
<li><a href="#line3"> <font face="STCAIYUN" size="3" color="blueGreen">屏幕尺寸和浏览器尺寸</font></a></li>
<li><a href="#line4"> <font face="STCAIYUN" size="3" color="blueGreen">页面的滚动移位</font></a></li>
<li><a href="#line5"> <font face="STCAIYUN" size="3" color="blueGreen"> viewport 以及度量 viewport</font></a></li>
<li><a href="#line6"> <font face="STCAIYUN" size="3" color="blueGreen">html 元素以及度量 html</font></a></li>
<li><a href="#line7"> <font face="STCAIYUN" size="3" color="blueGreen"> 关于事件坐标</font></a></li>
<li><a href="#line8"> <font face="STCAIYUN" size="3" color="blueGreen">媒体查询 width/height 与 device-width/height</font></a></li>
</ul>
</li>
<li>mobile<ul>
<li><a href="#line9"> <font face="STCAIYUN" size="3" color="blueGreen">mobile 浏览器</font></a></li>
<li><a href="#line10"> <font face="STCAIYUN" size="3" color="blueGreen">两种 viewport</font></a><ul>
<li><font face="STCAIYUN" size="3" color="red">layoutviewport</font></li>
<li><font face="STCAIYUN" size="3" color="red">visualviewport</font></li>
</ul>
</li>
<li><a href="#line11"> <font face="STCAIYUN" size="3" color="blueGreen"> 缩放 Zooming</font></a></li>
<li><a href="#line12"> <font face="STCAIYUN" size="3" color="blueGreen"> 屏幕尺寸</font></a></li>
<li><a href="#line13"> <font face="STCAIYUN" size="3" color="blueGreen">页面的滚动移位</font></a></li>
<li><a href="#line14"> <font face="STCAIYUN" size="3" color="blueGreen"> html 元素以及度量 html</font></a></li>
<li> <a href="#line15"> <font face="STCAIYUN" size="3" color="blueGreen"> 关于事件坐标</font></a></li>
<li><a href="#line16"> <font face="STCAIYUN" size="3" color="blueGreen">媒体查询 width/height 与 device-width/height</font></a></li>
<li><a href="#line17"> <font face="STCAIYUN" size="3" color="blueGreen">viewport 的 meta 标签</font></a></li>
</ul>
</li>
</ul>
<p id="line1">
<font face="STCAIYUN" color="#883958" size="3">设备的 pixels 和 CSS 的 pixels</font>
</p>
**设备的pixels**
    设备像素是我们直觉上觉得「靠谱」的像素。这些像素为你所使用的各种设备都提供了正规的分辨率
    大多数情况下能从`screen.width/height` 取出具体值
    当然了 设备的pixels对web开发人员几乎毫无用处
    这里只需要知道它的概念即可
**CSS的pixels**
这些就是那些控制你的样式表如何被渲染的像素

<p>现代浏览器上的缩放是基于<code>伸展</code> pixels<br>所以 html 元素上的宽度不会因为你缩放了 200% 而变成了两倍宽，它在形式上还是一倍宽 只不过占用了两倍的设备 pixels<br>如下图 1-1 有 4 个 1pixels，缩放为 100% 的 html 元素 此时 css pixels 和设备的 pixels 完全重合<br><img src="/images/viewports/1.jpg"><br>此时我们如果缩小浏览器 css 的 pixels 开始收缩，导致 1 单位的设备 pixels 上重叠了多个 css 的 pixels 如下图 1-2<br><img src="/images/viewports/2.jpg"><br>如果放大浏览器 css 的 pixels 就会放大 导致 1 单位的 css pixels 上重叠了多个设备 pixels 如图 1-3<br><img src="/images/viewports/3.jpg"><br>总而言之 你只需要关注 CSS 的 pixels 这些 pixels 将指定你的样式被如何渲染<br>就像上面所说的 设备的 pixels 对开发人员无用 但是对用户有用，因为用户回手动缩放页面，这些开发人员不用关注 <font face="STCAIYUN" color="red" size="3">浏览器会自动保证你的 css pixels 会被伸展还是被收缩</font></p>
<p id="line2">
<font face="STCAIYUN" color="#883958" size="3">所谓的 100% 缩放</font>
</p>
<font face="STCAIYUN" color="red" size="3"> 100% 缩放的情况下 1 单位的的 CSS pixels 严格等于 1 单位的设备 pixels</font>
<p id="line3">
<font face="STCAIYUN" color="#883958" size="3"> 屏幕尺寸和浏览器尺寸</font>
</p>
**屏幕尺寸（Screen size）**
含义：用户的屏幕的完整大小
度量：设备的pixels 不会因为缩放而改变 是显示器的特征
对我们来说<font face="STCAIYUN" color="red" size="4">没用</font>
获取方式
如下图1-4
![](/images/viewports/4.jpg)

<p><strong>浏览器尺寸（Window size）</strong><br>含义：包含<code>滚动条尺寸</code>的浏览器完整尺寸<br>度量：CSS pixels<br>浏览器内部尺寸，它定义了当前用户有多大区域。可供你的 css 布局占用<br>如下图 1-5<br><img src="/images/viewports/5.jpg"></p>
<p id="line4">
<font face="STCAIYUN" color="#883958" size="3">页面的滚动移位</font>
</p>
含义：页面的移位
度量：CSS pixels
定义了页面（document）的相对于窗口远点的位移，可以利用这个特性获取用户滚动了多少的滚动条距离
如下图1-6
![](/images/viewports/6.jpg)

<p id="line5">
<font face="STCAIYUN" color="#883958" size="3"> viewport 以及度量 viewport</font>
</p>
**viewport**
啊啊啊 终于提到viewport了 鸡冻
<font face="STCAIYUN" color="red" size="3"> 划重点</font> `viewport`是控制``元素的容器  是``的爹

<p>你发现了么？<br>百分比布局时 你定义的一个侧边栏宽度为 10% 当你改变大小时 它的宽度会自动扩张和收缩  原理是啥<br>当然了 它的宽度是依赖父元素 假如它父元素就是 <code>&lt;body&gt;</code> 那么 <code>&lt;body&gt;</code> 多宽？<br>向上类推 <code>&lt;body&gt;</code> 的宽度取决于它的父元素 <code>&lt;html&gt;</code><br>呃.. 废话好多 <code>&lt;html&gt;</code> 宽度取决于它的父元素<br> <code>&lt;html&gt;</code> 恰好等于浏览器的宽度 所以你的 10% 会占用浏览器宽度的 10% 我们都是这么用的  今天深扒发现<br><code>&lt;html&gt;</code> 宽度受 <code>viewport</code> 限制 ，等于 <code>viewport</code> 宽度的 100%<br>也就是说<br><code>viewport</code> 严格等于浏览器窗口<br>需要注意的是：<code>viewport</code> 不是一个 html 的概念 所以不能通过 CSS 修改它</p>
<p><strong>真实页面宽度概念</strong><br>如果你放大页面几倍 如何标识页面宽度（此时已经有横向滚动条了，也就是说页面的内容溢出了 <code>&lt;html&gt;</code> 元素）<br>使用 document width<br>如图 1-7<br><img src="/images/viewports/7.jpg"><br>如图 1-8<br><img src="/images/viewports/8.jpg"><br><strong>度量 viewport</strong><br>含义：viewport 尺寸<br>度量：CSS pixels<br>如下图 1-9<br><img src="/images/viewports/9.jpg"><br>document.documentElement 代表<font face="STCAIYUN" color="red" size="3"> HTML 文档根元素</font><code>&lt;html&gt;</code><br>来 先看张图<br><img src="/images/viewports/10.jpg"><br>这张图是在为 <code>&lt;html&gt;</code> 元素赋值 25% 但是 <code>document.documentElement.clientWidth</code> 值仍然不变<br>说明<font face="STCAIYUN" color="red" size="3"> document. documentElement. clientWidth/Height 只会给出 viewport 的尺寸，而不管元素尺寸如何改变</font><br><font face="STCAIYUN" color="#886" size="4">那么问题来了</font><br>我是不是也可以用 <code>window.innerWidth</code> 来定义 <code>viewport</code><br>呃.<br>他与 <code>document.documentElement.clientWidth</code> 有一点细微的差别<br>前者不包含滚动条</p>
<p id="line6">
<font face="STCAIYUN" color="#883958" size="3">html 元素以及度量 html</font>
</p>
**html**
ta爹(`viewport`)如果`document.documentElement.clientWidth`表示那么``这样获取 `document.documentElement.offsetWidth`
![](/images/viewports/11.jpg)
如果给``元素赋值了宽度 那么`offsetWidth`就会真实的反映出来


<p><img src="/images/viewports/12.jpg"></p>
<p id="line7">
<font face="STCAIYUN" color="#883958" size="3"> 关于事件坐标</font>
</p>
**pageX/Y, clientX/Y, screenX/Y**

<ul>
<li> pageX/Y：从原点到事件触发点的 CSS 的 pixels</li>
<li>clientX/Y：从 viewport 原点（浏览器窗口）到事件触发点的 CSS 的 pixels</li>
<li>screenX/Y：从用户显示器窗口原点到事件触发点的设备 的 pixels。<br>上图<br><img src="/images/viewports/13.jpg"><br><img src="/images/viewports/14.jpg"><br><img src="/images/viewports/15.jpg"></li>
</ul>
<p id="line8">
<font face="STCAIYUN" color="#883958" size="3">媒体查询 width/height 与 device-width/height</font>
</p>
* `device-width/height`使用`screen.width/height`来做为的判定值。该值以设备的pixels来度量
* `width/height`使用`documentElement.clientWidth/Height`即viewport的值。该值以CSS的pixels来度量
![](/images/viewports/16.jpg)
桌面浏览器上使用<font face="STCAIYUN" color="red" size="4">width</font>
<p id="line9">
<font face="STCAIYUN" color="#883958" size="3">mobile 浏览器</font>
</p>
移动设备的屏幕宽度比桌面浏览器小（好多废话.）
试想一下 如果我们只是copy桌面的样式到移动设备 该有多丑
如下图
移动设备浏览器在初始默认打开以最小缩放模式打开网站。（即在手机屏幕上展示完整宽度的页面）

<p><img src="/images/viewports/viewport-21.jpg"></p>
<p><font face="STCAIYUN" color="#285853" size="3">假设当前设备的宽度是 400px 还是之前说过的 10% 侧边栏，如果移动设备上做同样的处理，会显示 40px 的宽 太窄了，布局会变得非常可怕</font><br>那么 如何处理？</p>
<p id="line10">
<font face="STCAIYUN" color="#883958" size="3">两种 viewport</font></p>
因为viewport太窄，最显然的解决方式就是将它变宽
由此 引出了 虚拟视口  （`viewportvisualviewport`） 与      布局视口（`viewportlayoutviewport`）
关于它们 有一个很好的解释

<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">  想象一下viewportlayoutviewport是一张大的不能改变大小和角度的图片 现在你有个更小的框来观看这张大图片</span><br><span class="line">这个框被不透明的材料包围 因而你只能看到大图片的一部分 你通过这个框子看到的大图片的那部分就叫做虚拟视口（viewportvisualviewport）</span><br><span class="line"></span><br><span class="line">你拿着这个框拿着站的离大图原点（用户的缩小页面功能）以一次性看到这个大图片</span><br><span class="line">你站的离的近一点（用户的放大页面功能）以看到一部分</span><br><span class="line">你能改变这个框框的远近 但是这张大图片的大小和形状都不会改变</span><br></pre></td></tr></tbody></table></figure>
<p>visualviewport 是当前显示在屏幕上的部分页面。用户会滚动页面来改变可见部分，或者缩放浏览器来改变 visualviewport 的尺寸。<br>如下图<br><img src="/images/viewports/20.jpg"><br>但是 CSS 布局 通常是按照<font face="STCAIYUN" color="red" size="3"> layoutviewport 定义的，这要比 visualviewport 宽很多</font></p>
元素的宽度继承于layoutviewport
<p id="line11">
<font face="STCAIYUN" color="#883958" size="3">缩放 Zooming</font>
</p>
两种viewports都以CSS的 pixels来度量。当你通过缩放改变visualviewport时，layoutviewport保存不变。
<p id="line12">
<font face="STCAIYUN" color="#883958" size="3"> 屏幕尺寸</font>
</p>
**理解layout viewport**
许多移动设备浏览器在初始默认打开以最小缩放模式打开网站（也就是在手机屏幕上展示完整宽度的页面）

<p><img src="/images/viewports/21.jpg"><br>此时浏览器已经选择好他们的 layoutviewport 的尺寸 它完整覆盖了最小缩放模式下的移动浏览器的屏幕，这个时候 layoutviewport 的宽度高度和最小缩放模式下能在页面上显示的内容的宽度和高度一致。<br><br><br><font face="STCAIYUN" color="red" size="3">那么移动端如何计算 layoutviewport 的尺寸？</font><br><code>document. documentElement. clientWidth/Height</code></p>
<p><img src="/images/viewports/25.jpg"><br><strong>理解 visual viewport</strong><br><font face="STCAIYUN" color="red" size="3">那么移动端如何计算 visualviewport 的尺寸？</font><br><code>window.innerWidth/Height</code> 随着用户的缩放浏览器 值会改变 更多 更少的 CSS pixels 放进了屏幕<br><img src="/images/viewports/27.jpg"><br><strong>屏幕尺寸 screen</strong><br>和 pc 浏览器一样 screen.width/height 标示了设置屏幕的尺寸 以设备的 pixels 显然 这跟开发人员没有什么关系</p>
<p id="line13">
<font face="STCAIYUN" color="#883958" size="3">页面的滚动移位</font>
</p>
你同样需要知道当前的虚拟视口相对于布局视口的距离 这叫做`滚动位移` ，它像在pc端获取一样
使用**window.pageX/YOffset**

<p><img src="/images/viewports/29.jpg"></p>
<p id="line14">
<font face="STCAIYUN" color="#883958" size="3"> html 元素以及度量 html</font>
</p>
html元素的整体尺寸，和pc端一致 使用`document.documentElement.offsetWidth/Height`，元素以CSS pixels度量

<p><img src="/images/viewports/30.jpg"></p>
<p id="line15">
<font face="STCAIYUN" color="#883958" size="3"> 关于事件坐标</font>
</p>
同pc浏览器 只需要关注 pageX/Y

<p><img src="/images/viewports/32.jpg"></p>
<p id="line16">
<font face="STCAIYUN" color="#883958" size="3">媒体查询 width/height 与 device-width/height</font>
</p>
也如同pc浏览器
 `width/height `使用css的pixels度量layoutviewport 即`document. documentElement. clientWidth/Height `
`device-width/height  `使用设备的pixels 即 `screen.width/height. `
所有浏览器都遵循这个原理
<p id="line17">
<font face="STCAIYUN" color="#883958" size="3">viewport 的 meta 标签 </font>
</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;meta name="viewport" content="width=320"&gt;</span><br></pre></td></tr></tbody></table></figure>
最初这是apple的一个html扩展标签，被很多浏览器复用
设置 `虚拟视口`的宽度

<p>假设你现在创建一个页面  并不为它设置宽度 那么它会伸展开来占据 100% 的 viewlayout 的宽度 绝大多数浏览器缩小这个页面在一屏的宽度上显示这个 layoutviewport</p>
<p><img src="/images/viewports/33.jpg"><br>当用户放大页面  绝大多数会保存元素的宽度（保持元素的定位不变）而导致文字超出屏幕<br><img src="/images/viewports/34.jpg"><br>当你设置</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;meta name="viewport" content="width=320"&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>你网站的 layoutviewport 变成了 320px。页面的初始状态就很正确了<br><img src="/images/viewports/36.jpg"></p>
<ul>
<li>Part1:<a href="http://www.quirksmode.org/mobile/viewports.html">http://www.quirksmode.org/mobile/viewports.html</a></li>
<li>Part2:<a href="http://www.quirksmode.org/mobile/viewports2.html">http://www.quirksmode.org/mobile/viewports2.html</a></li>
</ul>
]]></content>
      <tags>
        <tag>mobile</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 开发中小技巧</title>
    <url>/2019/10/24/vue/</url>
    <content><![CDATA[<p>记录日常开发中不常用的一些小技巧</p>
<h1 id="require-context"><a href="#require-context" class="headerlink" title="require.context()"></a>require.context()</h1><p>1. 场景：如页面需要导入多个组件，原始写法:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">import titleCom from '@/components/home/titleCom'</span><br><span class="line">import bannerCom from '@/components/home/bannerCom'</span><br><span class="line">import cellCom from '@/components/home/cellCom'</span><br><span class="line">components:{titleCom,bannerCom,cellCom}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>2. 这样就写了大量重复的代码，利用 require.context 可以写成</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const path = require('path')</span><br><span class="line">const files = require.context('@/components/home', false, /\.vue$/)</span><br><span class="line">const modules = {}</span><br><span class="line">files.keys().forEach(key =&gt; {</span><br><span class="line">  const name = path.basename(key, '.vue')</span><br><span class="line">  modules[name] = files(key).default || files(key)</span><br><span class="line">})</span><br><span class="line">components:modules</span><br></pre></td></tr></tbody></table></figure>
<p>API 方法</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">实际上是 webpack 的方法,vue 工程一般基于 webpack,所以可以使用</span><br><span class="line">require.context(directory,useSubdirectories,regExp)</span><br><span class="line">接收三个参数:</span><br><span class="line">directory：说明需要检索的目录</span><br><span class="line">useSubdirectories：是否检索子目录</span><br><span class="line">regExp: 匹配文件的正则表达式,一般是文件名</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<a id="more"></a>
<h1 id="watch用法"><a href="#watch用法" class="headerlink" title="watch用法"></a>watch 用法</h1><h2 id="常用用法"><a href="#常用用法" class="headerlink" title="常用用法"></a>常用用法</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">created(){</span><br><span class="line">  this.getList()</span><br><span class="line">},</span><br><span class="line">watch: {</span><br><span class="line">  inpVal(){</span><br><span class="line">    this.getList()</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="立即执行"><a href="#立即执行" class="headerlink" title="立即执行"></a>立即执行</h2><p>可以直接利用 watch 的 immediate 和 handler 属性简写</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">watch: {</span><br><span class="line">  inpVal:{</span><br><span class="line">    handler: 'getList',</span><br><span class="line">      immediate: true</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="深度监听"><a href="#深度监听" class="headerlink" title="深度监听"></a>深度监听</h2><p>watch 的 deep 属性，深度监听，也就是监听复杂数据类型</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">watch:{</span><br><span class="line">  inpValObj:{</span><br><span class="line">    handler(newVal,oldVal){</span><br><span class="line">      console.log(newVal)</span><br><span class="line">      console.log(oldVal)</span><br><span class="line">    },</span><br><span class="line">    deep:true</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h1 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h1><h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 数组:不建议使用</span><br><span class="line">props:[]</span><br><span class="line"></span><br><span class="line">// 对象</span><br><span class="line">props:{</span><br><span class="line"> inpVal:{</span><br><span class="line">  type:Number, //传入值限定类型</span><br><span class="line">  // type 值可为String,Number,Boolean,Array,Object,Date,Function,Symbol</span><br><span class="line">  // type 还可以是一个自定义的构造函数，并且通过 instanceof 来进行检查确认</span><br><span class="line">  required: true, //是否必传</span><br><span class="line">  default:200,  //默认值,对象或数组默认值必须从一个工厂函数获取如 default:()=&gt;[]</span><br><span class="line">  validator:(value) {</span><br><span class="line">    // 这个值必须匹配下列字符串中的一个</span><br><span class="line">    return ['success', 'warning', 'danger'].indexOf(value) !== -1</span><br><span class="line">  }</span><br><span class="line"> }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h1 id="Attr和listeners"><a href="#Attr和listeners" class="headerlink" title="Attr和listeners"></a>Attr 和 listeners</h1><h2 id="attrs"><a href="#attrs" class="headerlink" title="attrs"></a>attrs</h2><p>场景：如果父传子有很多值，那么在子组件需要定义多个 props</p>
<p>attrs 获取未在 props 定义的值</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;home title="这是标题" width="80" height="80" imgUrl="imgUrl"/&gt;</span><br><span class="line"></span><br><span class="line">// 子组件</span><br><span class="line">mounted() {</span><br><span class="line">  console.log(this.$attrs) //{title: "这是标题", width: "80", height: "80", imgUrl: "imgUrl"}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>相对应的如果子组件定义了 props, 打印的值就是剔除定义的属性</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">props: {</span><br><span class="line">  width: {</span><br><span class="line">    type: String,</span><br><span class="line">    default: ''</span><br><span class="line">  }</span><br><span class="line">},</span><br><span class="line">mounted() {</span><br><span class="line">  console.log(this.$attrs) //{title: "这是标题", height: "80", imgUrl: "imgUrl"}</span><br><span class="line">},</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="listeners场景"><a href="#listeners场景" class="headerlink" title="listeners场景"></a>listeners 场景</h2><p>子组件内需要调用父组件的方法解决：<br>父组件的方法可以通过 v-on=”listeners” 传入内部组件</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;home @change="change"/&gt;</span><br><span class="line"></span><br><span class="line">// 子组件</span><br><span class="line">mounted() {</span><br><span class="line">  console.log(this.$listeners) //即可拿到 change 事件</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="root"><a href="#root" class="headerlink" title="$root"></a>$root</h1><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">mounted(){</span><br><span class="line">  console.log(this.$root) //获取根实例,最后所有组件都是挂载到根实例上</span><br><span class="line">  console.log(this.$root.$children[0]) //获取根实例的一级子组件</span><br><span class="line">  console.log(this.$root.$children[0].$children[0]) //获取根实例的二级子组件</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h1 id="sync"><a href="#sync" class="headerlink" title=".sync"></a>.sync</h1><p>在 <a href="mailto:vue@1.x">vue@1.x</a> 的时候曾作为双向绑定功能存在，即子组件可以修改父组件中的值；在 <a href="mailto:vue@2.0">vue@2.0</a> 的由于违背单项数据流的设计被干掉了；在 <a href="mailto:vue@2.3.0">vue@2.3.0</a>+ 以上版本又重新引入了这个 .sync 修饰符；</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;home :title.sync="title" /&gt;</span><br><span class="line">//编译时会被扩展为</span><br><span class="line">&lt;home :title="title"  @update:title="val =&gt; title = val"/&gt;</span><br><span class="line"></span><br><span class="line">// 子组件</span><br><span class="line">// 所以子组件可以通过$emit 触发 update 方法改变</span><br><span class="line">mounted(){</span><br><span class="line">  this.$emit("update:title", '这是新的title')</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="路由传参方案"><a href="#路由传参方案" class="headerlink" title="路由传参方案"></a>路由传参方案</h1><p>方案一</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 路由定义</span><br><span class="line">{</span><br><span class="line">  path: '/describe/:id',</span><br><span class="line">  name: 'Describe',</span><br><span class="line">  component: Describe</span><br><span class="line">}</span><br><span class="line">// 页面传参</span><br><span class="line">this.$router.push({</span><br><span class="line">  path: `/describe/${id}`,</span><br><span class="line">})</span><br><span class="line">// 页面获取</span><br><span class="line">this.$route.params.id</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>方案二</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 路由定义</span><br><span class="line">{</span><br><span class="line">  path: '/describe',</span><br><span class="line">  name: 'Describe',</span><br><span class="line">  omponent: Describe</span><br><span class="line">}</span><br><span class="line">// 页面传参</span><br><span class="line">this.$router.push({</span><br><span class="line">  name: 'Describe',</span><br><span class="line">  params: {</span><br><span class="line">    id: id</span><br><span class="line">  }</span><br><span class="line">})</span><br><span class="line">// 页面获取</span><br><span class="line">this.$route.params.id</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>方案三</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 路由定义</span><br><span class="line">{</span><br><span class="line">  path: '/describe',</span><br><span class="line">  name: 'Describe',</span><br><span class="line">  component: Describe</span><br><span class="line">}</span><br><span class="line">// 页面传参</span><br><span class="line">this.$router.push({</span><br><span class="line">  path: '/describe',</span><br><span class="line">    query: {</span><br><span class="line">      id: id</span><br><span class="line">  `}</span><br><span class="line">)</span><br><span class="line">// 页面获取</span><br><span class="line">this.$route.query.id</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>三种方案对比 方案二参数不会拼接在路由后面，页面刷新参数会丢失 方案一和三参数拼接在后面，丑，而且暴露了信息</p>
<h1 id="render函数"><a href="#render函数" class="headerlink" title="render函数"></a>render 函数</h1><p>场景：有些代码在 template 里面写会重复很多，所以这个时候 render 函数就有作用啦</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 根据 props 生成标签</span><br><span class="line">// 初级</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div v-if="level === 1"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;</span><br><span class="line">    &lt;p v-else-if="level === 2"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/p&gt;</span><br><span class="line">    &lt;h1 v-else-if="level === 3"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h1&gt;</span><br><span class="line">    &lt;h2 v-else-if="level === 4"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h2&gt;</span><br><span class="line">    &lt;strong v-else-if="level === 5"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/stong&gt;</span><br><span class="line">    &lt;textarea v-else-if="level === 6"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/textarea&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">// 优化版,利用 render 函数减小了代码重复率</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;child :level="level"&gt;Hello world!&lt;/child&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type='text/javascript'&gt;</span><br><span class="line">  import Vue from 'vue'</span><br><span class="line">  Vue.component('child', {</span><br><span class="line">    render(h) {</span><br><span class="line">      const tag = ['div', 'p', 'strong', 'h1', 'h2', 'textarea'][this.level-1]</span><br><span class="line">      return h(tag, this.$slots.default)</span><br><span class="line">    },</span><br><span class="line">    props: {</span><br><span class="line">      level: {  type: Number,  required: true  } </span><br><span class="line">    }</span><br><span class="line">  })   </span><br><span class="line">  export default {</span><br><span class="line">    name: 'hehe',</span><br><span class="line">    data() { return { level: 3 } }</span><br><span class="line">  }</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>2.render 和 template 的对比 前者适合复杂逻辑，后者适合逻辑简单；后者属于声明是渲染，前者属于自定 Render 函数；前者的性能较高，后者性能较低。</p>
<h1 id="路由的按需加载"><a href="#路由的按需加载" class="headerlink" title="路由的按需加载"></a>路由的按需加载</h1><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">webpack&lt; 2.4 时</span><br><span class="line">{</span><br><span class="line">  path:'/',</span><br><span class="line">  name:'home',</span><br><span class="line">  components:resolve=&gt;require(['@/components/home'],resolve)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">webpack&gt; 2.4 时</span><br><span class="line">{</span><br><span class="line">  path:'/',</span><br><span class="line">  name:'home',</span><br><span class="line">  components:()=&gt;import('@/components/home')</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">import()方法由es6提出，import()方法是动态加载，返回一个Promise对象，then方法的参数是加载到的模块。类似于Node.js的require方法，主要import()方法是异步加载的。</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h1 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h1><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;component v-bind:is="currentTabComponent"&gt;&lt;/component&gt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>但是这样每次组件都会重新加载，会消耗大量性能，所以 就起到了作用</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">  &lt;component v-bind:is="currentTabComponent"&gt;&lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>这样切换效果没有动画效果，这个也不用着急，可以利用内置的</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;transition&gt;</span><br><span class="line">&lt;keep-alive&gt;</span><br><span class="line">  &lt;component v-bind:is="currentTabComponent"&gt;&lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></tbody></table></figure>
<h1 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h1><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;template functional&gt;</span><br><span class="line">  &lt;div v-for="(item,index) in props.arr"&gt;{{item}}&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></tbody></table></figure>
<h1 id="mixins"><a href="#mixins" class="headerlink" title="mixins"></a>mixins</h1><p>场景：有些组件有些重复的 js 逻辑，如校验手机验证码，解析时间等，mixins 就可以实现这种混入 mixins 值是一个数组</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const mixin={</span><br><span class="line">    created(){</span><br><span class="line">      this.dealTime()</span><br><span class="line">    },</span><br><span class="line">    methods:{</span><br><span class="line">      dealTime(){</span><br><span class="line">        console.log('这是mixin的dealTime里面的方法');</span><br><span class="line">      }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">export default{</span><br><span class="line">  mixins:[mixin]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="Vue-nextTick"><a href="#Vue-nextTick" class="headerlink" title="Vue.nextTick"></a>Vue.nextTick</h1><p>2.1.0 新增 场景：页面加载时需要让文本框获取焦点 用法：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">mounted(){ //因为 mounted 阶段 dom 并未渲染完毕,所以需要$nextTick</span><br><span class="line">  this.$nextTick(() =&gt; {</span><br><span class="line">    this.$refs.inputs.focus() //通过 $refs 获取dom 并绑定 focus 方法</span><br><span class="line">  })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="Vue-version"><a href="#Vue-version" class="headerlink" title="Vue.version"></a>Vue.version</h1><p>场景：有些开发插件需要针对不同 vue 版本做兼容，所以就会用到 Vue.version 用法：Vue.version () 可以获取 vue 版本</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var version = Number(Vue.version.split('.')[0])</span><br><span class="line"></span><br><span class="line">if (version === 2) {</span><br><span class="line">  // Vue v2.x.x</span><br><span class="line">} else if (version === 1) {</span><br><span class="line">  // Vue v1.x.x</span><br><span class="line">} else {</span><br><span class="line">  // Unsupported versions of Vue</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h1 id="Vue-config-performance"><a href="#Vue-config-performance" class="headerlink" title="Vue.config.performance"></a>Vue.config.performance</h1><p>监听性能</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Vue.config.performance = true</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h1 id="Vue-config-warnHandler"><a href="#Vue-config-warnHandler" class="headerlink" title="Vue.config.warnHandler"></a>Vue.config.warnHandler</h1><p>2.4.0 新增 1. 场景：为 Vue 的运行时警告赋予一个自定义处理函数，只会在开发者环境下生效 2. 用法:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Vue.config.warnHandler = function (msg, vm, trace) {</span><br><span class="line">  // `trace` 是组件的继承关系追踪</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="v-pre"><a href="#v-pre" class="headerlink" title="v-pre"></a>v-pre</h1><p>场景:vue 是响应式系统，但是有些静态的标签不需要多次编译，这样可以节省性能</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;span v-pre&gt;{{ this will not be compiled }}&lt;/span&gt;   显示的是{{ this will not be compiled }}</span><br><span class="line">&lt;span v-pre&gt;{{msg}}&lt;/span&gt;&nbsp; &nbsp; &nbsp;即使data里面定义了msg这里仍然是显示的{{msg}}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h1><p>场景：在网速慢的情况下，在使用 vue 绑定数据的时候，渲染页面时会出现变量闪烁<br>用法：这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 [v-cloak] { display: none } 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// template 中</span><br><span class="line">&lt;div class="#app" v-cloak&gt;</span><br><span class="line">    &lt;p&gt;{{value.name}}&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">// css 中</span><br><span class="line">[v-cloak] {</span><br><span class="line">    display: none;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这样就可以解决闪烁，但是会出现白屏，这样可以结合骨架屏使用</p>
<h1 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h1><p>场景：有些 template 中的静态 dom 没有改变，这时就只需要渲染一次，可以降低性能开销</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;span v-once&gt; 这时只需要加载一次的标签&lt;/span&gt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>v-once 和 v-pre 的区别: v-once 只渲染一次；v-pre 不编译，原样输出</p>
<h1 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h1><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">.stop:阻止冒泡</span><br><span class="line">.prevent:阻止默认行为</span><br><span class="line">.self:仅绑定元素自身触发</span><br><span class="line">.once: 2.1.4 新增,只触发一次</span><br><span class="line">.passive: 2.3.0 新增,滚动事件的默认行为 (即滚动行为) 将会立即触发,不能和.prevent 一起使用</span><br></pre></td></tr></tbody></table></figure>
<h1 id="Vue-router"><a href="#Vue-router" class="headerlink" title="Vue.$router"></a>Vue.$router</h1><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">this.$router.push():跳转到不同的url，但这个方法回向history栈添加一个记录，点击后退会返回到上一个页面</span><br><span class="line">this.$router.replace():不会有记录</span><br><span class="line">this.$router.go(n):n可为正数可为负数。正数返回上一个页面,类似 window.history.go(n)</span><br></pre></td></tr></tbody></table></figure>
<h1 id="Vue-route"><a href="#Vue-route" class="headerlink" title="Vue.$route"></a>Vue.$route</h1><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">this.$route.params.id:获取通过 params 或/:id传参的参数</span><br><span class="line">this.$route.query.id:获取通过 query 传参的参数</span><br></pre></td></tr></tbody></table></figure>
<h1 id="调试-template"><a href="#调试-template" class="headerlink" title="调试 template"></a>调试 template</h1><p>场景：在 Vue 开发过程中，经常会遇到 template 模板渲染时 JavaScript 变量出错的问题，此时也许你会通过 console.log 来进行调试 这时可以在开发环境挂载一个 log 函数</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// main.js</span><br><span class="line">Vue.prototype.$log = window.console.log;</span><br><span class="line"></span><br><span class="line">// 组件内部</span><br><span class="line">&lt;div&gt;{{$log(info)}}&lt;/div&gt;</span><br></pre></td></tr></tbody></table></figure>

<h1 id="vue-loader-小技巧"><a href="#vue-loader-小技巧" class="headerlink" title="vue-loader 小技巧"></a>vue-loader 小技巧</h1><h2 id="preserveWhitespace"><a href="#preserveWhitespace" class="headerlink" title="preserveWhitespace"></a>preserveWhitespace</h2><p>场景：开发 vue 代码一般会有空格，这个时候打包压缩如果不去掉空格会加大包的体积 配置 preserveWhitespace 可以减小包的体积</p>
<p>{<br>  vue: {<br>    preserveWhitespace: false<br>  }<br>}</p>
<h2 id="transformToRequire"><a href="#transformToRequire" class="headerlink" title="transformToRequire"></a>transformToRequire</h2><p>场景：以前在写 Vue 的时候经常会写到这样的代码：把图片提前 require 传给一个变量再传给组件</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// page 代码</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;avatar :img-src="imgSrc"&gt;&lt;/avatar&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default {</span><br><span class="line">    created () {</span><br><span class="line">      this.imgSrc = require('./assets/default-avatar.png')</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>现在：通过配置 transformToRequire 后，就可以直接配置，这样 vue-loader 会把对应的属性自动 require 之后传给组件</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// vue-cli 2.x在vue-loader.conf.js 默认配置是</span><br><span class="line">transformToRequire: {</span><br><span class="line">    video: ['src', 'poster'],</span><br><span class="line">    source: 'src',</span><br><span class="line">    img: 'src',</span><br><span class="line">    image: 'xlink:href'</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 配置文件,如果是vue-cli2.x 在vue-loader.conf.js里面修改</span><br><span class="line">  avatar: ['default-src']</span><br><span class="line"></span><br><span class="line">// vue-cli 3.x 在vue.config.js</span><br><span class="line">// vue-cli 3.x 将transformToRequire属性换为了transformAssetUrls</span><br><span class="line">module.exports = {</span><br><span class="line">  pages,</span><br><span class="line">  chainWebpack: config =&gt; {</span><br><span class="line">    config</span><br><span class="line">      .module</span><br><span class="line">        .rule('vue')</span><br><span class="line">        .use('vue-loader')</span><br><span class="line">        .loader('vue-loader')</span><br><span class="line">        .tap(options =&gt; {</span><br><span class="line">      options.transformAssetUrls = {</span><br><span class="line">        avatar: 'img-src',</span><br><span class="line">      }</span><br><span class="line">      return options;</span><br><span class="line">      });</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// page 代码可以简化为</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;avatar img-src="./assets/default-avatar.png"&gt;&lt;/avatar&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></tbody></table></figure>
<h1 id="为路径设置别名"><a href="#为路径设置别名" class="headerlink" title="为路径设置别名"></a>为路径设置别名</h1><p>1. 场景：在开发过程中，我们经常需要引入各种文件，如图片、CSS、JS 等，为了避免写很长的相对路径（../），我们可以为不同的目录配置一个别名</p>
<p>2.vue-cli 2.x 配置</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 在 webpack.base.config.js中的 resolve 配置项，在其 alias 中增加别名</span><br><span class="line">resolve: {</span><br><span class="line">    extensions: ['.js', '.vue', '.json'],</span><br><span class="line">    alias: {</span><br><span class="line">      'vue$': 'vue/dist/vue.esm.js',</span><br><span class="line">      '@': resolve('src'),</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>3.vue-cli 3.x 配置</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 在根目录下创建vue.config.js</span><br><span class="line">var path = require('path')</span><br><span class="line">function resolve (dir) {</span><br><span class="line">  console.log(__dirname)</span><br><span class="line">  return path.join(__dirname, dir)</span><br><span class="line">}</span><br><span class="line">module.exports = {</span><br><span class="line">  chainWebpack: config =&gt; {</span><br><span class="line">    config.resolve.alias</span><br><span class="line">      .set(key, value) // key,value自行定义，比如.set('@@', resolve('src/components'))</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="img-加载失败"><a href="#img-加载失败" class="headerlink" title="img 加载失败"></a>img 加载失败</h1><p>场景：有些时候后台返回图片地址不一定能打开，所以这个时候应该加一张默认图片</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// page 代码</span><br><span class="line">&lt;img :src="imgUrl" @error="handleError" alt=""&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default{</span><br><span class="line">  data(){</span><br><span class="line">    return{</span><br><span class="line">      imgUrl:''</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">  methods:{</span><br><span class="line">    handleError(e){</span><br><span class="line">      e.target.src=reqiure('图片路径') //当然如果项目配置了transformToRequire,参考上面 27.2</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="局部样式"><a href="#局部样式" class="headerlink" title="局部样式"></a>局部样式</h2><p>1.Vue 中 style 标签的 scoped 属性表示它的样式只作用于当前模块，是样式私有化.</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 原始代码</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class="demo"&gt;</span><br><span class="line">    &lt;span class="content"&gt;</span><br><span class="line">      Vue.js scoped</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang="less" scoped&gt;</span><br><span class="line">  .demo{</span><br><span class="line">    font-size: 16px;</span><br><span class="line">    .content{</span><br><span class="line">      color: red;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">// 浏览器渲染效果</span><br><span class="line">&lt;div data-v-fed36922&gt;</span><br><span class="line">  Vue.js scoped</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;style type="text/css"&gt;</span><br><span class="line">.demo[data-v-039c5b43] {</span><br><span class="line">  font-size: 14px;</span><br><span class="line">}</span><br><span class="line">.demo .content[data-v-039c5b43] { //.demo 上并没有加 data 属性</span><br><span class="line">  color: red;</span><br><span class="line">}</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="deep-属性"><a href="#deep-属性" class="headerlink" title="deep 属性"></a>deep 属性</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 上面样式加一个 /deep/</span><br><span class="line">&lt;style lang="less" scoped&gt;</span><br><span class="line">  .demo{</span><br><span class="line">    font-size: 14px;</span><br><span class="line">  }</span><br><span class="line">  .demo /deep/ .content{</span><br><span class="line">    color: blue;</span><br><span class="line">  }</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">// 浏览器编译后</span><br><span class="line">&lt;style type="text/css"&gt;</span><br><span class="line">.demo[data-v-039c5b43] {</span><br><span class="line">  font-size: 14px;</span><br><span class="line">}</span><br><span class="line">.demo[data-v-039c5b43] .content {</span><br><span class="line">  color: blue;</span><br><span class="line">}</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>




























]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>不要再问关于缓存的问题了</title>
    <url>/2019/01/21/%E4%B8%8D%E8%A6%81%E5%86%8D%E9%97%AE%E5%85%B3%E4%BA%8E%E7%BC%93%E5%AD%98%E7%9A%84%E9%97%AE%E9%A2%98%E4%BA%86/</url>
    <content><![CDATA[<p>背景：<br>前端 er 需要关注的点，<code>缓存</code><br>它在移动端上尤其严重，因为手机随时随地会缓存你的资源，要想清缓存，不像 PC 使用强制刷新，还要手动找到浏览器的缓存，有时候还要重启等<br>所以 用实践理解缓存机制 写下此文记录</p>
<p>为了对比理解本文会涉及到</p>
<ul>
<li>DNS 缓存</li>
<li> CDN 缓存</li>
<li>浏览器缓存 (HTTP 缓存)</li>
</ul>
<hr>
<a id="more"></a>
<h2 id="先梳理以下web缓存的优缺点"><a href="#先梳理以下web缓存的优缺点" class="headerlink" title="先梳理以下web缓存的优缺点"></a>先梳理以下 web 缓存的优缺点</h2><h3 id="缓存的优势"><a href="#缓存的优势" class="headerlink" title="缓存的优势"></a>缓存的优势</h3><ul>
<li>减少网络延迟 加快页面打开速度</li>
<li>降低服务器压力</li>
</ul>
<h3 id="缓存的缺点"><a href="#缓存的缺点" class="headerlink" title="缓存的缺点"></a>缓存的缺点</h3><ul>
<li>缓存没有清理机制（时间一长 当你不需要浏览之前的这些网页，他们就变成了无用文件）</li>
<li>给开发带来困扰</li>
</ul>
<h2 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS 缓存</h2><h3 id="什么是DNS？"><a href="#什么是DNS？" class="headerlink" title="什么是DNS？"></a>什么是 DNS？</h3><p>全称 <code>Domain Name System</code> 域名解析系统</p>
<hr>
<p>万维网上作为域名和 IP 地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的 IP 数串。DNS 协议运行在 UDP 协议之上，使用端口号 53。</p>
<hr>
<h3 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS 解析</h3><p>简单的说，通过域名，最终得到该域名对应的 IP 地址的过程叫做域名解析（或主机名解析）</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">www.dnscache.com (域名)  - DNS解析 -&gt; 11.222.33.444 (IP地址)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="DNS缓存-1"><a href="#DNS缓存-1" class="headerlink" title="DNS缓存"></a>DNS 缓存</h3><p>有 DNS 的地方，就有缓存。浏览器、操作系统、Local DNS、根域名服务器，它们都会对 DNS 结果做一定程度的缓存。</p>
<hr>
<h3 id="DNS查询过程"><a href="#DNS查询过程" class="headerlink" title="DNS查询过程"></a>DNS 查询过程</h3><hr>
<ol>
<li>首先搜索浏览器自身的 DNS 缓存，如果存在，则域名解析到此完成。</li>
<li>如果浏览器自身的缓存里面没有找到对应的条目，那么会尝试读取操作系统的 hosts 文件看是否存在对应的映射关系，如果存在，则域名解析到此完成。</li>
<li>如果本地 hosts 文件不存在映射关系，则查找本地 DNS 服务器 (ISP 服务器，或者自己手动设置的 DNS 服务器), 如果存在，域名到此解析完成。</li>
<li>如果本地 DNS 服务器还没找到的话，它就会向根服务器发出请求，进行递归查询。</li>
</ol>
<h2 id="CDN缓存"><a href="#CDN缓存" class="headerlink" title="CDN缓存"></a>CDN 缓存</h2><h3 id="什么是CDN？"><a href="#什么是CDN？" class="headerlink" title="什么是CDN？"></a>什么是 CDN？</h3><p>全称 Content Delivery Network, 即内容分发网络。<br>类似于火车站代售点 这样儿 乘客不用再去售票大厅去排队买票 减轻了售票大厅的压力（起到分流作用，减轻服务器负载压力）</p>
<hr>
<p>用户在浏览网站的时候，<code>CDN</code> 会选择一个离用户最近的 CDN 边缘节点来响应用户的请求，这样海南移动用户的请求就不会千里迢迢跑到北京电信机房的服务器（假设源站部署在北京电信机房）上了。</p>
<h3 id="CDN缓存-1"><a href="#CDN缓存-1" class="headerlink" title="CDN缓存"></a>CDN 缓存</h3><p><code>CDN缓存</code> , 在浏览器本地缓存失效后，浏览器会向 CDN 边缘节点发起请求。类似浏览器缓存，CDN 边缘节点也存在着一套缓存机制。CDN 边缘节点缓存策略因服务商不同而不同，但一般都会遵循 <code>http</code> 标准协议，通过 http 响应头中的<br><code>Cache-control: max-age   //后面会提到</code>的字段来设置 CDN 边缘节点数据缓存时间。</p>
<hr>
<p><strong>CDN 边缘节点数据缓存机制</strong></p>
<ul>
<li>当浏览器向 CDN 节点请求数据时，CDN 节点会判断缓存数据是否过期，</li>
<li>未过期：直接将缓存数据返回给客户端；</li>
<li>过期：CDN 节点向服务器发出回源请求，拉取最新数据同时更新本地缓存，并将最新数据返回给客户端。 </li>
</ul>
<p>CDN 服务商一般会提供基于<font color="red">文件后缀、目录多个维度来指定 CDN 缓存时间</font>，为用户提供更精细化的缓存管理。</p>
<hr>
<h3 id="CDN-优势"><a href="#CDN-优势" class="headerlink" title="CDN 优势"></a>CDN 优势</h3><ol>
<li>CDN 节点解决了跨运营商和跨地域访问的问题，访问延时大大降低。</li>
<li>大部分请求在 CDN 边缘节点完成，CDN 起到了分流作用，减轻了源服务器的负载。</li>
</ol>
<hr>
<h2 id="浏览器缓存（HTTP缓存）"><a href="#浏览器缓存（HTTP缓存）" class="headerlink" title="浏览器缓存（HTTP缓存）"></a>浏览器缓存（HTTP 缓存）</h2><p>对于一个数据请求来说，可以分为发起网络请求 后端处理  浏览器响应三个步骤<br>浏览器缓存可以 i 帮助我们在第一步和第三步中优化性能<br>比如我们可以直接使用缓存而不发起请求</p>
<p>盯着这张图<br><img src="/images/cache/cache_detail.png" alt="cache_detai"></p>
<h3 id="什么是浏览器缓存？"><a href="#什么是浏览器缓存？" class="headerlink" title="什么是浏览器缓存？"></a>什么是浏览器缓存？</h3><p><img src="/images/cache/cachehttp.png" alt="cachehttp"><br>浏览器缓存其实就是浏览器保存通过 HTTP 获取的所有资源，是浏览器将网络资源存储在本地的一种行为。</p>
<p>我们从两个方面来看浏览器缓存</p>
<ul>
<li>缓存位置</li>
<li>缓存策略</li>
</ul>
<h3 id="缓存的资源去哪里了（缓存位置）"><a href="#缓存的资源去哪里了（缓存位置）" class="headerlink" title="缓存的资源去哪里了（缓存位置）?"></a>缓存的资源去哪里了（缓存位置）?</h3><p>你可能会有疑问，浏览器存储了资源，那它把资源存储在哪里呢？</p>
<ul>
<li>memory cache (存在内存)</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">MemoryCache顾名思义，就是将资源缓存到内存中，等待下次访问时不需要重新下载资源，而直接从内存中获取。Webkit早已支持memoryCache。</span><br><span class="line">目前Webkit资源分成两类，一类是主资源，比如HTML页面，或者下载项，一类是派生资源，比如HTML页面中内嵌的图片或者脚本链接，分别对应代码中两个类：MainResourceLoader和SubresourceLoader。虽然Webkit支持memoryCache，但是也只是针对派生资源，它对应的类为CachedResource，用于保存原始数据（比如CSS，JS等），以及解码过的图片数据。</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>disk cache（存在磁盘）</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">DiskCache顾名思义，就是将资源缓存到磁盘中，等待下次访问时不需要重新下载资源，而直接从磁盘中获取，它的直接操作对象为CurlCacheManager。</span><br></pre></td></tr></tbody></table></figure>
<p><img src="/images/cache/huancunduibi.png" alt="huancunduibi"></p>
<h3 id="访问缓存优先级"><a href="#访问缓存优先级" class="headerlink" title="访问缓存优先级"></a>访问缓存优先级</h3><ol>
<li>先在内存中查找，如果有，直接加载。</li>
<li>如果内存中不存在，则在硬盘中查找，如果有直接加载。</li>
<li>如果硬盘中也没有，那么就进行网络请求。</li>
<li>请求获取的资源缓存到硬盘和内存。</li>
</ol>
<h3 id="浏览器缓存的分类（缓存策略）"><a href="#浏览器缓存的分类（缓存策略）" class="headerlink" title="浏览器缓存的分类（缓存策略）"></a>浏览器缓存的分类（缓存策略）</h3><h4 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h4><h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>需要说明的是 浏览器会先判断是否命中强缓存</p>
<h3 id="浏览器缓存的优点"><a href="#浏览器缓存的优点" class="headerlink" title="浏览器缓存的优点"></a>浏览器缓存的优点</h3><ol>
<li>减少了冗余的数据传输 节省了网费</li>
<li>减少了服务器的负担，大大提升了网站的性能</li>
<li>加快了客户端加载网页的速度</li>
</ol>
<p><strong>浏览器在第一次请求发生后，再次请求时：</strong></p>
<ol>
<li>验证是否命中强缓存，如果命中，就直接使用缓存了。</li>
<li>如果没有命中强缓存，就发请求到服务器检查是否命中协商缓存。</li>
<li>如果命中协商缓存，服务器会返回 304 告诉浏览器使用本地缓存。</li>
<li>否则，返回最新的资源。</li>
</ol>
<h4 id="强缓存-1"><a href="#强缓存-1" class="headerlink" title="强缓存"></a>强缓存</h4><p>强缓存是利用 http 的返回头中的 <code>Expires</code> 或者 <code>Cache-Control</code> 两个字段来控制的，用来表示资源的缓存时间。</p>
<p><font color="red">Expires</font>:<br>该字段是 http1.0 时的规范，它的值为一个绝对时间的 GMT 格式的时间字符串，比如 Expires:Mon,18 Oct 2066 23:59:59 GMT。这个时间代表着这个资源的失效时间，在此时间之前，即命中缓存。这种方式有一个明显的缺点，由于失效时间是一个绝对时间，所以当服务器与客户端时间偏差较大时，就会导致缓存混乱。</p>
<hr>
<p><font color="red">Cache-Control</font>:<br>Cache-Control 是 http1.1 时出现的 header 信息，主要是利用该字段的 max-age 值来进行判断，它是一个相对时间，例如 Cache-Control:max-age=3600，代表着资源的有效期是 3600 秒。cache-control 除了该字段外，还有下面几个比较常用的设置值：</p>
<ul>
<li>no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在 ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。</li>
<li>no-store：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。</li>
<li>public：可以被所有的用户缓存，包括终端用户和 CDN 等中间代理服务器。</li>
<li>private：只能被终端用户的浏览器缓存，不允许 CDN 等中继缓存服务器对其缓存。</li>
</ul>
<p><font color="red">Cache-Control 与 Expires 可以在服务端配置同时启用，同时启用的时候 Cache-Control 优先级高。</font></p>
<h2 id="协商缓存-1"><a href="#协商缓存-1" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>当强缓存没有命中的时候，浏览器会发送一个请求到服务器，服务器根据 <code>header</code> 中的部分信息来判断是否命中缓存。如果命中，则返回<code> 304</code> ，告诉浏览器资源未更新，可使用本地的缓存。</p>
<hr>
<p>header： <code>Last-Modify/If-Modify-Since </code>和 <code>ETag/If-None-Match</code>.</p>
<p><strong>Last-Modify/If-Modify-Since</strong><br>浏览器第一次请求一个资源的时候，服务器返回的 header 中会加上 Last-Modify，Last-modify 是一个时间标识该资源的最后修改时间。<br>当浏览器再次请求该资源时，request 的请求头中会包含 If-Modify-Since，该值为缓存之前返回的 Last-Modify。服务器收到 If-Modify-Since 后，根据资源的最后修改时间判断是否命中缓存。<br>如果命中缓存，则返回 304，并且不会返回资源内容，并且不会返回 Last-Modify。</p>
<p><font color="red">缺点:</font></p>
<ol>
<li><strong>短时间内资源发生了改变</strong> ,<code>Last-Modified </code>并不会发生变化。</li>
<li><strong>周期性变化</strong> , 如果这个资源在一个周期内修改回原来的样子了，我们认为是可以使用缓存的，但是 <code>Last-Modified</code> 可不这样认为，因此便有了 <code>ETag</code></li>
</ol>
<p><strong>ETag/If-None-Match</strong><br>与 <code>Last-Modify/If-Modify-Since</code> 不同的是，<code>Etag/If-None-Match </code>返回的是一个校验码。<code>ETag</code> 可以保证每一个资源是唯一的，资源变化都会导致 <code>ETag </code>变化。服务器根据浏览器上送的 <code>If-None-Match</code> 值来判断是否命中缓存。<br>与 <code>Last-Modified</code> 不一样的是，当服务器返回 <code>304 Not Modified </code>的响应时，由于 <code>ETag </code>重新生成过，<code>response header </code>中还会把这个 <code>ETag</code> 返回，即使这个 <code>ETag</code> 跟之前的没有变化。</p>
<p><font color="red">Last-Modified 与 ETag 是可以一起使用的，服务器会优先验证 ETag，一致的情况下，才会继续比对 Last-Modified，最后才决定是否返回 304。</font></p>
<hr>
<h3 id="实践检验"><a href="#实践检验" class="headerlink" title="实践检验"></a>实践检验</h3><p>我讨厌文字记忆，所以毫不犹豫选了理工科～～<br><code>talk is cheap , show me your code</code></p>
<p>⚠️ 实践过程控制台不要禁用缓存</p>
<p>利用 <code>koa</code> 启动 <code>server</code> 服务 <code>port：8000</code></p>
<p>引入静态资源 加载前端模版 去内蒙的航拍 哈哈哈 有我</p>
<p><img src="/images/cache/cache_one.png" alt="cache_one"></p>
<p>如图可见 初次访问 正常加载模版页面 <code>cache</code> 与图片资源 <code>1.jpeg</code></p>
<p><strong>实现强缓存</strong></p>
<hr>
<ol>
<li><strong>服务端</strong>设置响应头 Cache-Control 资源有效期为 300 秒 </li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">app.use(async (ctx, next) =&gt; {</span><br><span class="line"> </span><br><span class="line">  ctx.set({</span><br><span class="line">    'Cache-Control': 'max-age=300'  </span><br><span class="line">  });</span><br><span class="line">  await next();</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li>刷新页面</li>
</ol>
<p><img src="/images/cache/cache1.png" alt="cache1"><br>响应头的 <code>Cache-Control</code> 变成了 max-age=300</p>
<p><font color="red">验证访问缓存的优先级:</font><br>第一次的网络请求，浏览器把图片资源缓存到了磁盘和内存里，根据约定 应该会先从内存中找资源</p>
<ol>
<li>再次刷新页面</li>
</ol>
<p> <img src="/images/cache/cache-----.png" alt="cache-----"></p>
<p>确实是从内存获取的</p>
<p>4. 关掉页面再重新打开 （内存是存在进程中的，所以关闭该页面，内存中的资源也被释放掉了，磁盘中的资源是永久性的，所以还存在）<br><img src="/images/cache/cache_disk.png" alt="cache_disk"></p>
<p>from disk cache 从磁盘中获取资源</p>
<p>5. 接下来 有效期 300 秒 后.<br><img src="/images/cache/cachehuancunshixiao.png" alt="cachehuancunshixiao"><br>缓存失效 重新向服务器载入资源</p>
<hr>
<p><strong>实现协商缓存</strong><br>协商缓存本地测试直接拦截 url 给定 code</p>
<p>Cache-Control 取默认值 no-cache</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">app.use( async(ctx, next) =&gt; {</span><br><span class="line">// // 强制缓存</span><br><span class="line">//  ctx.set({</span><br><span class="line">//    'Cache-Control': 'max-age=300'  </span><br><span class="line">//  });</span><br><span class="line"></span><br><span class="line">// 协商缓存测试</span><br><span class="line">if(ctx.url === '/imgs/1.jpeg'){</span><br><span class="line">  ctx.status = 304;</span><br><span class="line">  return;</span><br><span class="line">}</span><br><span class="line">await next();</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>
<p><img src="/images/cache/xieshang.png" alt="xieshang"></p>
<p>服务器返回 <code>304</code> 同时 <code>size</code> 变小了很多 因为只返回了必要信息</p>
<p>也可利用 现成的插件帮我们计算文件的 ETag<br><code>npm install koa-tag -D npm install koa-conditional-get -D</code><br>就不演示了</p>
<p>加载资源发生变化（比如换了张图片）<code>ETag</code> 改变 会导致协商缓存策略失效</p>
<p>然后  就行了. 😊</p>
<p>如果你想亲自体验</p>
<p><a href="">源码在这里</a></p>
<p>day day up</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>从不规范生产套路看效率</title>
    <url>/2017/07/22/%E4%BB%8E%E4%B8%8D%E8%A7%84%E8%8C%83%E5%9B%A2%E9%98%9F%E7%9C%8B%E6%95%88%E7%8E%87/</url>
    <content><![CDATA[<p>标题好像是句废话，” 不规范” 何谈 <font face="STCAIYUN" color="red" size="5">效率</font> 呢？</p>
<p><img src="http://oucjferwh.bkt.clouddn.com/wunai.jpg"></p>
<ol>
<li> <font face="STCAIYUN" color="#83933b" size="4">何为效率</font></li>
<li> <font face="STCAIYUN" color="#83933b" size="4">从产品看效率</font></li>
<li> <font face="STCAIYUN" color="#83933b" size="4">从 UI 看效率</font></li>
<li> <font face="STCAIYUN" color="#83933b" size="4">从开发看效率</font></li>
<li> <font face="STCAIYUN" color="#83933b" size="4">从测试看效率 </font></li>
</ol>
<p><strong>何为效率？</strong></p>
<p><a href="https://baike.baidu.com/item/%E6%95%88%E7%8E%87/868847?fr=aladdin">百度百科</a>上大概是这么定义的：是指在给定投入和技术等条件下，<font face="STCAIYUN" color="red" size="4">最有效地</font>使用资源以满足设定的愿望和需要的评价方式</p>
<p>对我来说最直观的判断方式就是  <font face="STCAIYUN" color="red" size="4">项目是否有延期 线上是否有 bug</font></p>
<ul>
<li><p><font face="STCAIYUN" color="darkorange" size="4">效率有多重要？</font></p>
<p>大部分的电子厂工资都是按件计费的，多劳多得，单位时间产出与收入能正比，所以工人们都非常努力 这是自发性行为 所以也是最任怨的。</p>
<p>对我而言 效率能带来好心情 好状态以及好的生活态 废话 大家都一样 –  </p>
</li>
</ul>
<p><strong>从产品看效率</strong><br>一款产品的成功与否 有多方便的决定因素 产品最终都是面向用户的 一个不能为用户创造价值的产品应该是没有使用价值的，产品本就是提升效率的一种方式</p>
<p>那么 接下来  我要开始吐槽了</p>
<p><font face="STCAIYUN" color="darkorange" size="4">如果产品需求不明确或者需求不完整  项目要不要开始做？</font><br>一般来说 不要 绝对不要 除非是两个完全不相干的模块 昂 基本也不太可能<br>但是尼 为了所谓的工期 产品大大一般会这么说  做呗  先做着  我这么单（wu）纯（nai）的 每次都被套路住🤡 然后后来计算工时的时候 ： 哦 你不是从那个什么什么时候就开始了吗？👐🏽<br>这还不是最主要的，毕竟 时间就像海绵里的水 挤一挤总会有的😂</p>
<p>最主要的当然是<font face="STCAIYUN" color="red" size="4">改需求</font>啦 这大概是所有产品最擅长的</p>
<p>这两者本质上是没有矛盾的，只不过产品更多的以目标为导向，需求只是手段，而对开发来说 技术是手段 需求是目标 只不过产品更容易主观，比如需求，比如说功能，比如说交互，这些都受到个人经验，眼界，学识很大影响。朝三暮四，朝令夕改，是常有的事情。</p>
<p><strong>说真的</strong><br>产品的功能、质量、发布时间和需要投入的资源这四者不能都是封闭条件，否则可能无解</p>
<p>而且现在的产品很是聪明啊 需求给了，开始做了，做到最后发现这种情况下不是很合理，简单啊 改呗 反正做到这里我逻辑也捋清楚了，也知道该咋办了<font face="STCAIYUN" color="#83933b" size="3">产品默想到</font></p>
<p>呃.. 这两天刚遇到个类似的情况 哦 不好意思，是<font face="STCAIYUN" color="red" size="5">经常遇到</font>，提测一周也测了<font face="STCAIYUN" color="red" size="5">一周</font>了，代码上体验版（预上线）了</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">产品：咦？这块不是那样儿的吗？怎么是这样的？</span><br><span class="line"></span><br><span class="line">开发：？ 前两天不是专门讨论过这个问题吗，这个就是这样儿的！</span><br><span class="line"></span><br><span class="line">产品：哦？是吗？ 但是这样儿看起来好诡异啊！就应该是那样儿的 改一下吧</span><br><span class="line"></span><br><span class="line">开发：...当初接口设计的就是这样儿的，怎么不早说？这都要上线啦！😩</span><br><span class="line"></span><br><span class="line">产品："之前流程没走通 不太清楚这块儿的逻辑，现在改一下吧" 然后就走了</span><br><span class="line"></span><br><span class="line">开发：...</span><br></pre></td></tr></tbody></table></figure>

<p>还有就是<strong>排期</strong></p>
<p>产品经常这么一句话：因为我们的上线时间是 XX 号 测试需要 XX 天 所以 开发排下期吧 ？</p>
<p>…..</p>
<p>排完期之后..</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">产品：昂昂，你这儿不行啊 时间太长了 能不能缩短点</span><br><span class="line"></span><br><span class="line">开发：我按工时算的 每一项 都列出来了 不会差太多</span><br><span class="line"></span><br><span class="line">产品：这不行啊 因为我们要XX提审 测试需要XX天 所以你必须 XX天提测</span><br><span class="line"></span><br><span class="line">开发：这等于 XX 天的工期 你给我压到 XX／2 天</span><br><span class="line"></span><br><span class="line">产品：嘿嘿😉</span><br><span class="line"></span><br><span class="line">开发：...</span><br><span class="line"></span><br><span class="line">开发OS："赶紧开发 为了给测试腾时间😂😭🙈，尼萌给开发时间充足了 问题自然就会少很多好吗 测试好像是最重要的噻"</span><br></pre></td></tr></tbody></table></figure>


<p>百度过类似的问题 最好的办法<font face="STCAIYUN" color="red" size="3">是让产品也学会基础的编程，了解每一个实现都是需要耗费资源的，这样才能基于对有限资源的理解，做出更谨慎的规划。</font><br><font face="STCAIYUN" color="#83933b" size="3">然而，这基本不可能，所以..</font></p>
<p>实际上 那些<font face="STCAIYUN" color="#83933b" size="4">非常紧急</font>的需求，这么一搞成了拖延的第一个关键点<br><br></p>
<p><img src="http://oucjferwh.bkt.clouddn.com/tuxie.jpeg" alt="tuxie"></p>
<p><strong>从 UI 看效率</strong></p>
<p>呃。对于用户来说 一个产品能不能吸引到你，最浅显也最重要的是<font face="STCAIYUN" color="red" size="5">眼缘</font>，说俗气点就是颜值<br>而且 UI 链接 产品与开发 自然也是马虎不得的 深刻理解原型的精髓 然后利用智慧的小脑瓜设计成用户想要的样子，上面说了 他们最重要的工作是 <font face="STCAIYUN" color="red" size="5">深刻理解原型的精髓</font>，因为 对于<font face="STCAIYUN" color="#83933b" size="4">美</font>，设计师总是有不一样的定义，就比如 <font face="STCAIYUN" color="gold" size="4">情人眼里出西施</font></p>
<p>非常不幸 我们 UI 也是必须要吐槽的对象</p>
<p>直接上日常</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">开发：设计小哥，对比原型 是不是缺了一张图</span><br><span class="line"></span><br><span class="line">设计：？</span><br><span class="line"></span><br><span class="line">开发：搜索中状态</span><br><span class="line"></span><br><span class="line">设计：沉默</span><br><span class="line"></span><br><span class="line">产品：哦 那个不就是在未搜索的状态基础上把导航去掉吗？还用出图吗？</span><br><span class="line"></span><br><span class="line">一分钟后～～</span><br><span class="line"></span><br><span class="line">设计：突然扔出来一张图  @开发:好了</span><br><span class="line"></span><br><span class="line">开发：瞅了一眼 @设计：嗯 ？不是这样儿的吧</span><br><span class="line"></span><br><span class="line">设计：？</span><br><span class="line"></span><br><span class="line">开发：把产品的话 @设计：“哦 那个不就是在未搜索的状态基础上把导航去掉吗？还用出图吗？”</span><br><span class="line"></span><br><span class="line">设计：沉默</span><br><span class="line"></span><br><span class="line">两分钟后～～</span><br><span class="line"></span><br><span class="line">设计：扔出来一张图 呐 上传了</span><br><span class="line"></span><br><span class="line">开发：嗯 现在才是对的</span><br><span class="line"></span><br><span class="line">设计：嗯</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>类似的事情简直日常</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">上午～</span><br><span class="line"></span><br><span class="line">产品：今天周五 需要把UI提的问题都改完</span><br><span class="line"></span><br><span class="line">开发：ok</span><br><span class="line"></span><br><span class="line">设计：ok</span><br><span class="line"></span><br><span class="line">下午～</span><br><span class="line"></span><br><span class="line">开发：什么时候有空，当面改</span><br><span class="line"></span><br><span class="line">设计：嗯</span><br><span class="line"></span><br><span class="line">下午四点～</span><br><span class="line"></span><br><span class="line">开发：什么时候有空</span><br><span class="line"></span><br><span class="line">设计：现在过去</span><br><span class="line"></span><br><span class="line">开发：嗯</span><br><span class="line"></span><br><span class="line">改了大概有两个之后 设计被叫走</span><br><span class="line"></span><br><span class="line">又过了一个小时～</span><br><span class="line"></span><br><span class="line">开发：快下班了 啥时候改尼</span><br><span class="line"></span><br><span class="line">设计：今天比较忙 现在可以开始了</span><br><span class="line"></span><br><span class="line">开发： 嗯？我看了一下 你拿到的不是最新版吧 好些问题现在不能复现了</span><br><span class="line"></span><br><span class="line">设计：哦</span><br><span class="line"></span><br><span class="line">一个小时之后</span><br><span class="line"></span><br><span class="line">开发：改完了 我下班了啊 今天有点事儿</span><br><span class="line"></span><br><span class="line">设计：嗯 好的 下班吧</span><br><span class="line"></span><br><span class="line">开发 走了</span><br><span class="line"></span><br><span class="line">两个小时后 忙完 开发都到家了～～</span><br><span class="line"></span><br><span class="line">产品：@开发：在哪里呢 啥时候回来</span><br><span class="line"></span><br><span class="line">开发：？我到家了啊</span><br><span class="line"></span><br><span class="line">产品：你咋走了？设计小哥还在等你呢</span><br><span class="line"></span><br><span class="line">开发：？我走的时候跟他说了啊 他知道啊</span><br><span class="line"></span><br><span class="line">产品：我不是说了今天要改完吗 设计review了 还有一点问题</span><br><span class="line"></span><br><span class="line">开发：... 那我明天去加班吧</span><br><span class="line"></span><br><span class="line">第二天，到公司之后</span><br><span class="line"></span><br><span class="line">开发：在群里@设计@产品 ：这个只有截图看不出来哪有问题噻</span><br><span class="line"></span><br><span class="line">设计：沉默</span><br><span class="line"></span><br><span class="line">产品：沉默</span><br><span class="line"></span><br><span class="line">开发：...</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>




<p><strong>从开发看效率</strong></p>
<p>开发效率无疑存在于两方面</p>
<p>强健的框架支撑与准确的拆分估期</p>
<p>一般情况下是不会延期的 也算是这几个环节当中最可控的</p>
<p><strong>从测试看效率</strong></p>
<p>你理解一个开发只用了一天的功能测试测了四天的心情吗</p>
<p>你理解一个开发用了一周 测试用了 9 个工作日的心痛吗</p>
<p>🙊</p>
<p>结语：💊</p>
]]></content>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>前端防刷实现</title>
    <url>/2018/12/26/%E5%89%8D%E7%AB%AF%E9%98%B2%E5%88%B7/</url>
    <content><![CDATA[<p>前段时间写了前端防刷逻辑 作此记录<br>当时的需求</p>
<hr>
<blockquote>
<p>防刷逻辑 1 24 小时内 一个手机号只能提交三次 第四次提交的时候 提示 已提交成功 请耐心等待 400<br>防刷逻辑 2 24 小时内 提交三个手机号 提交第四个时 提示 401</p>
</blockquote>
<a id="more"></a>

<p><strong>步骤一 页面加载 获取 cookie 中当前的信息</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"> componentDidMount() {</span><br><span class="line">    // 获取cookie里存的用户信息</span><br><span class="line">    let cookieSaveInfo = getCookie(COOKIE_CONFIG.FINANCIAL_SAVE_INFO) || "{}";</span><br><span class="line">    //todo...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>点击保存按钮 防刷逻辑</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">saveInfo = () =&gt; {</span><br><span class="line">   const { userInfoFromCookie, setModal } = this;</span><br><span class="line">  </span><br><span class="line">   // 获取手机号列表</span><br><span class="line">   let phoneList = Object.keys(userInfoFromCookie); // ['12','21212','212']</span><br><span class="line">  </span><br><span class="line">   // 获取当前存的手机号的个数</span><br><span class="line">   let phoneListLength = phoneList.length;</span><br><span class="line">   // 当前输入的存在手机号列表中</span><br><span class="line">   if (phone in userInfoFromCookie) {</span><br><span class="line">       if (userInfoFromCookie[phone] &gt;= 3) {</span><br><span class="line">           // 当前的手机号存在手机列表中 看当前是第几次 大于三次提示</span><br><span class="line">         </span><br><span class="line">          setModal(400);</span><br><span class="line">          //todo...</span><br><span class="line">           return; //防御式编程</span><br><span class="line">       }</span><br><span class="line">   } else if (phoneListLength &gt;= 3) {</span><br><span class="line">       // 如果当前列表中已经有三个不同的手机号 则提示401</span><br><span class="line">       setModal(401);</span><br><span class="line">       return;</span><br><span class="line">   }</span><br><span class="line">   //可以发起请求</span><br><span class="line">   </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>请求成功的回调</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"> saveFunc = (resData) =&gt; {</span><br><span class="line">    </span><br><span class="line">   let thePhoneCount = userInfoFromCookie[phone] || 1;</span><br><span class="line">   if (resData.error_code === 200) {</span><br><span class="line">   </span><br><span class="line">       // 存cookie 规则 看下当前手机号在不在列表里 在的话 就更新次数 不在的数就设置这个key</span><br><span class="line">       if (phone in userInfoFromCookie) {</span><br><span class="line">           userInfoFromCookie[phone] = thePhoneCount + 1;</span><br><span class="line">       } else {</span><br><span class="line">           userInfoFromCookie[phone] = thePhoneCount;</span><br><span class="line">       }</span><br><span class="line">       // cookie存储</span><br><span class="line">       setCookie(COOKIE_CONFIG.FINANCIAL_SAVE_INFO, JSON.stringify(userInfoFromCookie), 24 * 60 * 60);</span><br><span class="line">   }</span><br><span class="line"> </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>微信小程序开发常见问题</title>
    <url>/2017/07/19/%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="场景一：首页增加下拉刷新功能无效？"><a href="#场景一：首页增加下拉刷新功能无效？" class="headerlink" title="场景一：首页增加下拉刷新功能无效？"></a>场景一：首页增加下拉刷新功能无效？</h2><p>经过各种尝试 问题定位到了是因为 在 <code>scroll-view</code> 中使用了 <code>onPullDownRefresh</code>，最后通过改首页的代码结构达到了预期结果</p>
<p>结论：<font face="STCAIYUN" color="#83933b" size="3"><br>在滚动 scroll-view 时会阻止页面回弹，所以在 scroll-view 中滚动，是无法触发 onPullDownRefresh</font></p>
<p>如果非要在 <code>scroll-view</code> 使用下拉刷新，<font face="STCAIYUN" color="#83933b" size="3">官方给出的解决方案</font>是监听页面的滚动事件 <code>bindscroll</code>  厄.. 也是一种方法 只不过我的更粗鲁一些</p>
<p><strong>其他需要注意的：</strong></p>
<ul>
<li>不要在 <code>scroll-view</code> 中使用 <code>textarea</code>、<code>map</code>、<code>canvas</code>、<code>video</code> 组件</li>
<li>目前只验证过 <code>textarea</code> 暂且放到场景二吧</li>
<li><code>scroll-into-view</code> 的优先级高于 <code>scroll-top</code></li>
</ul>
<h2 id="场景二：无法在-scroll-view中使用textarea？"><a href="#场景二：无法在-scroll-view中使用textarea？" class="headerlink" title="场景二：无法在 scroll-view中使用textarea？"></a>场景二：无法在 scroll-view 中使用 textarea？</h2><p><font face="STCAIYUN" color="red" size="3">这是个只有在真机上才会出现的 bug</font></p>
<p>刚开始以为是不能在某些特定的组件内使用<code>textarea</code> 几番尝试 发现是因为 <code>textarea</code>组件与其他组件的层级关系 后来发现 <font face="STCAIYUN" color="#83933b" size="3">文档在最下方用最小号的字体给标注出来了已经！</font><font face="STCAIYUN" color="red" size="3">吐血</font></p>
<p>结论：<font face="STCAIYUN" color="#83933b" size="3"><br><code>textarea</code>组件是由客户端创建的原生组件，他的层级是最高的，在实际项目中 要保证本页面中 无 </font><font face="STCAIYUN" color="red" size="3">弹层</font>之类一切可能会覆盖到页面的鬼。<br></p>
<p><strong>其他需要注意的：</strong></p>
<ul>
<li>不要在 <code>scroll-view</code> 中使用 <code>textarea</code> 组件。</li>
<li>css 动画对 textarea 组件无效</li>
<li> textarea 的 <code>blur</code> 事件会晚于页面上的 tap 事件，如果需要在 button 的点击事件获取 textarea，可以使用 <code>form</code> 的 bindsubmit。</li>
<li>官方遗留 bug: <code>textarea</code> 在列表渲染时，新增加的 textarea 在自动聚焦时的位置计算错误。<h2 id="场景三：textarea的placeholder不固定的问题"><a href="#场景三：textarea的placeholder不固定的问题" class="headerlink" title="场景三：textarea的placeholder不固定的问题"></a>场景三：textarea 的 placeholder 不固定的问题</h2></li>
</ul>
<p>当把<code>textarea</code>放到一个<code> position：fixed</code> 中的元素中时，会发现这个<code>textarea</code>也会跟着固定位置，但是<code>textarea</code>的 placeholder 内容不会固定，当滚动页面时，placeholder 的内容会跟着滚动</p>
<p>解决方式：<font face="STCAIYUN" color="red" size="3">给<code>textarea</code>组件增加属性 fixed<br></font></p>
<p>结论：<font face="STCAIYUN" color="#83933b" size="3">踩坑大法好</font></p>
<h2 id="场景四：微信小程序的兼容问题"><a href="#场景四：微信小程序的兼容问题" class="headerlink" title="场景四：微信小程序的兼容问题"></a>场景四：微信小程序的兼容问题</h2><p><code>wx.request()</code> 返回的状态码 <code>res.statusCode</code> 的值 在 IOS 下是<font face="STCAIYUN" color="red" size="3"> init</font> 型的数据 但是在 Android 6.0.1 上却是 <font face="STCAIYUN" color="red" size="3">String</font> 型数据<br>要特别注意判断状态码的方式</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">X</span><br><span class="line">wx.request({</span><br><span class="line">    url: 'http://api.example.com',</span><br><span class="line">    success: function (res) {</span><br><span class="line">        if (res.statusCode === 200) {</span><br><span class="line">            // success</span><br><span class="line">        } else {</span><br><span class="line">            // server failure</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">})</span><br><span class="line">像这样使用 === 就错了 不要判断类型</span><br><span class="line">使用 ==即可</span><br></pre></td></tr></tbody></table></figure>

<p>小程序的 WXML 没有 HTML 的宽容度​那么高，单标签必需是 /&gt; 结尾的 不然会报错。</p>
<h2 id="场景五：小程序版本的兼容问题"><a href="#场景五：小程序版本的兼容问题" class="headerlink" title="场景五：小程序版本的兼容问题"></a>场景五：小程序版本的兼容问题</h2><p>无论用哪个组件 必须时刻注意当前兼容的版本 做低版本兼容</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"> wx.openBluetoothAdapter()</span><br><span class="line">} else {</span><br><span class="line">  // 如果希望用户在最新版本的客户端上体验您的小程序，可以这样子提示</span><br><span class="line">  wx.showModal({</span><br><span class="line">    title: '提示',</span><br><span class="line">    content: '当前微信版本过低，无法使用该功能，请升级到最新微信版本后重试。'</span><br><span class="line">  })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>Fundebug</code> 能够实时监测小程序，捕获小程序 Bug，然后反馈给开发者<br><a href="https://fundebug.com/">Fundebug</a></p>
<h2 id="场景六：小程序版本的兼容问题"><a href="#场景六：小程序版本的兼容问题" class="headerlink" title="场景六：小程序版本的兼容问题"></a>场景六：小程序版本的兼容问题</h2><p>绑定事件的时候，当两个方法重名时，后面的方法会覆盖前面的方法，并且 IDE 不报错</p>
<h2 id="场景七：image"><a href="#场景七：image" class="headerlink" title="场景七：image"></a>场景七：image</h2><p>小程序的 image 与 HTML5 的 img 最大的区别在于：<br>小程序的 image 是按照 <code>background-image</code> 来实现的。<br>默认 image 的高宽是 320*240。必须通过样式定义去覆盖这个默认高宽，auto 在这里不生效。<br><font face="STCAIYUN" color="red" size="3">开发者说这样设置的原因是：如果设置 auto ，页面布局会因为图片加载的过程有一个闪的现象（例如高度从 0 到 height ），所以要求一定要设置一个宽度和高度。</font></p>
<p>图片包括三种缩放模式 scaleToFill、aspectFit、aspectFill 和 9 种裁剪模式，三种缩放模式的实现原理对应如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">scaleToFill{</span><br><span class="line"></span><br><span class="line">background-size:100% 100%;//不保持纵横比缩放图片，使图片的宽高完全拉伸至填满 image 元素</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">aspectFit{</span><br><span class="line"></span><br><span class="line">background-size:contain;//保持纵横比缩放图片，使图片的长边能完全显示出来。也就是说，可以完整地将图片显示出来。</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">aspectFill{</span><br><span class="line"></span><br><span class="line">background-size:cover;//保持纵横比缩放图片，只保证图片的短边能完全显示出来。也就是说，图片通常只在水平或垂直方向是完整的，另一个方向将会发生截取。</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>


<h2 id="场景八：navigator"><a href="#场景八：navigator" class="headerlink" title="场景八：navigator"></a>场景八：navigator</h2><p>navigator 支持相对路径和绝对路径的跳转，默认是打开新页面，当前页面打开需要加 redirect；<br>navigator 仅支持<font face="STCAIYUN" color="red" size="3"> 5 级</font>页面的跳转；<br>navigator 不可跳转到小程序外的链接地址；</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;navigator class="navigator" redirect  url="../login/index" &gt;登录页&lt;/navigator&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>在小程序开发工具里，默认打开新页面，工具左上角有返回按钮。加上 redirect，当前页打开，不出现返回按钮。</p>
<h2 id="场景八：大胆使用flex布局"><a href="#场景八：大胆使用flex布局" class="headerlink" title="场景八：大胆使用flex布局"></a>场景八：大胆使用 flex 布局</h2><p>在做传统 H5 的时候，为了兼容各种低端设备的机型，通常不太敢轻易尝试 flex，但在小程序里就可以大胆的使用了。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">.media {</span><br><span class="line"></span><br><span class="line">display: flex;</span><br><span class="line"></span><br><span class="line">justify-content:center;</span><br><span class="line">align-items:center;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">.media .content {</span><br><span class="line"></span><br><span class="line">flex: 1;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="场景八：大胆使用flex布局-1"><a href="#场景八：大胆使用flex布局-1" class="headerlink" title="场景八：大胆使用flex布局"></a>场景八：大胆使用 flex 布局</h2><p>在做传统 H5 的时候，为了兼容各种低端设备的机型，通常不太敢轻易尝试 flex，但在小程序里就可以大胆的使用了。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">.media {</span><br><span class="line"></span><br><span class="line">display: flex;</span><br><span class="line"></span><br><span class="line">justify-content:center;</span><br><span class="line">align-items:center;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">.media .content {</span><br><span class="line"></span><br><span class="line">flex: 1;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="场景八：页面最后一个-view-组件-设置margin-bottom属性-IOS-机型-失效的问题"><a href="#场景八：页面最后一个-view-组件-设置margin-bottom属性-IOS-机型-失效的问题" class="headerlink" title="场景八：页面最后一个 view 组件 设置margin-bottom属性 IOS 机型 失效的问题"></a>场景八：页面最后一个 view 组件 设置 margin-bottom 属性 IOS 机型 失效的问题</h2><p>解决方式：<font face="STCAIYUN" color="red" size="3">当前 view 当前组件下加一个同级 view<br></font></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">wxml</span><br><span class="line">    &lt;view&gt;这是个按钮&lt;/view&gt;</span><br><span class="line">    &lt;view class="marginB"&gt;&lt;/view&gt;</span><br><span class="line"></span><br><span class="line">    css</span><br><span class="line"></span><br><span class="line">    .marginB{</span><br><span class="line">        	height: 0rpx;</span><br><span class="line">        	font-size: 0rpx;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>


<h2 id="场景九：实现长按保存图片-短按图片隐藏"><a href="#场景九：实现长按保存图片-短按图片隐藏" class="headerlink" title="场景九：实现长按保存图片 短按图片隐藏"></a>场景九：实现长按保存图片 短按图片隐藏</h2><p>现有问题  用户体验不佳 长按需要抬起才能弹出 <code>sheetAction</code> 菜单</p>
<p>理想状态下是长按开始计时 350 秒之后自动弹操作菜单</p>
<p>利用 <code>bindtouchstart</code> 与 <code>bindtouchend</code> 事件结合 <code>bindtap</code> 实现</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">问题代码一</span><br><span class="line"></span><br><span class="line">WXML</span><br><span class="line"></span><br><span class="line">&lt;view  bindtouchstart="mytouchstart" bindtouchend="mytouchend" bindtap="editAddress" &gt;</span><br><span class="line"></span><br><span class="line">JS</span><br><span class="line"></span><br><span class="line">editAddress: function (event) {  </span><br><span class="line">   let that = this;  </span><br><span class="line">   //触摸时间距离页面打开的毫秒数  </span><br><span class="line">   var touchTime = that.data.touch_end - that.data.touch_start;  </span><br><span class="line">   console.log(touchTime);  </span><br><span class="line">   //如果按下时间大于350为长按  </span><br><span class="line">   if (touchTime &gt; 350) {</span><br><span class="line"></span><br><span class="line">    //TODO..</span><br><span class="line"></span><br><span class="line">   } else {  </span><br><span class="line"></span><br><span class="line">    //TODO..</span><br><span class="line"></span><br><span class="line">   }  </span><br><span class="line"> },  </span><br><span class="line"> //按下事件开始  </span><br><span class="line"> mytouchstart: function (e) {  </span><br><span class="line">   let that = this;  </span><br><span class="line">   that.setData({  </span><br><span class="line">     touch_start: e.timeStamp  </span><br><span class="line">   })  </span><br><span class="line">   console.log(e.timeStamp + '- touch-start')  </span><br><span class="line"> },  </span><br><span class="line"> //按下事件结束  </span><br><span class="line"> mytouchend: function (e) {  </span><br><span class="line">   let that = this;  </span><br><span class="line">   that.setData({  </span><br><span class="line">     touch_end: e.timeStamp  </span><br><span class="line">   })  </span><br><span class="line">   console.log(e.timeStamp + '- touch-end')  </span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>改进</p>
<p>小程序的事件触发顺序</p>
<p>单击 touchstart → touchend → tap<br>双击 touchstart → touchend → tap → touchstart → touchend → tap<br>长按 touchstart → longtap → touchend → tap</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">问题代码二</span><br><span class="line"></span><br><span class="line">wxml</span><br><span class="line"></span><br><span class="line">&lt;view  bindlongtap="longPress"   bindtap="tapFun" style="width: 100%;height:100%" mode="scaleToFill" src="{{img_url}}"&gt;&lt;/view&gt;</span><br><span class="line"></span><br><span class="line">js</span><br><span class="line"></span><br><span class="line">longPress(e){</span><br><span class="line">  var that = this;</span><br><span class="line">  console.log('你点击了长按时间',e)</span><br><span class="line">  // 可以通过 wx.getSetting 先查询一下用户是否授权了 "scope.record" 这个 scope</span><br><span class="line">  wx.getSetting({</span><br><span class="line">      success(res) {</span><br><span class="line">        console.log('222222222222222222')</span><br><span class="line">          if (!res['scope.writePhotosAlbum']) {</span><br><span class="line">              wx.authorize({</span><br><span class="line">                  scope: 'scope.writePhotosAlbum',</span><br><span class="line">                  success() {</span><br><span class="line">                   //  调起操作菜单</span><br><span class="line">                   console.log('33333333333333333333')</span><br><span class="line">                   console.log('wx.showActionSheet()',wx.showActionSheet)</span><br><span class="line">                    wx.showActionSheet({</span><br><span class="line">                         itemList: ['保存到本地'],</span><br><span class="line">                         success: function(res) {</span><br><span class="line">                           console.log('操作菜单弹出成功','第'+res.tapIndex+'个操作菜单弹出成功')</span><br><span class="line">                           // 下载文件资源到本地。客户端直接发起一个 HTTP GET 请求，返回文件的本地临时路径。</span><br><span class="line">                         if(res.tapIndex ==0){</span><br><span class="line">                          console.log('wx.downloadFile',wx.downloadFile)</span><br><span class="line">                           wx.downloadFile({</span><br><span class="line">                           url: that.data.img_url, //仅为示例，并非真实的资源</span><br><span class="line">                           success: function(res) {</span><br><span class="line">                             wx.playVoice({</span><br><span class="line">                               filePath: res.tempFilePath</span><br><span class="line">                             });</span><br><span class="line">                             console.log('wx.playVoice()',wx.playVoice)</span><br><span class="line">                             console.log('将图片先保存到本地--res.tempFilePath',res.tempFilePath);</span><br><span class="line">                                     // 用户已经同意小程序使用功能，后续调用 wx.startRecord 接口不会弹窗询问</span><br><span class="line">                                     console.log('wx.saveImageToPhotosAlbum()',wx.saveImageToPhotosAlbum)</span><br><span class="line">                                     wx.saveImageToPhotosAlbum({</span><br><span class="line">                                       filePath:res.tempFilePath,</span><br><span class="line">                                       success(res) {</span><br><span class="line">                                         wx.showToast({</span><br><span class="line">                                         title: '保存成功',</span><br><span class="line">                                         icon: 'success'</span><br><span class="line">                                       });</span><br><span class="line">                                       setTimeout(function(){</span><br><span class="line">                                         wx.hideToast();</span><br><span class="line">                                       },3000)</span><br><span class="line">                                       },</span><br><span class="line">                                       fail(res){</span><br><span class="line">                                         wx.showToast({</span><br><span class="line">                                         title: '保存失败',</span><br><span class="line">                                         icon: 'success'</span><br><span class="line">                                       });</span><br><span class="line">                                       setTimeout(function(){</span><br><span class="line">                                         wx.hideToast();</span><br><span class="line">                                       },3000)</span><br><span class="line">                                       }</span><br><span class="line">                                   })</span><br><span class="line"></span><br><span class="line">                           }</span><br><span class="line">                         })</span><br><span class="line">                         }</span><br><span class="line">                         },</span><br><span class="line">                         fail: function(res) {</span><br><span class="line">                           console.log('操作菜单弹出失败',res.tapIndex)</span><br><span class="line">                         }</span><br><span class="line">               })</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                  }</span><br><span class="line">              })</span><br><span class="line">          }</span><br><span class="line">      }</span><br><span class="line">  })</span><br><span class="line">},</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tapFun: function(event) {</span><br><span class="line">        that.setData({</span><br><span class="line">        qrShow:false</span><br><span class="line">        })</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">很显然 这也是有问题的</span><br><span class="line"></span><br><span class="line">因为事件机制。总会触发 tap事件 表现形式比 问题一还难以接受</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>好了，结合前两种 解决办法如下</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">WXml</span><br><span class="line"></span><br><span class="line"> &lt;image  wx:if="{{img_url !=''}}"  bindlongtap="editAddress1"   bindtouchstart="mytouchstart" bindtouchend="mytouchend"  style="width: 100%;height:100%" mode="scaleToFill" src="{{img_url}}"&gt;&lt;/image&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">js</span><br><span class="line"></span><br><span class="line">//按下事件开始</span><br><span class="line">mytouchstart:function(e){</span><br><span class="line">  let that = this;</span><br><span class="line">  that.setData({</span><br><span class="line">    touch_start: e.timeStamp</span><br><span class="line">  })</span><br><span class="line">  console.log(e.timeStamp + '- touch-start')</span><br><span class="line">},</span><br><span class="line"></span><br><span class="line">//按下事件结束</span><br><span class="line">mytouchend:function(e){</span><br><span class="line">  let that = this;</span><br><span class="line">  that.setData({</span><br><span class="line">    touch_end: e.timeStamp</span><br><span class="line">  })</span><br><span class="line">  console.log(e.timeStamp + '- touch-end')</span><br><span class="line">  that.editAddress(e);</span><br><span class="line">},</span><br><span class="line"></span><br><span class="line">// 判断是长按操作还是短按操作</span><br><span class="line">editAddress: function(event) {</span><br><span class="line">      var that = this;</span><br><span class="line">      if(that.data.touch_end - that.data.touch_start &lt; 350){</span><br><span class="line">        that.setData({</span><br><span class="line">        qrShow:false</span><br><span class="line">        })</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">},</span><br><span class="line"></span><br><span class="line">editAddress1(e){}   // 同问题二  longPress（）</span><br></pre></td></tr></tbody></table></figure>
<h2 id="场景十：第二次扫码进入小程序的缓存问题"><a href="#场景十：第二次扫码进入小程序的缓存问题" class="headerlink" title="场景十：第二次扫码进入小程序的缓存问题"></a>场景十：第二次扫码进入小程序的缓存问题</h2>]]></content>
      <tags>
        <tag>issue</tag>
        <tag>wechat</tag>
      </tags>
  </entry>
  <entry>
    <title>2018 写在年终的话</title>
    <url>/2019/01/21/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>2018 年终总结</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title>微信小程序 初见篇</title>
    <url>/2017/07/19/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%20%E5%88%9D%E8%A7%81%E7%AF%87/</url>
    <content><![CDATA[<ul>
<li><p><strong>题外话</strong></p>
<ul>
<li><a href="#line6"> <font face="STCAIYUN" size="3">关于微信小程序</font></a></li>
<li><a href="#line5"> <font face="STCAIYUN" size="3">小程序与传统 HTML5 的区别</font></a></li>
</ul>
</li>
<li><p><strong>框架</strong></p>
<ul>
<li><a href="#line1"> <font face="STCAIYUN" size="3">目录结构与配置</font></a></li>
<li><a href="#line2"> <font face="STCAIYUN" size="3">逻辑层</font></a></li>
<li><a href="#line3"> <font face="STCAIYUN" size="3">视图层</font></a></li>
<li><a href="#line4"> <font face="STCAIYUN" size="3">运行机制</font></a></li>
</ul>
</li>
</ul>
<br>

<a id="more"></a>
<p id="line6">
<font face="STCAIYUN" color="#883958" size="4">关于微信小程序</font>
</p>

<p><strong>小程序是什么？它有着什么样的功能？</strong></p>
<p>A：小程序是一种不需要下载安装即可使用的应用，用户扫一扫或者搜一下即可打开应用。也体现了 “用完即走” 的理念，通过公众号关联，用户可以实现公众号与小程序之间相互跳转。</p>
<p><strong>小程序可以和现有的 App 打通吗？</strong></p>
<p>A：小程序可以借助微信联合登录，和开发者已有的 App 后台的用户数据进行打通，但不会支持小程序和 App 直接的跳转，<font face="STCAIYUN" color="red" size="4">现在最新版已经支持小程序跳转到另一个小程序了</font></p>
<p id="line5">
<font face="STCAIYUN" color="#883958" size="4">小程序与传统 HTML5 的区别</font>
</p>

<ul>
<li><p><strong>开发工具不同</strong><br>区别于 H5 的开发工具 + 浏览器 Device Mode 预览的模式，小程序的开发基于自己的开发者工具，可以实现同步本地文件 + 开发调试 + 编译 + 预览 + 上传 + 发布等一整套流程。</p>
</li>
<li><p><strong>开发语言不同</strong><br>小程序自己开发了一套 WXML 标签语言和 WXSS 样式语言，并非直接使用标准的 HTML5+css3。</p>
</li>
<li><p><strong>组件封装不同</strong><br>小程序独立出来了很多原生 APP 的组件，在 HTML5 需要模拟才能实现的功能，小程序里可以直接调用组件。</p>
</li>
</ul>
<p>传统 HTML5 在加载的时候受限于网络环境，需要顺序加载 HTML、CSS、JS，然后返回数据，最后渲染页面显示在浏览器中</p>
<p>小程序的两个线程：逻辑层和视图层会同时进行、并行加载，甚至视图层会更早执行，当视图线程加载完，通知逻辑层，逻辑层会把准备好的数据用 setData 的方法返回给视图线程</p>
<p id="line1">
<font face="STCAIYUN" color="#883958" size="4">目录结构与配置</font>
</p>

<p><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html">官方框架配置</a></p>
<p>小程序包含一个描述整体程序的 app 和多个描述各个页面的 page<br>小程序的主体部分由三个文件组成 必须放在<font face="STCAIYUN" color="#883958" size="3">项目的根目录</font>下</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">app.js 小程序入口逻辑</span><br><span class="line">app.json 小程序的公共设置</span><br><span class="line">对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等</span><br><span class="line">app.wxss 小程序的公共样式表</span><br></pre></td></tr></tbody></table></figure>

<p>一个程序页面由四个页面组成</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">wxml 页面结构</span><br><span class="line">wxss 页面的样式表 （不必填）</span><br><span class="line">json 页面的配置 （不必填）</span><br><span class="line">js   页面逻辑</span><br></pre></td></tr></tbody></table></figure>

<font face="STCAIYUN" color="#83933b" size="3">
为了方便开发者减少配置项，我们规定描述页面的这四个文件必须具有相同的路径与文件名。</font>

<p id="line2">
<font face="STCAIYUN" color="#883958" size="4">逻辑层</font>
</p>

<p>小程序开发框架的逻辑层是由<font face="STCAIYUN" color="#83933b" size="3"> Javascript</font> 编写的<br>逻辑层将数据进行处理后发送给视图层，同时接收视图层的反馈，为了方便开发 小程序做了以下更改</p>
<ol>
<li><p><font face="STCAIYUN" color="#83933b" size="3">增加 APP 和 Page 方法，进行程序和页面的注册</font></p>
<p>APP () 函数用来注册一个小程序 接受一个 object 参数 也就是小程序的生命周期函数</p>
</li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">onLaunch	监听小程序初始化 当小程序初始化完成时，会触发 onLaunch（全局只触发一次）</span><br><span class="line">onShow		生命周期函数--监听小程序显示	当小程序启动，或从后台进入前台显示，会触发 onShow</span><br><span class="line">onHide		生命周期函数--监听小程序隐藏	当小程序从前台进入后台，会触发 onHide</span><br><span class="line"></span><br><span class="line">前台、后台定义： 当用户点击左上角关闭，或者按了设备 Home 键离开微信，小程序并没有直接销毁，而是进入了后台；当再次进入微信或再次打开小程序，又会从后台进入前台。需要注意的是：只有当小程序进入后台一定时间，或者系统资源占用过高，才会被真正的销毁。</span><br><span class="line"></span><br><span class="line">onError		错误监听函数	当小程序发生脚本错误，或者 api 调用失败时，会触发 onError 并带上错误信息</span><br><span class="line">当然了 开发者也可以添加任意的函数或数据到 Object 参数中，用 this 可以访问比如点击 长按 事件等</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>  Page () 函数用来注册一个页面 接受一个 object 参数 其指定页面的初始数据、生命周期函数、事件处理函数等。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">data		            页面的初始数据</span><br><span class="line">onLoad(query)		   生命周期函数--监听页面加载</span><br><span class="line">onReady		         生命周期函数--监听页面初次渲染完</span><br><span class="line">onShow		         生命周期函数--监听页面显示</span><br><span class="line">onHide		         生命周期函数--监听页面隐藏</span><br><span class="line">onUnload		         生命周期函数--监听页面卸载</span><br><span class="line">onPullDownRefresh		页面相关事件处理函数--监听用户下拉</span><br><span class="line">onReachBottom		   页面上拉触底事件的处理函数</span><br><span class="line">onShareAppMessage		用户点击右上角转发</span><br><span class="line">onPageScroll(scrollTop)		   页面滚动触发事件的处理函数 参数代表页面垂直方向已经滚动的距离</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">route 字段可以获取到当前页面的路径。</span><br><span class="line">注册函数里 console.log('this.route',this.route)</span><br><span class="line"></span><br><span class="line">setData 函数以key value 的形式接收一个对象 用于将数据从逻辑层发送到视图层，改变对应的 this.data中相应key的值。</span><br><span class="line">set的值不需要在this.data中预先定义</span><br><span class="line"></span><br><span class="line">    this.setData({</span><br><span class="line">      name:'马莹'</span><br><span class="line">    })</span><br><span class="line">    console.log('this.data',this.data)</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line"></span><br><span class="line">    直接修改 this.data 而不调用 this.setData 是无法改变页面的状态的，还会造成数据不一致</span><br><span class="line">    单次设置的数据不能超过1024kB，请尽量避免一次设置过多的数据。</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<ol start="2">
<li><p><font face="STCAIYUN" color="#83933b" size="3">增加 getAPP 和 getCurrentPages 方法，分别用来获取 App 实例和当前技术栈</font></p>
<p>可以根据全局函数获取到小程序的实例</p>
</li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var appInstance = getApp()</span><br><span class="line">console.log(appInstance.globalData)</span><br><span class="line"></span><br><span class="line">console.log('getCurrentPages()',getCurrentPages())</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><font face="STCAIYUN" color="#b36666" size="3">小 tips：</font></p>
<ul>
<li><p> <code>App()</code> 必须在 app.js 中注册，只能注册一次</p>
</li>
<li><p> 在定义在 <code>APP()</code> 的函数中想获取 app 实例，不要用<code> getApp()</code> 的方式 直接用<font face="STCAIYUN" color="#b36666" size="3"> this</font> 就行</p>
</li>
<li><p>不要在 onLaunch 的时候调用 <code>getCurrentPages()</code>，此时 page 还没有生成</p>
<br>
3 . <font face="STCAIYUN" color="#83933b" size="3">每个页面有独立的作用域，并提供模块化的能力</font>

<p>  在 javascript 文件中声明的变量和函数只是在该文件中有效</p>
<p>   我们可以将一些公共的代码抽离成为一个单独的 js 文件，作为一个模块。模块只有通过 module.exports 或者 exports 才能对外暴露接口。</p>
<pre><code>  需要注意的是：

  exports 是 module.exports 的一个引用，因此在模块里边随意更改 exports 的指向会造成未知的错误。所以我们更推荐开发者采用 module.exports 来暴露模块接口，除非你已经清晰知道这两者的关系。
  小程序目前不支持直接引入 node_modules , 开发者需要使用到 node_modules 时候需要拷贝出相关的代码到小程序的目录中。</code></pre>
</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">function sayHello(name) {</span><br><span class="line">  console.log(`Hello ${name} !`)</span><br><span class="line">}</span><br><span class="line">function sayGoodbye(name) {</span><br><span class="line">  console.log(`Goodbye ${name} !`)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">module.exports.sayHello = sayHello</span><br><span class="line">exports.sayGoodbye = sayGoodbye</span><br><span class="line"></span><br><span class="line">引用</span><br><span class="line">var common = require('common.js')  require 暂时不支持绝对路径</span><br><span class="line">Page({</span><br><span class="line">  helloMINA: function() {</span><br><span class="line">    common.sayHello('MINA')</span><br><span class="line">  },</span><br><span class="line">  goodbyeMINA: function() {</span><br><span class="line">    common.sayGoodbye('MINA')</span><br><span class="line">  }</span><br><span class="line">})</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>4 .  <font face="STCAIYUN" color="#83933b" size="3">由于框架并非运行在浏览器中，所以 JavaScript 在 web 中一些能力都无法使用，如 document，window 等。 </font></p>
<p>5 . <font face="STCAIYUN" color="#83933b" size="3">开发者写的所有代码最终将会打包成一份 JavaScript，并在小程序启动的时候运行，直到小程序销毁， </font></p>
<p><strong>页面路由</strong><br>在小程序中所有页面的路由全部由框架进行管理。<br>框架以栈的形式维护了当前的所有页面。 当发生路由切换的时候，页面栈的表现如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">初始化-&gt; 新页面入栈</span><br><span class="line">打开新页面-&gt; 新页面入栈</span><br><span class="line">页面重定向-&gt; 当前页面出栈 新页面入栈</span><br><span class="line">页面返回-&gt; 页面不断出栈，直到目标返回页，新页面入栈</span><br><span class="line">Tab切换-&gt;  页面全部出栈 只留下新的Tab页面</span><br><span class="line">重加载-&gt;  页面全部出栈 只留下新的页面</span><br></pre></td></tr></tbody></table></figure>

<p> <font face="STCAIYUN" color="#b36666" size="3">小 tips：</font></p>
<ul>
<li> <code>navigateTo</code>, <code>redirectTo</code> 只能打开非 tabBar 页面。</li>
<li> switchTab 只能打开 tabBar 页面</li>
<li> reLaunch 可以打开任意页面</li>
<li>页面底部的 tabBar 由页面决定，即只要是定义为 tabBar 的页面，底部都有 tabBar。<p id="line3">
<font face="STCAIYUN" color="#883958" size="4">视图层</font>
</p>

</li>
</ul>
<p>**WXml **<br>WXML（WeiXin Markup Language）是框架设计的一套标签语言，结合基础组件、事件系统，可以构建出页面的结构。<br>WXML 在语法上更接近 XML 语言，遵循 SGML 规范，区别于 HTML 语言随意的标签闭合方式，<font face="STCAIYUN" color="#883958" size="4">WXML 语言必须包括开始标签和结束标签</font></p>
<p><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/">基本语法</a><br>WXML 中的动态数据均来自对应 Page 的 data。不同于 Vue 它是<code>单向绑定</code> 必须通过调用事件来 <code>setData</code> 新的数据</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;view&gt; {{ message }} &lt;/view&gt;</span><br><span class="line">Page({</span><br><span class="line">  data: {</span><br><span class="line">    message: 'Hello MINA!'</span><br><span class="line">  }</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">花括号和引号之间不能留空，否则将最终被解析成为字符串</span><br><span class="line"></span><br><span class="line">&lt;view wx:for="{{[1,2,3]}} "&gt;</span><br><span class="line">  {{item}}</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">等同于</span><br><span class="line"></span><br><span class="line">&lt;view wx:for="{{[1,2,3] + ' '}}" &gt;</span><br><span class="line">  {{item}}</span><br><span class="line">&lt;/view&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当 wx:for 的值为字符串时，会将字符串解析成字符串数组</span><br><span class="line">&lt;view wx:for="yishu"&gt;</span><br><span class="line">  {{item}}</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">===</span><br><span class="line">&lt;view wx:for="{{['y','i','s','h','u']}}"&gt;</span><br><span class="line">  {{item}}</span><br><span class="line">&lt;/view&gt;</span><br><span class="line"></span><br><span class="line">&lt;view wx:if="{{condition}}"&gt; &lt;/view&gt;</span><br><span class="line">&lt;view wx:if="{{length &gt; 5}}"&gt; &lt;/view&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">关键字 需要在双引号之内 checked="false"，其计算结果是一个字符串，转成 boolean 类型后代表真值。</span><br><span class="line">&lt;checkbox checked="{{false}}"&gt; &lt;/checkbox&gt;</span><br><span class="line"></span><br><span class="line">&lt;view hidden="{{flag ? true : false}}"&gt; Hidden &lt;/view&gt;</span><br><span class="line"></span><br><span class="line">条件渲染</span><br><span class="line">&lt;view wx:if="{{length &gt; 5}}"&gt; 1 &lt;/view&gt;</span><br><span class="line">&lt;view wx:elif="{{length &gt; 2}}"&gt; 2 &lt;/view&gt;</span><br><span class="line">&lt;view wx:else&gt; 3 &lt;/view&gt;</span><br><span class="line"></span><br><span class="line">如果想一次性判断多个组件标签  可以这么写</span><br><span class="line">&lt;block wx:if="{{true}}"&gt;</span><br><span class="line">  &lt;view&gt; view1 &lt;/view&gt;</span><br><span class="line">  &lt;view&gt; view2 &lt;/view&gt;</span><br><span class="line">&lt;/block&gt;</span><br><span class="line"> 是一个包装元素，不会在页面中做任何渲染，只接受控制属性。当然了 我是经常用View标签包裹的</span><br><span class="line"></span><br><span class="line"> 关于 wx:if 与 hidden</span><br><span class="line"> 简单来说 hidden为true的组件始终被渲染 只是切换 display与none状态</span><br><span class="line"> 而 wx:if只有在条件成立的情况下才会被真的渲染</span><br></pre></td></tr></tbody></table></figure>
<p>使用模版 模板拥有自己的作用域，只能使用 data 传入的数据。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;template name="msgItem"&gt;</span><br><span class="line">  &lt;view&gt;</span><br><span class="line">    &lt;text&gt; {{index}}: {{msg}} &lt;/text&gt;</span><br><span class="line">    &lt;text&gt; Time: {{time}} &lt;/text&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">引用</span><br><span class="line">&lt;template is="msgItem" data="{{...item}}"/&gt;</span><br></pre></td></tr></tbody></table></figure>
<p><strong>事件 （冒泡 非冒泡）</strong><br><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/event.html">事件 API</a><br>事件是视图层到逻辑层的通讯方式，当组件触发事件时，逻辑层绑定该事件的处理函数会收到一个事件对象。<br>冒泡事件<br>touchstart    手指触摸动作开始<br>touchmove    手指触摸后移动<br>touchcancel    手指触摸动作被打断，如来电提醒，弹窗<br>touchend    手指触摸动作结束<br>tap    手指触摸后马上离开<br>longtap 手指触摸后，超过 350ms 再离开</p>
<p><font face="STCAIYUN" color="#83933b" size="3">bind 事件绑定不会阻止冒泡事件向上冒泡，<br>catch 事件绑定可以阻止冒泡事件向上冒泡。</font></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">视图层</span><br><span class="line">&lt;view id="tapTest" data-hi="WeChat" bindtap="tapName"&gt; Click me! &lt;/view&gt;</span><br><span class="line">逻辑层</span><br><span class="line">Page({</span><br><span class="line">  tapName: function(event) {</span><br><span class="line">    console.log(event)</span><br><span class="line">  }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p><strong>文件引入</strong><br>WXML 提供两种文件引用方式 import 和 include。</p>
<p>import 可以在该文件中使用目标文件定义的 template</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;!-- item.wxml --&gt;</span><br><span class="line">&lt;template name="item"&gt;</span><br><span class="line">  &lt;text&gt;{{text}}&lt;/text&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">引入模版</span><br><span class="line">&lt;import src="item.wxml"/&gt;</span><br><span class="line">&lt;template is="item" data="{{text: 'forbar'}}"/&gt;</span><br></pre></td></tr></tbody></table></figure>

<p><code>import</code> 有作用域的概念，即只会<br><font face="STCAIYUN" color="#83933b" size="3">import 目标文件中定义的 template，而不会 import 目标文件 import 的 template。</font></p>
<p><code>include</code> 可以将目标文件除了 <code>&lt;template/&gt;</code> 的整个代码引入 也就是说 copy 到了当前引入的位置</p>
<p><strong>WXSS</strong><br>WXSS (WeiXin Style Sheets) 是一套样式语言，用于描述 WXML 的组件样式。</p>
<p>WXSS 支持的单位有 <code>px、rem和rpx</code>，其中 rem 和 rpx 可以针对屏幕容器进行适配，px 则为固定尺寸。<br>其中 <code>1rpx=0.5px</code>，在 WXSS 和 WXML 中定义的 rpx 单位最终会转换为在手机端可以识别的 <code>rem</code> 单位。</p>
<p><strong>建议</strong>：<font face="STCAIYUN" color="red" size="3">开发微信小程序时设计师可以用 iPhone6 作为视觉稿的标准。<br>我们拿到 750 的设计稿，在 PS 中量取的容器大小，可以直接定义为 rpx，不需要进行 2 倍尺寸的换算，rpx 的单位不光在样式中会自适应，写在 WXML 的 style 里也会根据屏幕自适应。</font></p>
<p>像 CSS 一样 可以使用 <code>@import</code> 语句可以导入外联样式表，@import 后跟需要导入的外联样式表的<font face="STCAIYUN" color="#83933b" size="3"> 相对路径</font></p>
<p><code>import "../../wxss/common.wxss";</code></p>
<p>为了提高渲染速度尽量避免静态样式存在于 style 中，除非需要接收动态样式才应该写在行内<font face="STCAIYUN" color="#83933b" size="3">（貌似说了一句废话）</font></p>
<p><code>&lt;view style="color:{{color}};" /&gt;</code></p>
<p>全局样式与局部样式<br>全局样式都在 <code>app.wxss </code>中定义 page 里的 wxss 文件定义的是局部样式 局部样式可以覆盖同名的全局样式</p>
<p id="line4">
<font face="STCAIYUN" color="#883958" size="4">运行机制</font>
</p>

<ul>
<li>小程序没有重启的概念</li>
<li>当小程序进入后台，客户端会维持一段时间的运行状态，超过一定的时间后会自动销毁（目前是五分钟）</li>
<li>置顶的小程序不会被微信主动销毁</li>
<li>当收到内存警号时小程序会销毁</li>
</ul>
]]></content>
      <tags>
        <tag>wechat</tag>
      </tags>
  </entry>
  <entry>
    <title>揭秘 setState 机制</title>
    <url>/2018/11/23/%E6%8F%AD%E7%A7%98setState%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>前言：state 是 react 中重要的概念， react 是通过管理状态来实现对组件的管理，那么 react 是如何控制组件的状态 又是如何利用状态来管理组件的呢？</p>
<p>我们所知道的版本 大概是 通过 <code>this.state</code> 来访问 <code>state</code>，通过 <code>setState()</code> 方法来更新 <code>state</code>，当 <code>this.state()</code> 被调用的时候 <code>React</code> 会重新调用 <code>render</code> 方法来重新渲染 <code>UI</code></p>
<p>那好的 先来看一道题吧</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">export default class SetState extends React.Component {</span><br><span class="line">    constructor(){</span><br><span class="line">        super();</span><br><span class="line">        this.state = {</span><br><span class="line">            val:0</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    componentWillMount(){</span><br><span class="line">        this.setState({val:this.state.val+1});</span><br><span class="line">        console.log('componentWillMount第一次输出',this.state.val)</span><br><span class="line">        this.setState({val:this.state.val+1});</span><br><span class="line">        console.log('componentWillMount第二次输出',this.state.val)</span><br><span class="line">    }</span><br><span class="line">    componentDidMount(){</span><br><span class="line">        // debugger;</span><br><span class="line">        this.setState({val:this.state.val+1});</span><br><span class="line">        console.log('componentDidMount第一次输出',this.state.val)</span><br><span class="line">        this.setState({val:this.state.val+1});</span><br><span class="line">        console.log('componentDidMount第二次输出',this.state.val)</span><br><span class="line">        setTimeout(()=&gt;{</span><br><span class="line">            // debugger;</span><br><span class="line">            console.log('开始setTimeout',this.state.val)</span><br><span class="line">            this.setState({val:this.state.val+1});</span><br><span class="line">            console.log('第三次输出',this.state.val) </span><br><span class="line"></span><br><span class="line">            this.setState({val:this.state.val+1});</span><br><span class="line">            console.log('第四次输出',this.state.val) </span><br><span class="line">        },0)</span><br><span class="line">    }</span><br><span class="line">   </span><br><span class="line">    render(){</span><br><span class="line">        return null;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>
<p>这道题的答案是 <code>0 0 1 1 2 3 4</code></p>
<p>假如结果与你心中的答案并不完全相同，那么你应该感兴趣这背后究竟发生了什么.</p>
<a id="more"></a>
<h2 id="了解setState"><a href="#了解setState" class="headerlink" title="了解setState"></a>了解 setState</h2><ol>
<li>setState 是同步执行的 但是 state 并不一定会同步更新（异步更新）</li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">实际上react的异步更新通过一个队列机制来实现，当执行state时 需要将更新的state合并后放入状态队列而不会立刻更新 队列机制可以高效的批量更新state 如果在非构造方法里更改值  类似 this.state.name='yishu' 是不会被放到状态队列中 当下次调用setState并对状态队列进行合并时 将会忽略它而造成无法预知的错误</span><br></pre></td></tr></tbody></table></figure>
<ol start="2">
<li>setState 在 React 生命周期和合成事件中批量覆盖执行 </li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">在React的生命周期钩子和合成事件中，多次执行setState，会批量执行，多次同步执行的setState，会进行合并，类似于Object.assign</span><br></pre></td></tr></tbody></table></figure>

<ol start="3">
<li>setState 在原生事件，setTimeout，setInterval，Promise 等异步操作中，state 会同步更新 </li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">当执行到 setTimeout 的时候，把它丢到列队里，并没有去执行，而是先执行的 finally 主进程代码块，等 finally 执行完了， isBatchingUpdates 又变为了 false ，导致最后去执行队列里的 setState 时候， requestWork 走的是和原生事件一样的 expirationTime === Sync if分支，所以表现就会和原生事件一样，可以同步拿到最新的state的值。</span><br></pre></td></tr></tbody></table></figure>

<p>关于 setState 这个方法 源码记载</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">ReactComponent.prototype.setState = function(partialState, callback) {</span><br><span class="line">  //...</span><br><span class="line">  this.updater.enqueueSetState(this, partialState);</span><br><span class="line">  if (callback) {</span><br><span class="line">    this.updater.enqueueCallback(this, callback, 'setState');</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">  enqueueSetState: function(publicInstance, partialState) {</span><br><span class="line">  //...</span><br><span class="line">    var queue =internalInstance._pendingStateQueue ||</span><br><span class="line">      (internalInstance._pendingStateQueue = []);</span><br><span class="line">    queue.push(partialState);</span><br><span class="line"></span><br><span class="line">    enqueueUpdate(internalInstance);</span><br><span class="line">  },</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>setState 方法实际上会执行 <code>enqueueSetState</code> 方法 通过<code>_pendingStateQueue</code> 更新队列进行合并操作 最终通过 <code>enqueueUpdate</code> 执行 state 更新</p>
<h2 id="setState调用栈"><a href="#setState调用栈" class="headerlink" title="setState调用栈"></a>setState 调用栈</h2><p><img src="/images/setState/setState1.png"></p>
<p>如图：通过变量 isBatchingUpdate 来决定当前是应该走批量更新 还是立即更新 为 true 时 说明当前在批量更新模式 为 false 的话 会立即更新</p>
<p>为了更好的理解 涉及到部分源码</p>
<p>enqueueUpdate 代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">function enqueueUpdate(component) {</span><br><span class="line"></span><br><span class="line">  // 如果不处于批量更新模式 更新</span><br><span class="line">  if (!batchingStrategy.isBatchingUpdates) {</span><br><span class="line">batchingStrategy.batchedUpdates(enqueueUpdate, component);</span><br><span class="line">    return;</span><br><span class="line">  }</span><br><span class="line">  // 如果处于批量更新模式 则将该组件保存在 dirtyComponents 中</span><br><span class="line">  dirtyComponents.push(component);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>那么这个 <code>batchingStrategy</code> 究竟是做什么的？ 其实它只是一个简单的对象，定义了 isBatchingUpdates 和 batchedUpdates 方法 其中 transaction.perform 的调用 涉及到了<font color="red">事务</font>的概念</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">// batchedUpdates 方法</span><br><span class="line">var ReactDefaultBatchingStrategy = {</span><br><span class="line">  isBatchingUpdates: false,</span><br><span class="line"></span><br><span class="line">   batchedUpdates: function(callback, a, b, c, d, e) {</span><br><span class="line">    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;</span><br><span class="line"></span><br><span class="line">    ReactDefaultBatchingStrategy.isBatchingUpdates = true;</span><br><span class="line"></span><br><span class="line">    if (alreadyBatchingUpdates) {</span><br><span class="line">      callback(a, b, c, d, e);</span><br><span class="line">    } else {</span><br><span class="line">      transaction.perform(callback, null, a, b, c, d, e);</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="事务机制"><a href="#事务机制" class="headerlink" title="事务机制"></a>事务机制</h2><p>事务就是将需要执行的方法使用 wrapper 封装起来 再通过事务提供的 perform 方法执行<br><img src="/images/setState/setState2.png"><br>执行 perform 之前 先执行  wrapper 中的 init 方法 执行完 perform 之后 再执行 所有的 close 方法<br>假如有一个事务 test 执行顺序表现为 </p>
<p><code>init-&gt;test-&gt;close</code></p>
<h2 id="揭秘setState机制"><a href="#揭秘setState机制" class="headerlink" title="揭秘setState机制"></a>揭秘 setState 机制</h2><p>那么 说了这么多，事务是怎么导致前面所述的 setState 的各种不同表现呢.</p>
<p>在整个 React 组件渲染到 Dom 中的过程就处于一个大的事务中 ，在生命周期和合成事件执行前后都会执行 init 和 close，init 会调用 batchedUpdate 方法将 isBatchingUpdates 变量置为 true，开启批量更新，而 close 会将 isBatchingUpdates 置为 false，setState 的更新会被存入队列中，待同步代码执行完后，再执行队列中的 state 更新。</p>
<p>而在原生事件和异步操作中，不会执行 pre 钩子，或者生命周期的中的异步操作之前执行了 pre 钩子，但是 pos 钩子也在异步操作之前执行完了，isBatchingUpdates 必定为 false，也就不会进行批量更新</p>
<h2 id="获取正确的state值"><a href="#获取正确的state值" class="headerlink" title="获取正确的state值"></a>获取正确的 state 值</h2><p>以下：</p>
<ol>
<li>setState 函数式</li>
<li>放到 setTimeout，Promise 等异步中执行</li>
<li>放到 componentDidUpdate 中</li>
</ol>
<h2 id="说在最后的话"><a href="#说在最后的话" class="headerlink" title="说在最后的话"></a>说在最后的话</h2><p>所以 开篇的结果应该可以理解了吧</p>
<p>我们把 didMount 中四次调用归类，前两次一类 因为它们在同一个调用栈中执行 setTimeout 中的两次属于另一类，我们重点看第一类，早在 setState 调用之前  ReactDefaultBatchingStrategy.isBatchingUpdates 已经被设置为 true，所以两次的 setSate 并没有生效 而是被放进了队列中<br>再看 setTimeout 中的两次 state 此时的 isBatchingUpdates 为 false，这也就导致了心的 state 马上生效 没有走到队列的分支（可参考调用栈图）也就是说 第一次执行 setState 时 值就为 1 加 1 之后变为 2 第二次打印同理</p>
<p>参考：深入 react 技术栈一书 希望通过 setState 深入源码 知其然也知其所以然</p>
]]></content>
      <categories>
        <category>react</category>
      </categories>
  </entry>
  <entry>
    <title>彻底理解 js 是如何工作的</title>
    <url>/2018/11/17/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3js%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/</url>
    <content><![CDATA[<p>曾经 你一定遇到过类似这样儿的题目</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">console.log('script start')</span><br><span class="line"></span><br><span class="line">setTimeout(function() {</span><br><span class="line">    console.log('timer over')</span><br><span class="line">}, 0)</span><br><span class="line"></span><br><span class="line">Promise.resolve().then(function() {</span><br><span class="line">    console.log('promise1')</span><br><span class="line">}).then(function() {</span><br><span class="line">    console.log('promise2')</span><br><span class="line">})</span><br><span class="line">console.log('script end')</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">script start</span><br><span class="line">script end</span><br><span class="line">promise1</span><br><span class="line">promise2</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>如果你很轻松的答对并且能说出原理 那么恭喜你，倘若有些疑问，那么读完这篇文章，你一定会彻底搞懂它的运行原理。</p>
<a id="more"></a>

<h3 id="首先-先了解几个概念"><a href="#首先-先了解几个概念" class="headerlink" title="首先  先了解几个概念"></a>首先  先了解几个概念</h3><blockquote>
<p>JavaScript 引擎</p>
</blockquote>
<p>js 引擎是执行 js 的程序或者解释器 我们常说的 V8 引擎就是一种 js 引擎的实现，其他的还有基于 <code>java</code> 开发的 <code>Rhin</code> <code>Nashorn</code> 等</p>
<p>V8 引擎 使用在 chrome 和 node 中，它由两部分组成</p>
<ul>
<li>内存堆 ：这是内存分配发生的地方</li>
<li>调用栈： 这是你的代码执行时的地方</li>
</ul>
<hr>
<blockquote>
<p>JS 的特性</p>
</blockquote>
<p><font color="red">单线程 异步 非阻塞</font></p>
<p><strong>js 的单线程</strong><br>由于 js 的单线程</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">console.log('script start')</span><br><span class="line">console.log('do something...')</span><br><span class="line">console.log('script end')</span><br><span class="line"></span><br><span class="line">// script start</span><br><span class="line">// do something...</span><br><span class="line">// script end</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>很好理解</p>
<p>那再来看</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">console.log('1')</span><br><span class="line"></span><br><span class="line">console.log('2')</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; {</span><br><span class="line">  console.log('3')</span><br><span class="line">}, 1000)</span><br><span class="line"></span><br><span class="line">// 点击页面</span><br><span class="line">console.log('4')</span><br><span class="line"></span><br><span class="line">console.log('5')</span><br></pre></td></tr></tbody></table></figure>
<p>那么它的输出是什么呢？ 应该是 <code>1，2，4，5，3 </code>？ 而不是 <code>1，2，3，4，5</code>，js 不是一行一行从上到下执行的吗 为啥会出现这种情况？</p>
<p><strong>这就是我们接下来要说的问题</strong></p>
<p>为什么不能同步执行？</p>
<p>如果一个任务的处理耗时（或者是等待）很久的话，如：网络请求、定时器、等待鼠标点击等，后面的任务也就会被阻塞，可能会出现白屏的情况 用户体验极其不友好</p>
<p>所幸的是 浏览器给我们提供了很多有用的 <code>webapi</code></p>
<p>如何优化？</p>
<p>js 的单线程指的是浏览器中负责解释和执行 js 代码的只有一个线程 -js 引擎线程 但是浏览器的渲染进程是提供多个线程的，遇到定时器 Dom 事件或者是网络请求的任务的时候 js 引擎会将他们交给 webapi 也就是浏览器提供的相应线程去处理 而 js 引擎线程继续去处理后面的任务 这样儿实现了<strong>异步非阻塞</strong><br>以下是日常线程：</p>
<ul>
<li>js 引擎线程</li>
<li>事件触发线程</li>
<li>定时器触发线程</li>
<li>异步 HTTP 请求线程</li>
<li> GUI 渲染线程</li>
</ul>
<p>图示的话 大概长下面这样儿<br><img src="/images/jsWorker/jsworker.jpg" alt="jsworke"><br>所以 这里的 图例中的 <code>setTimeout</code> 会被分配到定时器触发线程去维护 去定时，时间一到 还是会把它的回调塞到<code>消息队列</code>等待</p>
<p>那么 到这里 又引出了两个问题<br>1. 什么叫消息队列？<br>2.js 引擎什么时候处理这个定时器 怎么处理？</p>
<p>JavaScript 通过事件循环（ event loop）的机制来解决这些问题<br>猜对了吗？<br>事件循环 机制和 消息队列 的维护是由<strong>事件触发线程</strong>（浏览器渲染引擎 webapi 之一）控制的</p>
<p>JS 引擎线程 会维护一个 执行栈</p>
<ol>
<li>同步和异步任务进入不同的执行场所 同步的进入<strong>主线程</strong> 异步的进入 Event Table 并注册函数</li>
<li>当指定的事情完成时 Event Table 会将这个函数移入 <strong>Event Queue</strong></li>
<li> 主线程内的任务执行完毕为空，会去 <strong>Event Queue</strong> 读取对应的函数，进入主线程执行</li>
<li>上述过程会不断重复，也就是常说的 <strong>Event Loop</strong>(事件循环)。</li>
</ol>
<p>言语太过苍白 举个🌰～</p>
<p><img src="/images/jsWorker/jswork2.jpg" alt="jswork2"></p>
<p>所以 这个时候来看<br>setTimeout 异步函数对应的回调函数 (() =&gt; {} ) 会在执行栈为空，主代码块执行完了后才会执行</p>
<p>结果就不意外了吧</p>
<p>那么 像这样</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">setTimeout(() =&gt; {</span><br><span class="line">  console.log('timer')</span><br><span class="line">}, 0)</span><br></pre></td></tr></tbody></table></figure>
<p>0 延时的情况是啥意思呢<br>只是 timer 的回调函数会立即加入消息队列而已，回调的执行还是得等执行栈为空（JS 引擎线程空闲）时执行。</p>
<p>还没完～～</p>
<p>ES5 中以上标准就够用了 但是 ES6 中新出了一些 API 引出了一些新概念</p>
<blockquote>
<p>宏任务与微任务</p>
</blockquote>
<p>先来看一段代码 你能立刻说出它的执行结果吗</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">console.log('script start')</span><br><span class="line"></span><br><span class="line">setTimeout(function() {</span><br><span class="line">    console.log('timer over')</span><br><span class="line">}, 0)</span><br><span class="line"></span><br><span class="line">Promise.resolve().then(function() {</span><br><span class="line">    console.log('promise1')</span><br><span class="line">}).then(function() {</span><br><span class="line">    console.log('promise2')</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">console.log('script end')</span><br><span class="line"></span><br><span class="line">// script start</span><br><span class="line">// script end</span><br><span class="line">// promise1</span><br><span class="line">// promise2</span><br><span class="line">// timer over</span><br></pre></td></tr></tbody></table></figure>
<p>What？ timer over 会在 promise1 promise2 之后执行？</p>
<p>好的 不要着急 往下看👇<br>所有任务分为 <code>宏任务</code> 和 <code>微任务</code></p>
<ul>
<li>宏任务（macrotask）：主代码块、setTimeout、setInterval 等（可以看到，事件队列中的每一个事件都是一个 macrotask，现在称之为宏任务队列</li>
<li>微任务（microtask）：Promise、process.nextTick 等 在 microtask 中 process.nextTick 优先级高于 Promise，它用来调度应在当前执行的脚本执行结束后立即执行的任务</li>
</ul>
<p>事件（任务）队列和宏任务和微任务的联系：</p>
<ul>
<li>一个事件循环有一个或者多个任务队列；</li>
<li>每个事件循环都有一个 microtask 队列</li>
<li> macrotask 队列就是我们常说的任务队列，microtask 队列不是任务队列</li>
<li>一个任务可以被放入到 macrotask 队列，也可以放入 microtask 队列</li>
<li>当一个任务被放入 microtask 或者 macrotask 队列后，准备工作就已经结束，这时候可以开始执行任务了</li>
</ul>
<p>js 的执行规则：</p>
<ol>
<li>执行一个宏任务（栈中没有就从事件队列中获取）</li>
<li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</li>
<li>宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）</li>
<li>当前宏任务执行完毕，开始检查渲染，然后 GUI 线程接管渲染</li>
<li>渲染完毕后，JS 引擎线程继续，开始下一个宏任务（从宏任务队列中获取）</li>
</ol>
<p>所以 promise1 与 promise1 属于微任务 会在第一个宏任务结束之后立即执行 而 setTimeout 即使延时为 0 也是要等到下个事件循环去执行的😊</p>
<p>再简单点的话 那就</p>
<p>macro-task 队列包含任务: a1, a2 , a3<br>micro-task 队列包含任务: b1, b2 , b3</p>
<p>执行顺序为，首先执行 marco-task 队列开头的任务，也就是 a1 任务，执行完毕后，在执行 micro-task 队列里的所有任务，也就是依次执行 b1, b2 , b3，执行完后清空 micro-task 中的任务，接着执行 marco-task 中的第二个任务，依次循环。</p>
<p>再简单点的话 那就.. 上图吧😄</p>
<p><img src="/images/jsWorker/jsworker3.jpg" alt="jsworke">s</p>
<p>好的 理解的话 再来一个栗子 你可能继续懵逼</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">setTimeout(function(){console.log(1)},0);</span><br><span class="line"></span><br><span class="line">new Promise(function(resolve,reject){</span><br><span class="line">   console.log(2);</span><br><span class="line">   resolve();</span><br><span class="line">}).then(function(){console.log(3)</span><br><span class="line">}).then(function(){console.log(4)});</span><br><span class="line"></span><br><span class="line">process.nextTick(function(){console.log(5)});</span><br><span class="line"></span><br><span class="line">console.log(6);</span><br><span class="line">输出 2，6，5 ，3，4，1</span><br></pre></td></tr></tbody></table></figure>
<p>定义 promise 的构造部分是同步的<br>如下<br>script (主程序代码)——&gt;process.nextTick——&gt;promise——&gt;setTimeout</p>
<p>关于 process.nextTick ()<br>插入到事件队列尾部，但在下次事件队列之前会执行。也就是说，它指定的任务总是发生在所有异步任务之前，当前主线程的末尾。<br>大致流程：当前” 执行栈” 的尾部–&gt; 下一次 Event Loop（主线程读取” 任务队列”）之前–&gt; 触发 process 指定的回调函数。<br>服务器端 node 提供的办法。用此方法可以用于处于异步延迟的问题。<br>可以理解为：此次不行，预约下次优先执行。</p>
<p>好的 再再来一个😂</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">setTimeout(function(){console.log(1)},0); （setTimeout1）</span><br><span class="line"></span><br><span class="line">new Promise(function(resolve,reject){</span><br><span class="line">   console.log(2);  （promise1）</span><br><span class="line">   setTimeout(function(){resolve()},0) （setTimeout2）</span><br><span class="line">}).then(function(){console.log(3)  （then1）</span><br><span class="line">}).then(function(){console.log(4)}); （then2）</span><br><span class="line"></span><br><span class="line">process.nextTick(function(){console.log(5)}); （nextTick）</span><br><span class="line"></span><br><span class="line">console.log(6); （log）</span><br><span class="line">输出： 2 6 5 1 3 4</span><br></pre></td></tr></tbody></table></figure>

<p>区别在于 promise 的构造中，没有同步的 resolve，因此 promise.then 在当前的执行队列中是不存在的，只有 promise 从 pending 转移到 resolve，才会有 then 方法，而这个 resolve 是在一个 setTimout 时间中完成的，因此 3,4 最后输出。</p>
<p>写到这里 想到一个某位大师的很形象的例子</p>
<p>事件循环队列就类似于游乐园游戏，玩过了一个游戏之后 你需要到队尾去排队才能再玩一次 而任务队列类似 w 玩过了这个游戏之后 插队接着玩<br>看到这里 文章开头的题目应该不成问题了 甚至还觉得 so easy</p>
<p>好的 到这里 就完了 下面是两个js 运行时的概念 你可以傲娇的略过</p>
<hr>
<blockquote>
<p>js 执行时</p>
</blockquote>
<p>js 调用栈</p>
<p>拥有 LIFO（后进先出）数据结构的栈，被用来存储代码运行时创建的所有<strong>执行上下文</strong>，记录了我们在程序中的位置  如果我们运行到一个函数 它就会将其放到栈顶 当从这个函数返回的时候，就会将这个函数从栈顶弹出，这就是调用栈做的事情</p>
<p>当 <code>JavaScript</code> 引擎第一次遇到你的脚本时，它会创建一个全局的执行上下文并且压入当前执行栈。每当引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部。</p>
<p>引擎会执行那些执行上下文位于栈顶的函数。当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文</p>
<hr>
<blockquote>
<p>js 执行上下文</p>
</blockquote>
<p>执行上下文是评估和执行 js 代码的环境的抽象概念<br>js 代码在执行的时候 它都是在执行上下文中运行</p>
<p>它分为三种类型</p>
<ol>
<li>全局执行上下文 </li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">它会执行两件事： 创建一个全局window对象 并且设置this的值等于这个全局对象 一个程序中只会有一个全局执行上下文</span><br></pre></td></tr></tbody></table></figure>
<ol start="2">
<li>函数执行上下文 </li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">函数被调用时候 会创建上下文，函数上下文可以有任意多个  每当一个新的执行上下文被创建 它会按定义的顺序 执行一系列步骤</span><br></pre></td></tr></tbody></table></figure>
<ol start="3">
<li>eval 函数执行上下文 </li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">执行在eval函数内部的代码会有他自己的执行上下文</span><br></pre></td></tr></tbody></table></figure>

<p><strong>js 如何创建执行上下文</strong></p>
<p>两个阶段</p>
<ul>
<li>创建阶段</li>
<li>执行阶段</li>
</ul>
<p>代码执行栈 执行上下文经历创建阶段 会发生</p>
<ol>
<li>this 值的制定</li>
<li>创建词法环境组件</li>
<li>创建变量环境组件</li>
</ol>
<hr>
<p>最后的最后</p>
<p>JavaScript 是单线程语言，决定于它的设计最初是用来处理浏览器网页的交互。浏览器负责解释和执行 JavaScript 的线程只有一个（所以说是单线程），即 JS 引擎线程，但是浏览器同样提供其他线程，如：事件触发线程、定时器触发线程等</p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>深入理解 Javascript 系列二：揭秘命名函数表达式</title>
    <url>/2018/03/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3js%E7%B3%BB%E5%88%97%E4%BA%8C/</url>
    <content><![CDATA[<p><a href="http://www.cnblogs.com/TomXu/archive/2011/12/29/2290308.html">汤姆大叔的原文链接</a></p>
<a id="more"></a>
<h2 id="函数表达式-和函数声明"><a href="#函数表达式-和函数声明" class="headerlink" title="函数表达式 和函数声明"></a>函数表达式 和函数声明</h2><h4 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">function 函数名称（可选）（参数：可选）{函数体}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">function 函数名称（参数：可选）{函数体}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="如何区分两者"><a href="#如何区分两者" class="headerlink" title="如何区分两者"></a>如何区分两者</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">函数表达式：不声明函数名称和声明了函数名称的其他情况</span><br><span class="line">          如果 function foo(){} 是作为赋值表达式的一部分的话</span><br><span class="line">          像这样：</span><br><span class="line">           1.var bar = function foo(){}; // 表达式，因为它是赋值表达式的一部分</span><br><span class="line">           2.new function bar(){}; // 表达式，因为它是new表达式</span><br><span class="line">           3.被括号括住的(function foo(){})他是表达式的原因是因为括号 ()是一个分组操作符，它的内部只能包含表达式</span><br><span class="line">            (function foo(){}); // 函数表达式：包含在分组操作符内</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">函数声明：声明了函数名称且function foo(){} 被包含在一个函数体内（规则：只能出现在程序或函数体内）</span><br><span class="line">            像这样</span><br><span class="line">            (function(){</span><br><span class="line">                function bar(){} // 声明，因为它是函数体的一部分</span><br><span class="line">            })();</span><br><span class="line">        或者位于程序最顶部的话</span><br><span class="line">        像这样</span><br><span class="line">        function foo(){} // 声明，因为它是程序的一部分</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h4 id="一些特性"><a href="#一些特性" class="headerlink" title="一些特性"></a>一些特性</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">函数声明:会在任何表达式被解析和求值之前先被解析和求值 即使你的声明在最后一行 它也会在同作用域内的第一个表达式之前被解析/求值</span><br></pre></td></tr></tbody></table></figure>
<h4 id="函数语句"><a href="#函数语句" class="headerlink" title="函数语句"></a>函数语句</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">函数语句不是在变量初始化期间声明的，而是在运行时声明的——与函数表达式一样。不过，函数语句的标识符一旦声明能在函数的整个作用域生效了。标识符有效性正是导致函数语句与函数表达式不同的关键所在</span><br><span class="line"></span><br><span class="line">// 此刻，foo还没用声明</span><br><span class="line">    console.log('typeof foo1',typeof foo)// "undefined"</span><br><span class="line"></span><br><span class="line">    if (true) {</span><br><span class="line">        // 进入这里以后，foo就被声明在整个作用域内了</span><br><span class="line">        function foo(){ console.log('11111') }</span><br><span class="line">    }</span><br><span class="line">    else {</span><br><span class="line">        // 从来不会走到这里，所以这里的foo也不会被声明</span><br><span class="line">        function foo(){ console.log('222') }</span><br><span class="line">    }</span><br><span class="line">    typeof foo; // "function"</span><br><span class="line">    console.log('typeof foo2',typeof foo)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h4 id="命名函数表达式"><a href="#命名函数表达式" class="headerlink" title="命名函数表达式"></a>命名函数表达式</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">命名函数表达式，理所当然，就是它得有名字，前面的例子var bar = function foo(){};就是一个有效的命名函数表达式，但有一点需要记住：这个名字只在新定义的函数作用域内有效， 这就是 与函数语句的区别</span><br><span class="line"></span><br><span class="line"> var f = function foo(){</span><br><span class="line">    return typeof foo; // foo是在内部作用域内有效</span><br><span class="line">  };</span><br><span class="line">  // foo在外部用于是不可见的</span><br><span class="line">  typeof foo; // "undefined"</span><br><span class="line">  f(); // "function"</span><br><span class="line"></span><br><span class="line">  命名函数表达式出现的意义：便于调试 调试器在调试的时候会将它的名字显示在调用的栈上</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Javascript 系列一：编写高质量代码的基本要点</title>
    <url>/2018/03/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3js%E7%B3%BB%E5%88%97%E4%B8%80/</url>
    <content><![CDATA[<p><a href="http://www.cnblogs.com/TomXu/archive/2011/12/28/2286877.html">汤姆大叔的原文链接</a></p>
<a id="more"></a>
<h2 id="书写可维护的代码"><a href="#书写可维护的代码" class="headerlink" title="书写可维护的代码"></a>书写可维护的代码</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">目标：可读的 一致的 可预测的 看上去就像是同一个人写的</span><br></pre></td></tr></tbody></table></figure>
<h2 id="js的变量问题"><a href="#js的变量问题" class="headerlink" title="js的变量问题"></a>js 的变量问题</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">js通过函数管理作用域</span><br><span class="line">在任何函数外面上声明的变量 或者 不声明就直接使用的（隐含的全局概念） 均为全局变量</span><br><span class="line"></span><br><span class="line">var uu; // 显式全局变量</span><br><span class="line">function sum(x, y) {</span><br><span class="line">   // 不推荐写法: 隐式全局变量</span><br><span class="line">   result = x + y;</span><br><span class="line">   return result;</span><br><span class="line">}</span><br><span class="line">// 创建隐式全局变量 反例，勿使用</span><br><span class="line">function foo() {</span><br><span class="line">   var a = b = 0;发生的原因是 这个从右往左赋值 b = 0  此时 b是未声明的</span><br><span class="line">   相当于</span><br><span class="line">   var a = (b = 0);</span><br><span class="line">   你可以这个定义局部变量（正确写法）</span><br><span class="line">   var a, b;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="隐式全局变量-与显式全局变量的差异"><a href="#隐式全局变量-与显式全局变量的差异" class="headerlink" title="隐式全局变量 与显式全局变量的差异"></a><font color="green">隐式全局变量 与显式全局变量的差异</font></h4><ul>
<li>通过 var 创建的全局变量是不能被删除的</li>
<li>无 var 创建的隐式全局变量 是能被删除的</li>
</ul>
<h6 id="关于隐式全局变量的解释"><a href="#关于隐式全局变量的解释" class="headerlink" title="关于隐式全局变量的解释"></a>关于隐式全局变量的解释</h6><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">不管一个变量有没有用过，JavaScript解释器反向遍历作用域链来查找整个变量的var声明，如果没有找到var，解释器则假定该变量是全局变量，如果该变量用于了赋值操作的话，之前如果不存在的话，解释器则会自动创建它，这就是说在匿名闭包里使用或创建全局变量非常容易 避免创建式全局变量 方式</span><br><span class="line"></span><br><span class="line">(function ($, YAHOO) {</span><br><span class="line">    // 这里，我们的代码就可以使用全局的jQuery对象了，YAHOO也是一样</span><br><span class="line">} (jQuery, YAHOO))</span><br><span class="line">将全局变量当做一个参数传入匿名函数内使用 jquery源码就用这种方式</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">在技术上 隐式全局变量 并不是真正的全局变量 但他们是全局对象的属性</span><br><span class="line">属性是可以通过delete 操作符删除的</span><br></pre></td></tr></tbody></table></figure>
<h4 id="如何访问全局变量"><a href="#如何访问全局变量" class="headerlink" title="如何访问全局变量"></a><font color="green">如何访问全局变量</font></h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">一般情况下 全局对象可以通过window属性在任何位置访问</span><br><span class="line">也可以</span><br><span class="line"></span><br><span class="line">var gobal =function(){</span><br><span class="line">return this;</span><br><span class="line">}</span><br><span class="line">这种方法可以随时获取全局变量 this总是指向全局对象</span><br></pre></td></tr></tbody></table></figure>
<h4 id="变量与函数的预解析（变量提升）"><a href="#变量与函数的预解析（变量提升）" class="headerlink" title="变量与函数的预解析（变量提升）"></a><font color="green">变量与函数的预解析（变量提升）</font></h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">function func() {</span><br><span class="line">   var a = 1,</span><br><span class="line">       b = 2,</span><br><span class="line">       sum = a + b,</span><br><span class="line">       myobject = {},</span><br><span class="line">       i, // undefined</span><br><span class="line">       j; //undefined</span><br><span class="line">   // function body...</span><br><span class="line">}</span><br><span class="line">变量初始化可以防止逻辑错误 也解决了var散布的问题</span><br><span class="line"></span><br><span class="line">// 反例</span><br><span class="line">myname = "global"; // 全局变量</span><br><span class="line">function func() {</span><br><span class="line">    alert(myname); // "undefined"</span><br><span class="line">    var myname = "local"; // 声明myname的变量被当做局部变量预解析了</span><br><span class="line">    alert(myname); // "local"</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">相当于</span><br><span class="line">myname = "global"; // 全局变量</span><br><span class="line">function func() {</span><br><span class="line">     var myname； // === var myname == undefined</span><br><span class="line">     alert(myname); // "undefined"</span><br><span class="line">     myname = "local";</span><br><span class="line">     alert(myname); // "local"</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h4 id="【延伸】js-是如何执行的"><a href="#【延伸】js-是如何执行的" class="headerlink" title="【延伸】js 是如何执行的"></a><font color="green">【延伸】js 是如何执行的</font></h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">代码处理 分为两个阶段</span><br><span class="line">1.变量 函数声明 以及 正常格式的参数创建 这是一个解析和进入上下文的阶段</span><br><span class="line">2.代码执行 函数表达式和 声明的变量被创建</span><br></pre></td></tr></tbody></table></figure>
<h2 id="js的循环问题"><a href="#js的循环问题" class="headerlink" title="js的循环问题"></a>js 的循环问题</h2><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for 循环</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">缓存 数组 以及 HTMLCollection 的长度</span><br><span class="line">当要循环的是一个集合对象时候 如果不缓存长度 你要实时查询Dom 而Dom操作一般来讲比较昂贵</span><br><span class="line"></span><br><span class="line">像这样</span><br><span class="line"></span><br><span class="line">for (var i = 0, max = myarray.length; i &lt; max; i++) {</span><br><span class="line">   // 使用myarray[i]做点什么</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">尽量不要使用i++</span><br><span class="line">像这样儿</span><br><span class="line"></span><br><span class="line">i = i + 1</span><br><span class="line">i += 1</span><br><span class="line"></span><br><span class="line">还有两种改进形式（参考）</span><br><span class="line">少了一个变量(无max)</span><br><span class="line">向下数到0，通常更快，因为和0做比较要比和数组长度或是其他不是0的东西作比较更有效率</span><br><span class="line"></span><br><span class="line">像这样</span><br><span class="line"></span><br><span class="line">//第一种变化的形式：</span><br><span class="line"></span><br><span class="line">var i, myarray = [];</span><br><span class="line">for (i = myarray.length; i–-;) {</span><br><span class="line">  //....</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//第二种使用while循环：</span><br><span class="line"></span><br><span class="line">var myarray = [],</span><br><span class="line">    i = myarray.length;</span><br><span class="line">while (i–-) {</span><br><span class="line">   // ....</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>


<h4 id="for-in循环"><a href="#for-in循环" class="headerlink" title="for-in循环"></a>for-in 循环</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">也称 ‘枚举’ 应该用在非数组对象的遍历上 不推荐用来循环数组（数组也是对象 但是 for-in中 属性列表的顺序是不能保证的）</span><br><span class="line"></span><br><span class="line">值得说明的是 我们平常老是忽略一个很重要的方法</span><br><span class="line">hasOwnProperty() 遍历对象属性的时候可以过滤掉从原型链上下来的属性</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	var man = {</span><br><span class="line">	    hands:2,</span><br><span class="line">		legs:2,</span><br><span class="line">		heads:1</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	if (typeof Object.prototype.clone === 'undefined'){</span><br><span class="line">	    Object.prototype.clone = function(){</span><br><span class="line">	        //。。。。</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">//	为了避免枚举 出现clone方法</span><br><span class="line">	for (var i in man) {</span><br><span class="line">//	    方式一 过滤原型属性</span><br><span class="line">	    if (man.hasOwnProperty(i)) {</span><br><span class="line">//            console.log(i, "1:", man[i]);</span><br><span class="line">		}</span><br><span class="line">//		方式二 取消Object。prototype上的方法</span><br><span class="line">		if (Object.prototype.hasOwnProperty.call(man,i)){</span><br><span class="line">//            console.log(i, "1:", man[i]);</span><br><span class="line">		}</span><br><span class="line">		//或者 避免长属性查找</span><br><span class="line">		var hasOwn = Object.prototype.hasOwnProperty;</span><br><span class="line">        if (hasOwn.call(man,i)){</span><br><span class="line">//            console.log(i, "1:", man[i]);</span><br><span class="line">        }</span><br><span class="line">	}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h4 id="给原型自定义添加方法"><a href="#给原型自定义添加方法" class="headerlink" title="给原型自定义添加方法"></a>给原型自定义添加方法</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">if (typeof Object.prototype.myMethod ！=="function"){</span><br><span class="line">    Object.prototype.myMethod = function(){</span><br><span class="line">    //....</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="避免隐式类型转换"><a href="#避免隐式类型转换" class="headerlink" title="避免隐式类型转换"></a>避免隐式类型转换</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">js变量在比较时会隐式类型转换</span><br><span class="line">为了避免引起混乱的隐式类型转换 比较值和表达式类型的时候始终使用</span><br><span class="line">=== 和 !== 操作符</span><br></pre></td></tr></tbody></table></figure>
<h2 id="避免-eval-不给-给setInterval-setTimeout-和Function-构造函数传递字符串"><a href="#避免-eval-不给-给setInterval-setTimeout-和Function-构造函数传递字符串" class="headerlink" title="避免 eval() 不给 给setInterval(), setTimeout()和Function()构造函数传递字符串"></a>避免 eval () 不给 给 setInterval (), setTimeout () 和 Function () 构造函数传递字符串</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 反面示例</span><br><span class="line">setTimeout("myFunc()", 1000);</span><br><span class="line">setTimeout("myFunc(1, 2, 3)", 1000);</span><br><span class="line"></span><br><span class="line">// 更好的</span><br><span class="line">setTimeout(myFunc, 1000);</span><br><span class="line">setTimeout(function () {</span><br><span class="line">   myFunc(1, 2, 3);</span><br><span class="line">}, 1000);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="parseInt-数值转换不应该忽略第二个参数"><a href="#parseInt-数值转换不应该忽略第二个参数" class="headerlink" title="parseInt()数值转换不应该忽略第二个参数"></a>parseInt () 数值转换不应该忽略第二个参数</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">在ECMAScript 3中，开头为”0″的字符串被当做8进制处理了，但这已在ECMAScript 5中改变了。为了避免矛盾和意外的结果，总是指定基数参数</span><br><span class="line"></span><br><span class="line">var month = "06",</span><br><span class="line">    year = "09";</span><br><span class="line">month = parseInt(month, 10);</span><br><span class="line">year = parseInt(year, 10);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h2><ul>
<li>编码规范</li>
<li>代码缩进</li>
<li>技术上可以省略的花括号 (只有一条语句的 for 循环 {}) 也不要省略</li>
<li>不要省略分号；</li>
<li>左花括号的位置</li>
<li>适当的地方使用空格 – 列表模样表达式（相当于逗号）和结束语句（相对于完成了 “想法”）后面添加间隔</li>
<li>命名规范</li>
<li>注释 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">if (true) {</span><br><span class="line">   alert("It's TRUE!");</span><br><span class="line">}</span><br><span class="line">或者</span><br><span class="line">if (true)</span><br><span class="line">{</span><br><span class="line">   alert("It's TRUE!");</span><br><span class="line">}</span><br><span class="line">但是如果要返回一个对象自变量的话</span><br><span class="line">function func() {</span><br><span class="line">   return  // === return undefined;</span><br><span class="line">  // 下面代码不执行</span><br><span class="line">   {</span><br><span class="line">      name : "Batman"</span><br><span class="line">   }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">结论</span><br><span class="line">总之，总是使用花括号，并始终把在与之前的语句放在同一行：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">使用空格</span><br><span class="line"></span><br><span class="line">for循环分号分开后的的部分：如for (var i = 0; i &lt; 10; i += 1) {...}</span><br><span class="line">for循环中初始化的多变量(i和max)：for (var i = 0, max = 10; i &lt; max; i += 1) {...}</span><br><span class="line">分隔数组项的逗号的后面：var a = [1, 2, 3];</span><br><span class="line">对象属性逗号的后面以及分隔属性名和属性值的冒号的后面：var o = {a: 1, b: 2};</span><br><span class="line">限定函数参数：myFunc(a, b, c)</span><br><span class="line">函数声明的花括号的前面：function myFunc() {}</span><br><span class="line">匿名函数表达式function的后面：var myFunc = function () {};</span><br><span class="line">花括号的间距  最好使用空格</span><br><span class="line">有一个经常被忽略的代码可读性方面是垂直空格的使用。你可以使用空行来分隔代码单元，就像是文学作品中使用段落分隔一样。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">命名规范</span><br><span class="line"></span><br><span class="line">以大写字母写构造函数(Capitalizing Constructors)</span><br><span class="line"></span><br><span class="line">getName() 公共方法</span><br><span class="line">_getFirst() 私有方法</span><br></pre></td></tr></tbody></table></figure>


]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>网易与淘宝移动端适配工作流思考一</title>
    <url>/2017/08/09/%E7%BD%91%E6%98%93%E4%B8%8E%E6%B7%98%E5%AE%9D%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E5%B7%A5%E4%BD%9C%E6%B5%81/</url>
    <content><![CDATA[<p>最近尝试了解了一些移动端的概念<br>得空总结了网易与淘宝的一些适配方案，为后续工作记录一下</p>
<a id="more"></a>
<p>## 网易移动端适配方案<br>要点：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">* 网易页面上html的font-size不是预先通过媒介查询在css里定义好的，而是通过js计算出来的</span><br><span class="line">* 为了方便，取一个100px的font-size为参照</span><br></pre></td></tr></tbody></table></figure>
<p>步骤：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1.拿设计稿竖着的横向分辨率除以100得到body的宽度</span><br><span class="line">  eg：  iphone6，横向分辨率为750，width =750 / 100 = 7.5rem</span><br><span class="line">        iphone4/5，横向分辨率为640，width为640 / 100 = 6.4rem</span><br><span class="line"> 2.布局时  css尺寸 = 设计稿标注尺寸／100</span><br><span class="line">   eg：210px = 210/100 = 2.1rem       </span><br><span class="line">  3.   Dom ready以后获取html的font-size</span><br><span class="line">    ⚠️ 当设备宽度（deviceWidth大于设计稿的横向分辨率时 html的font-size始终等于横向分辨率/body元素宽）</span><br><span class="line"> 代码体现</span><br><span class="line">   var deviceWidth = document.documentElement.clientWidth;</span><br><span class="line">        if(deviceWidth &gt; 640) deviceWidth = 640;</span><br><span class="line">        document.documentElement.style.fontSize = deviceWidth / 7.5 + 'px';</span><br><span class="line">4.font-size 可能需要额外的媒体查询 而且不要用rem</span><br><span class="line"></span><br><span class="line">   @media screen and (max-width:321px){</span><br><span class="line">           .m-navlist{font-size:15px}</span><br><span class="line">          }</span><br><span class="line"></span><br><span class="line">          @media screen and (min-width:321px) and (max-width:400px){</span><br><span class="line">              .m-navlist{font-size:16px}</span><br><span class="line">          }</span><br><span class="line"></span><br><span class="line">          @media screen and (min-width:400px){</span><br><span class="line">              .m-navlist{font-size:18px}</span><br><span class="line">          }</span><br><span class="line">5.关于视口的设置</span><br><span class="line">      &lt;meta name="viewport" content="initial-scale=1,maximum-scale=1, minimum-scale=1"&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>#淘宝移动端适配方案<br>要点：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1.设置视口标签</span><br><span class="line"> &lt;meta name="viewport"   content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"&gt;</span><br><span class="line">使得整个网页在设备内显示时页面的宽度始终等于设备宽度（device-width）</span><br><span class="line"></span><br><span class="line">scale  =1 时 device-width = 设备的物理分辨率／devicePixelRatio（设备像素比）</span><br></pre></td></tr></tbody></table></figure>

<p> <font face="STCAIYUN" color="#83933b" size="4">手淘的布局前提是  动态设置 viewport 的 scale  目的就是为了保证页面大小与设计稿大小一致</font></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">比如设计稿是750的横向分辨率 那么实际页面的device-width 以iphone6来说 也等于750</span><br><span class="line">这样的话设计稿上标注的尺寸只要除以某一个值就能够转换成rem了</span><br></pre></td></tr></tbody></table></figure>
<p>2.<font face="STCAIYUN" color="red" size="3"> 那么 如何动态设置？</font></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var scale = 1 / devicePixelRatio;</span><br><span class="line">document.querySelector('meta[name="viewport"]').setAttribute('content','initial-scale=' + scale + ', maximum-scale=' + scale + ', minimum-scale=' + scale + ', user-scalable=no');</span><br></pre></td></tr></tbody></table></figure>

<p>3.<font face="STCAIYUN" color="red" size="3"> 手淘布局的第二个要点就是关于 html 元素的 font-size 计算公式</font></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">font-size = deviceWidth/10;</span><br></pre></td></tr></tbody></table></figure>
<p>可能会需要额外的媒体查询 同网易 不使用 rem<br>但是呢 淘宝的 rem 不太好计算  如果借助 less 就好算多了<br>类似：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">//定义一个变量和一个mixin</span><br><span class="line">@baseFontSize: 75;//基于视觉稿横屏尺寸/100得出的基准font-size</span><br><span class="line">.px2rem(@name, @px){</span><br><span class="line">    @{name}: @px / @baseFontSize * 1rem;</span><br><span class="line">}</span><br><span class="line">//使用示例：</span><br><span class="line">.container {</span><br><span class="line">    .px2rem(height, 240);</span><br><span class="line">}</span><br><span class="line">//less翻译结果：</span><br><span class="line">.container {</span><br><span class="line">    height: 3.2rem;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>4.<font face="STCAIYUN" color="red" size="3"> 元素的 css 尺寸如何计算？</font></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">比如一个设计稿上某一个元素的高是 150px</span><br><span class="line">css尺寸 =  设计稿标记尺寸/该设计稿对应的html的font-size</span><br><span class="line">也就是说  设计稿是750  所以 font-size = 750/10 =75px</span><br><span class="line"> 150/75 = 2rem</span><br></pre></td></tr></tbody></table></figure>


<p>关于这种做法的具体实现，淘宝已经给我们提供了一个开源的解决方案</p>
<p><font face="STCAIYUN" color="bluegreen" size="5"><a href="https://github.com/amfe/lib-flexible">淘宝移动端布局方案</a></font></p>
<p><font face="STCAIYUN" color="red" size="3">比较网易与淘宝的做法</font><br><font face="STCAIYUN" color="bluegreen" size="3">共同点：</font><br>都能适配所有的手机设备，对于 pad，网易与淘宝都会跳转到 pc 页面，不再使用触屏版的页面<br>都需要动态设置 html 的 font-size<br>布局时各元素的尺寸值都是根据设计稿标注的尺寸计算出来，由于 html 的 font-size 是动态调整的，所以能够做到不同分辨率下页面布局呈现等比变化<br>容器元素的 font-size 都不用 rem，需要额外地对 font-size 做媒介查询<br>都能应用于尺寸不同的设计稿，只要按以上总结的方法去用就可以了</p>
<p><font face="STCAIYUN" color="bluegreen" size="3">不同点：</font><br>淘宝的设计稿是基于 750 的横向分辨率，网易的设计稿是基于 640 的横向分辨率，还要强调的是，虽然设计稿不同，但是最终的结果是一致的，设计稿的尺寸一个公司设计人员的工作标准，每个公司不一样而已<br>淘宝还需要动态设置 viewport 的 scale，网易不用<br>最重要的区别就是：网易的做法，rem 值很好计算，淘宝的做法肯定得用计算器才能用好了 。不过要是你使用了 less 和 sass 这样的 css 处理器，就好办多了</p>
]]></content>
      <tags>
        <tag>mobile</tag>
      </tags>
  </entry>
  <entry>
    <title>记梦一</title>
    <url>/2017/07/31/%E8%AE%B0%E6%A2%A6/</url>
    <content><![CDATA[<p>此时此刻 ，反复思索着昨晚的梦，<font face="STCAIYUN" color="red" size="4">人生充满无奈，珍惜眼前人</font></p>
<p>具体的故事背景记不清了 大概是朋友的奶奶蹊跷去世了，我去她家安慰她并试图查事故原因，结果等我回去找他们的时候发现自己已经变成了<font face="STCAIYUN" color="red" size="4">隐形人</font> 其实就是已经死掉了，显然我自己也不知道自己发生了什么事情，事实就是我还在人间，就是我能看世人，世人再也看不到我了</p>
<p>第一反应是：  <font face="STCAIYUN" color="red" size="4">我要回家</font><br>我不知道他们是怎么处理世间的我，我只知道我的灵魂回家了<br>我也记不清爸妈是否知不知道我已经不在了，我用力的跟他们讲话 只可惜他们大大小小全都对我视而不见，我来不及思考 依然用力呼唤他们，追着拉着，全都没有用， <font face="STCAIYUN" color="yellow" size="3">我好无力…</font></p>
<p>想到多年前看过一部日本的温情电影，讲的也是主人公意外身故 化身隐形人回家，发现自己没办法让家人注意到也是很痛苦 不过电影就是电影 有一个巫婆是阴阳眼 成了 家人跟 “隐形人” 沟通的桥梁，必要的时候还会帮助家人度过难关  影片最后是巫婆帮助隐形人附身于自己身上，与妻子做最后的告别，最后安稳投胎<br>印象中这才是鬼魂的正确打开方式 国产剧中的鬼魂仿佛都很厉害的样子，有仇报仇，有冤报冤，一言不合就施法 也是～</p>
<p>我当时想起来银行账户还有钱 就想给他们转过去，但是负责管我的警察，暂且叫他 <font face="STCAIYUN" color="red" size="4">灵魂摆渡人</font> （404 号便利店), 对耶 我为什么没去 404 号便利店找夏冬青帮我实现愿望，大概我遇见的是赵吏 笑 cry 他说 我可以往人间账户汇款，就是有损耗 1W 只能到账 1k 这尼玛是跨行手续费吗😢</p>
<p>不记得最后是咋解决的， 反正世界就再也没有我了，就算再挣扎<br>我开始回忆一生，那些活过的平淡日子，能记起来的只有桩桩件件的遗憾</p>
<p>我还没有孝顺父母</p>
<p>上次电话里没有喊一嗓子 爸妈我爱你</p>
<p>我应该再回一次家的</p>
<p>想在老家给爹妈买房子的钱还没存够</p>
<p>家庭旅行的计划家门口还没出</p>
<p>想起来这些碎碎念</p>
<p>突然我就开始怀念了</p>
<p>我想，如果我在世的时候能有这些危机感 现在也不会有这么多遗憾了</p>
<p>私人一点的是</p>
<p>恋爱记有这么多点滴 另一半还没添加<br>这世上 除了爸妈亲人 连个记挂我的人都没有</p>
<p>好悲哀</p>
<p>早上被闹钟叫醒 发现自己还活着</p>
<p>感谢上帝 有些事只有失去过才知道 我拥有的还很多</p>
<p>致每一个空虚的你</p>
]]></content>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>面向未来的 API-GraphQL</title>
    <url>/2019/12/23/GraphQL/</url>
    <content><![CDATA[<h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p>你有没有遇到以下问题</p>
<ul>
<li>字段冗余</li>
</ul>
<p><img src="http://cdn.anruence.com/%E7%A3%90%E7%9F%B3%E6%95%B0%E6%8D%AE.png" alt="image"></p>
<ul>
<li>若干个不得不发的 HTTP 请求</li>
</ul>
<p><img src="http://cdn.anruence.com/graphql1.png" alt="image"></p>
<p>发生这些，并不是前端 er 本意，但是又要承担诸如页面渲染慢等副作用而被用户诟病<br>究其原因，是前端在数据层面没有主动权</p>
<p>针对但不限于以上种种<br>我们需要以前端的设计者和开发者的角度出发 设计新的数据查询方式</p>
<p>Facebook 工程师率先提出 RESTful 架构体系的替代方案</p>
<p>并且应用在了其应用中</p>
<p><a href="https://www.youtube.com/watch?v=WxPtYJRjLL0&amp;t=2s">Facebook 使用 graphql 重构他们的 pc 站</a></p>
<p>接下来 让我们站在巨人的肩膀上，由浅至深聊聊被称之为面向未来的 API 的 - GraphQL</p>
<a id="more"></a>

<h1 id="明确本文的边界"><a href="#明确本文的边界" class="headerlink" title="明确本文的边界"></a>明确本文的边界</h1><p>本文主要介绍接触 GraphQL 这段时间，觉得必须要掌握的一些核心 适合以下人群</p>
<ul>
<li>完全没听说过 GraphQL</li>
<li> 听说过 GraphQL 的读者，想深入了解一下</li>
<li>想系统地学习 GraphQL 的读者</li>
<li>正在调研 GraphQL 技术的读者</li>
</ul>
<p>帮助你对 GraphQL 建立一个统观全局的认知及原理性的解读</p>
<p>你可能会得到以下解答</p>
<ul>
<li>重新思考 RESTful</li>
<li>what GraphQL</li>
<li>RESTful &amp; GraphQL</li>
<li>how GraphQL</li>
<li>GraphQL 组成链路</li>
<li>阻碍你使用 GraphQL 的 N 个问题</li>
<li>现有应用的接入方式</li>
<li> GraphQL 不足</li>
<li>基于 GraphQL 的社区解决方案</li>
<li>小结</li>
</ul>
<h1 id="重新思考RESTful"><a href="#重新思考RESTful" class="headerlink" title="重新思考RESTful"></a>重新思考 RESTful</h1><ul>
<li>接口数膨胀，需自行组合多个接口才能获取到完整的数据结构</li>
<li> API 文档更新不及时，联调基本靠猜</li>
<li>客户端对接口数据类型校验 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">- 除了服务端要校验客户端传来的参数，客户端自己也需要去校验服务端返回的参数</span><br><span class="line">- 比如客户端要的是数组，你有没有返回数组</span><br><span class="line">- 需要依赖类似出var x = data?(data.obj?data.obj.name:null):null兼容</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>接口字段冗余，移动 / PC 需求无法满足 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">- 冗余数据的返回浪费了流量</span><br><span class="line">- 服务端决定有哪些数据获取方式，客户端只能挑选使用，如果数据过于冗余也只能默默接收再对数据进行处理</span><br><span class="line">- 而数据不能满足需求则需要请求更多的接口</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>前后端字段命名规范不一致，</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">依赖数据层逐量转换</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>维护多版本接口 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">任何的变动都会被视为一种破坏性的改变，而破坏性改变就需要更新API的版本</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="我的诉求"><a href="#我的诉求" class="headerlink" title="我的诉求"></a>我的诉求</h2><ol>
<li>可不可以客户端要什么字段，服务端就给什么字段的值？</li>
<li>可不可以定义一个返回数据格式与请求的数据格式的一个强类型的约束？</li>
<li>能不能客户端可以问服务端要 1、2、3 这些数据，服务端一次给我返回就行？</li>
</ol>
<p>GraphQL 的出现就是为了解决 RESTful 的痛点</p>
<h1 id="what-GraphQL"><a href="#what-GraphQL" class="headerlink" title="what GraphQL"></a>what GraphQL</h1><p><a href="http://graphql.org/">GraphQl 官网</a></p>
<p><a href="https://graphql.cn/">GraphQL 中文网</a></p>
<blockquote>
<p>它既是一种用于 API 的查询语言 (规范) 也是一个满足你数据查询的运行时</p>
</blockquote>
<p>强类型可以在查询执行之前进行验证</p>
<p>用于组织应用程序中数据的创建，读取，更新和删除（是的，CRUD）</p>
<p>脑袋里巨大的问号❓ API 怎么就可以查询呢？</p>
<p>这正是其强大之处</p>
<blockquote>
<p>ask exactly what you want.</p>
</blockquote>
<ul>
<li>用已有的代码和技术来进行数据源管理</li>
<li>对 API 数据提供了一套易于理解的完整描述</li>
<li>非数据库查询语言，不是一门语言 / 框架 </li>
<li>不绑定任何的数据库或者存储引擎</li>
<li>使得客户端能按需获取数据，无冗余</li>
<li>让 API 更容易随着时间推移而演进</li>
<li> GraphQL = Graph (图表化 / 可视化)+ QL (查询语言)</li>
<li> 是一种描述客户端如何向服务端请求数据的 API 语法</li>
</ul>
<h1 id="RESTful-amp-GraphQL"><a href="#RESTful-amp-GraphQL" class="headerlink" title="RESTful &amp; GraphQL"></a>RESTful &amp; GraphQL</h1><h2 id="资源获取"><a href="#资源获取" class="headerlink" title="资源获取"></a>资源获取</h2><p><img src="http://cdn.anruence.com/rest.png" alt="image"></p>
<ul>
<li>RESTful 用不同 URL 来区分资源，GraphQL 用特有的类型区分资源</li>
<li>获取相同资源 REST API 需要聚合多个接口</li>
<li>获取相同资源 GraphQL 只需一次请求获取多组数据</li>
<li> GraphQL 更有效率更强大更灵活，对前端更友好</li>
</ul>
<h2 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h2><p><img src="http://cdn.anruence.com/graphql%20%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96.png" alt="image"></p>
<ul>
<li>获取数据的方式由 == 这里有什么 == 向 == 你需要什么 == 转变 </li>
<li>GraphQL 可以简化理解成一个灵活的 ajax 接口</li>
<li>客户端完全自主决定获取信息的内容，服务端负责精确的返回目标数据</li>
</ul>
<h2 id="GraphQL优点"><a href="#GraphQL优点" class="headerlink" title="GraphQL优点"></a>GraphQL 优点</h2><ul>
<li>请求你所要的数据，不多不少 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">- 向你的 API 发出一个 GraphQL 请求就能准确获得你想要的数据，不多不少。</span><br><span class="line">- GraphQL 查询总是返回可预测的结果。使用 GraphQL 的应用可以工作得又快又稳，因为控制数据的是应用，而不是服务器。</span><br></pre></td></tr></tbody></table></figure>
<p><img src="http://cdn.anruence.com/graphql-fetchdata.png" alt="image"></p>
<ul>
<li>获取多个资源，只需要一个请求 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">- GraphQL 查询不仅能够获得资源的属性，还能沿着资源间引用进一步查询</span><br><span class="line">- 典型的 REST API 请求多个资源时得载入多个 URL</span><br><span class="line">- GraphQL 可以通过一次请求就获取你应用所需的所有数据</span><br><span class="line">- 即使是比较慢的移动网络连接下，使用 GraphQL 的应用也能表现得足够迅速。</span><br></pre></td></tr></tbody></table></figure>
<p><img src="http://cdn.anruence.com/graphQL-huoqu.png" alt="image"></p>
<ul>
<li>描述所有可能的类型系统（强类型自身）</li>
</ul>
<p>强类型可以在查询执行之前进行验证</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">- GraphQL API 基于类型和字段的方式进行组织，而非入口端点</span><br><span class="line">- 你可以通过一个单一入口端点得到你所有的数据能力</span><br><span class="line">- GraphQL 使用类型来保证应用只请求可能的数据</span><br><span class="line">- 还提供了清晰的辅助性错误信息</span><br><span class="line">- 应用可以使用类型，而避免编写手动解析代码。</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>强大的开发者工具 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">- 代码即文档</span><br><span class="line">- 不用离开编辑器就能准确知道你可以从 API 中请求的数据</span><br><span class="line">- 发送查询之前就能高亮潜在问题，高亮代码智能提示</span><br><span class="line">- 提供了GraphiQL图形界面编写可测试的查询语句</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>无版本约束 平滑演进（<font color="red">GraphQL 的设计精髓</font>）</li>
</ul>
<blockquote>
<p>由于仅返回明确的请求数据，所以设计良好的「GraphQL API」不存在「接口突变」的情况，这是从「版本化」到「无版本」的一个明确转变！</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">- 给你的 GraphQL API 添加字段和类型而无需影响现有查询</span><br><span class="line">- 老旧的字段可以废弃，从工具中隐藏</span><br><span class="line">- 通过使用单一演进版本，GraphQL API 使得应用始终能够使用新的特性，并鼓励使用更加简洁、更好维护的服务端代码</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h1 id="GraphQL改善RESTful"><a href="#GraphQL改善RESTful" class="headerlink" title="GraphQL改善RESTful"></a>GraphQL 改善 RESTful</h1><p>了解了 GraphQL 的一大堆特点，我们开篇的诉求解决了吗？</p>
<p><img src="http://cdn.anruence.com/graphql99.png" alt="image"></p>
<p>到这里 我们看到了 GraphQL 原则上的可行性</p>
<h1 id="How-GraphQL"><a href="#How-GraphQL" class="headerlink" title="How GraphQL"></a>How GraphQL</h1><p>接下来 趁热打铁 来聊聊怎么用 GraphQL</p>
<p><img src="http://cdn.anruence.com/graphql-banner.png" alt="image"></p>
<p>官网上特别醒目的一张图，我们可以得到如下信息</p>
<ul>
<li>服务端定义好强类型的数据入参和返回的数据结构</li>
<li>客户端发送一个带有查询语句（GraphQL 查询协议）的请求，定义好返回数据的格式及类型</li>
<li>返回符合客户端预期的 Json 字符串结果</li>
</ul>
<p><font color="red">再通俗一点</font></p>
<p>我们拥有 UI，并且需要用数据填充它，因此我们向服务器进行查询<br>使用传统的 REST API，我们的查询将以 GET 请求的形式出现 借助 GraphQL，我们引入了一种用于请求数据的新语法</p>
<h3 id="一个基础的GraphQL服务"><a href="#一个基础的GraphQL服务" class="headerlink" title="一个基础的GraphQL服务"></a>一个基础的 GraphQL 服务</h3><h4 id="GraphQL服务-类型（schema）-解析器-（resolve）"><a href="#GraphQL服务-类型（schema）-解析器-（resolve）" class="headerlink" title="GraphQL服务 = 类型（schema） + 解析器 （resolve）"></a>GraphQL 服务 = 类型（schema） + 解析器 （resolve）</h4><p>明确以下知识点</p>
<ul>
<li>为了发出 GraphQL 请求，我们需要有一个 GraphQL 服务器</li>
<li> GraphQL 服务器是附加了 GraphQL 模式的常规 HTTP 服务器</li>
<li>类型系统描述了数据的类型与结构，但它只是形状，不包含真正的数据</li>
<li>通过编写 Resolver 函数，从而去获取真正的数据</li>
</ul>
<p><img src="http://cdn.anruence.com/graphQL%20lizi.png" alt="image"></p>
<ul>
<li>服务端（或中间层）需要描述所有可能的类型系统（schema）</li>
</ul>
<p><img src="http://cdn.anruence.com/graphql.png" alt="image"></p>
<ul>
<li>按你所需请求你所需要的数据，解决了不同客户端不同的渲染需求</li>
</ul>
<p>是不是贼简单～</p>
<p>不知道你没有注意到 上面我们提到了<font color="red"> GraphQL 查询协议</font></p>
<h2 id="GraphQL查询协议"><a href="#GraphQL查询协议" class="headerlink" title="GraphQL查询协议"></a>GraphQL 查询协议</h2><p>GraphQL 有三种请求方式</p>
<ul>
<li>query (请求)   </li>
<li>mutation (修改)</li>
<li>subscribe (订阅)</li>
</ul>
<p>GraphQL 的核心依赖于简单的 GET 或 POST 请求来将数据往返于客户端，而 GraphQL 只是一个经过修饰的 GET 或 POST 请求，通过 <a href="https://myapp.com/graphql">https://myapp.com/graphql</a><br>之类的 URL 发送到 GraphQL 服务器</p>
<p>是的，虽然 GraphQL 确实引入了一些新的概念来组织数据进行交互，但在幕后，但 GraphQL 仍然依靠良好的 HTTP 请求来实现其神奇效果</p>
<p>只需要为类型系统的字段编写函数，GraphQL 就能通过优化并发的方式来调用它们</p>
<p>具体参照如上的 demo，建议拷贝代码亲自感受一下</p>
<h1 id="GraphQL组成链路"><a href="#GraphQL组成链路" class="headerlink" title="GraphQL组成链路"></a>GraphQL 组成链路</h1><p>当然了 对于开发者来说，我们无非关注两点</p>
<ul>
<li>客户端做什么？</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">向服务端发送查询字符串</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>服务端做什么？</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">基于GraphQL构建类型系统 </span><br><span class="line">定义与Query下字段对应的resolver</span><br><span class="line">可以在resolver获取真正的数据</span><br></pre></td></tr></tbody></table></figure>


<h2 id="资源路径图"><a href="#资源路径图" class="headerlink" title="资源路径图"></a>资源路径图</h2><p><img src="http://cdn.anruence.com/ziyuanlujing.png" alt="image"></p>
<p>客户端 Schema 本质上就是一段字符串，服务端如何识别并响应这段字符串？</p>
<h2 id="服务端执行过程"><a href="#服务端执行过程" class="headerlink" title="服务端执行过程"></a>服务端执行过程</h2><p><img src="http://cdn.anruence.com/%E6%9C%8D%E5%8A%A1%E7%AB%AF.png" alt="image"></p>
<p>拿到客户端字符串之后，依赖官方类库 graphql-js, 服务端具体执行经历三个阶段</p>
<ul>
<li>解析：逐字符扫描，如果不符合服务端定义的 AST 规范，解析过程会直接跑出语法异常，当然了，是结构化报错</li>
<li>校验：发起了查询，GraphQL 会解析我们的查询语句，确保啊我们查询的结构是存在的，参数是足够的，类型是一致的，任何环节出了问题，都将返回错误信息</li>
<li>执行：验证通过后，GraphqL 会根据 query 语句包含的字段结构一一触发对应的 Resolver 函数，获取查询结果，也就是说 如果前端没有查询某个字段，就不会触发该字段对应的 Resolver 函数，也就不会产生对数据的获取行为</li>
</ul>
<p>注：如果 Reaolver 返回的数据结构，大于 Schema 里描绘的结构，那么多出来的部分会被忽略，这是一个合理的设计，我们可以通过控制 Schema 来控制前端的数据访问权限，防止意外的将用户的隐私信息泄漏出去 </p>
<h1 id="阻碍你使用GraphQL的N个问题"><a href="#阻碍你使用GraphQL的N个问题" class="headerlink" title="阻碍你使用GraphQL的N个问题"></a>阻碍你使用 GraphQL 的 N 个问题</h1><p>既然 GraphQL 那么方便，为啥没有大火呢？<br>结合了多篇文章，整理了若干了阻止你使用 GraphQL 的 N 个问题</p>
<p>一起来看一看</p>
<h2 id="GraphQL一定要操作数据库？"><a href="#GraphQL一定要操作数据库？" class="headerlink" title="GraphQL一定要操作数据库？"></a>GraphQL 一定要操作数据库？</h2><ul>
<li>数据提供方编写 GraphQL Schema</li>
<li> 数据消费方编写 GraphQL Query</li>
<li>GraphQL 只是关于 schema 和 resolver 的一一对应和调用，它并为对数据的获取方式和来源做任何假设</li>
</ul>
<h2 id="GraphQL-跟-RESTful-api-是对立的？"><a href="#GraphQL-跟-RESTful-api-是对立的？" class="headerlink" title="GraphQL 跟 RESTful api 是对立的？"></a>GraphQL 跟 RESTful api 是对立的？</h2><p>两者不仅不是对立的，还可以相互结合<br>事实上可以把 Query 下的字段，理解为一个个 RESTful API</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Query {</span><br><span class="line">   hello: String,</span><br><span class="line">   sayhi:String</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>

<h2 id="GraphQL不一定需要Schema（类型系统）？"><a href="#GraphQL不一定需要Schema（类型系统）？" class="headerlink" title="GraphQL不一定需要Schema（类型系统）？"></a>GraphQL 不一定需要 Schema（类型系统）？</h2><ul>
<li>GraphQL Type System 是一个静态的类型系统，我们可以称之为静态类型 GraphQL</li>
<li> 此外，社区还有一种动态类型的 GraphQL 实践，它跟静态类型的 GraphQL 差别在于，没有了基于 Schema 的数据形状验证阶段，而是直接无脑地根据 query 查询语句里的字段，去触发 Resolver 函数，动态类型的 GraphQL 有一定的便利性，不过，它同时丧失了 GraphQL 的部分精髓</li>
</ul>
<h2 id="GraphQL-一定是后端服务？"><a href="#GraphQL-一定是后端服务？" class="headerlink" title="GraphQL 一定是后端服务？"></a>GraphQL 一定是后端服务？</h2><p>尽管绝大多数 GraphQL，都以 server 的形式存在。&nbsp;但它并没有限制在后端场景</p>
<p> <a href="https://codesandbox.io/s/youthful-mestorf-r8s38">在浏览器中运行</a> </p>
<h1 id="现有应用的接入方式"><a href="#现有应用的接入方式" class="headerlink" title="现有应用的接入方式"></a>现有应用的接入方式</h1><h2 id="暴力改造RESTful-Like模式"><a href="#暴力改造RESTful-Like模式" class="headerlink" title="暴力改造RESTful-Like模式"></a>暴力改造 RESTful-Like 模式</h2><p>RESTful -&gt; GraphQL</p>
<ul>
<li>就是简单粗暴的把 RESTful API 服务，替换成 GraphQL 实现。之前有多少 RESTful 服务，重构后就有多少 GraphQL 服务，</li>
<li>默认情况下，面向两个 GraphQL 服务发起的查询是两次请求，而不是一次 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">前端需要产品数据时，从之前调用产品相关的 RESTful API，变成查询产品相关的 GraphQL。不过，需要订单相关的数据时，可能要查询另一个 GraphQL 服务</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>它是一个简单的一对一关系</li>
</ul>
<p>收益甚微 选型失误</p>
<h2 id="作为中间层"><a href="#作为中间层" class="headerlink" title="作为中间层"></a>作为中间层</h2><p>同样是 API Gateway 角色的 GraphQL 服务，在实现方式上有不同的分类 </p>
<ul>
<li>1，传统意义上的后端服务（包含大量真实的数据操作和处理的 GraphQL）</li>
<li>2，<font color="red">GraphQL as BFF</font>（转发接口请求，聚合数据结果的 GraphQL）</li>
</ul>
<p>我们今天主要讨论 第二种</p>
<p><img src="http://cdn.anruence.com/%E6%8E%A5%E5%85%A5%E6%96%B9%E5%BC%8F.png" alt="image"></p>
<ul>
<li>前端不再直接调用具体的 RESTful 等接口，而是通过 GraphQL 去间接获取产品、订单、搜索等数据</li>
<li>在 GraphQL 这个中间层里，我们将各个微服务，按照它们的数据关联，整合成一个基于 GraphQL Schema 的数据关系网络。前端可以通过 GraphQL 查询语句，同时发起对多个微服务的数据的获取、筛选、裁剪等行为。</li>
<li>作为 API Gateway 的 GraphQL 服务，可以在其 Resolver 内，向前面提到的 RESTful-like 的 GraphQL 发起查询请求</li>
<li>既避免了前端需要一对多的问题，也解决了 API Gateway GraphQL 需要请求 RESTful 全量数据接口的内部冗余问题</li>
</ul>
<p><img src="http://cdn.anruence.com/airbnb.png" alt="image"></p>
<p>将 GraphQL schemas 转化为 Thhrift IDL，再统一操作底层数据</p>
<p><img src="http://cdn.anruence.com/%E5%BE%AE%E6%9C%8D%E5%8A%A1..png" alt="image"></p>
<h1 id="GraphQL不足"><a href="#GraphQL不足" class="headerlink" title="GraphQL不足"></a>GraphQL 不足</h1><ul>
<li>改造成本：后端服务需要按领域进行重构</li>
<li>存量大：迁移困难</li>
<li>数据库性能 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">- GraphQL 虽然解决将多个 HTTP 请求聚合成了一个请求，但是schema 会逐层解析方式递归获取全部数据</span><br><span class="line">- 前端请求少了但是query很多 数据库设计影响日后性能</span><br><span class="line">- 后端对前端改造无感知：前端修改了GraphQL的请求格式，可能会造成深层嵌套，对后端服务有较大影响</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>侵入性：前端利好，却需要服务端鼎力支持</li>
<li>复杂性：学习成本高 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">需要了解GraphQL一整套类型系统</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>典型的 N+1 问题 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">使用REST API 是很容易评估 ，识别和解决N+1问题的</span><br><span class="line">使用GraphQL会使这个问题变得相对复杂</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>数据缓存问题 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">REST强制使用具有缓存机制的HTTP协议 ，可以通过它 避免活回去多余资源</span><br><span class="line">GraphQL没有缓存机制，它把缓存的重任交给了用户</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>可见，整体来看，实际接入 GraphQL 并非易事，它只是一套规范，各种语言实现不一致，周边生态不够完善，需要后端配合改造，成本大，</li>
<li>除此之外，还有各种错误处理，日志上报及缓存机制的处理办法良莠不齐</li>
</ul>
<p>正因如此，GraphQL 很长一段时间还不能发挥其巨大作用</p>
<p>这一切 随着 Apollo 登场 正在逐步改善</p>
<h1 id="基于GraphQL的社区解决方案"><a href="#基于GraphQL的社区解决方案" class="headerlink" title="基于GraphQL的社区解决方案"></a>基于 GraphQL 的社区解决方案</h1><h2 id="Apollo"><a href="#Apollo" class="headerlink" title="Apollo"></a>Apollo</h2><p>可以把 GraphQL 理解成 NodeJS 的 http 包，那么 Apollo-server 就类似于在前面基础上封装出来的框架</p>
<h3 id="Apollo-Client"><a href="#Apollo-Client" class="headerlink" title="Apollo-Client"></a>Apollo-Client</h3><p>web，iOS，Android 三端的实现</p>
<h3 id="Apollo-Server"><a href="#Apollo-Server" class="headerlink" title="Apollo-Server"></a>Apollo-Server</h3><p>koa，express 等 NodeJsWeb 的实现</p>
<p>还提供了如下能力</p>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>接口格式五花八门，错误处理也没有统一的方案，Apollo 会将所有的错误内容格式化统一的错误信息，从此可以摆脱后端带来的束缚，方便我们在前端去处理。</p>
<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>借助 GraphQL 的 makeExecutableSchema 和 mergeSchemas 方法，能够按模块去编写类型定义及 resolve，最后使用 mergeSchemas 将他们合并到一起</p>
<h3 id="错误监控"><a href="#错误监控" class="headerlink" title="错误监控"></a>错误监控</h3><p>Apollo server 提供 formatError，formatResponse，能够细化到每一次请求，每一次错误的发生，方便我们去上报日志及错误</p>
<p>工作流程</p>
<p><img src="http://cdn.anruence.com/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88wee.png" alt="image"></p>
<p>接入架构设想</p>
<p><img src="http://cdn.anruence.com/jiagoushaxiang.png" alt="image"></p>
<ul>
<li>通过复用现有的 REST 接口，做到无需后端配合改造</li>
<li>在我们开发的项目里，由于会对接不同的后端团队，伴随着一些历史遗留问题，接口格式五花八门，错误处理也没有统一的方案，Apollo 会将所有的错误内容格式化统一的错误信息，从此可以摆脱后端带来的束缚，方便我们在前端去处理</li>
<li>在开发大型应用中，模块是是必不可少的。借助 GraphQL 的 makeExecutableSchema 和 mergeSchemas 方法，能够按模块去编写类型定义及 resolve，最后使用 mergeSchemas 将他们合并到一起</li>
<li>由于接入了 node server，那么我们需要监控错误以及请求日志等内容，Apollo server 提供 formatError，formatResponse，能够细化到每一次请求，每一次错误的发生，方便我们去上报日志及错误</li>
</ul>
<p>接入成果设想<br><img src="http://cdn.anruence.com/chengguoshexiang.png" alt="image"></p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul>
<li><font color="red">更准确的获取你想要的数据</font> - 核心诉求</li>
<li>控制数据的是应用而非服务器 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">在应用层对数据模型的抽象</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>将你需要的数据汇聚成数据网格 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">前端不能通过一次查询直接得到自己所需要的数据，Graphql的查询不仅指定了要查询的信息同时给出了期望的数据结构</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>应对复杂场景的一种新思路 thinking in graph</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">设计 GraphQL接口更像是在建立资源与资源之间的关系，并最终得到一个单一内聚图的过程 GraphQL 给了我们一种基于「图」的设计思路</span><br></pre></td></tr></tbody></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>深入理解 Flexbox</title>
    <url>/2019/03/14/flex/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>过去，我们总是不得不忍受 <code>float、display:table</code> 这些布局方式带来的痛苦，不过现在是时候去拥抱一个更简洁的制作智能布局的现代语法 <code>Flexbox</code></p>
<h2 id="Flexbox是什么"><a href="#Flexbox是什么" class="headerlink" title="Flexbox是什么"></a>Flexbox 是什么</h2><p>根据规范中的描述可知道，<code>Flexbox</code> 模块提供了一个有效的布局方式，即使不知道视窗大小或者未知元素情况之下都可以智能的，灵活的调整和分配元素和空间两者之间的关系</p>
<a id="more"></a>
<h2 id="如何开始使用Flexbox"><a href="#如何开始使用Flexbox" class="headerlink" title="如何开始使用Flexbox"></a>如何开始使用 Flexbox</h2><p>幸运的是，入门超级简单<br>你要做的第一件事就是声明一个 <code>Flex</code> 容器</p>
<p>就像这样儿，声明了 <code>Flex</code> 容器之后，一个 <code>Flexbox</code> 格式化上下文就立即启动了</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;ul class="oul"&gt;</span><br><span class="line">  &lt;li&gt;1&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;2&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;3&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>正常情况下 div 在 CSS 中垂直堆栈的，也就是说从上到下排列显示</p>
<p>图一<br><img src="/images/flex/flex2.png" alt="flex2"></p>
<p>声明 <code>Flex容器</code></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">.oul {</span><br><span class="line">    //...</span><br><span class="line">    display: flex</span><br><span class="line">    //...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>现在已经是一个 Flexbox 格式化上下文<br>图二<br><img src="/images/flex/flex1.png" alt="flex1"></p>
<p><strong>很简单 一行代码就能看到布局改变了子元素就像你使用了 float 一样是水平排列的</strong></p>
<p>拿这个例子来说此时 <code>ul</code> 自动变成了 <code>Flex</code>，而 <code>li</code> 变成了 <code>Flex</code> 项目</p>
<p>记住这些名词，它们是 <code>Flexbox</code> 模块的基础</p>
<h2 id="Flex容器属性"><a href="#Flex容器属性" class="headerlink" title="Flex容器属性"></a>Flex 容器属性</h2><p><code>flex-direction || flex-wrap || flex-flow || justify-content || align-items || align-content </code><br>解释这些属性之前，先来看一张 flex 世界比较重要的概念</p>
<p><img src="/images/flex/flex3.png" alt="flex3"></p>
<ul>
<li><code>Main-Axis</code> 就是水平方向，从左到右，这也是默认方向</li>
<li><code>Cross-Axis</code> 是垂直方向，从上往下</li>
</ul>
<h3 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h3><p>属性值</p>
<figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> { <span class="attribute">flex-direction</span>: row || column || row-reverse || column-reverse; }</span><br></pre></td></tr></tbody></table></figure>
<p>默认值是 <code>row</code> 它让 Flex 项目沿着 Main-Axis 排列（从左向右，水平排列） 这也解释了图二的效果</p>
<h3 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h3><p>属性值</p>
<figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> { <span class="attribute">flex-wrap</span>: wrap || nowrap || wrap-reverse; }</span><br><span class="line"></span><br><span class="line">*  <span class="selector-tag">nowrap</span>: <span class="selector-tag">Flex</span>容器内的<span class="selector-tag">Flex</span>项目不换行排列 （默认值）</span><br><span class="line">*  <span class="selector-tag">wrap</span>:换行排列 这种情况下，一行不能包含所有列表项的默认宽度，它们就会多行排列</span><br><span class="line">*  <span class="selector-tag">wrap-reverse</span>:反向换行</span><br></pre></td></tr></tbody></table></figure>

<h3 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h3><figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-tag">flex-flow</span>是<span class="selector-tag">flex-direction</span>和<span class="selector-tag">flex-wrap</span>两个属性的速记属性</span><br></pre></td></tr></tbody></table></figure>
<p>语法</p>
<figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> { <span class="attribute">flex-flow</span>: row wrap; }</span><br></pre></td></tr></tbody></table></figure>

<h3 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h3><p>接下来感受来自 <code>flex</code> 容器的魔法</p>
<p>它主要定义了 Flex 项目在 <code>Main-Axis</code> 上的对齐方式</p>
<p>属性值</p>
<figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> { <span class="attribute">justify-content</span>: flex-start || flex-end || center || space-between || space-around }</span><br><span class="line">* <span class="selector-tag">flex-start</span> 元素位于容器的开头。弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。</span><br><span class="line">* <span class="selector-tag">flex-end</span> 元素位于容器的结尾，弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界</span><br><span class="line">* <span class="selector-tag">center</span>：居中对齐</span><br><span class="line">* <span class="selector-tag">space-between</span>：让除了第一个和最一个<span class="selector-tag">Flex</span>项目的两者间间距相同（两端对齐）</span><br><span class="line">* <span class="selector-tag">space-around</span>：让每个<span class="selector-tag">Flex</span>项目具有相同的空间</span><br></pre></td></tr></tbody></table></figure>

<p><strong>space-between</strong><br><img src="/images/flex/between.png" alt="between"><br><strong>space-around</strong></p>
<p>和 space-between 有点不同，第一个 Flex 项目和最后一个 Flex 项目距 Main-Axis 开始边缘和结束边缘的的间距是其他相邻 Flex 项目间距的一半<br><img src="/images/flex/around.png" alt="around"></p>
<h3 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h3><p>它主要用来控制 Flex 项目在侧轴上的对齐方式</p>
<figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> { <span class="attribute">align-items</span>: flex-start || flex-end || center || stretch || baseline }</span><br><span class="line"></span><br><span class="line">* <span class="selector-tag">stretch</span> 默认值 让所有的<span class="selector-tag">Flex</span>项目高度和<span class="selector-tag">Flex</span>容器高度一样。</span><br><span class="line">* <span class="selector-tag">flex-start</span> 元素位于容器的开头。弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。</span><br><span class="line">* <span class="selector-tag">flex-end</span> 元素位于容器的结尾，弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界</span><br><span class="line">* <span class="selector-tag">center</span> 元素位于容器的中心</span><br><span class="line">* <span class="selector-tag">baseline</span> 让所有<span class="selector-tag">Flex</span>项目在<span class="selector-tag">Cross-Axis</span>上沿着他们自己的基线对齐</span><br></pre></td></tr></tbody></table></figure>

<p><strong>baseline</strong><br>效果类似 <code>flex-start</code> 但略有不同<br>区别就在于 <code>baseline</code><br><img src="/images/flex/base.png" alt="base"></p>
<h3 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">ul { align-items: stretch|center|flex-start|flex-end|space-between|space-around}</span><br><span class="line"></span><br><span class="line">* stretch 默认值 元素被拉伸以适应容器</span><br><span class="line">* flex-start 元素位于容器的开头。弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。</span><br><span class="line">* flex-end 元素位于容器的结尾，弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界</span><br><span class="line">* center 元素位于容器的中心</span><br><span class="line">* space-between：让除了第一个和最一个Flex项目的两者间间距相同（两端对齐）</span><br><span class="line">* space-around：让每个Flex项目具有相同的空间</span><br></pre></td></tr></tbody></table></figure>
<p><strong>stretch</strong><br><img src="/images/flex/align-content.png" alt="align-content"><br>flex-end<br><img src="/images/flex/ennd.png" alt="ennd"></p>
<p><strong>flex-start</strong></p>
<p><img src="/images/flex/align-content-start.png" alt="align-content-start"></p>
<p><strong>center</strong><br><img src="/images/flex/center.png" alt="cente"></p>
<h2 id="Flex项目属性"><a href="#Flex项目属性" class="headerlink" title="Flex项目属性"></a>Flex 项目属性</h2><figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">order || flex-grow || flex-shrink || flex-basis</span><br></pre></td></tr></tbody></table></figure>

<h3 id="order"><a href="#order" class="headerlink" title="order"></a>order</h3><p>允许 Flex 项目在一个 Flex 容器中重新排序。基本上，你可以改变 Flex 项目的顺序，从一个位置移动到另一个地方而不改变源代码，所有 Flex 项目的 order 值都是 0，Flex 项目会根据 order 值从低到高重新排序</p>
<figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-class">.oul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(1)</span> {</span><br><span class="line">    <span class="attribute">order</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/*设置一个比0更大的值*/</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>Flex 项目 2、3、4 的 order 值为 0。现在 Flex 项目 1 的 order 值为 1</p>
<p><img src="/images/flex/order.png" alt="orde"></p>
<p>Flex 项目 <code>2、3和4的order</code> 值都是 <code>0</code>。HTML 源代码秩序并没有修改过。如果给 <code>Flex</code> 项目 2 的 <code>order</code> 设置为 <code>2</code><br><img src="/images/flex/order2.png" alt="orde"></p>
<p>可见 它也增加堆栈。现在代表 <code>Flex</code> 项目的最高的 <code>order</code> 值</p>
<p>当两个 Flex 项目具有相同的 order 值呢？在下面的示例中，把 Flex 项目 1 和 3 设置相同的 order 值。<br><img src="/images/flex/order3.png" alt="orde"><br>现在仍是从低到高排列。这次 <code>Flex</code> 项目 <code>3</code> 排在 <code>Flex</code> 项目 <code>1</code> 后面，那是因为在 <code>HTML</code> 文档中 <code>Flex</code> 项目 <code>3</code> 出现在 <code>Flex</code> 项目 <code>1</code> 后面。</p>
<p>如果两个以下 <code>Flex</code> 项目有相同的 <code>order</code> 值时，<code>Flex</code> 项目重新排序是基于 <code>HTML</code> 源文件的位置进行排序</p>
<h3 id="flex-grow-和-flex-shrink"><a href="#flex-grow-和-flex-shrink" class="headerlink" title="flex-grow 和 flex-shrink"></a>flex-grow 和 flex-shrink</h3><ul>
<li>flex-grow ：控制 <code>Flex</code> 项目在容器有多余的空间如何放大（扩展）默认值是 0 表示开关是关闭的，即如果存在剩余空间，也不放大 </li>
</ul>
<figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> {</span><br><span class="line">  <span class="attribute">flex-grow</span>: &lt;number&gt;; <span class="comment">/* default 0 */</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/images/flex/flow-grow.png" alt="flow-gro"><br>属性值为 1 时<br><img src="/images/flex/flow-grow1.png" alt="flow-gro"></p>
<p>现在 <code>Flex</code> 项目扩展了，占据了 Flex 容器所有可用空间。也就是说开关打开了。如果你试着调整你浏览器的大小，<code>Flex</code> 项目也会缩小，以适应新的屏幕宽度</p>
<p>如果所有项目的 <code>flex-grow</code> 属性都为 <code>1</code>，则它们将等分剩余空间（如果有的话）<br>如果一个项目的 <code>flex-grow</code> 属性为 <code>2</code>，其他项目都为 <code>1</code>，则前者占据的剩余空间将比其他项多一倍</p>
<ul>
<li>flex-shrink：属性定义了项目的缩小比例，默认为 <code>1</code>（默认开启），即如果空间不足，该项目将缩小 </li>
</ul>
<figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> {</span><br><span class="line">  <span class="attribute">flex-shrink</span>: &lt;number&gt;; <span class="comment">/* default 1 */</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h3><p>它用于设置或检索弹性盒伸缩基准值<br><code>浏览器</code>根据这个属性，计算主轴是否有多余空间一般配合 <code>flex-wrap </code>一起使用，flex 容器根据 <code>flex-basis</code> 计算是否需要换行</p>
<p>一些特性</p>
<h4 id="1-它的属性值可以是长度单位-em-rem-px-或百分比-，百分比是按照父元素的width为标准"><a href="#1-它的属性值可以是长度单位-em-rem-px-或百分比-，百分比是按照父元素的width为标准" class="headerlink" title="1.它的属性值可以是长度单位(em || rem || px)**或百分比(%)**，百分比是按照父元素的width为标准"></a>1. 它的属性值可以是<strong>长度单位 (em || rem || px)** 或</strong>百分比 (%)**，<font color="red">百分比是按照父元素的 width 为标准</font></h4><h4 id="2-默认值为-auto-MDN"><a href="#2-默认值为-auto-MDN" class="headerlink" title="2.默认值为 auto  MDN"></a>2. 默认值为 <font color="red">auto</font>  <a href="https://drafts.csswg.org/css-flexbox/#flexibility">MDN</a></h4> <figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">取值为**auto**时，它的值就等于当前项的**width**（或者默认的大小，width没有设置的话）" </span><br><span class="line">flex-basis:auto" 的含义是 "参照我的width和height属性</span><br></pre></td></tr></tbody></table></figure>
<h4 id="当flex-item没有自身宽高，其默认大小由flex-basis决定"><a href="#当flex-item没有自身宽高，其默认大小由flex-basis决定" class="headerlink" title="当flex-item没有自身宽高，其默认大小由flex-basis决定"></a>当 flex-item 没有自身宽高，其默认大小由 flex-basis 决定</h4><p>即优先级： <font color="red">flex-basis &gt; width (非 auto)</font></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">.oul2-li{</span><br><span class="line">      flex-basis: 200px;</span><br><span class="line">      width: 10px;</span><br><span class="line">      margin: 0px 4px;</span><br><span class="line">      background: red;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>
<p><img src="/images/flex/shiliflex1.png" alt="shiliflex1"></p>
<h4 id="4-当元素存在默认宽高（input）"><a href="#4-当元素存在默认宽高（input）" class="headerlink" title="4.当元素存在默认宽高（input）"></a>4. 当元素存在默认宽高（<font color="red">input</font>）</h4><p>并且设置了 <code>flex-basis</code>，那么它的初始大小<code>以固定宽高为下限</code>，如果 <code>flex-basis </code>超过了固定宽高，那么以 <code>flex-basis</code> 设置大小为准，如果 <code>flex-basis</code> 比固定宽高小，那么以固定宽高为准</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">.Myinput {</span><br><span class="line">     background: greenyellow;</span><br><span class="line">     flex-basis: 200px;</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>
<p><img src="/images/flex/gfdsdf.png" alt="gfdsdf"><br>当将 <code>flex-basis</code> 设置的比默认宽度大</p>
<p><img src="/images/flex/swqs.png" alt="swqs"></p>
<p>当将 <code>flex-basis</code> 设置的比默认宽度小 100<br><img src="/images/flex/jnjjjuuu.png" alt="jnjjjuuu"></p>
<h4 id="5-当元素存在-min-width-height-或者-max-width-height"><a href="#5-当元素存在-min-width-height-或者-max-width-height" class="headerlink" title="5.当元素存在 min-width[height] 或者 max-width[height]"></a>5. 当元素存在 min-width [height] 或者 max-width [height]</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">如果 `flex-basis` 的值 大于 `min-width[min-height]`，`flex-item content`的值为 `flex-basis`</span><br><span class="line">如果`flex-basis `的值小于` min-width[min-height]` 那么`flex-item content`以`min-width[min-height]`计算</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/images/flex/jsjjsjsjjjsjsjs.png" alt="jsjjsjsjjjsjsjs"></p>
<h4 id="6-元素设置width-height-auto"><a href="#6-元素设置width-height-auto" class="headerlink" title="6.元素设置width[height]: auto;"></a>6. 元素设置 <code>width[height]: auto;</code></h4><p>CSS 解析器对比两者的值，两者<strong>谁大取谁</strong>作为 <code>item</code> 的基本尺寸，如果一个 <code>item</code> 没有内容，flex-item 初始大小就会以 <code>flex-basis</code> 来决定<br>但是如果 <code>item</code> 有了内容，且内容撑开的尺寸比 <code>flex-basis</code> 大，那么 <code>flex-item</code> 初始大小就会以 <code>width[height]: auto; </code>来决定<br><br>优先级：<font color="red">width[height]: auto == flex-basis</font></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"> &lt;ul class="oul2"&gt;</span><br><span class="line">      &lt;li class="li1"&gt;666666666666666666666666666666666666666666666666666666666666666666666666666666666666&lt;/li&gt;</span><br><span class="line">      &lt;li class="li2"&gt;77777&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    </span><br><span class="line">    .li1{</span><br><span class="line">    flex-basis: 100px;</span><br><span class="line">    margin-right: 5px;</span><br><span class="line">    background: greenyellow;</span><br><span class="line">    width: auto;</span><br><span class="line">}</span><br><span class="line">.li2{</span><br><span class="line">    flex-basis: 300px;</span><br><span class="line">    width: auto;</span><br><span class="line">    background: red;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">.oul2{</span><br><span class="line">    display: flex;</span><br><span class="line">    list-style: none;</span><br><span class="line">    border: 1px solid #ccc;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><img src="/images/flex/uuxsuudhdusd.png" alt="uuxsuudhdusd"></p>
<h2 id="绝对和相对Flex项目"><a href="#绝对和相对Flex项目" class="headerlink" title="绝对和相对Flex项目"></a>绝对和相对 Flex 项目</h2><p>绝对 Flex 项目的宽度只基于 flex 属性，而相对 Flex 项目的宽度基于内容大小</p>
<p><strong>相对项目</strong></p>
<figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-class">.oul</span> {</span><br><span class="line">     <span class="attribute">display</span>: flex;</span><br><span class="line">     <span class="comment">/*触发弹性盒*/</span></span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> <span class="selector-class">.oul</span> <span class="selector-tag">li</span> {</span><br><span class="line">     //flex-basis: auto;</span><br><span class="line">     <span class="selector-tag">flex</span>: <span class="selector-tag">auto</span>; <span class="comment">/*记住这与 flex: 1 1 auto; 相同*/</span></span><br><span class="line">     <span class="selector-tag">border</span>: 2<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-tag">red</span>;</span><br><span class="line">     <span class="selector-tag">margin</span>: 2<span class="selector-tag">rem</span>;</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/images/flex/xianngdui.png" alt="xianngdui"></p>
<p>Flex 项目的初始宽度是被自动计算的（<code>flex-basis: auto</code>），然后会伸展以适应可用空间（<code>flex-grow: 1</code>）</p>
<p>像这样 当 <code>Flex</code> 项目因为被设置为 <code>flex-basis: auto</code>，而导致宽度被自动计算时，是基于 <code>Flex</code> 项目内包含的内容的大小而计算的就是相对项目</p>
<p><strong>绝对项目</strong></p>
<figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-class">.oul</span> <span class="selector-tag">li</span> {</span><br><span class="line">     <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">     <span class="attribute">flex-shrink</span>: <span class="number">1</span>;</span><br><span class="line">     <span class="attribute">flex-basis</span>: <span class="number">0</span>;</span><br><span class="line">     <span class="comment">/*与 flex: 1 1 0 相同*/</span></span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> solid red;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">2rem</span>;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/images/flex/juedui.png" alt="juedui"></p>
<p><code>Flex</code> 项目的初始宽度是零（<code>flex-basis: 0</code>），并且它们会伸展以适应可用空间。当有两到多个 <code>Flex</code> 项目的 <code>flex-basis</code> 取值为 <code>0</code> 时，它们会基于 <code>flex-grow</code> 值共享可用空间</p>
<h3 id="flex组合属性"><a href="#flex组合属性" class="headerlink" title="flex组合属性"></a>flex 组合属性</h3><p>flex 是 <code>flex-grow、flex-shrink和flex-basis</code> 三个属性的速记（简写）顺序缩写为 GSB </p>
<h4 id="一些取值规律"><a href="#一些取值规律" class="headerlink" title="一些取值规律"></a>一些取值规律</h4><p><strong>当 flex 取值为一个非负数字，则该数字为 flex-grow 值，flex-shrink 取 1，flex-basis 取 0%，例如：flex: 1; 相当于</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">li {</span><br><span class="line">    flex-grow: 1;</span><br><span class="line">    flex-shrink: 1;</span><br><span class="line">    flex-basis: 0%;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>⚠️ <code>flex-basis的</code>默认值为 <code>auto</code>，为什么此时是 <code>0%</code>？<br>当你创建一个 flexbox 上下文而不给 flex 项目设置任何属性，此时的默认值<br><img src="/images/flex/wwwaaaa111.png" alt="wwwaaaa111"><br>此时它是<font color="red">相对项目</font><br>一旦你设置了 <code>flex:1</code> 简写属性</p>
<p>参考 MDN 所说<br><img src="/images/flex/flexjianxie.png" alt="flexjianxie"><br>浏览器使其变成了<font color="red">绝对项目</font></p>
<p><strong>flex: auto;</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">li {</span><br><span class="line">    </span><br><span class="line">    flex-grow: 1;</span><br><span class="line">    flex-shrink: 1;</span><br><span class="line">    flex-basis: auto;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>当 flex 取值为一个长度或百分比，则视为 flex-basis 值，flex-grow 取 1，flex-shrink 取 1，有如下等同情况（注意 0% 是一个百分比而不是一个非负数字）</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">.item-1 {flex: 0%;}</span><br><span class="line">.item-1 {</span><br><span class="line">    flex-grow: 1;</span><br><span class="line">    flex-shrink: 1;</span><br><span class="line">    flex-basis: 0%;</span><br><span class="line">}</span><br><span class="line">.item-2 {flex: 24px;}</span><br><span class="line">.item-1 {</span><br><span class="line">    flex-grow: 1;</span><br><span class="line">    flex-shrink: 1;</span><br><span class="line">    flex-basis: 24px;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>当 flex 取值为两个非负数字，则分别视为 flex-grow 和 flex-shrink 的值，flex-basis 取 0%，如下是等同的：</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">.item {flex: 2 3;}</span><br><span class="line">.item {</span><br><span class="line">    flex-grow: 2;</span><br><span class="line">    flex-shrink: 3;</span><br><span class="line">    flex-basis: 0%;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>当 flex 取值为一个非负数字和一个长度或百分比，则分别视为 flex-grow 和 flex-basis 的值，flex-shrink 取 1，如下是等同的：</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">.item {flex: 2333 3222px;}</span><br><span class="line">.item {</span><br><span class="line">    flex-grow: 2333;</span><br><span class="line">    flex-shrink: 1;</span><br><span class="line">    flex-basis: 3222px;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<h2 id="深入flex"><a href="#深入flex" class="headerlink" title="深入flex"></a>深入 flex</h2><p>到这里 关于 <code>Flex</code> 的基础知识已经结束了，你可以用它们处理几乎任何问题<br>但是<br><font color="red">Flexbox 是如何弹性的计算子级项目的大小的，它有没有什么规则 </font><br>令我费解</p>
<p>好了，小🌻课堂开始了</p>
<p>flex 是应用在 X 轴和 Y 轴上的<br>每一根轴都包括三个东西 <code> 维度、方向、尺寸</code></p>
<ul>
<li>维度：子元素横着排 (X 轴) 还是竖着排 (Y 轴)</li>
<li> 方向：子元素的顺序 (顺序还是逆序)</li>
<li> 尺寸：即父元素的 <code>width</code>，子元素在当前轴方向所占的位置的总和</li>
</ul>
<p>如下图所示（来自 W3C 规范）</p>
<p><img src="/images/flex/w3c.png" alt="w3"></p>
<h2 id="FFC-flex-formatting-context"><a href="#FFC-flex-formatting-context" class="headerlink" title="FFC(flex formatting context)"></a>FFC(flex formatting context)</h2><p>Flexbox 布局新定义了格式化上下文，类似 BFC（block formatting context）<br>定义了 <code>display: flex;</code> 或 <code>display: inline-flex</code> 的元素，和 <code>BFC</code> 一样，不会被浮动的元素遮盖，不会垂直外边距坍塌等等</p>
<h2 id="与BFC的细微区别"><a href="#与BFC的细微区别" class="headerlink" title="与BFC的细微区别"></a>与 BFC 的细微区别</h2><ul>
<li>vertical-align 对 Flexbox 中的子元素 是没有效果的</li>
<li> float 和 clear 属性对 Flexbox 中的子元素是没有效果的，也不会使子元素脱离文档流 (但是对 Flexbox 是有效果的！)</li>
<li>Flexbox 下的子元素不会继承父级容器的宽</li>
</ul>
<h2 id="flex-item（flex-子元素）"><a href="#flex-item（flex-子元素）" class="headerlink" title="flex item（flex 子元素）"></a>flex item（flex 子元素）</h2><p>CSS 解析器会把 定义了 <code>display: flex;</code> 和 <code>display: inline-flex;</code> 的 <code>Flexbox </code>下的子元素外部装进一个看不见的盒子里，我们通过排列这些盒子来达到排序、布局、 伸缩的目的</p>
<h3 id="flex-item-size-是如何计算的"><a href="#flex-item-size-是如何计算的" class="headerlink" title="flex-item-size 是如何计算的"></a>flex-item-size 是如何计算的</h3><p>子元素的尺寸为主轴方向上元素的的自身宽度 再加上自身的 <code>margin 、 border 和 padding </code></p>
<p>W3C 规范中介绍了  <code>flex-item content</code> 的计算规则</p>
<h3 id="隐藏属性对-items-size-的影响"><a href="#隐藏属性对-items-size-的影响" class="headerlink" title="隐藏属性对 items-size 的影响"></a>隐藏属性对 items-size 的影响</h3><p>针对 <code>display: none; visibility: hidden; visibility: collapse; transform: scale;</code> 进行测试</p>
<p>结论</p>
<ul>
<li>如果设置了 <code>visibility: hidden; | visibility: collapse; | transform: scale;</code> 的 <code>flex-item content </code>依然被算进主轴尺寸，CSS 解析器依然将可用空间分配给他们</li>
<li>如果设置了 <code>display: none;</code> CSS 解析器不会对该 <code>item</code> 的空间进行计算</li>
</ul>
<h3 id="关于position-absolute-对item影响"><a href="#关于position-absolute-对item影响" class="headerlink" title="关于position: absolute 对item影响"></a>关于 position: absolute 对 item 影响</h3><p><code>position: absolute </code>也是适用 <code>Flexbox</code> 中的子元素的，并且，设置了 <code>position: absolute</code> 属性的子元素，也会受到 <code>Flexbox</code> 排列的影响</p>
<p>absolute 的子元素重叠在了一起，但是依然会受到 <code>align-items: center; </code>的影响而居中</p>
<p><img src="/images/flex/jjjjjdsd.png" alt="jjjjjdsd"></p>
<p>并且根据一系列的实验得知</p>
<p><code>flexbox</code> 下设置了 <code>absolute</code>：</p>
<ul>
<li>flexbox 流下面的 <code>justify-content</code> 和 <code>align-items</code></li>
<li><code>item</code> 的 <code>top、left、right、bottom</code></li>
<li><code>margin</code> 自始至终都会影响 <code>item</code> 的位置</li>
<li>脱离了文档流的 <code>item</code> 不会影响正常的 <code>flex</code> 布局</li>
</ul>
<p><strong>小结</strong><br><code>justify-content、align-items</code> 和 <code>top、left、right、bottom </code>都是位置属性 且 <code>top、left、right、bottom </code>的值会覆盖 <code>justify-content、align-items</code> 的值</p>
<p><code>margin </code>的优先级是和 <code>top、left、right、bottom</code> 一样的，也就是说 <code>margin 和 top、left、right、bottom</code> 所设置的值会<strong>同时生效</strong></p>
<h2 id="flex-basis、flex-grow、flex-shrink-以及相应的计算"><a href="#flex-basis、flex-grow、flex-shrink-以及相应的计算" class="headerlink" title="flex-basis、flex-grow、flex-shrink 以及相应的计算"></a>flex-basis、flex-grow、flex-shrink 以及相应的计算</h2><p>这三个属性只有父级元素设置了 <code>display: flex | inline-flex;</code> 才会生效，并且只针对主轴方向生效</p>
<ul>
<li>如果 主轴是水平的，即 <code>flex-direction: row</code>; 那么 <code>flex-basis、flex-grow、flex-shrink </code>控制的就是单个 <code>item</code> 的宽度</li>
<li>如果 主轴是垂直的，即 <code>flex-direction: column</code>; 那么 <code>flex-basis、flex-grow、flex-shrink</code> 控制的就是单个 item 的高度</li>
</ul>
<hr>
<p>那么所有 <code>items</code> 都会在主轴方向上的一条线上排列，<code>CSS解析器</code>会计算 <code>items</code> 在主轴方向上所占的空间 相对于 <code>Flexbox</code> 在主轴方向的所占的空间进行比较计算</p>
<ul>
<li>如果 <code>items</code> 所占的空间是小于 <code>Flexbox</code> 的 那么说明 <code>Flexbox</code> 还没有填满，<code>CSS解析器</code>就会计算还有多少空间没有填满，根据每一个 <code>item</code> 所设置的 <code>flex-grow</code> 设置的值，将这些空间分配按比例分配给每一个 <code>item</code></li>
</ul>
<p><img src="/images/flex/wwwqwq.png" alt="wwwqwq"></p>
<ul>
<li>如果 <code>items</code> 所占的空间是大于 <code>Flexbox</code> 的 那么说明 <code>Flexbox</code> 被填满了，<code>CSS解析器</code>就会计算超出了多少空间，根据每一个 <code>item</code> 所设置的 <code>flex-shrink</code> 设置的值，将这些空间分配按比例缩小每一个 <code>item</code><br><img src="/images/flex/fukeyongkongjian.png" alt="fukeyongkongjian"></li>
</ul>
<h3 id="超出的空间是如何计算的"><a href="#超出的空间是如何计算的" class="headerlink" title="超出的空间是如何计算的"></a>超出的空间是如何计算的</h3><p><strong><code>flow-grow</code> 的计算流程</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">可用空间 = 将flexbox-content - 每个item-size的总和</span><br></pre></td></tr></tbody></table></figure>

<p>将元素设置的 <code>flow-grow</code> 值加起来设置为 <code>growSize</code><br><code>单位分配空间 = 可用空间/growSize</code><br>然后真正分配的时候根据自己的比例计算增加的值<br><code>应该增加的值 = 自己的grow值 *  单位分配空间 </code></p>
<p><img src="/images/flex/growfencdc.png" alt="growfencd"></p>
<p><strong><code>flow-shrink</code> 的计算流程</strong></p>
<p>它的流程与 <code>flow-grow</code> 的计算流程<font color="red">不同</font></p>
<figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line">shrink比例 = flex-shrink * item-size / 之前的总和</span><br><span class="line"></span><br><span class="line">应该缩减的值：超出的空间 <span class="selector-tag">-</span> <span class="selector-tag">shrink</span>比例 * <span class="selector-tag">item-size</span></span><br></pre></td></tr></tbody></table></figure>

<p>如图所示</p>
<p><img src="/images/flex/shrinksw.png" alt="shrinks"></p>
<p><strong>max-width [height] 情况下 flex-grow 的计算流程</strong></p>
<p>由于可能存在某一个或多个 <code>item</code> 设置了有 <code>max-width[height]</code>。所以，CSS 引擎会先进行一次分配，分配后，统计那些有 <code>max-width[height]的items</code>, 分配后是否有超出的剩余空间，然后对这些剩余空间再分配给那些没有设置 <code>max-width[height]</code> 的 <code>item</code></p>
<p><img src="/images/flex/sandjandjnsjdwednjsedf.png" alt="sandjandjnsjdwednjsedf"></p>
<p><strong>min-width [height] 情况下 flex-shrink</strong></p>
<p>由于可能存在某一个或多个 item 设置了有 <code>min-width[height]</code>。所以，<code>CSS引擎</code>会先进行一次 <code>shrink</code>， <code>shrink</code> 后，统计那些有 <code>min-width[height]</code> 的 <code>items</code>, <code>shrink</code> 后是否有的剩余的未 <code>shrink</code> 空间，然后对这些剩余空间再分配给那些没有设置 <code>min-width[height]</code> 的 <code>item</code></p>
<p><img src="/images/flex/iiisjindndnjsndjsdnxjksndj.png" alt="iiisjindndnjsndjsdnxjksndj"></p>
<h2 id="Flexbox的浏览器支持"><a href="#Flexbox的浏览器支持" class="headerlink" title="Flexbox的浏览器支持"></a>Flexbox 的浏览器支持</h2><p>让我们求助于 <a href="https://caniuse.com/#search=flex">caniuse</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>深入理解 Flex 还是挺不容易的。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.w3cplus.com/css3/understanding-flexbox-everything-you-need-to-know.html">理解 flexbox，你需要知道的一切</a><br><a href="https://www.w3cplus.com/css3/flexbox-adventures.html">探索 Flexbox</a><br><a href="https://www.w3cplus.com/css3/flexbox-layout-and-calculation.html?from=groupmessage">理解 flex</a></p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js 实战 - 技术预研</title>
    <url>/2020/03/23/node/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>以一种要开发 Node.js 实战项目为最终目标<br>进行一系列的技术预研过程</p>
<p>有特点，有针对性，有目标</p>
<p>培养 Node 领域的全局观</p>
<h1 id="1-关于Nodejs"><a href="#1-关于Nodejs" class="headerlink" title="1 关于Nodejs"></a>1 关于 Nodejs</h1><h2 id="1-1-什么是Node-js"><a href="#1-1-什么是Node-js" class="headerlink" title="1.1 什么是Node.js"></a>1.1 什么是 Node.js</h2><p>官网的话：</p>
<ul>
<li>Node.js 是基于 ChromeV8 执行引擎的 JS 运行时环境</li>
<li> Node.js 使用了一个事件驱动，非阻塞式 I/O 的模型，使其轻量又高效</li>
</ul>
<p>每一个字其实都看得懂，聚合到一起就有点懵了</p>
<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1584894283204&amp;di=6e87b25c91207a1929250f11285d3a2c&amp;imgtype=0&amp;src=http://img2.biaoqingjia.com/biaoqing/201608/a70d12bb1f409850857c8d930cf2d6d1.gif" alt="image"></p>
<p>我们先不来说 nodejs 是什么，先根据以往的经验抛出问题</p>
<h3 id="1-1-1-在Node-js里运行Js跟在Chrome运行Js有啥不同？"><a href="#1-1-1-在Node-js里运行Js跟在Chrome运行Js有啥不同？" class="headerlink" title="1.1.1 在Node.js里运行Js跟在Chrome运行Js有啥不同？"></a>1.1.1 在 Node.js 里运行 Js 跟在 Chrome 运行 Js 有啥不同？</h3><p>已知 Chrome 浏览器用的是同样的 Javascript 引擎和模型</p>
<blockquote>
<p>其实，在 Node.js 里写 Js 和在 Chrome 里写 Js，<font color="red">几乎一样</font></p>
</blockquote>
<p>晃眼的<font color="red">几乎一样</font> 那就是有不一样的地方呗！</p>
<ul>
<li>Nodejs 没有浏览器 API，即 (Document,window 等)</li>
<li> 相应的，也增加了它专属的 API，比如文件系统，进程.</li>
</ul>
<p>有了这些差别，其实就不难理解了</p>
<h4 id="对于开发者来说"><a href="#对于开发者来说" class="headerlink" title="对于开发者来说"></a>对于开发者来说</h4><ul>
<li>你在 chrome 里写 js <strong>控制浏览器</strong></li>
<li> Node.js 让你用类似的方式，<strong>控制整个计算机</strong></li>
</ul>
<p>Node.js 的真谛，也就是官方抽象的释义，我们完全可以在不断深入的过程中慢慢理解～</p>
<a id="more"></a>
<h2 id="1-2-Node-js可以用来做什么？"><a href="#1-2-Node-js可以用来做什么？" class="headerlink" title="1.2 Node.js可以用来做什么？"></a>1.2 Node.js 可以用来做什么？</h2><h3 id="1-2-1-提供Web服务"><a href="#1-2-1-提供Web服务" class="headerlink" title="1.2.1 提供Web服务"></a>1.2.1 提供 Web 服务</h3><ul>
<li>搜索引擎优化 + 首屏速度优化 = 服务端渲染</li>
<li>服务端渲染 + 前后端同构 = Node.js</li>
</ul>
<h3 id="1-2-2-构建工作流"><a href="#1-2-2-构建工作流" class="headerlink" title="1.2.2 构建工作流"></a>1.2.2 构建工作流</h3><p>在 <code>gulp webpack</code> 之间，前端是如何做构建工具呢？</p>
<p>可能用 java,ruby 等</p>
<p>但</p>
<ul>
<li>构建工具不会永远不出问题</li>
<li>构建工具不会永远满足需求</li>
</ul>
<p>前端同学很难对这些工具进行修改或者升级</p>
<p>所以</p>
<blockquote>
<p>用 Node.js 做 js 的构建工具，是最保险的选择</p>
</blockquote>
<h3 id="1-2-3-开发工具"><a href="#1-2-3-开发工具" class="headerlink" title="1.2.3 开发工具"></a>1.2.3 开发工具</h3><p>VScode</p>
<p>在 nodejs 的基础上封装了 chrome 的内核，使 nodejs 具有控制计算机得到能力</p>
<h3 id="1-2-3-可扩展性较强大的沙盒游戏"><a href="#1-2-3-可扩展性较强大的沙盒游戏" class="headerlink" title="1.2.3 可扩展性较强大的沙盒游戏"></a>1.2.3 可扩展性较强大的沙盒游戏</h3><p>需要给使用者自定义模块的能力</p>
<p>使用 Nodejs 做复杂的本地应用</p>
<ul>
<li>可以利用 js 大的灵活性实现外部扩展</li>
<li> Js 庞大的的开发者基数让他们的灵活性得到利用</li>
</ul>
<h3 id="1-2-4-客户端应用"><a href="#1-2-4-客户端应用" class="headerlink" title="1.2.4 客户端应用"></a>1.2.4 客户端应用</h3><p>在已有网站的基础上需要开发新的客户端应用<br>使用 Node.js 客户端技术实现，可以最大限度的复用现有工程</p>
<h1 id="2-Node-js-初探"><a href="#2-Node-js-初探" class="headerlink" title="2 Node.js 初探"></a>2 Node.js 初探</h1><h2 id="2-1-实现剪刀石头布"><a href="#2-1-实现剪刀石头布" class="headerlink" title="2.1 实现剪刀石头布"></a>2.1 实现剪刀石头布</h2><ul>
<li>node 运行方式游戏</li>
<li>全局变量 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var playerAction = process.argv[process.argv.length - 1];</span><br><span class="line">console.log("playerAction", playerAction);</span><br><span class="line"></span><br><span class="line">var random1 = Math.random() * 3;</span><br><span class="line"></span><br><span class="line">if (random1 &lt; 1) {</span><br><span class="line">  var computerAction = "rock";</span><br><span class="line">} else if (random1 &gt; 2) {</span><br><span class="line">  var computerAction = "scissor";</span><br><span class="line">} else {</span><br><span class="line">  var computerAction = "paper";</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">if (computerAction === playerAction) {</span><br><span class="line">  console.log("平局");</span><br><span class="line">} else if (</span><br><span class="line">  (computerAction === "rock" &amp;&amp; playerAction === "paper") ||</span><br><span class="line">  (computerAction === "scissor" &amp;&amp; playerAction === "rock") ||</span><br><span class="line">  (computerAction === "paper" &amp;&amp; playerAction === "scissor")</span><br><span class="line">) {</span><br><span class="line">  console.log("你赢了！");</span><br><span class="line">} else {</span><br><span class="line">  console.log("你输了！");</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="2-1-使用Node-js模块规范改造游戏"><a href="#2-1-使用Node-js模块规范改造游戏" class="headerlink" title="2.1 使用Node.js模块规范改造游戏"></a>2.1 使用 Node.js 模块规范改造游戏</h2><h3 id="2-1-1-如何加载js"><a href="#2-1-1-如何加载js" class="headerlink" title="2.1.1 如何加载js"></a>2.1.1 如何加载 js</h3><p>浏览器端</p>
<ul>
<li>使用 <code>&lt;script/&gt;</code> 标签</li>
<li>脚本变多时，需要手动管理加载顺序</li>
<li>不同脚本之间的逻辑调用需要全局变量</li>
</ul>
<p>Node 端</p>
<ul>
<li>没有 html 文件，无法使用 <code>&lt;script/&gt;</code> 标签</li>
</ul>
<p><img src="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=45975645,3909583844&amp;fm=11&amp;gp=0.jpg" alt="image"></p>
<p>所以 Node.js 要重新去搞一个模块管理机制来管理 js 的加载，就是现在我们熟悉的<font color="red"> CommonJS 规范</font></p>
<h3 id="2-1-2-重构剪刀石头布游戏"><a href="#2-1-2-重构剪刀石头布游戏" class="headerlink" title="2.1.2 重构剪刀石头布游戏"></a>2.1.2 重构剪刀石头布游戏</h3><p>games.js</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">module.exports = function(playerAction) {</span><br><span class="line">  if (["rock", "scissor", "paper"].indexOf(playerAction) == -1) {</span><br><span class="line">    throw new Error("invalid playerAction");</span><br><span class="line">  }</span><br><span class="line">  // 计算电脑出的东西</span><br><span class="line">  var computerAction;</span><br><span class="line">  var random = Math.random() * 3;</span><br><span class="line">  if (random &lt; 1) {</span><br><span class="line">    computerAction = "rock";</span><br><span class="line">    console.log("电脑出了石头");</span><br><span class="line">  } else if (random &gt; 2) {</span><br><span class="line">    computerAction = "scissor";</span><br><span class="line">    console.log("电脑出了剪刀");</span><br><span class="line">  } else {</span><br><span class="line">    computerAction = "paper";</span><br><span class="line">    console.log("电脑出了布");</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  if (computerAction == playerAction) {</span><br><span class="line">    console.log("平局");</span><br><span class="line">    return 0;</span><br><span class="line">  } else if (</span><br><span class="line">    (computerAction == "rock" &amp;&amp; playerAction == "scissor") ||</span><br><span class="line">    (computerAction == "scissor" &amp;&amp; playerAction == "paper") ||</span><br><span class="line">    (computerAction == "paper" &amp;&amp; playerAction == "rock")</span><br><span class="line">  ) {</span><br><span class="line">    console.log("你输了");</span><br><span class="line">    return -1;</span><br><span class="line">  } else {</span><br><span class="line">    console.log("你赢了");</span><br><span class="line">    return 1;</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>index.js</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const game = require("./game.js");</span><br><span class="line"></span><br><span class="line">var winCount = 0;</span><br><span class="line">// 获取进程的标准输入</span><br><span class="line">process.stdin.on("data", buffer =&gt; {</span><br><span class="line">  // 回调的是buffer，需要处理成string</span><br><span class="line">  const action = buffer.toString().trim();</span><br><span class="line">  const result = game(action);</span><br><span class="line">  if (result == 1) {</span><br><span class="line">    winCount++;</span><br><span class="line">    if (winCount == 3) {</span><br><span class="line">      console.log("我不玩儿了！哼！");</span><br><span class="line">      process.exit();</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">});</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h1 id="3-Node内置模块"><a href="#3-Node内置模块" class="headerlink" title="3 Node内置模块"></a>3 Node 内置模块</h1><p><a href="http://nodejs.cn/api/">内置模块合集</a></p>
<h2 id="3-1-Node-js系统架构图"><a href="#3-1-Node-js系统架构图" class="headerlink" title="3.1 Node.js系统架构图"></a>3.1 Node.js 系统架构图</h2><p><img src="http://cdn.anruence.com/node-system-1.png" alt="image"></p>
<h2 id="3-2-理解Node-js精髓"><a href="#3-2-理解Node-js精髓" class="headerlink" title="3.2 理解Node.js精髓"></a>3.2 理解 Node.js 精髓</h2><blockquote>
<p>Node.js 是基于 ChromeV8 执行引擎的 JS 运行时环境</p>
</blockquote>
<p><font color="red">ChromeV8 执行引擎的 JS 运行时环境</font>：架构图的左侧部分就是其体现</p>
<ul>
<li>application 代表你写的 nodejs 的代码</li>
<li>通过 V8 引擎来来运行，里面会涉及到一些关于操作系统调用，这部分就由 V8 引擎帮你转发到操作系统层面</li>
<li>从操作系统层面得到返回结果之后再通过 V8 引擎返回到 Js 里去</li>
</ul>
<ol>
<li>从 Js 到 V8 再到操作系统的能力，大部分都是通过 Node.js 的内置模块来提供的</li>
<li>还有一些数据是从操作系统底层通知到我们的 Node.js 层</li>
</ol>
<p>示例</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 将进程设置为长期存在并且监听用户的输入</span><br><span class="line">process.stdin.on('data',e=&gt;{</span><br><span class="line">  const playerAction = e.toString().trim();</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p>此时依赖的是 Node 的内置模块</p>
<ul>
<li>EventEmitter</li>
</ul>
<p>process 实际上是 EventEmitter 的实例，继承了 EventEmitter 使其具备了向上抛事件的能力</p>
<p>引出</p>
<h2 id="3-3-EventEmitter"><a href="#3-3-EventEmitter" class="headerlink" title="3.3 EventEmitter"></a>3.3 EventEmitter</h2><h3 id="3-3-1-解决了什么问题"><a href="#3-3-1-解决了什么问题" class="headerlink" title="3.3.1 解决了什么问题"></a>3.3.1 解决了什么问题</h3><ul>
<li>解决两个对象之间的通信问题<ul>
<li>函数调用</li>
<li>观察者模式（事件收发模式）- 抛事件<ul>
<li> addEventListener</li>
<li>removeEventListener</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-3-2-普通调用应用场景"><a href="#3-3-2-普通调用应用场景" class="headerlink" title="3.3.2 普通调用应用场景"></a>3.3.2 普通调用应用场景</h3><ul>
<li>老板通知秘书</li>
<li>说是通知，但是直接调用比较合适<h3 id="3-3-3-观察者模式应用场景"><a href="#3-3-3-观察者模式应用场景" class="headerlink" title="3.3.3 观察者模式应用场景"></a>3.3.3 观察者模式应用场景</h3></li>
<li>通知消息的人并不知道被通知者的存在（极客时间并不知道我的存在）</li>
<li>没有人接收事件，它还能继续下去（今天没有接收到 Geek 上新课的消息，但是它还是可以上新课）</li>
</ul>
<p>lib.js</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const EventEmitter = require('events')</span><br><span class="line">class Geektime extends EventEmitter{</span><br><span class="line">  constructor(){</span><br><span class="line">    super();</span><br><span class="line">    setInterval(() =&gt; {</span><br><span class="line">      this.emit('newlesson',{price:Math.random()* 100}) //触发事件</span><br><span class="line">    }, 3000);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">const geektime = new Geektime;</span><br><span class="line"></span><br><span class="line">module.exports = geektime</span><br></pre></td></tr></tbody></table></figure>

<p>index.js</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const geektime = require('./lib.js')</span><br><span class="line">geektime.addListener('newlesson',(res)=&gt;{</span><br><span class="line">  if(res.price &lt; 50){</span><br><span class="line">    console.log('buy!当前价格为---',res)</span><br><span class="line">  }</span><br><span class="line">})</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h1 id="4-Nodejs非阻塞I-O及异步编程"><a href="#4-Nodejs非阻塞I-O及异步编程" class="headerlink" title="4 Nodejs非阻塞I/O及异步编程"></a>4 Nodejs 非阻塞 I/O 及异步编程</h1><p>值得拿出来单独说，<a href="http://maying.ink/2019/03/19/promise/">戳此一览</a></p>
<h1 id="5-实现网页版石头剪刀布游戏"><a href="#5-实现网页版石头剪刀布游戏" class="headerlink" title="5 实现网页版石头剪刀布游戏"></a>5 实现网页版石头剪刀布游戏</h1><p>技术前置</p>
<h2 id="5-1-什么是HTTP服务"><a href="#5-1-什么是HTTP服务" class="headerlink" title="5.1 什么是HTTP服务"></a>5.1 什么是 HTTP 服务</h2><p>一个网页请求，包含两次 HTTP 包交换</p>
<ul>
<li>浏览器向 HTTP 服务器发送请求 HTTP 包</li>
<li> HTTP 服务器向浏览器返回 HTTP 包</li>
</ul>
<h2 id="5-2-HTTP服务要做什么事情"><a href="#5-2-HTTP服务要做什么事情" class="headerlink" title="5.2 HTTP服务要做什么事情"></a>5.2 HTTP 服务要做什么事情</h2><ul>
<li>解析进来的 HTTP 请求报文</li>
<li>返回对应的 HTTP 返回报文 </li>
</ul>
<h2 id="5-3-实现一个简单的HTTP服务器"><a href="#5-3-实现一个简单的HTTP服务器" class="headerlink" title="5.3 实现一个简单的HTTP服务器"></a>5.3 实现一个简单的 HTTP 服务器</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const http = require('http')</span><br><span class="line">const fs = require('fs')</span><br><span class="line">http</span><br><span class="line">.createServer((req,res)=&gt;{</span><br><span class="line">    res.writeHead(200);</span><br><span class="line">    res.end('hello')</span><br><span class="line"></span><br><span class="line">})</span><br><span class="line">.listen(8888)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="5-4-server端加载模版"><a href="#5-4-server端加载模版" class="headerlink" title="5.4 server端加载模版"></a>5.4 server 端加载模版</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const http = require('http')</span><br><span class="line">const fs = require('fs')</span><br><span class="line">http</span><br><span class="line">.createServer((req,res)=&gt;{</span><br><span class="line">    res.writeHead(200);</span><br><span class="line">    res.end('hello')</span><br><span class="line">    fs.createReadStream(__dirname + '/index.html')</span><br><span class="line">    .pipe(res)</span><br><span class="line"></span><br><span class="line">})</span><br><span class="line">.listen(8888)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="5-5-游戏逻辑"><a href="#5-5-游戏逻辑" class="headerlink" title="5.5 游戏逻辑"></a>5.5 游戏逻辑</h3><p>index.js  <a href="https://github.com/maying2020/nodejs-in-action/tree/master/http/nodeNative">源码点击</a></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const http = require("http");</span><br><span class="line">const fs = require("fs");</span><br><span class="line">const url = require("url");</span><br><span class="line">const querystring = require("queryString");</span><br><span class="line">const game = require("./game.js");</span><br><span class="line"></span><br><span class="line">let playerLastAction = null; //玩家上次出的</span><br><span class="line">let playerWon = 0; //玩家赢得次数</span><br><span class="line">let sameCount = 0; //统计相同操作统计次数</span><br><span class="line"></span><br><span class="line">http</span><br><span class="line">  .createServer((req, res) =&gt; {</span><br><span class="line">    // 通过内置模块url，转换发送到该http服务上的http请求包的url，</span><br><span class="line">    // 将其分割成 协议(protocol)://域名(host):端口(port)/路径名(pathname)?请求参数(query)</span><br><span class="line">    const parsedUrl = url.parse(req.url);</span><br><span class="line">    if (parsedUrl.pathname == "/game") {</span><br><span class="line">      const query = querystring.parse(parsedUrl.query);</span><br><span class="line">      // 玩家出的</span><br><span class="line">      const playerAction = query.action;</span><br><span class="line"></span><br><span class="line">      // 需求2:如果玩家赢了三次或者玩家作弊，则电脑不给他玩了</span><br><span class="line">      if (playerWon &gt;= 3 || sameCount == 9) {</span><br><span class="line">        res.writeHead(500);</span><br><span class="line">        res.end("我再也不和你玩了！");</span><br><span class="line">        return;</span><br><span class="line">      }</span><br><span class="line">      // 需求1:如果玩家操作连续三次相同，视为玩家作弊</span><br><span class="line">      if (playerLastAction &amp; (playerLastAction == playerAction)) {</span><br><span class="line">        sameCount++;</span><br><span class="line">      } else {</span><br><span class="line">        sameCount++;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      playerLastAction = playerAction;</span><br><span class="line"></span><br><span class="line">      if (sameCount &gt;= 3) {</span><br><span class="line">        res.writeHead(400);</span><br><span class="line">        res.end("你作弊");</span><br><span class="line">        // 将sameCount设置为9</span><br><span class="line">        sameCount = 9;</span><br><span class="line">        return;</span><br><span class="line">      }</span><br><span class="line">      // 执行游戏逻辑</span><br><span class="line">      var gameResult = game(playerAction);</span><br><span class="line">      res.writeHead(200);</span><br><span class="line">      if (gameResult == 0) {</span><br><span class="line">        res.end("平局！");</span><br><span class="line">      } else if (gameResult == 1) {</span><br><span class="line">        res.end("你赢了！");</span><br><span class="line">        // 玩家胜利次数统计+1</span><br><span class="line">        playerWon++;</span><br><span class="line">      } else {</span><br><span class="line">        res.end("你输了！");</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    // 如果请求url是浏览器icon，比如 http://localhost:3000/favicon.ico的情况</span><br><span class="line">    // 就返回一个200就好了</span><br><span class="line">    if (parsedUrl.pathname == "/favicon.ico") {</span><br><span class="line">      res.writeHead(200);</span><br><span class="line">      res.end();</span><br><span class="line">      return;</span><br><span class="line">    }</span><br><span class="line">    // 如果访问的是根路径，就把游戏页面读出来返回出去</span><br><span class="line">    if (parsedUrl.pathname == "/") {</span><br><span class="line">      fs.createReadStream(__dirname + "/index.html").pipe(res);</span><br><span class="line">    }</span><br><span class="line">  })</span><br><span class="line">  .listen(6001);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h1 id="6-使用express优化石头剪刀布游戏"><a href="#6-使用express优化石头剪刀布游戏" class="headerlink" title="6 使用express优化石头剪刀布游戏"></a>6 使用 express 优化石头剪刀布游戏</h1><h2 id="6-1-了解express"><a href="#6-1-了解express" class="headerlink" title="6.1 了解express"></a>6.1 了解 express</h2><p>要了解一个框架，最好的方法是 </p>
<ol>
<li>了解它的关键功能</li>
<li>推导出它要解决的问题是什么</li>
</ol>
<p>核心功能</p>
<ul>
<li>路由</li>
<li> request/response 简化<ul>
<li> request:pathname、query 等</li>
<li> response:send ()、json ()、jsonp () 等</li>
</ul>
</li>
<li>中间件<ul>
<li>更好地组织流程代码</li>
<li>异步会打破 Express 的洋葱模型</li>
</ul>
</li>
</ul>
<h2 id="6-2-游戏逻辑"><a href="#6-2-游戏逻辑" class="headerlink" title="6.2 游戏逻辑"></a>6.2 游戏逻辑</h2><p>index.js <a href="https://github.com/maying2020/nodejs-in-action/tree/master/http/express">源码点击</a></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const fs = require("fs");</span><br><span class="line">const game = require("./game");</span><br><span class="line">const express = require("express");</span><br><span class="line"></span><br><span class="line">// 玩家胜利次数，如果超过3，则后续往该服务器的请求都返回500</span><br><span class="line">var playerWinCount = 0;</span><br><span class="line">// 玩家的上一次游戏动作</span><br><span class="line">var lastPlayerAction = null;</span><br><span class="line">// 玩家连续出同一个动作的次数</span><br><span class="line">var sameCount = 0;</span><br><span class="line"></span><br><span class="line">const app = express();</span><br><span class="line"></span><br><span class="line">// 通过app.get设定 /favicon.ico 路径的路由</span><br><span class="line">// .get 代表请求 method 是 get，所以这里可以用 post、delete 等。这个能力很适合用于创建 rest 服务</span><br><span class="line">app.get("/favicon.ico", function(request, response) {</span><br><span class="line">  // 一句 status(200) 代替 writeHead(200); end();</span><br><span class="line">  response.status(200);</span><br><span class="line">  return;</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">// 设定 /game 路径的路由</span><br><span class="line">app.get(</span><br><span class="line">  "/game",</span><br><span class="line"></span><br><span class="line">  function(request, response, next) {</span><br><span class="line">    if (playerWinCount &gt;= 3 || sameCount == 9) {</span><br><span class="line">      response.status(500);</span><br><span class="line">      response.send("我不会再玩了！");</span><br><span class="line">      return;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 通过next执行后续中间件</span><br><span class="line">    next();</span><br><span class="line"></span><br><span class="line">    // 当后续中间件执行完之后，会执行到这个位置</span><br><span class="line">    if (response.playerWon) {</span><br><span class="line">      playerWinCount++;</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line"></span><br><span class="line">  function(request, response, next) {</span><br><span class="line">    // express自动帮我们把query处理好挂在request上</span><br><span class="line">    const query = request.query;</span><br><span class="line">    const playerAction = query.action;</span><br><span class="line"></span><br><span class="line">    if (!playerAction) {</span><br><span class="line">      response.status(400);</span><br><span class="line">      response.send();</span><br><span class="line">      return;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    if (lastPlayerAction == playerAction) {</span><br><span class="line">      sameCount++;</span><br><span class="line">      if (sameCount &gt;= 3) {</span><br><span class="line">        response.status(400);</span><br><span class="line">        response.send("你作弊！我再也不玩了");</span><br><span class="line">        sameCount = 9;</span><br><span class="line">        return;</span><br><span class="line">      }</span><br><span class="line">    } else {</span><br><span class="line">      sameCount = 0;</span><br><span class="line">    }</span><br><span class="line">    lastPlayerAction = playerAction;</span><br><span class="line"></span><br><span class="line">    // 把用户操作挂在response上传递给下一个中间件</span><br><span class="line">    response.playerAction = playerAction;</span><br><span class="line">    next();</span><br><span class="line">  },</span><br><span class="line"></span><br><span class="line">  function(req, response) {</span><br><span class="line">    const playerAction = response.playerAction;</span><br><span class="line">    const result = game(playerAction);</span><br><span class="line"></span><br><span class="line">    // 如果这里执行setTimeout，会导致前面的洋葱模型失效</span><br><span class="line">    // 因为playerWon不是在中间件执行流程所属的那个事件循环里赋值的</span><br><span class="line">    // setTimeout(()=&gt; {</span><br><span class="line">    response.status(200);</span><br><span class="line">    if (result == 0) {</span><br><span class="line">      response.send("平局");</span><br><span class="line">    } else if (result == -1) {</span><br><span class="line">      response.send("你输了");</span><br><span class="line">    } else {</span><br><span class="line">      response.send("你赢了");</span><br><span class="line">      response.playerWon = true;</span><br><span class="line">    }</span><br><span class="line">    // }, 500)</span><br><span class="line">  }</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">app.get("/", function(request, response) {</span><br><span class="line">  // send接口会判断你传入的值的类型，文本的话则会处理为text/html</span><br><span class="line">  // Buffer的话则会处理为下载</span><br><span class="line">  response.send(fs.readFileSync(__dirname + "/index.html", "utf-8"));</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">app.listen(6001);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h1 id="7-使用koa优化石头剪刀布游戏"><a href="#7-使用koa优化石头剪刀布游戏" class="headerlink" title="7 使用koa优化石头剪刀布游戏"></a>7 使用 koa 优化石头剪刀布游戏</h1><h2 id="7-1-了解koa"><a href="#7-1-了解koa" class="headerlink" title="7.1 了解koa"></a>7.1 了解 koa</h2><p>核心功能:</p>
<ul>
<li>比 Express 更极致的 request/response 简化<ul>
<li> ctx.status=200</li>
<li>ctx.body=’helloworld’</li>
</ul>
</li>
<li>使用 async function 实现的中间件<ul>
<li>有 “暂停执行” 的能力</li>
<li>在异步的情况下也符合洋葱模型</li>
</ul>
</li>
<li>精简内核，所有额外功能都移到中间件里实现</li>
</ul>
<h2 id="7-2-Express-vs-Koa"><a href="#7-2-Express-vs-Koa" class="headerlink" title="7.2 Express vs Koa"></a>7.2 Express vs Koa</h2><ul>
<li>Express 门槛更低，Koa 更强大优雅。</li>
<li>Express 封装更多东西，开发更快速，Koa 可定制型更高</li>
</ul>
<h2 id="7-3-孰“优”孰“劣”"><a href="#7-3-孰“优”孰“劣”" class="headerlink" title="7.3 孰“优”孰“劣”"></a>7.3 孰 “优” 孰 “劣”</h2><ul>
<li>框架之间其实没有优劣之分</li>
<li>不同的框架有不同的适用场景</li>
</ul>
<h2 id="7-4-游戏逻辑"><a href="#7-4-游戏逻辑" class="headerlink" title="7.4 游戏逻辑"></a>7.4 游戏逻辑</h2><p>index.js <a href="https://github.com/maying2020/nodejs-in-action/tree/master/http/koa">源码点击</a></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const fs = require("fs");</span><br><span class="line">const game = require("./game");</span><br><span class="line">const koa = require("koa");</span><br><span class="line">const mount = require("koa-mount");</span><br><span class="line"></span><br><span class="line">// 玩家胜利次数，如果超过3，则后续往该服务器的请求都返回500</span><br><span class="line">var playerWinCount = 0;</span><br><span class="line">// 玩家的上一次游戏动作</span><br><span class="line">var lastPlayerAction = null;</span><br><span class="line">// 玩家连续出同一个动作的次数</span><br><span class="line">var sameCount = 0;</span><br><span class="line"></span><br><span class="line">const app = new koa();</span><br><span class="line"></span><br><span class="line">app.use(</span><br><span class="line">  mount("/favicon.ico", function(ctx) {</span><br><span class="line">    // koa比express做了更极致的response处理函数</span><br><span class="line">    // 因为koa使用异步函数作为中间件的实现方式</span><br><span class="line">    // 所以koa可以在等待所有中间件执行完毕之后再统一处理返回值，因此可以用赋值运算符</span><br><span class="line">    ctx.status = 200;</span><br><span class="line">  })</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">const gameKoa = new koa();</span><br><span class="line">app.use(mount("/game", gameKoa));</span><br><span class="line">gameKoa.use(async function(ctx, next) {</span><br><span class="line">  if (playerWinCount &gt;= 3) {</span><br><span class="line">    ctx.status = 500;</span><br><span class="line">    ctx.body = "我不会再玩了！";</span><br><span class="line">    return;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  // 使用await 关键字等待后续中间件执行完成</span><br><span class="line">  await next();</span><br><span class="line"></span><br><span class="line">  // 就能获得一个准确的洋葱模型效果</span><br><span class="line">  if (ctx.playerWon) {</span><br><span class="line">    playerWinCount++;</span><br><span class="line">  }</span><br><span class="line">});</span><br><span class="line">gameKoa.use(async function(ctx, next) {</span><br><span class="line">  const query = ctx.query;</span><br><span class="line">  const playerAction = query.action;</span><br><span class="line">  if (!playerAction) {</span><br><span class="line">    ctx.status = 400;</span><br><span class="line">    return;</span><br><span class="line">  }</span><br><span class="line">  if (sameCount == 9) {</span><br><span class="line">    ctx.status = 500;</span><br><span class="line">    ctx.body = "我不会再玩了！";</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  if (lastPlayerAction == playerAction) {</span><br><span class="line">    sameCount++;</span><br><span class="line">    if (sameCount &gt;= 3) {</span><br><span class="line">      ctx.status = 400;</span><br><span class="line">      ctx.body = "你作弊！我再也不玩了";</span><br><span class="line">      sameCount = 9;</span><br><span class="line">      return;</span><br><span class="line">    }</span><br><span class="line">  } else {</span><br><span class="line">    sameCount = 0;</span><br><span class="line">  }</span><br><span class="line">  lastPlayerAction = playerAction;</span><br><span class="line">  ctx.playerAction = playerAction;</span><br><span class="line">  await next();</span><br><span class="line">});</span><br><span class="line">gameKoa.use(async function(ctx, next) {</span><br><span class="line">  const playerAction = ctx.playerAction;</span><br><span class="line">  const result = game(playerAction);</span><br><span class="line"></span><br><span class="line">  // 对于一定需要在请求主流程里完成的操作，一定要使用await进行等待</span><br><span class="line">  // 否则koa就会在当前事件循环就把http response返回出去了</span><br><span class="line">  await new Promise(resolve =&gt; {</span><br><span class="line">    setTimeout(() =&gt; {</span><br><span class="line">      ctx.status = 200;</span><br><span class="line">      if (result == 0) {</span><br><span class="line">        ctx.body = "平局";</span><br><span class="line">      } else if (result == -1) {</span><br><span class="line">        ctx.body = "你输了";</span><br><span class="line">      } else {</span><br><span class="line">        ctx.body = "你赢了";</span><br><span class="line">        ctx.playerWon = true;</span><br><span class="line">      }</span><br><span class="line">      resolve();</span><br><span class="line">    }, 500);</span><br><span class="line">  });</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">app.use(</span><br><span class="line">  mount("/", function(ctx) {</span><br><span class="line">    ctx.body = fs.readFileSync(__dirname + "/index.html", "utf-8");</span><br><span class="line">  })</span><br><span class="line">);</span><br><span class="line">app.listen(6001);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Javascript 设计模式系列</title>
    <url>/2018/01/16/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="面向对象的-Javascript"><a href="#面向对象的-Javascript" class="headerlink" title="面向对象的 Javascript"></a>面向对象的 Javascript</h2><p>不同于传统面向对象语言中的类式继承 js 通过 <strong>原型委托</strong> 的方式实现对象与对象之间的继承</p>
<p>编程语言分为 ：<br><strong>静态类型语言</strong>：编译时已确定变量的类型<br>  优点：在编译时就能发现类型不匹配的错误，编译器可以针对不同的数据类型对程序做一些优化工作 提高程序之心速度<br>  缺点：程序员依照契约来编写程序<br><strong>动态类型语言</strong>：要到程序运行的时候 待变量被赋予某个值之后 才会具有某种类型<br>  优点：代码数量少<br>  缺点：程序在运行期间有可能发生跟类型相关的错误</p>
<p>  Javascript 是一门典型的动态类型语言</p>
<p>  多态：给不同的对象发送同一条消息的时候 这些对象会根据这个消息分别给出不同的反馈</p>
<p> 多态：<br> 多种形态 在面向对象语言中，接口的多种不同的实现方式即为多态<br> 多态指同一个实体同时具有多种形式<br> 思想：把做什么 和 谁去做 分开<br> 同一个函数 传入不同的参数 可以实现不同的结果</p>
<p> js 的多态是与生俱来的<br> 它作为一门动态类型语言 他在编译时没有类型检查的类型</p>
<p> 多态的好处：你不必再向对象询问‘你是什么类型’而后根据得到的答案  调用对象的某个行为 你只管调用该行为就是了</p>
<p> 最根本的作用就是通过把过程话的条件分支语句转化为对象的多态性  从而消除这些条件分支语句</p>
<p> 面向对象编程的优点<br> 将行为分布在各个对象中，并且让这些对象各自负责自己的行为</p>
<p> 当我们对一些函数发出 调用的指令时 这些函数会返回不同的结果<br> 这也是多态的一些体现</p>
<p> 封装：封装的目的是将信息隐藏  </p>
<p> 封装数据<br> 封装实现<br> 封装类型<br> 封装变化<br>         把系统中不变的和变的分离开 只替换变化的 如果变化的也是封装好的 就好替换多了 保证程序的稳定性和可扩展性</p>
<p> 隐藏数据 隐藏实现细节 设计细节以及隐藏对象的类型<br> 其他对象或者用户不关心他的具体实现 封装使对象之前的耦合变得松散 对象之间只暴露 APi 接口来通信</p>
<h2 id="原型模式和基于原型继承的Javascript-对象系统"><a href="#原型模式和基于原型继承的Javascript-对象系统" class="headerlink" title="原型模式和基于原型继承的Javascript 对象系统"></a><strong>原型模式和基于原型继承的 Javascript 对象系统</strong></h2><h5 id="使用克隆的原型模式"><a href="#使用克隆的原型模式" class="headerlink" title="使用克隆的原型模式"></a>使用克隆的原型模式</h5><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var Plane = function(){</span><br><span class="line">	this.blood=100;</span><br><span class="line">	this.ss = 11;</span><br><span class="line">	this.tt =2;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var plane = new Plane();  </span><br><span class="line"></span><br><span class="line">	Object.create = Object.create ||function(value){</span><br><span class="line"></span><br><span class="line">       var F = function(){};</span><br><span class="line">		 F.prototype= value;</span><br><span class="line">		 return new F();</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	var clonePlane = Object.create(plane)</span><br><span class="line">	console.log('clonePlane',clonePlane)</span><br><span class="line">   console.log('clonePlane',clonePlane.blood)  100</span><br><span class="line">  console.log('clonePlane',clonePlane.ss)  11</span><br><span class="line">   console.log('clonePlane',clonePlane.tt) 2</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<a id="more"></a>

<h5 id="javascript的原型继承"><a href="#javascript的原型继承" class="headerlink" title="javascript的原型继承"></a>javascript 的原型继承</h5><p>所有的 js 对象都是从某个对象上克隆而来的</p>
<p> 原型编程范程的规则</p>
<ol>
<li><p>所有的数据都是对象</p>
<p> javascript 根对象是 <code>Object.prototype</code> 空对象</p>
</li>
</ol>
<pre><code><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var obj1 = new Object();</span><br><span class="line">var obj2 = {};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></code></pre>
<ol start="2">
<li>要得到一个对象 不是通过实例化类 而是找到一个对象作为一个原型并克隆他</li>
</ol>
<p>当我们调用 <code>var obj1 = new Object();</code> 引擎内部会从 <code>Object.prototype</code> 克隆一个对象出来</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">    function Person(name){</span><br><span class="line">    	this.name =name</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">Person.prototype.getName = function(){</span><br><span class="line">	return this.name;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">	var p = new Person('maying');</span><br><span class="line"></span><br><span class="line">	console.log(p.name)</span><br><span class="line">	console.log(p.getName())</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>js 没有类的概念 但是为什么还调用了 <code>new Person('maying');</code></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">在这里Person 并不是类 而是函数构造器</span><br><span class="line">Javascript的函数既可以作为普通函数被调用 也可以作为函数构造器被调用</span><br><span class="line">当使用 new 运算符来调用函数时 此时的函数就是一个构造器</span><br><span class="line"></span><br><span class="line">用new运算符来创建对象的过程 实际上也是先克隆 Object.prototype 对象</span><br></pre></td></tr></tbody></table></figure>

<p><strong>抛出问题：js 通过 Object.prototype 得到一个新的对象 但实际上并不是每次都真正的克隆了一个对象</strong></p>
<ol start="3">
<li>对象会记住他的原型 </li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">就javascript 真正实现来说并不能说对象有原型 而只能说是对象的构造器有原型 对于对象把请求委托给它自己的原型 更好的说法是对象把请求委托给它的构造器的原型。</span><br><span class="line"> 那么对象是如何委托给它的构造器的原型呢</span><br><span class="line"></span><br><span class="line"> 对象通过 _proto_的隐藏属性指向 {Constructor}.prototype</span><br><span class="line"></span><br><span class="line"> _proto_就是跟构造器的原型联系起来的纽带</span><br><span class="line"></span><br><span class="line"> js的对象最初都是由object.prototype创建的 但是对象构造器的原型并不局限于object.prototype上 二是可以动态指定其他对象</span><br><span class="line"></span><br><span class="line"> 应用</span><br><span class="line"> 当对象a需要借用对象b的能力时 可以有选择性的把对象a的构造器的原型指向对象b 从而达到继承的效果</span><br><span class="line"></span><br><span class="line">  var A = function(){</span><br><span class="line">	 	this.name="buyiyang"</span><br><span class="line">	 }</span><br><span class="line"></span><br><span class="line">	 A.prototype = {</span><br><span class="line">	 	constructor: A, //手动指定 不指定的话   console.log(A.prototype.constructor)=object()</span><br><span class="line">	 	name:'maying'</span><br><span class="line">	 }</span><br><span class="line"></span><br><span class="line"> var B = function(){}</span><br><span class="line"> B.prototype = new A()</span><br><span class="line"></span><br><span class="line">  var a = new A();</span><br><span class="line">  console.log('a',a.name)</span><br><span class="line">  console.log(A.prototype.constructor)  </span><br><span class="line"></span><br><span class="line">  //  function(){</span><br><span class="line">	 // 	this.name="buyiyang"</span><br><span class="line">	 // }</span><br><span class="line">  console.log(a.__proto__)    // {name: "maying",  constructor: ƒ}</span><br><span class="line">  console.log(A.prototype)  // {name: "maying", constructor: ƒ}</span><br><span class="line"></span><br><span class="line">原型链并不是无限长的</span><br><span class="line"></span><br><span class="line">当请求达到 A.prototype，并且在 A.prototype 中也没有找到 address 属性的时候， 请求会被传递给 A.prototype 的构造器原型 Object.prototype，显然 Object.prototype 中也没有 address 属性，但 Object.prototype 的原型是 null，说明这时候原型链的后面已经没有别的节点了。 所以该次请求就到此打住，a.address 返回 undefined。</span><br><span class="line"></span><br><span class="line">通过 Object.create(null) 可以创建出没有原型的对象</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">通过ES6 class 创建对象</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	 class Animal {</span><br><span class="line">	 	constructor(name){</span><br><span class="line">	 		this.name = name</span><br><span class="line">	 	}</span><br><span class="line">	 	getName(){</span><br><span class="line">		 		return this.name</span><br><span class="line">		 	}</span><br><span class="line">	 }</span><br><span class="line">	 class Dog extends Animal{</span><br><span class="line">	 	constructor(name){</span><br><span class="line">	 		// console.log('this',this)</span><br><span class="line">	 		console.log('super',super()) //不调用 super() 就没有绑定this super()只能调用一次</span><br><span class="line">	 		// Dog {name: undefined}</span><br><span class="line">	 		console.log('this',this) // Dog {name: undefined}</span><br><span class="line">	 		console.log('name',name)</span><br><span class="line">	 		// super(name)</span><br><span class="line">	 	}</span><br><span class="line">	 	speak(){</span><br><span class="line">	 		return 'woof'</span><br><span class="line">	 	}</span><br><span class="line">	 }</span><br><span class="line">	 var dog = new Dog('scamp')</span><br><span class="line"></span><br><span class="line">     console.log(dog.getName()+'----say-----'+dog.speak()) //undefined----say-----woof</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<ol start="4">
<li>如果对象无法响应某个请求 它会把这个请求委托给自己的原型</li>
</ol>
<h2 id="this-call-apply"><a href="#this-call-apply" class="headerlink" title="this call apply"></a><strong>this call apply</strong></h2><p><strong>this</strong><br>js 的 this 总是指向一个对象 在运行时基于函数的执行环境动态绑定的 而非函数被声明时的环境</p>
<p>this 的指向可以分为下面四种</p>
<p>作为对象的方法调用</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">this指向当前对象</span><br></pre></td></tr></tbody></table></figure>
<p>作为普通函数调用</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">this指向window</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">window.name='maying';</span><br><span class="line"></span><br><span class="line">	var getName = function(){</span><br><span class="line">		return  this.name</span><br><span class="line">	}</span><br><span class="line">	console.log(getName()) //maying</span><br><span class="line"></span><br><span class="line">	或者</span><br><span class="line"></span><br><span class="line">		window.name='maying';</span><br><span class="line"></span><br><span class="line">	var myObject = {</span><br><span class="line">		name:'stven',</span><br><span class="line">		getName :function(){</span><br><span class="line">			console.log('this',this)</span><br><span class="line">			return this.name;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">    var a = myObject.getName;</span><br><span class="line">	  console.log(a()) //maying 此时用另外一个变量a来引用myObject.getName 并且调用 a() 时 此时是普通函数的调用函数 this是指向全局的</span><br><span class="line"></span><br><span class="line">	console.log(myObject.getName()) // stven  getName是作为对象的属性被调用的 此时的this指向 myObject</span><br><span class="line"></span><br><span class="line">	在ES5 的 strict模式下 this已经被规定为不会指向全局对象 而是undefined</span><br><span class="line"></span><br><span class="line">	function func(){ "use strict"</span><br><span class="line">    alert ( this );</span><br><span class="line">    func();</span><br></pre></td></tr></tbody></table></figure>
<p>构造器调用<br>当使用 new 运算符调用函数时 该函数总会返回一个对象<br>通常情况下 构造器里的 this 就指向返回的这个对象<br>如果 构造器显示返回了一个 object 类型的对象 那么此次元算结果最终会返回这个对象</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var Preson = function(){</span><br><span class="line">	 	this.name='maying'</span><br><span class="line">	 	return {</span><br><span class="line">	 		name:'anne'</span><br><span class="line">	 	}</span><br><span class="line"></span><br><span class="line">	 }</span><br><span class="line"></span><br><span class="line">	   var p =new Preson()</span><br><span class="line">     console.log('p',p.name)  //anne</span><br><span class="line"></span><br><span class="line">     如果不显示返回数据会这返回一个非对象的类型 构造器里的this就指向返回的这个对象</span><br><span class="line"></span><br><span class="line">     	 var Preson = function(){</span><br><span class="line">	 	this.name='maying'</span><br><span class="line">	 	return 'swe'	 	</span><br><span class="line">	 }</span><br><span class="line">	  var p =new Preson()</span><br><span class="line">     console.log('p',p.name)  //maying</span><br></pre></td></tr></tbody></table></figure>


<p><code>Function.prototype.call</code> 或者 <code>Function.prototype.apply</code> 调用</p>
<p> 作用：可以动态地改变传入函数的 this<br> ES3 给 Function 原型定义的两个方法<br> call 和 apply 区别只是在传递参数的不同</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var func = function( a, b, c ){</span><br><span class="line">alert ( [ a, b, c ] ); // 输出 [ 1, 2, 3 ]</span><br><span class="line">};</span><br><span class="line">func.apply( null, [ 1, 2, 3 ] );</span><br><span class="line">第一个参数：函数体内this的指向 传null时 指向 默认的宿主对象 浏览器默认window</span><br><span class="line">第二个参数： 数组或者类数组 apply方法把这个集合中的元素作为参数传递给被调用的函数</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var func = function( a, b, c ){</span><br><span class="line">alert ( [ a, b, c ] ); // 输出 [ 1, 2, 3 ]</span><br><span class="line">};</span><br><span class="line">func.call( null, 1, 2, 3 );</span><br><span class="line">第一个参数：函数体内this的指向</span><br><span class="line">第二个参数：第二个参数开始往后，每个参数被依次传入函数</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var obj1 = {</span><br><span class="line">		name:'maying',</span><br><span class="line">		getInfo :function(){</span><br><span class="line">			return this.name</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	var obj2 = {</span><br><span class="line">		name:'anne'</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	  console.log('obj1',obj1.getInfo()) //maying</span><br><span class="line">    console.log('obj2',obj1.getInfo.call(obj2)) //anne 此刻getInfo函数体内的this指向obj2对象</span><br><span class="line">    相当于</span><br><span class="line"></span><br><span class="line">    var obj1 = {</span><br><span class="line">		name:'maying',</span><br><span class="line">		getInfo :function(){</span><br><span class="line">			return obj2.name</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Math.max.apply( null, [ 1, 2, 5, 3, 4 ] ) // 输出:5</span><br></pre></td></tr></tbody></table></figure>

<p><code>Function.prototype.bind()</code><br> 用来指定函数内部的 this 指向</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">     // js原生模拟 Function.prototype.bind 函数实现</span><br><span class="line"> Function.prototype.bind =  function(context){</span><br><span class="line"> 	  var self = this //this当前指向 fun函数</span><br><span class="line"> 	  console.log('self',self)</span><br><span class="line"> 	  return function(){</span><br><span class="line"> 	 	return self.apply(context,arguments)</span><br><span class="line"> 	 	// 将fun函数内部的this指向obj</span><br><span class="line"> 	 	// 相当于 function(){</span><br><span class="line">				//  console.log('obj1.name',obj1.name)</span><br><span class="line">				// }</span><br><span class="line"> 	  }</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var obj1 = {</span><br><span class="line">	name:'maxiaoyin'</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var fun = function(){</span><br><span class="line"> console.log('this.name',this.name)</span><br><span class="line">}.bind(obj1)</span><br><span class="line"></span><br><span class="line">    fun(); //maxiaoyin</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>借用其他对象的方法实现继承</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">function A (){</span><br><span class="line">     	this.name='maying'</span><br><span class="line">     }</span><br><span class="line">     function B(){</span><br><span class="line">     	A.apply(this,arguments)</span><br><span class="line">     	this.getName = function(){</span><br><span class="line">     		return this.name</span><br><span class="line">     	}</span><br><span class="line">     }</span><br><span class="line"></span><br><span class="line">     var b = new B();</span><br><span class="line"></span><br><span class="line">     console.log('b',b.getName()) //maying</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>想往 arguments 中添加一个新的元素</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"> (function abc (){</span><br><span class="line"> 		// arguments.push('1') 因为arguments不是数组 没办法执行数组有的push方法</span><br><span class="line"> 	    // [].push.call(arguments,'1') 或者</span><br><span class="line"> 	    Array.prototype.push.call(arguments,'7')</span><br><span class="line">     	console.log('arguments',arguments)</span><br><span class="line">     }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   再操作 arguments 时候 我们通常会借用</span><br><span class="line">Array.prototype的各种方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Array.prototype.push 实际上是属性复制的过程</span><br><span class="line"> 可以推断 我们可以把**任意**的对象 传入  Array.prototype.push</span><br><span class="line"></span><br><span class="line"> 这个任意的限制</span><br><span class="line"> 对象本身可以存取书香</span><br><span class="line"> 对象的length可读写</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> var a= {}</span><br><span class="line"> Array.prototype.push.call(a,'first')</span><br><span class="line"> console.log(a) //{0: "first", length: 1}</span><br><span class="line"> console.log(a instanceof Object) //true</span><br><span class="line"> console.log(a[0]) // 并非数组的用法 first</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="闭包和高阶函数"><a href="#闭包和高阶函数" class="headerlink" title="闭包和高阶函数"></a>闭<strong>包和高阶函数</strong></h3><p>js 的函数作用域 就像一层半透明的玻璃 从里面可以看到外面 从外面不能看到里面<br>变量的搜索是从内往外而不是从外往内的</p>
<p>带有 var 关键字的局部变量 会随着函数调用的结束而销毁</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">一个有趣的问题</span><br><span class="line">	  &lt;div&gt;1&lt;/div&gt;</span><br><span class="line">	  &lt;div&gt;2&lt;/div&gt;</span><br><span class="line">	  &lt;div&gt;3&lt;/div&gt;</span><br><span class="line">	  &lt;div&gt;4&lt;/div&gt;</span><br><span class="line">	  &lt;div&gt;5&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">	var nodes = document.getElementsByTagName( 'div' );</span><br><span class="line">	for ( var i = 0, len = nodes.length; i &lt; len; i++ ){</span><br><span class="line"></span><br><span class="line">			 nodes[ i ].onclick = function(){</span><br><span class="line"></span><br><span class="line">				alert ( i );</span><br><span class="line"></span><br><span class="line">			}</span><br><span class="line">	};</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">结果是每次都是5</span><br><span class="line">原因是： div的click是被异步触发的 当for循环被触发的时候 for循环早已经结束 此时i变量的值已经是5了 这个时候 click事件的函数顺着作用域链向上找变量i的时候 找到的始终是5</span><br><span class="line"></span><br><span class="line">解决方式</span><br><span class="line"></span><br><span class="line">	for ( var i = 0, len = nodes.length; i &lt; len; i++ ){</span><br><span class="line">            (function(i){</span><br><span class="line">            	       console.log('i',i)</span><br><span class="line">	            	   nodes[ i ].onclick = function(){</span><br><span class="line">					   alert ( i );</span><br><span class="line">			       }</span><br><span class="line">            })(i)</span><br><span class="line">	};</span><br></pre></td></tr></tbody></table></figure>

<p><strong>闭包的作用</strong></p>
<ol>
<li>封装变量<br>闭包可以把一些不需要暴漏在全局的变量封装成私有变量 </li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">改造之前</span><br><span class="line"></span><br><span class="line">var cache = {};</span><br><span class="line"></span><br><span class="line">var mult = function(){</span><br><span class="line"></span><br><span class="line">         var args = Array.prototype.join.call( arguments, ',' );</span><br><span class="line"></span><br><span class="line">		 if ( cache[ args ] ){</span><br><span class="line">		   return cache[ args ];</span><br><span class="line">		  }</span><br><span class="line">       var a = 1;</span><br><span class="line"></span><br><span class="line">		for ( var i = 0, l = arguments.length; i &lt; l; i++ ){</span><br><span class="line"></span><br><span class="line">		    a = a * arguments[i];</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">return cache[ args ] = a;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line">alert ( mult( 1,2,3 ) );</span><br><span class="line">alert ( mult( 1,2,3 ) );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">改造原理：如果大函数里面又可以复用的小函数 可以提炼出来 但是这些小函数不需要在其他地方调用的话最好用闭包封闭起来</span><br><span class="line">改造之后</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> var mult = (function (){</span><br><span class="line">          var cache={}</span><br><span class="line"></span><br><span class="line">	 	  var calculate = function(){</span><br><span class="line">			    	var a =1;</span><br><span class="line">			    	for(var i = 0;i&lt;arguments.length; i++){</span><br><span class="line">			    		a = a *arguments[i];</span><br><span class="line">			    	 }   </span><br><span class="line">		            return a;</span><br><span class="line">	 	  }</span><br><span class="line"></span><br><span class="line">	 	  return function(){</span><br><span class="line">	 	  	     var args = Array.prototype.join.call(arguments,',')</span><br><span class="line">		         // 如果存在的话</span><br><span class="line">			 	 if(cache[args]){</span><br><span class="line">			 		 	return  cache[args]</span><br><span class="line">			 	  }</span><br><span class="line">			 	  return cache[args] = 	calculate.apply(window,arguments)    </span><br><span class="line"> }})();</span><br><span class="line"> console.log(mult(1,2,3))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>2. 延续局部变量的寿命</p>
<p><strong>闭包和面向对象的设计</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"> // 用闭包实现一个面向对象系统</span><br><span class="line"> var extent = function(){</span><br><span class="line"> 	  var value = 0;</span><br><span class="line">        return {</span><br><span class="line">            call: function(){</span><br><span class="line">                   value++;</span><br><span class="line">                   console.log( value );</span><br><span class="line">     }</span><br><span class="line"></span><br><span class="line">     // 面向对象的写法</span><br><span class="line"></span><br><span class="line">     var extend = {</span><br><span class="line">     	this.value = 0;</span><br><span class="line">     	this.call = function(){</span><br><span class="line">     		this.value ++;</span><br><span class="line">     		console.log('this.value',this.value)</span><br><span class="line">     	}</span><br><span class="line">     }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 或者</span><br><span class="line"></span><br><span class="line">var Extend = function(){</span><br><span class="line">	this.value = 0</span><br><span class="line">};</span><br><span class="line">Extend.prototype.call=function(){</span><br><span class="line">	this.value ++;</span><br><span class="line">     		console.log('this.value',this.value)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong>高阶函数</strong><br>满足下列条件之一<br>函数可以作为参数被传递<br>函数可以作为返回值输出</p>
<p>判断数据的类型</p>
<p>Object.prototype.toString.call<br>对象的原生扩展函数 更精确的区分数据类型</p>
<p>15.2.4.2 Object.prototype.toString()<br>在 toString 方法被调用时，会执行下面的操作步骤:</p>
<ol>
<li><p>获取 this 对象的 [[Class]] 属性的值。</p>
</li>
<li><p>计算出三个字符串”[object “, 第一步的操作结果 Result (1), 以及 “]” 连接后的新字符串。</p>
</li>
<li><p>返回第二步的操作结果 Result (2)。<br>[[Class]] 是一个内部属性，所有的对象 (原生对象和宿主对象) 都拥有该属性。在规范中，[[Class]] 是这么定义的:<br>内部属性 描述<br>[[Class]] 一个字符串值，表明了该对象的类型。<br>其过程简单说来就是：1、获取对象的类名（对象类型）。2、然后将 [object、获取的类名、] 组合并返回。</p>
</li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"> Object.prototype.toString.call( [1,2,3] )</span><br><span class="line">"[object Array]"</span><br></pre></td></tr></tbody></table></figure>

<p><strong>判断数据的类型</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var isType = function( type ){</span><br><span class="line">    return function( obj ){</span><br><span class="line">          return Object.prototype.toString.call( obj ) === '[object '+ type +']';</span><br><span class="line">     }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">var isString = isType( 'String' );</span><br><span class="line"> var isArray = isType( 'Array' );</span><br><span class="line"> var isNumber = isType( 'Number' );</span><br><span class="line">console.log( isArray( [ 1, 2, 3 ] ) );</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>高阶函数实现 AOP<br>（AOP）面向切面编程 主要作用是把一些跟核心业务逻辑的代码抽离出来</p>
<p>函数节流</p>
<p>函数被频繁调用的场景<br>window.onresize 事件<br>mousemove 事件<br>图片或者视频的上传进度</p>
<p>函数节流的原理</p>
<p> setTimeout 来完成这件事情</p>
<p> 分时函数<br> 惰性加载函数</p>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="** 设计模式**"></a>** 设计模式 **</h2><h5 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h5><p>定义：保证一个类仅有一个实例，并且提供一个访问他的全局访问点</p>
<h6 id="实现单例模式"><a href="#实现单例模式" class="headerlink" title="实现单例模式"></a>实现单例模式</h6><p> 原理： 用一个对象来表示当前是否已经为这个类创建过对象，如果是 则在下一次获取该类的实例的时 直接返回之前创建的对象</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">  var Singleton = function(name){</span><br><span class="line">  	this.name=name,</span><br><span class="line">  	this.create = null;</span><br><span class="line">  }</span><br><span class="line">Singleton.prototype.sayName = function(){</span><br><span class="line">  console.log(this.name)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var sayFn = function(name){</span><br><span class="line">	if(!this.create){</span><br><span class="line">		this.create = new Singleton(name)</span><br><span class="line">	}</span><br><span class="line">    return this.create</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var a = sayFn('maxiaoying').sayName(); //maxiaoying</span><br><span class="line">var b = sayFn('lujing').sayName() //maxiaoying</span><br><span class="line">console.log(a ===b).  //true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">另一种闭包的实现方式</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var Sngal = function(name){</span><br><span class="line">	this.name=name;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Sngal.prototype.sayname =function(){</span><br><span class="line">     consoel.log('this.name',this.name)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// var getName= function(){</span><br><span class="line">// 	var instance = null;</span><br><span class="line">// 	return function(name){</span><br><span class="line">// 		if(!instance){</span><br><span class="line">// 			instance = new Sngal(name)</span><br><span class="line">// 		}</span><br><span class="line">// 		return  instance</span><br><span class="line">// 	}</span><br><span class="line">// }(name);</span><br><span class="line"></span><br><span class="line">// 或者</span><br><span class="line"></span><br><span class="line">var getName= function(){</span><br><span class="line">	var instance = null;</span><br><span class="line">	return function(name){</span><br><span class="line">		if(!instance){</span><br><span class="line">			instance = new Sngal(name)</span><br><span class="line">		}</span><br><span class="line">		return  instance</span><br><span class="line">	}</span><br><span class="line">}();</span><br><span class="line"></span><br><span class="line">先让getName 自执行才能得到  然后接收参数 理解闭包</span><br><span class="line">	-------------------------------------</span><br><span class="line">return function(name){</span><br><span class="line">		if(!instance){</span><br><span class="line">			instance = new Sngal(name)</span><br><span class="line">		}</span><br><span class="line">		return  instance</span><br><span class="line">	}</span><br><span class="line">	-------------------------------------</span><br><span class="line">var a = getName('maxiaogiou');</span><br><span class="line">console.log('a',a)</span><br><span class="line">var b = getName('xiaoxioamao');</span><br><span class="line">console.log('b',b)</span><br><span class="line">console.log('a ===b',a===b)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>design_mode</tag>
      </tags>
  </entry>
  <entry>
    <title>异步编程方案的演进</title>
    <url>/2019/03/19/promise/</url>
    <content><![CDATA[<p>程序中<strong>现在运行的部分</strong>和<strong>将来运行的部分</strong>就是<strong>异步编程的核心</strong></p>
<p>异步编程的演进大致分以下几个时期</p>
<ul>
<li>回调函数时期</li>
<li> promise 时期</li>
<li>生成器 (ES6) + promise 时期</li>
<li> async/await 时期 (ES7)</li>
</ul>
<a id="more"></a>
<h1 id="你必须要知道的基本概念"><a href="#你必须要知道的基本概念" class="headerlink" title="你必须要知道的基本概念"></a>你必须要知道的基本概念</h1><h2 id="异步、并行，并发的区别"><a href="#异步、并行，并发的区别" class="headerlink" title="异步、并行，并发的区别"></a>异步、并行，并发的区别</h2><ul>
<li>异步：是关于现在和将来的事件间隙</li>
<li>并行：是关于同时完成多个任务的概念</li>
<li>并发：是指分别由任务 a 和任务 b 在一段时间内通过任务间的切换完成了这两个任务，<strong>单线程事件循环是并发的一种形式 </strong></li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">并发是指两个或者多个事件随着时间发展交替执行，以至于从更高的层次上看是同时在运行（尽管在任意时刻只处理一个事件）</span><br><span class="line"></span><br><span class="line">实际的并发场景</span><br><span class="line">比如社交网站，随着用户向下滚动列表加载更多资源 （一边触发ajax一边响应数据）..</span><br></pre></td></tr></tbody></table></figure>
<h2 id="js里的完整运行特性"><a href="#js里的完整运行特性" class="headerlink" title="js里的完整运行特性"></a>js 里的完整运行特性</h2><p>js 从不跨线程共享数据，并且由于 js 单线程的特性，函数块儿中的代码具有完整运行机制，也就是说，一旦 <code>foo()</code> 开始运行，它的所有代码都会在 <code>bar()</code> 中的任意代码运行之前完成</p>
<h2 id="事件循环队列与任务队列的区别"><a href="#事件循环队列与任务队列的区别" class="headerlink" title="事件循环队列与任务队列的区别"></a>事件循环队列与任务队列的区别</h2><p>ES6 中，有一个任务队列的概念，它是挂载在事件循环队列的每个 <code>tick</code> 之后的一个队列</p>
<p>js 引擎运行在宿主环境中（浏览器，node 端等），这些环境都有线程的概念，他们都提供了一种机制来处理程序中多个块儿的执行，且执行每块儿时调用 js 引擎，这种机制被称之为<strong>事件循环</strong></p>
<p>一旦有事件需要运行，事件循环就会运行，直到队列清空，事件循环的每一轮称为一个 tick，用户交互 IO 和定时器会向事件队列中加入事件，任意时刻，一次只能从队列中处理一个事件，执行事件的时候，可能直接或者间接地引发一个或者多个后续事件</p>
<p>一个比较形象的比喻</p>
<ul>
<li>事件循环队列：类似于一个游乐场游戏，玩过了一个游戏之后，你需要重新到队尾排队才能再玩一次</li>
<li>任务队列：玩过了游戏之后，插队接着玩</li>
</ul>
<h1 id="第一阶段-回调函数时期"><a href="#第一阶段-回调函数时期" class="headerlink" title="第一阶段(回调函数时期)"></a>第一阶段 (回调函数时期)</h1><p>任何时候，只要把一段代码包装成一个函数，并指定它在响应某个事件时执行，你就是在代码中创建了一个将来执行的块儿，也由此在这个程序中引入了异步机制。</p>
<h2 id="回调实现异步的特性"><a href="#回调实现异步的特性" class="headerlink" title="回调实现异步的特性"></a>回调实现异步的特性</h2><ul>
<li>回调函数是 <code>js</code> 异步的基本单元，但是随着 js 越来越成熟，对于异步编程的发展，回调已经不够用了以至于产生可怕的<strong>回调地狱</strong>，嵌套函数存在耦合性，一大有所改动就会牵一发而动全身，而且嵌套过多导致错误难以处理</li>
<li>回调表达异步流程的方式是非线性的，非顺序的，这使得正确推理这样儿的代码难度很大，难以理解，我们需要一种更同步更顺序更阻塞的方式来表达异步，就像我们的大脑一样。</li>
<li>回调会受到<strong>控制反转</strong>的影响，因为回调函数中把控制权交给第三方比如 <code>ajax()</code>，会造成一系列麻烦的<strong>信任问题</strong> </li>
</ul>
<p><font color="red">可能产生的信任问题</font></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1. 调用回调过早</span><br><span class="line">2. 调用回调过晚（或者不被调用）</span><br><span class="line">3. 调用回调次数过多或者过少</span><br><span class="line">4. 未能传递所需的环境和参数</span><br><span class="line">5. 吞掉可能出现的错误和异常</span><br></pre></td></tr></tbody></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我们需要一个通用的方案来解决这些信任问题，不管我们创建多少回调，这一方案都可以复用，且没有重复代码的开销 引出了 <strong>Promise</strong></p>
<h1 id="第二阶段-Promise时期"><a href="#第二阶段-Promise时期" class="headerlink" title="第二阶段(Promise时期)"></a>第二阶段 (Promise 时期)</h1><p>直到 <code>ES6 Promise</code> 的引入 JS 才真正有内建的异步概念</p>
<p>我们开篇就了解到了 异步编程分现在运行部分 和将来运行部分的概念</p>
<ul>
<li>回调函数的模式是关于<strong>如何处理将来值</strong></li>
<li><code>Promise</code> 是把现在和将来归一化了 把他们都变成了将来，也就是说 它把所有的操作都变成了异步的</li>
</ul>
<h2 id="Promise的特点"><a href="#Promise的特点" class="headerlink" title="Promise的特点"></a>Promise 的特点</h2><ul>
<li>我们通过某种方式在函数完成时候得到通知，以便我们可以继续下一步</li>
<li>类似于事件订阅 我们不需要关注谁订阅了这些事件，实现了关注点分离</li>
<li> Promise 封装了依赖时间的状态 - 它等待底层值的完成或者拒绝 所以 promise 本身是与时间无关的</li>
<li>它可以按照可预测的方式组合 而不用关心底层代码如何结束</li>
<li>一旦 <code>promise</code> 决议，它就永远保持在这个状态</li>
<li> promise 是一种封装和组合未来值的易于复用的机制</li>
</ul>
<h2 id="Promise基本用法"><a href="#Promise基本用法" class="headerlink" title="Promise基本用法"></a>Promise 基本用法</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var p = new Promise(function(resolve,reject){</span><br><span class="line"> //resolve()用于完成</span><br><span class="line"> //reject() 用于拒绝</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"> 他有三个状态 </span><br><span class="line"> pending,fulfilled，rejected </span><br><span class="line"> </span><br><span class="line"> 两个过程</span><br><span class="line"> </span><br><span class="line"> pending -&gt; fulfilled</span><br><span class="line"> pending -&gt; rejected</span><br><span class="line"> </span><br><span class="line">resolve：会将传入的真正的promise直接返回，对传入的thenable会展开,如果这个thenable展开是一个拒绝状态，那么从promise.resolve()返回的promise实际上就是这同一个拒绝状态</span><br><span class="line">所以resolve实际上的结果可能是完成或拒绝</span><br><span class="line"></span><br><span class="line">rejected ：拒绝状态</span><br></pre></td></tr></tbody></table></figure>

<p>实例的调用</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">promise.then(resolveFn,rejectFn)</span><br><span class="line">如下：</span><br><span class="line">promise.then(function(value) {</span><br><span class="line">  // success</span><br><span class="line">}, function(error) {</span><br><span class="line">  // failure</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<h3 id="如何确定某个值是不是真正的promise（或者说thenable）"><a href="#如何确定某个值是不是真正的promise（或者说thenable）" class="headerlink" title="如何确定某个值是不是真正的promise（或者说thenable）"></a>如何确定某个值是不是真正的 promise（或者说 thenable）</h3><p>利用鸭子模型<br>如果一个函数或对象具有.then () 方法，我们认为这样儿的值就是 <code>Promise</code> 一致的 <code>thenable</code></p>
<p>所以不要给函数或者对象添加<code>.then</code><br>方法，否则这个值就会误认为是一个 <code>thenable</code> 导致难以追踪的 <code>bug</code></p>
<p>既然我们已经知道亟待解决的问题，把回调的缺陷解决了，否则引入 <code>Promise</code> 没有任何意义</p>
<h2 id="解决控制反转问题"><a href="#解决控制反转问题" class="headerlink" title="解决控制反转问题"></a>解决控制反转问题</h2><p>之前 我们用回调函数封装程序中的代码，然后将其交给第三方等（比如 ajax），接着期待其能调用回调实现功能<br>现在我们要能够把控制反转再反转回来<br>我们希望第三方<strong>给我们提供其任务何时结束的能力</strong>，然后由我们自己的代码来决定下一步做什么</p>
<p><font color="red">老实说 绝大多数 JS/DOM 新增的异步 API 都是基于 Promise 构建的</font></p>
<h2 id="解决信任问题"><a href="#解决信任问题" class="headerlink" title="解决信任问题"></a>解决信任问题</h2><h3 id="promise解决调用过早"><a href="#promise解决调用过早" class="headerlink" title="promise解决调用过早"></a>promise 解决调用过早</h3><p>对一个 <code>promise</code> 调用 then 的时候，即使这个 <code>promise</code> 已经决议，提供给 <code>then()</code> 的回调总会被异步调用</p>
<h3 id="promise解决调用过晚"><a href="#promise解决调用过晚" class="headerlink" title="promise解决调用过晚"></a>promise 解决调用过晚</h3><p><code>promise</code> 对象创建 <code>resolve</code> 或者 <code>reject</code> 时，这个 promise 的 then 注册的观察回调就会被自动调度，可以确信，这些被调度的回调在下一个异步事件点上依次被立即调用，这些回调中的任意一个都无法影响或延误对其他回调的调用，这是 promise 的运作方式</p>
<h3 id="回调未调用"><a href="#回调未调用" class="headerlink" title="回调未调用"></a>回调未调用</h3><p>没有任何东西（甚至是 js 错误）能阻止 promise 向你通知他的决议，promise 在决议时总是会调用其中一个</p>
<p>如果 promise 本身永远不被决议。promise 也提供了解决方案</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">用于一个超时的promise</span><br><span class="line">function timeoutpromise(){</span><br><span class="line">return new promise(function(){</span><br><span class="line"> setTimeout(functiion(){</span><br><span class="line">  reject('timeout')</span><br><span class="line"> },delay)</span><br><span class="line">})</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="调用次数过多或过少"><a href="#调用次数过多或过少" class="headerlink" title="调用次数过多或过少"></a>调用次数过多或过少</h3><p>promise 定义方式使得它只能被决议一次<br>如果试图调用多次或者 resolve 和 reject 都调用，那么这个 promise 只接受第一个决议，并默默的忽略任何后续调用<br>当然了，如果你把同一个回调注册了不止一次 (p.then (f);p.then (f)) 那么它被调用的次数就会和注册次数相等</p>
<h3 id="未能传递参数-环境值"><a href="#未能传递参数-环境值" class="headerlink" title="未能传递参数/环境值"></a>未能传递参数 / 环境值</h3><p>promise 至多只能有一个决议值（完成或拒绝）<br>如果使用多个参数调用 resolve 或者 reject 第一个参数之后的所有参数都会默默忽略</p>
<p>如果要传递多个值，就必须把他们封装在单个值中传递 比如一个数组或者对象</p>
<h3 id="吞掉错误或者异常"><a href="#吞掉错误或者异常" class="headerlink" title="吞掉错误或者异常"></a>吞掉错误或者异常</h3><p>如果在 <code>Promise</code> 的创建过程中或者查看决议结果过程中的任何时间点上出现了 js 的异常错误，那么这个异常就会被捕捉，并且会使这个 <code>Promise</code> 拒绝 <code>reject</code></p>
<p>promise 甚至把 js 的异常也变成了异步行为，进而极大降低了静态条件出现的可能</p>
<p>但是如果 promise 完成后的回调中出现了 js 异常</p>
<p>因为 p.then () 本身返回了另外一个 promise 正是这个 promise (下一个 promise) 将会因 TypeError 异常而被拒绝</p>
<p><font color="red">注意：为什么它不是简单的调用我们的错误处理函数呢？</font><br>如果这样儿的话就违背了 promise 的基本原则：promise 一旦决议就不可改变<br>也会造成有些回调会调用，有些回调不会调用情况会非常不透明</p>
<h3 id="是可信任的Promise"><a href="#是可信任的Promise" class="headerlink" title="是可信任的Promise"></a>是可信任的 Promise</h3><p><strong>promise 并没有完全摆脱回调，他们只是改变了传递回调的位置</strong></p>
<ul>
<li><p>如果你向 <code>promise.resolve()</code> 传递一个<code>非promise</code> 就会得到用这个值填充的 Promise</p>
</li>
<li><p>如果你向 promise.resolve () 传递一个真正的 promise 就会返回同一个 promise</p>
</li>
<li><p><code>promise.resolve()</code> 可以接受任何 <code>thenable</code>，得到的是一个真正的 Promise 是一个可信任的值，如果你传入的已经是真的 Promise 那么就更值得信任了</p>
</li>
<li><p>对于用 promise.resolve () 为所有函数的返回值（不管是不是 thenable）都封装一层，这样儿做很容易把函数调用规范为定义良好的异步任务</p>
</li>
<li><p><code>Promise</code> 这种模式通过可信任的语义把回调当参数传递，使得这种行为更加可靠合理，通过把回调的控制反转回来，我们把控制权放在了一个可信任的系统，这种系统的设计目的就是为了使得异步编码更清晰</p>
</li>
</ul>
<hr>
<p>以上 promise 解决了回调函数的致命问题<br>接下来 我们将展示基于 promise 的链式流作用</p>
<h2 id="Promise的链式流"><a href="#Promise的链式流" class="headerlink" title="Promise的链式流"></a>Promise 的链式流</h2><p>Promise 并不是一个单步遵循 <code>this-then-that</code> 操作的机制，我们可以将多个 Promise 链接在一起表示一系列异步步骤</p>
<p>这种方式实现的有以下特性</p>
<ul>
<li>每次你对 promise 调用 then () 它会创建并返回一个新的 promise, 我们可以将其链接起来</li>
<li>不管从 then () 调用的完成回调（第一个参数）返回的值是什么，他都会被自动设置为被链接 promise（第一点中的）的完成</li>
<li>调用 promise 的 then () 会自动创建一个新的 promise 从调用返回</li>
<li>在完成或拒绝处理函数内部，如果返回一个值或者抛出一个异常。新返回的 promise（可链接的）就相应的决议</li>
<li>如果返回或拒绝处理函数返回一个 promise, 它将会被展开，这样儿一来，不管它的决议值是什么，都会成为当前 then () 返回的链接 promise 的决议值</li>
</ul>
<p>如下</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var p = Promise.resolve(21);</span><br><span class="line"> p.then(function(v){</span><br><span class="line">  console.log(v * 2)  //42</span><br><span class="line">  return v + 2 // ***</span><br><span class="line">})</span><br><span class="line">.then(function(v){</span><br><span class="line">  console.log('ceshi',v) //23</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p>第一个 then 就是异步序列的第一步</p>
<p>第二个 then 是第二步，<strong>只要保证把先前的 then (..) 连到自动创建的每一个 promise 即可</strong></p>
<p>在这个 demo 中 我们用了立即返回的 return 语句</p>
<p>但是我们如果需要步骤二等待步骤一异步来完成一些事情怎么办？<br>也就是说我们想要使 promise 序列真正能够在每一步有异步能力？</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">我们可以给promise.resolve()传递非（最终值）即 **真正的promise或thenable**，Promise会直接返回真正的promise 或展开接收到的thenable值，并在持续展开`thanable`的同时递归前进</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>如下</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var p = Promise.resolve(21);</span><br><span class="line"> p.then(function(v){</span><br><span class="line">  return new Promise(function(resolve,reject){</span><br><span class="line">    resolve(v*2) //42</span><br><span class="line">  })</span><br><span class="line">})</span><br><span class="line">.then(function(v){</span><br><span class="line">  console.log(v) //42</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>
<p>我们把 42 封装到了返回的 promise 中，但是它仍然会被展开并最终成为链接的 promise 的决议，因此第二个.then 函数中的到的仍然是 42</p>
<p>此时，如果向封装的 promise 中引入异步，仍然会正常工作</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var p = Promise.resolve(21);</span><br><span class="line"> p.then(function(v){</span><br><span class="line">  return new Promise(function(resolve,reject){</span><br><span class="line">    setTimeout(function(){</span><br><span class="line">      resolve(v*2)</span><br><span class="line">    },200)</span><br><span class="line">  })</span><br><span class="line">})</span><br><span class="line">.then(function(v){</span><br><span class="line">  console.log(v) //42</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>
<p>完美 我们可以实现一系列个异步步骤</p>
<p>在这些例子中，一步一步传递的值是可选的，不传的话就是隐式返回 <code>undefined</code> 并且这些 <code>Promise</code> 仍然会以同样的方式链接到一起 每一个 <code>Promise</code> 的决议就成了继续下一个步骤的信号</p>
<h3 id="存在默认的resolve和reject回调"><a href="#存在默认的resolve和reject回调" class="headerlink" title="存在默认的resolve和reject回调"></a>存在默认的 resolve 和 reject 回调</h3><p>默认的 reject</p>
<p>如果你调用.then () 函数并且只传入一个完成处理函数，一个默认拒绝处理函数就会顶替上来，默认拒绝处理函数只是把错误重新抛出，这使得错误可以继续沿着 Promise 链传播下去，直到遇到显式定义的拒绝处理函数</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var p = new Promise(function(resolve,reject){</span><br><span class="line">  reject('ooPs');</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">var p2 = p.then(</span><br><span class="line">  function fulfilled(){</span><br><span class="line">    //不会执行到这里</span><br><span class="line">  },</span><br><span class="line">  //默认的拒绝处理函数 当你没有传时</span><br><span class="line">  function (err){</span><br><span class="line">    throw err;</span><br><span class="line">  }</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>

<p>默认的 reject</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var p = Promise.resolve(2)</span><br><span class="line"></span><br><span class="line">var p2 = p.then(</span><br><span class="line">  function (v){</span><br><span class="line">    //不会执行到这里</span><br><span class="line">    return v</span><br><span class="line">  },</span><br><span class="line">  //默认的拒绝处理函数 当你没有传时</span><br><span class="line">  function reject(err){</span><br><span class="line">    //..</span><br><span class="line">  }</span><br><span class="line">)</span><br><span class="line">.then(function(v){</span><br><span class="line">  console.log('ss',v) //2</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>
<p>默认的完成处理函数只是把接受到的任何传入值传递给下一个步骤的 <code>promise</code> 而已</p>
<h2 id="关于错误处理"><a href="#关于错误处理" class="headerlink" title="关于错误处理"></a>关于错误处理</h2><h3 id="之前同步的错误处理"><a href="#之前同步的错误处理" class="headerlink" title="之前同步的错误处理"></a>之前同步的错误处理</h3><hr>
<p>我们通常使用 try catch 处理异常<br>但是它只能是同步的，<strong>无法用于异步代码模式</strong><br>即使你在异步代码 比如 setTimeout 中谁用 try catch 仍然是有问题的，他们采用 error-first 回调风格，无法很好的组合，多级 error-first 回调交织，导致了回调地狱的风险</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">function foo(cb){</span><br><span class="line">  setTimeout(function(){</span><br><span class="line">    try {</span><br><span class="line">      var x = baz.bar();</span><br><span class="line">      cb(null,x)</span><br><span class="line">    }</span><br><span class="line">    catch(err){</span><br><span class="line">      cb(err)</span><br><span class="line">    }</span><br><span class="line">  })</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">只有在 baz.bar()调用会同步地立即成功或失败的情况下，这里的try catch才能工作</span><br></pre></td></tr></tbody></table></figure>

<h3 id="promise的错误处理-增加-catch-方法"><a href="#promise的错误处理-增加-catch-方法" class="headerlink" title="promise的错误处理 增加 .catch(..)方法"></a>promise 的错误处理 增加 .catch (..) 方法</h3><p>.catch (..) 会创建并返回新的 promise，这个 promise 可用于实现 promise 链式流程控制<br>它没有采用 error-first 回调设计风格，而是使用了分离回调风格<br><code>一个回调用于完成情况 一个回调用于拒绝情况</code></p>
<p>我们了解到 在完成或拒绝处理函数内部，如果返回一个值或者抛出一个异常。新返回的 promise（可链接的）就相应的决议，默认情况下，如果你没有捕捉<code>.then</code> 的异常，它假定你想要 promise 状态吞掉所有的错误，如果你忘记查看这个状态，这个错误就会默默地在暗处凋零</p>
<p>所以为了避免被忽略的错误，<code>promise</code> 链的最佳实践就是最后总以一个 <code>catch</code> 结束</p>
<p>诸如</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var p = Promise.resolve(42);</span><br><span class="line">p.then(function fulfilled(msg){</span><br><span class="line">  console.log(msg.toLowerCase())</span><br><span class="line">})</span><br><span class="line">.catch((error) =&gt; {</span><br><span class="line">  console.log('捕获错误',error)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>
<p>这样儿可以成功的捕获错误</p>
<p>但是 <code>reject()</code> 函数的任何异常都会被作为一个全局未处理的错误抛出</p>
<h2 id="Promise其他的API"><a href="#Promise其他的API" class="headerlink" title="Promise其他的API"></a>Promise 其他的 API</h2><h3 id="Promise-done"><a href="#Promise-done" class="headerlink" title="Promise.done(..)"></a>Promise.done(..)</h3><p>标示 promise 链的结束<br>done () 不会创建和返回 promise</p>
<h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all([])"></a>Promise.all([])</h3><p>在异步序列中，任意时刻都只能有一个异步任务正在执行<br>但是我们如果想要同时执行两个或更多步骤（“并行执行”）的时候，<code>Promise.all([])</code> 的魅力就体现出来<br>了</p>
<p>Promise.all ([]) 接收一个数组，值可以是（promise，thenable，甚至是立即值），列表里的每个值都要经过 Promise.resolve () 过滤，以确保要等待的是一个真正的 promise，<br>从返回的 promise 数据也是一个数组，与传入的顺序一致</p>
<p>如果返回的主 promise 在且仅在所有成员 promise 都完成后才会完成 如果有热和一个被拒绝，主 promise 就会立即被拒绝，并丢弃来自其他所有 promise 的结果</p>
<p>所以 要为每个 promise 关联一个错误处理函数</p>
<p>传入空数组时，它会立即完成</p>
<h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race([])"></a>Promise.race([])</h3><p>与 promise.all 类似<br>它一旦有人黑一个 promise 决议为完成，promise.race 就会完成，一旦有任何一个 promise 决议为拒绝，它就会拒绝</p>
<p>它的完成值是单个消息，并不像 promise.all 那样儿是一个数组，其他的 promise 会被丢弃或者忽略</p>
<p>两者都会创建一个 promise 作为他们的返回值，这个 promise 的决议完全由传入的 promise 数组控制</p>
<p>传入空数组时，它会挂住，且永远不会决议</p>
<h3 id="Promise-finally"><a href="#Promise-finally" class="headerlink" title="Promise.finally()"></a>Promise.finally()</h3><p>从行为的角度上 有些开发者提出，promise 需要一个 <code>finally()</code> 的回调注册，这个回调在 <code>promise</code> 决议后总是会被调用，并且允许你执行任何必要的清理工作</p>
<p>如下</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var p = Promise.resolve(42);</span><br><span class="line">p.then(()=&gt;{})</span><br><span class="line">.finally(cleanup)</span><br><span class="line">.then(()=&gt;{})</span><br><span class="line">.finally(cleanup)</span><br></pre></td></tr></tbody></table></figure>
<p>finally 会创建并返回一个新的 promise 以支持链接继续</p>
<h3 id="new-Promise-构造器"><a href="#new-Promise-构造器" class="headerlink" title="new Promise(..)构造器"></a>new Promise (..) 构造器</h3><p>构造器 Promise 必须和 new 一起使用，并且必须提供一个函数回调，这个回调是同步的，这个函数接收到两个函数回调，用以支持 promise 的决议</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var p = new Promise(function(resolve,reject){</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>
<h4 id="创建两种决议的快捷方式"><a href="#创建两种决议的快捷方式" class="headerlink" title="创建两种决议的快捷方式"></a>创建两种决议的快捷方式</h4><ol>
<li>Promise.resolve// 用于创建一个已完成的 promise</li>
<li>Promise.reject// 用于拒绝这个 promise</li>
</ol>
<p>以下是等价的</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">var p = new Promise(function(resolve,reject){</span><br><span class="line">reject('oop');</span><br><span class="line">})</span><br><span class="line">var p = Promise.reject('oop')</span><br></pre></td></tr></tbody></table></figure>


<p>##promise 的局限性</p>
<ul>
<li>顺序错误处理 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">他们链接的方式 promise链中的错误容易被无意中忽略掉</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>单一值 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">promise只能有一个完成值或一个拒绝理由 对于复杂的场景信息有点局限</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li> 单决议</li>
<li>无法取消的 promise</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">一旦创建了一个promise并为其注册了完成和拒绝处理函数，如果出现某种情况使得这个任务悬而未决的话 你也没有办法从外部停止它的进程</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>promise 性能 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">更多的工作更多的保护 promise与回调相比 会慢一点</span><br><span class="line">但是作为交换你得到的是大量内建的可信任性</span><br></pre></td></tr></tbody></table></figure>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><ul>
<li><p>promise 非常好 他们解决了我们因只用回调的代码而备受困扰的控制反转的问题</p>
</li>
<li><p>它并没有摒弃回调，只是把回调的安排转交给了一个位于我么和其他工具之间的可信任的中介机制</p>
</li>
<li><p>promise 也开始提供（尽管不完美）以顺序的方式表达异步流的一个更好的办法，这有助于我们的大脑更好的几乎是和维护异步 js 代码</p>
</li>
</ul>
<hr>
<p>#第二阶段 (生成器 Generator 时期)</p>
<p>先来回顾一下 回调表达异步控制流程的两个关键缺陷</p>
<ol>
<li>基于回调的异步不符合大脑对任务步骤的规划方式</li>
<li>由于控制反转回调并不是可信任的</li>
</ol>
<p>然后我们用 <code>Promise</code> 解决了如何把回调的控制反转 反转回来，恢复了可信任性<br>但是它不会暂停<br>现在我们寻求一种顺序，看似同步的异步流程控制表达这个 (.then () 钱嵌套多了也受不了)，引出了<font color="red"> ES6 生成器</font>的概念</p>
<p>Generator 最大的特点就是可以控制函数的执行<br>它会创建出一个迭代器<br>Generator 函数是一个状态机，封装了多个内部状态。<br>调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是遍历器对象（Iterator Object）</p>
<p>它打破了完整执行 我们不再依赖<strong>一个函数一旦开始执行，就会运行到结束，期间不会有其他代码能够打破它并插入其间</strong>的假定</p>
<p>ES6 中指定暂停点的语法是 <code>yield</code> 这样礼貌的表达了一种合作式的控制放弃</p>
<p>如下</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var x = 1;</span><br><span class="line">function *foo(){</span><br><span class="line">  x++;</span><br><span class="line">  yield;</span><br><span class="line">  console.log('x:',x);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">function bar(){</span><br><span class="line">  x++</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var it = foo(); //构建了一个迭代器 并没有执行foo</span><br><span class="line">it.next(); //启动生成器 *foo 并运行了第一行的 x++  *foo在yield处暂停</span><br><span class="line">console.log('sws',x) //2</span><br><span class="line">bar();</span><br><span class="line">console.log('二',x) //3</span><br><span class="line">it.next(); //最后从暂停处恢复了生成器 *foo的执行 运行了  console.log('x:',x); //3</span><br></pre></td></tr></tbody></table></figure>
<p>生成器是一种特殊的函数，可以一次或者多次的启动和停止 构建生成器是作为异步流程控制的代码模式的基础构件之一</p>
<p>我们可以看到 我们在暂停之后做了我们想做的操作 还执行了我们想要执行的函数 <code>bar</code></p>
<h3 id="生成器的输入和输出"><a href="#生成器的输入和输出" class="headerlink" title="生成器的输入和输出"></a>生成器的输入和输出</h3><p><code>var it = foo();</code> 这行只是创建了一个生成器对象，把它赋给了变量 it，用于控制生成器，它是特殊的函数，也具有函数的特质，可以传递参数<br><code>it.next()</code> 指定生成器从当前位置开始继续运行，停在下一个 <code>yield</code> 处或者直到生成器结束，它调用的结果是一个对象，有一个 value 属性，持有从 <code>*foo</code> 返回的值（如果有的话）也就是说 <code>yield</code> 会导致生成器在执行过程中发送出一个值 (类似 <code>return</code>)</p>
<p>如下</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">function *foo(x,y){</span><br><span class="line">  return x * y;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var it = foo(6,7); </span><br><span class="line">var obj = it.next(); </span><br><span class="line">console.log(obj) //{value: 42, done: true}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="迭代消息传递"><a href="#迭代消息传递" class="headerlink" title="迭代消息传递"></a>迭代消息传递</h3><p>通过 <code>yield</code> 和 <code>next</code> 实现的内建消息输入输出能力</p>
<p><code>next()</code> 调用要比 <code>yield</code> 语句多一个<br>因为第一个 <code>next()</code> 总是启动一个生成器，并运行到第一个 <code>yield</code> 处，执行第一次 <code>next</code> 时候，传递参数值会被忽略</p>
<p>第一个 yield 基本上是提出了一个问题：我的值是多少？<br>谁来回答这一个问题 显然第一个 next 已经执行，因此由第二个 next 调用回答第一个 yield 提出的这个问题</p>
<p>从迭代器的角度看问题</p>
<p>消息是双向传递的 next 也可以向暂停的 yield 表达式发送值 yield 作为一个表达式可以发出消息响应 next 的调用</p>
<p>这里有一个例子能帮助你理解 generator 的执行</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">//yield基本上就是提出了个问题 我的值等于什么 然后由下一个next()传递的参数回答</span><br><span class="line"></span><br><span class="line">function *foo(x){</span><br><span class="line">  let y = 2 *(yield(x+1));</span><br><span class="line">  let z = yield(y/3);</span><br><span class="line">  return x + y + z </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let it = foo(5);</span><br><span class="line"></span><br><span class="line">console.log(it.next()) //{value: 6, done: false}</span><br><span class="line">console.log(it.next(12)) //{value: 8, done: false}</span><br><span class="line">console.log(it.next(13)) //{value: 42, done: true}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">解析</span><br><span class="line">generator函数调用和普通函数不同 它会返回一个迭代器</span><br><span class="line"></span><br><span class="line">执行第一次next时候，传递参数值会被忽略，并且函数暂停在yield(x+1)处 所以返回 5+1</span><br><span class="line">执行第二次next时，传入的参数等于上一个yield的返回值 如果你不传参，yield永远返回undefined，此时  let y = 2 * 12 = 24，所以第二个z是24/3 =8</span><br><span class="line">当执行第三次next时 传递的参数会传递给z，所以z=13 x = 5 y = 24 相加等于42</span><br><span class="line">*/</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong>多个迭代器</strong><br>每次构建一个迭代器实际上就是隐式构建生成器的一个实例 通过这个迭代器控制的是这个生成器的实例</p>
<p>同一个生成器的多个实例可以同时运行它们甚至可以彼此交互</p>
<h4 id="生产者与迭代器"><a href="#生产者与迭代器" class="headerlink" title="生产者与迭代器"></a>生产者与迭代器</h4><p>假设你要产生一系列值，其中每个值都与前面一个有特定的关系  需要一个有状态的生产者能够记住其生成的最后一个值<br>在此之前 我们可以使用函数闭包来实现</p>
<p>迭代器是一个定义良好的接口，用于从一个生产者一步步得到一系列值，js 迭代器的接口与多数语言类似，就是每次想要从生产者得到下一个值的时候调用 next ()<br>next 调用返回一个对象有两个属性</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">done是一个布尔值 表示迭代器的完成状态</span><br><span class="line">value中放置迭代值</span><br></pre></td></tr></tbody></table></figure>

<h4 id="同步错误处理"><a href="#同步错误处理" class="headerlink" title="同步错误处理"></a>同步错误处理</h4><p>类似</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">try{</span><br><span class="line">    var text = yield foo(11,31);</span><br><span class="line">    console.log(text)</span><br><span class="line">}</span><br><span class="line">catch(err){</span><br><span class="line">    console.log(err)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>生成器 <code>yield</code> 暂停的特性意味着我们不仅能从异步函数调用的到看似同步的返回值，还可以同步捕获来自这些异步函数调用的错误 它使得生成器能够捕获错误是一个很大的进步</p>
<h1 id="第四阶段（async-await时期-ES7）"><a href="#第四阶段（async-await时期-ES7）" class="headerlink" title="第四阶段（async/await时期 ES7）"></a>第四阶段（async/await 时期 ES7）</h1><p>ES6 中最完美的时间就是生成器（看似同步的代码）和 promise（可信任可组合）的结合</p>
<p>我们不再 <code>yield</code> 出 <code>Promise</code> 而是用 <code>await</code> 等待它决议<br>它其实就是把前面的经验写进规范</p>
<h2 id="ES7的esync函数对于ES6的generator函数的改进体现了哪些方面"><a href="#ES7的esync函数对于ES6的generator函数的改进体现了哪些方面" class="headerlink" title="ES7的esync函数对于ES6的generator函数的改进体现了哪些方面"></a>ES7 的 esync 函数对于 ES6 的 generator 函数的改进体现了哪些方面</h2><ul>
<li>内置执行器 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">generator函数的执行必须依赖于执行器，而async函数自带执行器，也就是说async函数的执行，与普通函数一模一样，只需要一行</span><br><span class="line">asyncReadFile();</span><br><span class="line"></span><br><span class="line">像这样 直接调用函数 就可以直接得出结果 不像generator函数，需要调用next方法或者co模块 才能真正执行得到最后的结果</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>更好的语义 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">async和await比起 * 和 yield 语义更清楚了async表示函数有异步操作，await表示紧跟在后面的表达式需要等待的结果</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>更广的适用性 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">co模块规定 yield命令后面只能是thunk函数或者promise对象，而async函数的await后面 可以是promise对象和原始类型的值（数值，布尔等但这等同于同步操作）</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>返回值是 promise</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">async函数返回的是promise对象，这比generator函数的返回值是 Iterator对象方便多了，你可以用then方法指定下一步的操作</span><br><span class="line"></span><br><span class="line">进一步说 async函数可以看作是多个异步操作包装成的一个promise对象，而await命令就是内部then命令的语法糖</span><br></pre></td></tr></tbody></table></figure>





<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>一个函数如果加上 async 那么它就会返回 promise</li>
<li>async 就是将函数返回值使用 Promise.resolve () 包裹了下，和 then 中处理返回值一样</li>
<li> await 是异步操作，它内部实现了 generator, 如果后来的表达式不返回 promise 的话，它就会被包装成 Promise.resolve (返回值)，然后去执行函数的同步代码</li>
</ul>
<p>看下面这个等价的例子</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">async function async1(){</span><br><span class="line">    await async2();</span><br><span class="line">    console.log('async1 end')</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">async function async2(){</span><br><span class="line">  console.log('async2 end')</span><br><span class="line">}</span><br><span class="line">async1();</span><br><span class="line"></span><br><span class="line">等价于</span><br><span class="line"></span><br><span class="line">new Promise((resolve,reject)=&gt;{</span><br><span class="line">  console.log('async2 end')</span><br><span class="line">  resolve(Promise.resolve()) //Promise.resolve()决议之后将then代码插入到微任务队列的尾部</span><br><span class="line">})</span><br><span class="line">.then(()=&gt;{</span><br><span class="line">  console.log('async1 end')</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>


<ul>
<li> async 及 await 配合使用</li>
<li> await 就是 <code>generator</code> 加上 <code>promise</code> 的语法糖</li>
<li> <code>async/await</code> 是异步的终极解决方案</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p> <font color="red">优势</font> </p>
<ul>
<li> 处理 then 的调用链，能更清晰的写出来代码，毕竟写一堆 then 也很</li>
<li> 能解决回调地狱的问题</li>
</ul>
<p><font color="red">缺点</font></p>
<ul>
<li> 因为 <code>await</code> 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 <code>await</code> 导致性能上的降低</li>
</ul>
<p>如下</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">async function test(){</span><br><span class="line"> await fetch(url)</span><br><span class="line"> await fetch(url2)</span><br><span class="line"> await fetch(url3)</span><br><span class="line">}</span><br><span class="line">这样儿的代码 如果没有依赖最好用promise.all</span><br></pre></td></tr></tbody></table></figure>



<p>#总结</p>
<ul>
<li><p>生成器是 ES6 的一个新的函数类型 它并不像普通函数那样总是运行到结束，取而代之的是生成器可以在运行当中（完全保持其状态）暂停 并且将来再从咱题 ing 的地方恢复运行</p>
</li>
<li><p>这种简体的暂停和恢复是合作型的不是抢占型的，这意味着生成器具有独一无二的能力来暂停自身，这是通过关键字 <code>yield</code> 来实现的 不过 只有控制生成器的迭代器具有恢复生成器的能力（next (..)）</p>
</li>
<li><p>yield/next 不只是控制机制 实际上也是一种双向消息传递机制 yield 表达式备注上是暂停下来等待某个值 接下来的 next 调用则是会向被暂停的 yield 表达式传回一个值</p>
</li>
<li><p>在异步控制流程方便生成器的关键优点是 生成器内部的代码是以自然的同步 / 顺序方式表达任务的一系列步骤，其技巧在于 我们把可能的异步隐藏在关键字 yield 的后面 把异步移动到控制生成器的迭代器的代码部分</p>
</li>
<li><p>换句话说 生成器为异步代码保持了顺序同步 阻塞的代码模式 这使得大脑可以更自然的追踪代码 解决了基于回调的异步的缺陷</p>
</li>
</ul>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title>揭秘 setState 机制</title>
    <url>/2019/01/27/re_setState/</url>
    <content><![CDATA[<h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>要说 <code>React</code> 设计体现了响应式编程思想</p>
<blockquote>
<p>UI=f(state) </p>
</blockquote>
<p><a href="https://www.zhihu.com/people/morgancheng/activities">程墨 Morgan</a> 的总结真是恰到好处</p>
<p><code>state</code> 于 <code>React</code> 很重要，<code>setState</code> 作为管理 <code>state</code> 的重要方法自然也是头等公民</p>
<p>当然了，如果只是简单用法，API 足够了，你知道如何设置，如何更新，或许能解决眼前的需求，但是需求稍微复杂一点，可能会被动陷入 <code>setState</code> 怪圈</p>
<p>在哪里跌倒就把哪里买下来，被坑了之后，痛定思痛决定研究下 <code>setState</code> 怪象，最后发现 react 真是博大精深</p>
<p><font color="red">文章太太太长了，不太感兴趣的话，可以拉到最后总结，也能避免入坑</font></p>
<a id="more"></a>

<h2 id="引出问题"><a href="#引出问题" class="headerlink" title="引出问题"></a>引出问题</h2><p><strong>如果面试官问你</strong></p>
<ol>
<li>setState 是同步的还是异步的？</li>
<li>它可能是同步的吗？如果可能的话如何实现同步更新 state？</li>
</ol>
<p>如果是看这篇文章之前 我的答案可能是这样儿</p>
<ol>
<li>它是异步的 不能立马拿到结果</li>
<li> emm….</li>
</ol>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><!--最好的方式就是带着疑问看源码（基于版本<font color="red">16.4.1</font>），相信我 调试大法好-->

<p>可能会有疑问的几个问题.</p>
<h3 id="1-为什么要用setState更新state不能直接修改？"><a href="#1-为什么要用setState更新state不能直接修改？" class="headerlink" title="1. 为什么要用setState更新state不能直接修改？"></a>1. 为什么要用 setState 更新 state 不能直接修改？</h3><p>先更正一个观点 是可以通过 <code>this.state</code> 对象修改 state 的 也确实能改变状态，但是不能驱动 ui 更新（不走 render）那.. 有什么意义</p>
<h3 id="2-setState是同步的还是异步的？"><a href="#2-setState是同步的还是异步的？" class="headerlink" title="2. setState是同步的还是异步的？"></a>2. setState 是同步的还是异步的？</h3><p>setState 是同步执行的 但是 state 并不一定会同步更新（异步更新）, 这是结论</p>
<p>针对这个问题 让我们带着问题去源码（基于版本<font color="red"> 16.4.1</font>）中寻找答案</p>
<hr>
<h4 id="场景一（合成事件中调用setState）"><a href="#场景一（合成事件中调用setState）" class="headerlink" title="场景一（合成事件中调用setState）"></a><font color="green"><strong>场景一（合成事件中调用 setState）</strong></font></h4><p>点击按钮实现加一的操作</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">...</span><br><span class="line">onClick = ()=&gt; {</span><br><span class="line">   this.setState({</span><br><span class="line">       val: this.state.val + 1</span><br><span class="line">   })</span><br><span class="line">   console.log('onClick', this.state.val);</span><br><span class="line"> }</span><br><span class="line"> ...</span><br><span class="line"> render(){</span><br><span class="line">console.log('render', this.state.val);</span><br><span class="line"> &lt;button onClick={this.onClick}&gt;加1&lt;/button&gt;</span><br><span class="line"> }</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>首先 这是<font color="red">合成事件</font>中操作 <code>state</code>,</p>
<p><strong>了解什么是合成事件？</strong></p>
<blockquote>
<p>react 为了解决跨平台，兼容性问题，自己封装了一套事件机制，代理了原生的事件，像在 jsx 中常见的 onClick、onChange 这些都是合成事件</p>
</blockquote>
<p>盯着这张网络盗图，画的完全符合我的预期，先有个概览，下文会跟踪解释</p>
<p><img src="/images/setState/setState__.jpg" alt="setState的更新过程"></p>
<p>当你点击 <code>onClick</code> 时</p>
<ul>
<li>第一阶段 （对合成事件的前期处理）</li>
</ul>
<p>react 会在正式 <code>setState</code> 前执行一堆 pre 钩子函数 (<font color="red">大部分都不需要关心</font>), 你可以在 chrome 调试台或者 <code>console.trace()</code> 追踪到<br>像这样儿👇<br><img src="/images/setState/trace.png" alt="trace"><br>这些都是 react 的前期处理 这个过程你只需要关心👇</p>
<p><img src="/images/setState/pre11.png" alt="pre钩子"></p>
<p>得到的信息<br>isBatchingUpdates 默认为 false, 在这里 (某一个 pre 钩子函数中被置为 true 了)，划重点，以后要考的 此时程序走的是<font color="red"> try 分支</font></p>
<p>至此，前期处理结束</p>
<ul>
<li>第二阶段（setState 事件的处理）</li>
</ul>
<p>红框部分是 <code>setState</code> 逻辑的调用栈，执行到 <code>requestWork</code> 方法时会二次判断 如下图👇<br><img src="/images/setState/sasas.png" alt="sasas"></p>
<p>二阶段完</p>
<ul>
<li>第三阶段（重置 post 钩子，更新 state 渲染 ui 操作）</li>
</ul>
<p>接上文，那么我想知道它会 return 到哪里呢<br>通过追踪发现 会走你主进程里的 <code>console</code> 语句<br><img src="/images/setState/state_delay.png" alt="state延迟更新"><br><strong>这也就是为什么说 setState 更异步的</strong><br>上文中提到我们现在仍然处在 try 分支中，而在 finally 中才会更新 <code>state</code> 并且渲染到 UI 上，此时我们得到的仍然是<code>更新前的 state</code> 值，这就导致了<code>所谓的"异步"</code>, 为什么要用 <code>""</code> 号，因为这并不是我们的本意，是 <code>react为了性能着想私自做的处理</code></p>
<hr>
<p>接着往下走：<br><img src="/images/setState/sssswww.png" alt="ssssww"><br>最终还会走到这个方法<br>这个方法里面有个 try finally 语法，到这里 我们知道了原来 return 到了这个 fn<br>继续👇<br><img src="/images/setState/post0.png" alt="post钩子"><br><img src="/images/setState/ui.png" alt="ui"></p>
<p>render 之后 合成事件中 setState 的逻辑就结束了</p>
<hr>
<h4 id="场景二（生命周期中调用setState）"><a href="#场景二（生命周期中调用setState）" class="headerlink" title="场景二（生命周期中调用setState）"></a><font color="green"><strong>场景二（生命周期中调用 setState）</strong></font></h4><p>实际上与场景一只在第一阶段不同（没有对合成事件的各种处理）我们可能想在不同的生命周期中聊下 state 的更新状况</p>
<p>我们照例先来个小 demo 再来分析为什么会有这样儿的结果</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">state = {</span><br><span class="line">   val:0,</span><br><span class="line">   name:'yishu',</span><br><span class="line">   age:18</span><br><span class="line">}</span><br><span class="line"> componentWillMount(){</span><br><span class="line">      this.setState({val:this.state.val+1});</span><br><span class="line">      console.log('componentWillMount第一次输出',this.state.val)</span><br><span class="line">      this.setState({val:this.state.val+1});</span><br><span class="line">      console.log('componentWillMount第二次输出',this.state.val)</span><br><span class="line">    }</span><br><span class="line">     componentDidMount(){</span><br><span class="line">      this.setState({</span><br><span class="line">            val: this.state.val + 1,</span><br><span class="line">            name:'🐶'</span><br><span class="line">        });</span><br><span class="line">        console.log('componentDidMount第一次执行', this.state.val)</span><br><span class="line">        this.setState({</span><br><span class="line">            val: this.state.val + 1,</span><br><span class="line">            name:'🐱',</span><br><span class="line">            age:81</span><br><span class="line">        });</span><br><span class="line">        console.log('componentDidMount第二次输出', this.state.val)</span><br><span class="line">     }</span><br><span class="line">     </span><br><span class="line">     componentDidUpdate(){</span><br><span class="line">        console.log('componentDidUpdate执行',this.state.val)</span><br><span class="line">    }</span><br><span class="line">render(){</span><br><span class="line">      if(this.state.val !==0){</span><br><span class="line">            console.log('render执行',this.state)</span><br><span class="line">        }</span><br><span class="line">  &lt;p&gt;当前的值:{this.state.val}&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;你的名字:{this.state.name}&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;芳龄:{this.state.age}&lt;/p&gt;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>直接给出结果</p>
<p><img src="/images/setState/component_state.png" alt="component_state"><br>其实经过各种 API 的熏陶，不运行也能知道结果，既然摊开来讲，就比较想知道为什么。</p>
<p>按照流程 ，先来一张调用栈鸟瞰图（网图）</p>
<p><img src="/images/setState/gouzihanshu.jpg" alt="钩子函数中setState的调用栈"><br>还是三个阶段</p>
<ul>
<li><p>第一阶段<br><img src="/images/setState/did.png" alt="did"></p>
</li>
<li><p>第二阶段<br><img src="/images/setState/2121233434.png" alt="2121233434"><br>到现在就比较清晰了，与场景一不同的是 走的是 <code>requestWork</code> 中的第一个 <code>if</code> 分支，场景一（第二个 if 分支）不管哪种情况 结果都是一致的 那就是不会走到下面的同步更新分支 并且 两种情况都还只是在 <strong>try</strong> 模块中执行 再往下的流程参考场景一</p>
</li>
<li><p>第三阶段<br>同场景一</p>
</li>
</ul>
<p>关于这一场景 背着<br><font color="red"><code>render</code> 之前的生命周期拿到的都是更新之前的值，render 之后执行的才能拿到最新的值 比如 <code>componentDidUpdate</code></font></p>
<hr>
<h3 id="3-setState可以变成同步更新吗？-如果可以的话-怎么做才能获取最新的值？"><a href="#3-setState可以变成同步更新吗？-如果可以的话-怎么做才能获取最新的值？" class="headerlink" title="3. setState可以变成同步更新吗？ 如果可以的话 怎么做才能获取最新的值？"></a>3. setState 可以变成同步更新吗？ 如果可以的话 怎么做才能获取最新的值？</h3><p>面试官这么问的话 通常都是可以 😂<br>那我们如何做<br>实践中一般每个人都有一到两种解决方案，这里列举中处理方案 并将在下面的文章中深入研究 为什么 它 可以.</p>
<ul>
<li>在<strong>原生事件</strong>中调用 <code>setState</code> 函数</li>
<li>利用 setState 回调函数</li>
<li> setTimeout 等异步操作中调用 <code>setState</code> 函数</li>
<li>最近刚被种草的函数式 setstate 用法</li>
<li> componentDidUpdate 中获取</li>
</ul>
<p>名词释义：<br><strong>原生事件</strong>：指非 react 合成事件，原生自带的事件监听 <code>addEventListener</code> ，或者也可以用原生 <code>js、jq</code> 直接 <code>document.querySelector().onclick</code> 这种绑定事件的形式</p>
<hr>
<h4 id="在原生事件中调用setState函数"><a href="#在原生事件中调用setState函数" class="headerlink" title="在原生事件中调用setState函数"></a>在<strong>原生事件</strong>中调用 <code>setState</code> 函数</h4><p>一个小 demo</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">state = {</span><br><span class="line">   val:0</span><br><span class="line">}</span><br><span class="line">componentDidMount = () =&gt;{</span><br><span class="line"> document.querySelector('#btn-raw').addEventListener('click', this.onClick);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">onClick = ()=&gt; {</span><br><span class="line">   this.setState({</span><br><span class="line">       val: this.state.val + 1</span><br><span class="line">   });</span><br><span class="line">   console.log('onClick', this.state.val);</span><br><span class="line"> }</span><br><span class="line"> </span><br><span class="line">render(){</span><br><span class="line"> if(this.state.val !==0){</span><br><span class="line">            console.log('render执行',this.state)</span><br><span class="line">        }</span><br><span class="line"> &lt;button id="btn-raw"&gt;Increment &lt;/button&gt;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果<br><img src="/images/setState/js.png" alt="js"><br>意料之中</p>
<p>按理来说还需要张鸟瞰图 在这里 👇</p>
<p><img src="/images/setState/js0setState.jpg" alt="原生事件的setState"></p>
<p>其实应该已经挺清晰了，我们还是在调试器里走一下</p>
<ul>
<li>第一阶段（setState 逻辑之前的处理）</li>
</ul>
<p><img src="/images/setState/js_xzs.png" alt="js_xzs"><br>画风突变，调用栈内不再执行一堆看不懂的 pre 钩子函数了<br>简单的理解为 用原生事件调用时 不受 react 控制了 也就没办法针对它执行一堆函数，直接走 setState 的逻辑了</p>
<ul>
<li>第二阶段（setState 执行逻辑）</li>
</ul>
<p><img src="/images/setState/js999.png" alt="js999"></p>
<p>走了第三个 <code>if</code> 分支 同步更新了（执行了 render 再在 click 函数中打印的 所以拿到了最新值）</p>
<ul>
<li>第三阶段</li>
</ul>
<p>参考场景一</p>
<hr>
<h4 id="利用setState回调函数"><a href="#利用setState回调函数" class="headerlink" title="利用setState回调函数"></a>利用 setState 回调函数</h4><p>API 就不多说了</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"> this.setState({</span><br><span class="line">       val:this.state.val + 1</span><br><span class="line">        },()=&gt;{</span><br><span class="line">          console.log('cllback',this.state.val);</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>
<p>原理：回调函数被调用的时候，其实 render 函数已经被调用过了 参考 <code>demo</code> 的执行结果</p>
<hr>
<h4 id="setTimeout等异步操作中调用setState函数"><a href="#setTimeout等异步操作中调用setState函数" class="headerlink" title="setTimeout等异步操作中调用setState函数"></a>setTimeout 等异步操作中调用 <code>setState</code> 函数</h4><p>实际上 这并不是一个单独的场景，你可以在合成事件中 调用 <code>setTimeout</code> ，可以在生命周期中调用 <code>setTimeout</code> ，也可以在原生事件 <code>setTimeout</code>，但是不管是哪个场景下，基于 <code>event loop</code> 的模型下， setTimeout 中里去 setState 总能拿到最新的 state 值</p>
<p>一个 demo 👇</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">this.state = {</span><br><span class="line">       val:0,</span><br><span class="line">       name:'yishu',</span><br><span class="line">       age:18</span><br><span class="line">   }</span><br><span class="line">       componentDidMount(){</span><br><span class="line">        // // debugger;</span><br><span class="line">        // // 生命周期中调用---------------</span><br><span class="line">        this.setState({</span><br><span class="line">            val: this.state.val + 1,</span><br><span class="line">            name:'🐶'</span><br><span class="line">        });</span><br><span class="line">        console.log('componentDidMount第一次执行', this.state.val)</span><br><span class="line">        this.setState({</span><br><span class="line">            val: this.state.val + 1,</span><br><span class="line">            name:'🐱',</span><br><span class="line">            age:81</span><br><span class="line">        });</span><br><span class="line">        console.log('componentDidMount第二次输出', this.state.val)</span><br><span class="line"></span><br><span class="line">        setTimeout(() =&gt; {</span><br><span class="line">            console.log('开始setTimeout', this.state.val)</span><br><span class="line">            this.setState({</span><br><span class="line">                val: this.state.val + 1</span><br><span class="line">            });</span><br><span class="line">            console.log('setTimeout第一次执行', this.state.val)</span><br><span class="line">            this.setState({</span><br><span class="line">                val: this.state.val + 1</span><br><span class="line">            });</span><br><span class="line">            console.log('setTimeout第二次执行', this.state.val)</span><br><span class="line">        }, 0)</span><br><span class="line"></span><br><span class="line">        this.setState({</span><br><span class="line">            val: this.state.val + 1</span><br><span class="line">        });</span><br><span class="line">        console.log('componentDidMount第三次输出', this.state.val)        </span><br><span class="line">    }</span><br><span class="line">render(){</span><br><span class="line">if(this.state.val !==0){</span><br><span class="line">            console.log('render执行',this.state)</span><br><span class="line">        }</span><br><span class="line"> &lt;p&gt;当前的值:{this.state.val}&lt;/p&gt;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><img src="/images/setState/setTimeout.png" alt="setTimeout"><br>上述结果，如果你了解<font color="red"> js 事件循环（ event loop）</font>的机制 就太简单了</p>
<p>默认你已经阅读过全文的上半部分 了解了 <code>setState</code> 逻辑都是在 <strong>try</strong> 模块中执行的，此时当执行到 <code>setTimeout</code> 的时候，把它丢到 ** 定时器触发线程 (浏览器提供的线程)** 去维护，并没有立即执行，先执行的 <code>finally</code> 代码块，等 finally 执行完了， <code>isBatchingUpdates</code> 又变为了 <code>false</code> ，导致最后去执行队列里的 setState 时候， requestWork 走的是和原生事件一样的 <code>expirationTime === Sync if</code> 分支，所以表现就会和原生事件一样，可以同步拿到最新的 <code>state</code> 值。</p>
<p>关于 js 事件循环 又是另一个模块儿的东西 值得单开一章去研究，这里就不再细说了 感兴趣的同学 可移步<br><a href="http://maying.ink/2018/11/17/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3js%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/#more">js 到底是如何工作的</a> 寻找答案</p>
<hr>
<h3 id="4-函数式setState用法"><a href="#4-函数式setState用法" class="headerlink" title="4. 函数式setState用法"></a>4. 函数式 setState 用法</h3><p>我在想 怎么才能更好引出这个大彩蛋，那便又涉及到另一个问题<br>以上文章中我们为了说明 <code>setState执行的大流程</code> 有一个实际存在却没提及的问题，那就是 <code>setState的批量更新</code></p>
<p>类似这样儿的代码</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">//...</span><br><span class="line">this.setState({val: this.state.val + 1});</span><br><span class="line">console.log('componentDidMount第一次执行', this.state.val)</span><br><span class="line">this.setState({val: this.state.val + 1});</span><br><span class="line">console.log('componentDidMount第二次执行', this.state.val)</span><br><span class="line">this.setState({val: this.state.val + 1});</span><br><span class="line">console.log('componentDidMount第三次执行', this.state.val)</span><br><span class="line">//...</span><br></pre></td></tr></tbody></table></figure>
<p>得到的执行结果<br><img src="/images/setState/render.png" alt="rende"></p>
<p>API 告诉我可以接受，但是有点点懵 发生了什么… emm<br>假如这么写 会不会更清晰👇</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const currentCount = this.state.count;</span><br><span class="line">this.setState({count: currentCount + 1});</span><br><span class="line">this.setState({count: currentCount + 1});</span><br><span class="line">this.setState({count: currentCount + 1});</span><br></pre></td></tr></tbody></table></figure>
<p>对的 你每次设置的都是同一个值<br>setState 多次，re-render 一次，多次同步执行的 <code>setState</code>，会进行合并，类似于 <code>Object.assign</code>, 相同的 <code>key</code> 会被覆盖 所以结果为<font color="red"> 1</font></p>
<p>为了不偏题 实现过程暂时省略，接受这个结论，让我们看函数式 setState 用法</p>
<p><font color="red">如果传递给 this.setState 的参数<code>不是一个对象而是一个函数</code> 那就完全不一样儿了</font></p>
<p>一个小🌰体验下神奇的效果</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">componentDidMound = () =&gt;{</span><br><span class="line">        console.log('参数为函数第一次执行',this.state.val)</span><br><span class="line">        this.setState(this.increment);</span><br><span class="line">        console.log('参数为函数第二次执行',this.state.val)</span><br><span class="line">        this.setState(this.increment);</span><br><span class="line">        console.log('参数为函数第三次执行',this.state.val)</span><br><span class="line">        this.setState(this.increment);</span><br><span class="line">        console.log('参数为函数第四次执行',this.state.val)</span><br><span class="line">}</span><br><span class="line">   /**</span><br><span class="line">     * @description increment函数并不去修改组件状态，只是把“希望的状态改变”返回给React，维护状态这些苦力活完全交给React去做。</span><br><span class="line">     * params  state：当前的state</span><br><span class="line">     * params  props：当前的props</span><br><span class="line">     * @return 对象代表之前你想给this.setState传递的参数 比如你认为第一次传0 第二次传1 </span><br><span class="line">     * @memberof SetState</span><br><span class="line">     */</span><br><span class="line">    increment = (state, props) =&gt; {</span><br><span class="line">        // 计算这个对象的方法有些改变，不再依赖于this.state，而是依赖于输入参数state。</span><br><span class="line">        console.log('---state',state) </span><br><span class="line">        return {val: state.val + 1}; //同样是把状态中的count加1，但是状态的来源不是this.state，而是输入参数state。</span><br><span class="line">      }</span><br></pre></td></tr></tbody></table></figure>
<p><img src="/images/setState/fn_state.png" alt="fn_state"><br>仔细看下代码中的注释部分<br>结论：<br>对于多次调用函数式 setState 的情况，React 会保证调用每次 increment 时，state 都已经合并了之前的状态修改结果。<br>但是 在 <code>increment</code> 函数被调用时<code>，this.state</code> 并没有被改变，依然要等到 <code>render</code> 函数被重新执行时才被改变，也没有推翻上文的结论 真好。</p>
<p>API 的设计符合函数式编程思想，开发者编写无副作用的函数 increment 并不会去改变组件状态，只是把 “希望的状态改变” 返回给 React，维护状态这些苦力活完全交给 React 去做。<br>也正是 流程的控制权交给了 React，所以 React 才能协调多个 setState 调用的关系。</p>
<h3 id="4-手动避免setState的不当调用带来的性能问题"><a href="#4-手动避免setState的不当调用带来的性能问题" class="headerlink" title="4. 手动避免setState的不当调用带来的性能问题"></a>4. 手动避免 setState 的不当调用带来的性能问题</h3><p>到这里基本上就清楚了 setState 执行机制，那么 我们应该怎样儿利用自己的知识手动优化页面性能呢</p>
<p>这里列举了几条</p>
<ul>
<li>除了特殊需求 尽量不要在非合成事件中调用 <code>setState</code> 这样儿会失控 变成真的同步更新了 每次更新都会走 render 走 render 就不可避免的涉及到 <code>diff对比</code>.. 更新过程很频繁，也就会导致性能问题。</li>
<li>不要在 <code>shouldComponentUpdate</code> 和 <code>componentWillUpdate</code> 中调用 setState 会造成循环<br><img src="/images/setState/xunhuan.jpg" alt="xunhuan"></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>setState 不会立刻改变 React 组件中 state 的值；</li>
<li>setState 通过引发一次组件的更新过程来引发重新绘制；</li>
<li>多次 setState 函数调用产生的效果会合并。</li>
<li>setState 只在合成事件和钩子函数中是 “异步” 的，在原生事件和 setTimeout 中都是同步的，批量更新的策略是基于” 异步” 之上的，在 setTimeout 和原生事件中是没有的，因为此时时不受控的</li>
<li> setState 的 “异步” 并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形成了所谓的 “异步”，但是如果需要，也有解决方案可以直接拿到最新的值</li>
<li> setState 的批量更新优化也是建立在 “异步”（合成事件、钩子函数）之上的，在原生事件和 setTimeout 中不会批量更新，在 “异步” 中如果对同一个值进行多次 setState，setState 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新。</li>
<li>像写受控组件那样儿去操作 setState</li>
</ul>
<p>参考文章：<a href="https://zhuanlan.zhihu.com/p/39512941">https://zhuanlan.zhihu.com/p/39512941</a><br>        <a href="https://zhuanlan.zhihu.com/p/25990883">https://zhuanlan.zhihu.com/p/25990883</a></p>
]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>setState</tag>
      </tags>
  </entry>
  <entry>
    <title>react 基本概念解析</title>
    <url>/2018/06/24/%E8%AF%BBreact%E5%AE%98%E7%BD%91/</url>
    <content><![CDATA[<p><a href="http://www.css88.com/react/docs/hello-world.html">读 react 官网</a></p>
<p>关于 react 你必须要知道的事情～</p>
<a id="more"></a>

<h2 id="react阻止默认事件"><a href="#react阻止默认事件" class="headerlink" title="react阻止默认事件"></a>react 阻止默认事件</h2><p>在 react 阻止默认行为 必须使用<br>  e.preventDefault();</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">function handleClick(e) {</span><br><span class="line">  e.preventDefault();</span><br><span class="line">  console.log('The link was clicked.');</span><br><span class="line">}</span><br><span class="line">这里， e 是一个合成的事件。 React 根据 W3C 规范 定义了这个合成事件，所以你不需要担心跨浏览器的兼容性问题。查看 SyntheticEvent 参考指南了解更多。</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>在 JSX 回调中你必须注意 this 的指向。 在 JavaScript 中，类方法默认没有 绑定 的。如果你忘记绑定 this.handleClick 并将其传递给 onClick，那么在直接调用该函数时，this 会是 undefined 。</p>
<p>这不是 React 特有的行为；这是 JavaScript 中的函数如何工作的一部分。 一般情况下，如果你引用一个后面没跟 () 的方法，例如 onClick={this.handleClick} ，那你就应该 绑定 (bind) 该方法。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">class Toggle extends React.Component {</span><br><span class="line">  constructor(props) {</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = {isToggleOn: true};</span><br><span class="line"></span><br><span class="line">    // 这个绑定是必要的，使`this`在回调中起作用</span><br><span class="line">    this.handleClick = this.handleClick.bind(this);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  handleClick() {</span><br><span class="line">    this.setState(prevState =&gt; ({</span><br><span class="line">      isToggleOn: !prevState.isToggleOn</span><br><span class="line">    }));</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  render() {</span><br><span class="line">    return (</span><br><span class="line">      &lt;button onClick={this.handleClick}&gt;</span><br><span class="line">        {this.state.isToggleOn ? 'ON' : 'OFF'}</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Toggle /&gt;,</span><br><span class="line">  document.getElementById('root')</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>
<p>解决方式</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">class LoggingButton extends React.Component {</span><br><span class="line">  // 这个语法确保 `this` 绑定在 handleClick 中。</span><br><span class="line">  // 警告：这是 *实验性的* 语法。</span><br><span class="line">  handleClick = () =&gt; {</span><br><span class="line">    console.log('this is:', this);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  render() {</span><br><span class="line">    return (</span><br><span class="line">      &lt;button onClick={this.handleClick}&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">class LoggingButton extends React.Component {</span><br><span class="line">  handleClick() {</span><br><span class="line">    console.log('this is:', this);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  render() {</span><br><span class="line">    // 这个语法确保 `this` 被绑定在 handleClick 中</span><br><span class="line">    return (</span><br><span class="line">      &lt;button onClick={(e) =&gt; this.handleClick(e)}&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line">这样不好  问题是</span><br><span class="line">这个语法的问题是，每次 LoggingButton 渲染时都创建一个不同的回调。在多数情况下，没什么问题。然而，如果这个回调被作为 prop(属性) 传递给下级组件，这些组件可能需要额外的重复渲染。我们通常建议在构造函数中进行绑定，以避免这类性能问题。</span><br></pre></td></tr></tbody></table></figure>

<p>如果需要参数传递给事件处理程序</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;button onClick={(e) =&gt; this.deleteRow(id, e)}&gt;Delete Row&lt;/button&gt;</span><br><span class="line">&lt;button onClick={this.deleteRow.bind(this, id)}&gt;Delete Row&lt;/button&gt;</span><br></pre></td></tr></tbody></table></figure>


<p>使用逻辑 &amp;&amp; 操作符的内联 if 用法 来进行条件渲染</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">function Mailbox(props) {</span><br><span class="line">  const unreadMessages = props.unreadMessages;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello!&lt;/h1&gt;</span><br><span class="line">      {unreadMessages.length &gt; 8 ?</span><br><span class="line">        &lt;h2&gt;</span><br><span class="line">          You have {unreadMessages.length} unread messages.</span><br><span class="line">        &lt;/h2&gt;</span><br><span class="line">       : ''</span><br><span class="line">      }</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">const messages = ['React', 'Re: React', 'Re:Re: React'];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Mailbox unreadMessages={messages} /&gt;,</span><br><span class="line">  document.getElementById('root')</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">==</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function Mailbox(props) {</span><br><span class="line">  const unreadMessages = props.unreadMessages;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello!&lt;/h1&gt;</span><br><span class="line">      {unreadMessages.length &gt; 8 &amp;&amp;</span><br><span class="line">        &lt;h2&gt;</span><br><span class="line">          You have {unreadMessages.length} unread messages.</span><br><span class="line">        &lt;/h2&gt;</span><br><span class="line">       </span><br><span class="line">      }</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">const messages = ['React', 'Re: React', 'Re:Re: React'];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Mailbox unreadMessages={messages} /&gt;,</span><br><span class="line">  document.getElementById('root')</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">条件渲染的一种简便写法（类似于三目运算符）</span><br><span class="line"></span><br><span class="line">它可以正常运行，因为在 JavaScript 中， true &amp;&amp; expression 总是会评估为 expression ，而 false &amp;&amp; expression 总是执行为 false 。</span><br><span class="line"></span><br><span class="line">因此，如果条件为 true ，则 &amp;&amp; 后面的元素将显示在输出中。 如果是 false，React 将会忽略并跳过它。</span><br><span class="line"></span><br><span class="line">最low的一种方式也是借助于元素变量</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    let button = null;</span><br><span class="line">    if (isLoggedIn) {</span><br><span class="line">      button = &lt;LogoutButton onClick={this.handleLogoutClick} /&gt;;</span><br><span class="line">    } else {</span><br><span class="line">      button = &lt;LoginButton onClick={this.handleLoginClick} /&gt;;</span><br><span class="line">    }</span><br><span class="line">    这可以帮助您有条件地渲染组件的一部分，而输出的其余部分不会更改。</span><br></pre></td></tr></tbody></table></figure>

<p>使用条件操作符的内联 if-else<br>另一个用于条件渲染元素的内联方法是使用 JavaScript 的条件操作符 condition ? true : false 。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">render() {</span><br><span class="line">  const isLoggedIn = this.state.isLoggedIn;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      The user is &lt;b&gt;{isLoggedIn ? 'currently' : 'not'}&lt;/b&gt; logged in.</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="防止组件渲染-返回null"><a href="#防止组件渲染-返回null" class="headerlink" title="防止组件渲染 返回null"></a>防止组件渲染 返回 null</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">function WarningBanner(props) {</span><br><span class="line">  if (!props.warn) {</span><br><span class="line">    return null;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div className="warning"&gt;</span><br><span class="line">      Warning!</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"> render() {</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;WarningBanner warn={this.state.showWarning} /&gt;</span><br><span class="line">        &lt;button onClick={this.handleToggleClick}&gt;</span><br><span class="line">          {this.state.showWarning ? 'Hide' : 'Show'}</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="react和key"><a href="#react和key" class="headerlink" title="react和key"></a>react 和 key</h2><p>键（key）<br>键 (Keys) 帮助 React 标识哪个项被修改、添加或者移除了。数组中的每一个元素都应该有一个唯一不变的键 (Keys) 来标识：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const numbers = [1, 2, 3, 4, 5];</span><br><span class="line">const listItems = numbers.map((number) =&gt;</span><br><span class="line">  &lt;li key={number.toString()}&gt;</span><br><span class="line">    {number}</span><br><span class="line">  &lt;/li&gt;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="如何指定key？"><a href="#如何指定key？" class="headerlink" title="如何指定key？"></a>如何指定 key？</h3><p>如果你提取 一个 ListItem 组件，应该把 key 放置在数组处理的 <listitem> 元素中，不能放在 ListItem 组件自身中的 </listitem></p><li> 根元素上。<p></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">function ListItem(props) {</span><br><span class="line">  // 正确！这里不需要指定 key ：</span><br><span class="line">  return &lt;li&gt;{props.value}&lt;/li&gt;;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">function NumberList(props) {</span><br><span class="line">  const numbers = props.numbers;</span><br><span class="line">  const listItems = numbers.map((number) =&gt;</span><br><span class="line">    // 正确！key 应该在这里被指定</span><br><span class="line">    &lt;ListItem key={number.toString()}</span><br><span class="line">              value={number} /&gt;</span><br><span class="line"></span><br><span class="line">  );</span><br><span class="line">  return (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      {listItems}</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">const numbers = [1, 2, 3, 4, 5];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;NumberList numbers={numbers} /&gt;,</span><br><span class="line">  document.getElementById('root')</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">一个好的经验准则是元素中调用 map() 需要 keys 。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="组合-继承"><a href="#组合-继承" class="headerlink" title="组合 继承"></a>组合 继承</h2><p>react 拥有一个强大的组合模型 建议使用组合而不是继承以实现代码的重用</p>
<p>包含  如果你不确定要使用什么组件 在 弹层等通用的容器中比较常见<br>建议这种组件使用特别的 children props 来直接传递</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">function FancyBorder(props) {</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className={'FancyBorder FancyBorder-' + props.color}&gt;</span><br><span class="line">      {props.children}</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">function WelcomeDialog() {</span><br><span class="line">  return (</span><br><span class="line">    &lt;FancyBorder color="blue"&gt;</span><br><span class="line">      &lt;h1 className="Dialog-title"&gt;</span><br><span class="line">        Welcome</span><br><span class="line">      &lt;/h1&gt;</span><br><span class="line">      &lt;p className="Dialog-message"&gt;</span><br><span class="line">        Thank you for visiting our spacecraft!</span><br><span class="line">      &lt;/p&gt;</span><br><span class="line">    &lt;/FancyBorder&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">function Dialog(props) {</span><br><span class="line">  return (</span><br><span class="line">    &lt;FancyBorder color="blue"&gt;</span><br><span class="line">      &lt;h1 className="Dialog-title"&gt;</span><br><span class="line">        {props.title}</span><br><span class="line">      &lt;/h1&gt;</span><br><span class="line">      &lt;p className="Dialog-message"&gt;</span><br><span class="line">        {props.message}</span><br><span class="line">      &lt;/p&gt;</span><br><span class="line">      {props.children}</span><br><span class="line">    &lt;/FancyBorder&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class SignUpDialog extends React.Component {</span><br><span class="line">  constructor(props) {</span><br><span class="line">    super(props);</span><br><span class="line">    this.handleChange = this.handleChange.bind(this);</span><br><span class="line">    this.handleSignUp = this.handleSignUp.bind(this);</span><br><span class="line">    this.state = {login: ''};</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  render() {</span><br><span class="line">    return (</span><br><span class="line">      &lt;Dialog title="Mars Exploration Program"</span><br><span class="line">              message="How should we refer to you?"&gt;</span><br><span class="line">        &lt;input value={this.state.login}</span><br><span class="line">               onChange={this.handleChange} /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;button onClick={this.handleSignUp}&gt;</span><br><span class="line">          Sign Me Up!</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      &lt;/Dialog&gt;</span><br><span class="line">    );</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  handleChange(e) {</span><br><span class="line">    this.setState({login: e.target.value});</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  handleSignUp() {</span><br><span class="line">    alert(`Welcome aboard, ${this.state.login}!`);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="自定义组件写法"><a href="#自定义组件写法" class="headerlink" title="自定义组件写法"></a>自定义组件写法</h2><p>用户自定义的组件必须以大写字母开头</p>
<p>但一个元素类型以小写字母开头 他表示引用一个类似于</p><div>或者<span>的内置组件<br>以大写字母开头的类型，类似于 <foo>，会被编译成 React.createElement (Foo) ，对应于自定义组件 或者在 JavaScript 文件中导入的组件。<p></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">import React from 'react';</span><br><span class="line"></span><br><span class="line">// 错误！这是一个组件，首字母应该大写：</span><br><span class="line">function hello(props) {</span><br><span class="line">  // 正确！这种使用 &lt;div&gt; 是合法的，因为 div 是一个有效的HTML标记：</span><br><span class="line">  return &lt;div&gt;Hello {props.toWhat}&lt;/div&gt;;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">function HelloWorld() {</span><br><span class="line">  // 错误！React 认为 &lt;hello /&gt; 是一个 HTML 标签，因为它首字母应不是大写的：</span><br><span class="line">  return &lt;hello toWhat="World" /&gt;;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>字符串字面量</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;MyComponent message="hello world" /&gt;</span><br><span class="line">====</span><br><span class="line">&lt;MyComponent message={'hello world'} /&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>props (属性) 默认为 true</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;MyTextBox autocomplete /&gt;</span><br><span class="line">===</span><br><span class="line">&lt;MyTextBox autocomplete={true} /&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>jsx 中的 children</p>
<p>字符串变量</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;MyComponent&gt;Hello world!&lt;/MyComponent&gt;</span><br><span class="line">这是有效的 JSX ，MyComponent 组件中的 props.children 值为字符串 "Hello world!" 。</span><br></pre></td></tr></tbody></table></figure>
<p>JSX 会删除每行开头和结尾的空格，并且也会删除空行。邻接标签的空行也会被移除，字符串之间的空格会被压缩成一个空格，因此下面的渲染效果都是相同的</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;div&gt;Hello World&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line">  Hello World</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line">  Hello</span><br><span class="line">  World</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line"></span><br><span class="line">  Hello World</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>Booleans, Null, 和 Undefined 被忽略<br>false，null，undefined，和 true 都是有效的的 children (子元素) 。但是并不会被渲染，下面的 JSX 表达式渲染效果是相同的：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;div /&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;{false}&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;{null}&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;{undefined}&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;{true}&lt;/div&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>在有条件渲染的时候非常有用 如果 showheader 为 true 的时候 </p><header>会被渲染（必须保证 &amp;&amp; 表达式之前总是布尔值）<p></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  {showHeader &amp;&amp; &lt;Header /&gt;}</span><br><span class="line">  &lt;Content /&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>如果在输出中想要渲染 false true null 或者 undefined 必须先将其转化为字符串</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  My JavaScript variable is {String(myVariable)}.</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>使用 propType 进行类型检查<br>可以通过赋值特定的 default 属性为 pros 定义默认值</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">class Greeting extends React.Component {</span><br><span class="line">  render() {</span><br><span class="line">    return (</span><br><span class="line">      &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;</span><br><span class="line">    );</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 指定 props 的默认值：</span><br><span class="line">Greeting.defaultProps = {</span><br><span class="line">  name: 'Stranger'</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">// 渲染为 "Hello, Stranger":</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Greeting /&gt;,</span><br><span class="line">  document.getElementById('example')</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line"> class Greeting extends React.Component {</span><br><span class="line">  static defaultProps = {</span><br><span class="line">    name: 'stranger'</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  render() {</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;Hello, {this.props.name}&lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">propTypes 的类型检测是在defaultProps 解析之后发生的，因此也会对默认属性 defaultProps 进行类型检测。</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="ES6-声明class组件"><a href="#ES6-声明class组件" class="headerlink" title="ES6 声明class组件"></a>ES6 声明 class 组件</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">class Greeting extends React.Component {</span><br><span class="line">  // ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Greeting.defaultProps = {</span><br><span class="line">  name: 'Mary'</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h3 id="设置初始化组件"><a href="#设置初始化组件" class="headerlink" title="设置初始化组件"></a>设置初始化组件</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">class Counter extends React.Component {</span><br><span class="line">  constructor(props) {</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = {count: props.initialCount};</span><br><span class="line">  }</span><br><span class="line">  // ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<h2 id="一致性比较（diff算法的实现）"><a href="#一致性比较（diff算法的实现）" class="headerlink" title="一致性比较（diff算法的实现）"></a>一致性比较（diff 算法的实现）</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">使用react的时候 任何一个单点时刻可以认为 render（）函数的作用是创建react元素树</span><br><span class="line">在下一个state或者props更新的时候 render（）函数将会返回一个不同的react元素树</span><br><span class="line">接下来 react将会找出如何高效的更新ui来匹配最近时刻的react元素树</span><br></pre></td></tr></tbody></table></figure>
<p>react 基于以下两个假设实现了时间复杂度为 o（n）的算法</p>
<ul>
<li>不同类型的两个元素将会产生不同的树。</li>
<li>开发人员可以使用一个 key prop 来指示在不同的渲染中那个那些元素可以保持稳定</li>
</ul>
<h3 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff 算法</h3><p>当比较不同的树 react 会首先比较两个根元素 根据根的类型不同 它有不同的行为</p>
<h4 id="元素类型不相同时"><a href="#元素类型不相同时" class="headerlink" title="元素类型不相同时"></a>元素类型不相同时</h4><p>无论什么时候 当根元素类型不同时，react 将会销毁原先的树并重写构建新的树<br>当销毁原先的树时 之前的 dom 节点将销毁，实例组件执行 componentWillUnmount () 。当构建一个新的树 新的 dom 节点将会插入 dom 中 组件将会执行 componentWillMount () 以及 componentDidMount () 。与之前旧的树相关的 state 都会丢失。</p>
<h4 id="dom元素类型相同时"><a href="#dom元素类型相同时" class="headerlink" title="dom元素类型相同时"></a>dom 元素类型相同时</h4><p>当元素类型相同 react 会比较检查它们的属性（attributes）保留相同的底层 dom 节点 只更新发生改变的属性</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;div className="before" title="stuff" /&gt;</span><br><span class="line"></span><br><span class="line">&lt;div className="after" title="stuff" /&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>通过比较两个元素，React 会仅修改底层 DOM 节点的 className 属性。<br>在处理完当前 DOM 节点后，React 会递归处理子节点。</p>
<h4 id="相同类型的组件"><a href="#相同类型的组件" class="headerlink" title="相同类型的组件"></a>相同类型的组件</h4><p>当一个组件更新的时候 组件实例保持不变 以便在渲染中保持 state react 会更新组件实例的属性来匹配新的元素 并在组件实例中调用 componentWillReceiveProps () 和 componentWillUpdate ()。接下来， render () 方法会被调用并且 diff 算法对上一次的结果和新的结果进行递归。</p>
<h4 id="子元素递归"><a href="#子元素递归" class="headerlink" title="子元素递归"></a>子元素递归</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;first&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;second&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;first&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;second&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;third&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">React 会比较两个 &lt;li&gt;first&lt;/li&gt; 树与两个 &lt;li&gt;second&lt;/li&gt; 树，然后插入 &lt;li&gt;third&lt;/li&gt; 树。</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;Duke&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;Villanova&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;Connecticut&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;Duke&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;Villanova&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">React 将会改变每一个子节点而没有意识到需要保留 &lt;li&gt;Duke&lt;/li&gt; 和 &lt;li&gt;Villanova&lt;/li&gt; 两个子树。这种低效是一个问题。</span><br></pre></td></tr></tbody></table></figure>
<p>怎么解决类似的问题<br>为了解决这个问题 react 支持一个 key 属性 当子节点有了 key react 使用这个 key 去比较原来的树的子节点和之后的子节点 </p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li key="2015"&gt;Duke&lt;/li&gt;</span><br><span class="line">  &lt;li key="2016"&gt;Villanova&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li key="2014"&gt;Connecticut&lt;/li&gt;</span><br><span class="line">  &lt;li key="2015"&gt;Duke&lt;/li&gt;</span><br><span class="line">  &lt;li key="2016"&gt;Villanova&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">现在 react知道2014的key元素是新的 key为2015和2016的两个元素仅仅只是被移动而已</span><br></pre></td></tr></tbody></table></figure>

<h2 id="片段"><a href="#片段" class="headerlink" title="片段"></a>片段</h2><p>解决痛点</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">class Table extends React.Component {</span><br><span class="line">  render() {</span><br><span class="line">    return (</span><br><span class="line">      &lt;table&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">          &lt;Columns /&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">      &lt;/table&gt;</span><br><span class="line">    );</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">为了渲染有效的 HTML ， &lt;Columns /&gt; 需要返回多个 &lt;td&gt; 元素。如果 &lt;Columns /&gt; 的 render() 函数里面使用一个父级 div ，那么最终生成的 HTML 将是无效的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Columns extends React.Component {</span><br><span class="line">  render() {</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;td&gt;Hello&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;World&lt;/td&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">最后会渲染成</span><br><span class="line">&lt;table&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;td&gt;Hello&lt;/td&gt;</span><br><span class="line">      &lt;td&gt;World&lt;/td&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">使用方式</span><br><span class="line">class Columns extends React.Component {</span><br><span class="line">  render() {</span><br><span class="line">    return (</span><br><span class="line">      &lt;React.Fragment&gt;</span><br><span class="line">        &lt;td&gt;Hello&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;World&lt;/td&gt;</span><br><span class="line">      &lt;/React.Fragment&gt;</span><br><span class="line">    );</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line">新的声明方式（看起来像空标签）</span><br><span class="line">class Columns extends React.Component {</span><br><span class="line">  render() {</span><br><span class="line">    return (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;td&gt;Hello&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;World&lt;/td&gt;</span><br><span class="line">      &lt;/&gt;</span><br><span class="line">    );</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">带key的片段</span><br><span class="line"></span><br><span class="line">function Glossary(props) {</span><br><span class="line">  return (</span><br><span class="line">    &lt;dl&gt;</span><br><span class="line">      {props.items.map(item =&gt; (</span><br><span class="line">        // 没有`key`，将会触发一个key警告</span><br><span class="line">        &lt;React.Fragment key={item.id}&gt;</span><br><span class="line">          &lt;dt&gt;{item.term}&lt;/dt&gt;</span><br><span class="line">          &lt;dd&gt;{item.description}&lt;/dd&gt;</span><br><span class="line">        &lt;/React.Fragment&gt;</span><br><span class="line">      ))}</span><br><span class="line">    &lt;/dl&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line">key 是唯一可以传递给 Fragment 的属性。在将来，我们可能增加额外的属性支持，比如事件处理。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><p>Portals 提供了一种很好的方法，将子节点渲染到父组件 DOM 层次结构之外的 DOM 节点。</p>
<p><code>ReactDOM.createPortal(child, container)</code></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">第一个参数（child）是任何可渲染的 React 子元素，例如一个元素，字符串或 片段(fragment)。</span><br><span class="line">第二个参数（container）则是一个 DOM 元素。</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">render() {</span><br><span class="line">  // React 装载一个新的 div，并将 children 渲染到这个 div 中</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      {this.props.children}</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line">然而，有时候将子元素插入到 DOM 节点的其他位置会有用的：</span><br><span class="line"></span><br><span class="line">render() {</span><br><span class="line">  // React *不* 会创建一个新的 div。 它把 children 渲染到 `domNode` 中。</span><br><span class="line">  // `domNode` 可以是任何有效的 DOM 节点，不管它在 DOM 中的位置。</span><br><span class="line">  return ReactDOM.createPortal(</span><br><span class="line">    this.props.children,</span><br><span class="line">    domNode,</span><br><span class="line">  );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="错误边界"><a href="#错误边界" class="headerlink" title="错误边界"></a>错误边界</h3><p>部分 UI 中的 JavaScript 错误不应该破坏整个应用程序，错误边界是 React 组件，它可以在子组件树的任何位置捕获 JavaScript 错误，记录这些错误，并显示一个备用 UI ** ，而不是使整个组件树崩溃。错误边界 (Error Boundaries) 在渲染，生命周期方法以及整个组件树下的构造函数中捕获错误。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">class ErrorBoundary extends React.Component {</span><br><span class="line">  constructor(props) {</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = { hasError: false };</span><br><span class="line">  }</span><br><span class="line"> 有这个生命周期方法 证明是错误边界方式</span><br><span class="line">  componentDidCatch(error, info) {</span><br><span class="line">    // Display fallback UI</span><br><span class="line">    this.setState({ hasError: true });</span><br><span class="line">    // You can also log the error to an error reporting service</span><br><span class="line">    logErrorToMyService(error, info);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  render() {</span><br><span class="line">    if (this.state.hasError) {</span><br><span class="line">      // You can render any custom fallback UI</span><br><span class="line">      return &lt;h1&gt;Something went wrong.&lt;/h1&gt;;</span><br><span class="line">    }</span><br><span class="line">    return this.props.children;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line">调用</span><br><span class="line">&lt;ErrorBoundary&gt;</span><br><span class="line">  &lt;MyWidget /&gt;</span><br><span class="line">&lt;/ErrorBoundary&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>注意错误边界 (Error Boundaries) 仅可以捕获其子组件的错误。错误边界无法捕获其自身的错误。如果一个错误边界无法渲染错误信息，则错误会向上冒泡至最接近的错误边界。这也类似于 JavaScript 中 catch {} 的工作机制</p>
<p><a href="https://codepen.io/anon/pen/VdyBrE?editors=0010">https://codepen.io/anon/pen/VdyBrE?editors=0010</a></p>
<h3 id="未捕获错误的新行为"><a href="#未捕获错误的新行为" class="headerlink" title="未捕获错误的新行为"></a>未捕获错误的新行为</h3><p>这一改变有非常重要的意义。自 React 16 开始，任何未被错误边界捕获的错误将会卸载整个 React 组件树。</p>
<p>时间处理器如何处理<br>错误边界无法捕获事件处理器内部的错误。</p>
<p>因为时间处理器不会在渲染周期内触发<br>因此若他们抛出异常 react 仍然能够知道需要在屏幕中显示什么<br>如果你需要在事件处理器内部捕获错误，使用普通的 JavaScript try /catch 语句：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">class MyComponent extends React.Component {</span><br><span class="line">  constructor(props) {</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = { error: null };</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  handleClick = () =&gt; {</span><br><span class="line">    try {</span><br><span class="line">      // Do something that could throw</span><br><span class="line">    } catch (error) {</span><br><span class="line">      this.setState({ error });</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  render() {</span><br><span class="line">    if (this.state.error) {</span><br><span class="line">      return &lt;h1&gt;Caught an error.&lt;/h1&gt;</span><br><span class="line">    }</span><br><span class="line">    return &lt;div onClick={this.handleClick}&gt;Click Me&lt;/div&gt;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<p>代码拆分</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">import { add } from './math';</span><br><span class="line"></span><br><span class="line">console.log(add(16, 26));</span><br></pre></td></tr></tbody></table></figure>
<p>以后</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">import("./math").then(math =&gt; {</span><br><span class="line">  console.log(math.add(16, 26));</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>
<p>当 Webpack 遇到这个语法时，它会自动启动 代码拆分 来拆分你的应用程序。</p>
<p>react component</p>
<h3 id="Mounting-装载"><a href="#Mounting-装载" class="headerlink" title="Mounting(装载)"></a>Mounting (装载)</h3><p> 当组件实例被创建并且将其插入 dom 时 z 和谐方法将会被调用</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">constructor()</span><br><span class="line">componentWillMount()</span><br><span class="line">render()</span><br><span class="line">componentDidMount()</span><br></pre></td></tr></tbody></table></figure>
<h3 id="Updating-更新"><a href="#Updating-更新" class="headerlink" title="Updating(更新)"></a>Updating (更新)</h3><p>改变 props 或者 state 可以触发更新事件，在重新渲染组件时将会调用</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">componentWillReceiveProps()</span><br><span class="line">shouldComponentUpdate()</span><br><span class="line">componentWillUpdate()</span><br><span class="line">render()</span><br><span class="line">componentDidUpdate()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h3 id="Unmounting-卸载"><a href="#Unmounting-卸载" class="headerlink" title="Unmounting(卸载)"></a>Unmounting (卸载)</h3><p>当一个组件从 Dom 中删除时 将会调用</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">componentWillUnmount()</span><br></pre></td></tr></tbody></table></figure>
<h3 id="render-方法"><a href="#render-方法" class="headerlink" title="render() 方法"></a>render () 方法</h3><p>render () 函数应该是纯函数，这意味着它不会修改组件状态，每次调用它时返回相同的结果 如果 shouldComponentUpdate () 方法返回 false ，render () 不会被调用。</p>
<p>当被调用时，它会检查 this.props 和 this.state 并返回其中一个类型</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">react元素</span><br><span class="line">字符串和数字</span><br><span class="line">Portals  ReactDOM.createPortal 创建。</span><br><span class="line">null:不渲染任何东西</span><br><span class="line">布尔值:不渲染任何东西 （通常存在于 return test &amp;&amp; &lt;Child /&gt;写法，其中 test 是布尔值。）</span><br></pre></td></tr></tbody></table></figure>
<p>你可以返回 null 或 false 来表示你不想要渲染任何东西 当返回 null 或 false 时，ReactDOM.findDOMNode (this) 将返回 null<br>当你想返回多个元素时 用数组操作</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">render() {</span><br><span class="line">  return [</span><br><span class="line">    &lt;li key="A"&gt;First item&lt;/li&gt;,</span><br><span class="line">    &lt;li key="B"&gt;Second item&lt;/li&gt;,</span><br><span class="line">    &lt;li key="C"&gt;Third item&lt;/li&gt;,</span><br><span class="line">  ];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="constructor-方法"><a href="#constructor-方法" class="headerlink" title="constructor()方法"></a>constructor () 方法</h3><p>组件被装载前调用，当实现 <code>react.component</code> 时子类的 constructor (构造函数) 时 应该最先调用 <code>super(props)</code> 否则将找不到 this 报错</p>
<p>可以在构造函数中初始化 state 采用<br>this.state={} 的方式而不是使用 setState ()  构造函数也经常用于将事件处理程序绑定到类实例 (目前可以用箭头函数解决此类问题)<br>如果 state 需要根据 props 的值来初始化，就是你需要考虑变量提升的时候</p>
<p>如果你没有初始化 状态 (state) ，并且没有绑定方法，不用实现一个构造函数</p>
<h3 id="componentWillMount"><a href="#componentWillMount" class="headerlink" title="componentWillMount()"></a>componentWillMount()</h3><p>在组件装载之前立即被调用的方法 在 render 之前渲染 所以 不会触发 render<br>也是服务端渲染调用的唯一的生命周期的<br>钩子</p>
<h3 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount()"></a>componentDidMount()</h3><p>组件装载之后立即被调用<br>初始化需要的 dom 节点或从远程加载数据的地方<br>在这里调用 <code>setState()</code> 会触 render ()<br>但会在浏览器更新屏幕之前发生。在这种情况下，即使 render () 会被调用两次， 也可以保证用户不会看到中间状态</p>
<h3 id="componentWillReceiveProps"><a href="#componentWillReceiveProps" class="headerlink" title="componentWillReceiveProps()"></a>componentWillReceiveProps()</h3><p> 在已装载组件接收新 props 之前被调用，<br> 可以在此方法中比较 this.props 和 nextProps 并使用 this.setState () 执行状态转换。</p>
<h3 id="shouldComponentUpdate-nextProps-nextState"><a href="#shouldComponentUpdate-nextProps-nextState" class="headerlink" title="shouldComponentUpdate(nextProps, nextState)"></a>shouldComponentUpdate(nextProps, nextState)</h3><p>让 React 知道组件的输出是否不受 state 或 props 当前变化的影响，默认行为是在每次 state 更改时重新渲染，并且在绝大多数情况下，你应该依赖于默认行为。<br>当接收到新的 props 或 state 时，shouldComponentUpdate () 在渲染之前被调用。 默认返回 true ，对于初始 (第一次) 渲染，不调用此方法，返回 false 不会阻止子组件在 state 更改时重新渲染 但是<br><code>componentWillUpdate()</code> ，<code>render()</code> 和 <code>componentDidUpdate() </code>将不会被调用</p>
<h3 id="componentWillUpdate"><a href="#componentWillUpdate" class="headerlink" title="componentWillUpdate()"></a>componentWillUpdate()</h3><p>当接收到 state 或者 props，它会在渲染之前被调用</p>
<h3 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate()"></a>componentDidUpdate()</h3><p>在更新发生之立即被调用，当组件已经更新时，也可以在这里操作 dom 也可以做网络请求</p>
<h3 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount()"></a>componentWillUnmount()</h3><p>当组件被卸载和销毁之前 被调用 可以在此执行必要的清理 计时器 网络请求 或者在 didmount 创建的元素</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">componentDidMount() {</span><br><span class="line">  this.serverRequest = axios.get('/api')</span><br><span class="line">    .then(posts =&gt; {</span><br><span class="line">      this.setState({</span><br><span class="line">        posts</span><br><span class="line">    })</span><br><span class="line">  })</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">componentWillUnmount() {</span><br><span class="line">  this.serverRequest.abort()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="componentDidCatch"><a href="#componentDidCatch" class="headerlink" title="componentDidCatch()"></a>componentDidCatch()</h3><p>错误边界 可以在其_子组件树 _中的任何位置捕获 js 错误 显示备用 ui<br>错误边界在渲染过程中，在生命周期方法中，以及整个树下的构造函数中捕获错误。</p>
<h3 id="setState"><a href="#setState" class="headerlink" title="setState()"></a>setState()</h3><p>setState () 总是会导致重新渲染，除非 shouldComponentUpdate () 返回 false</p>
<p>setState 是作为一个请求而不是立即命令来更新组件 为了性能考虑 react 可能会批量 或 延迟到后面更新它 然后合并多个 setState () 更新多个组件<br>React 不保证 state 更新就立即应用 (重新渲染)。所以更新之后立即读取可能会有问题<br>你可以使用 componentDidUpdate 或者 setState 回调 <code>（setState(updater, callback)）</code></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">例如，假设我们想通过 props.step 在 state 中增加一个值：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">this.setState((prevState, props) =&gt; {</span><br><span class="line">  return {counter: prevState.counter + props.step};</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">setState(stateChange, [callback])</span><br><span class="line">这将执行 stateChange 的浅合并到新的 state </span><br><span class="line"></span><br><span class="line">这种也是异步的会进行批处理 如果同一时间段需要多次操作 可能会被覆盖</span><br><span class="line">Object.assign(</span><br><span class="line">  previousState,</span><br><span class="line">  {quantity: state.quantity + 1},</span><br><span class="line">  {quantity: state.quantity + 1},</span><br><span class="line">  ...</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">可以这么使用</span><br><span class="line">this.setState((prevState) =&gt; {</span><br><span class="line">  return {counter: prevState.quantity + 1};</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p>传递一个更新函数允许你在更新中访问当前的状态值。由于 setState 调用是批处理的，这允许你链式更新并确保它们建立在彼此之上，而不是产生冲突：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">incrementCount() {</span><br><span class="line">  this.setState((prevState) =&gt; {</span><br><span class="line">    return {count: prevState.count + 1}</span><br><span class="line">  });</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">handleSomething() {</span><br><span class="line">  // this.state.count 是 1，然后我们这样做：</span><br><span class="line">  this.incrementCount();</span><br><span class="line">  this.incrementCount(); // count 现在是 3</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="ReactDOMServer"><a href="#ReactDOMServer" class="headerlink" title="ReactDOMServer"></a>ReactDOMServer</h2><p>ReactDOMServer 对象允许您在服务器上渲染组件。</p>
<p>renderToString()<br>renderToStaticMarkup()</p>
<p>渲染流<br>renderToNodeStream()<br>renderToStaticNodeStream()</p>
<p>渲染流可以减小第一个字节 (TTFB) 渲染时间，在文档的下一个部分生成之前，将文档的开头向下发送到浏览器。所有主流浏览器都会在服务器以这种方式流出内容时开始解析和呈现文档。</p>
<h4 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h4><p>是阻止函数在给定时间内被多次调用</p>
<h4 id="Debounce（防抖）"><a href="#Debounce（防抖）" class="headerlink" title="Debounce（防抖）"></a>Debounce（防抖）</h4><p>防抖确保函数上次执行后的一段时间内，不会再次执行。</p>
<h4 id="操作css"><a href="#操作css" class="headerlink" title="操作css"></a>操作 css</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">render() {</span><br><span class="line">  let className = 'menu';</span><br><span class="line">  if (this.props.isActive) {</span><br><span class="line">    className += ' menu-active';</span><br><span class="line">  }</span><br><span class="line">  return &lt;span className={className}&gt;Menu&lt;/span&gt;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="Virtual-DOM-and-Internals"><a href="#Virtual-DOM-and-Internals" class="headerlink" title="Virtual DOM and Internals"></a>Virtual DOM and Internals</h3><h4 id="什么是虚拟dom"><a href="#什么是虚拟dom" class="headerlink" title="什么是虚拟dom"></a>什么是虚拟 dom</h4><p>虚拟 dom 是一种编程概念，是指虚拟的视图被保留在内存中 通过如 reactDom 这样的库与 “真实” 的 dom 保持同步<br>虚拟 DOM 是由 JavaScript 库在浏览器 API 之上实现的一种概念</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文为 react 概况，意在对 react 有个整理认知，其中的任意一条都值得深入研究，日后可能会针对某一个知识点单开文章～ </p>
</header></foo></span></div></li>]]></content>
      <tags>
        <tag>js</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>看完这篇，我奶奶都会设计组件了</title>
    <url>/2019/07/29/part/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://juejin.im/post/5d566e82f265da03f77e653c">掘金链接</a></p>
<p>组件化思想并不是前端独有的，但却是前端技术的延伸</p>
<p>随着三大框架崛起，前端组件化逐渐成为前端开发的迫切需求，一种主流，一种共识，它不仅提高开发效率，同时也降低了维组件内聚原则护成本<br>开发者们不需要再面对一堆晦涩难懂的代码，转而只需要关注以组件⽅式存在的代码⽚段</p>
<p>这是一场新的挑战！</p>
<h2 id="文章开始之前，明确本文的边界"><a href="#文章开始之前，明确本文的边界" class="headerlink" title="文章开始之前，明确本文的边界"></a>文章开始之前，明确本文的边界</h2><ul>
<li>从前端工程谈到组件化开发</li>
<li>组件的设计原则</li>
<li>组件的职能划分及利弊</li>
<li>组件设计的边界</li>
<li>落实到具体业务中如何做</li>
<li>一些感悟</li>
<li>总结</li>
</ul>
<h1 id="一个面试题引发的思考"><a href="#一个面试题引发的思考" class="headerlink" title="一个面试题引发的思考"></a>一个面试题引发的思考</h1><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">面试官通常会问 写过前端通用组件吗？</span><br></pre></td></tr></tbody></table></figure>

<a id="more"></a>

<p>你可能会自信的表示： sure！</p>
<p>emm.. 是的吗？</p>
<h1 id="从前端工程谈到组件化开发"><a href="#从前端工程谈到组件化开发" class="headerlink" title="从前端工程谈到组件化开发"></a>从前端工程谈到组件化开发</h1><p>前端工程经历的三个阶段</p>
<h2 id="1-库-框架选型"><a href="#1-库-框架选型" class="headerlink" title="1. 库/框架选型"></a>1. 库 / 框架选型</h2><p><img src="http://cdn.anruence.com/ku.png" alt="image"><br>确定技术选型，为项目节省许多工程量<br>后来三大框架的横空出世，解放了不少生产力</p>
<h2 id="2-简单构建优化"><a href="#2-简单构建优化" class="headerlink" title="2. 简单构建优化"></a>2. 简单构建优化</h2><p><img src="http://cdn.anruence.com/tools.png" alt="image"></p>
<p>解决完开发效率，还需要兼顾运行性能，<br>故而选择某种构建工具，对代码进行压缩，校验，之后再以页面为单位进行简单的资源合并</p>
<h2 id="3-JS-CSS模块化开发"><a href="#3-JS-CSS模块化开发" class="headerlink" title="3. JS/CSS模块化开发"></a>3. JS/CSS 模块化开发</h2><p><img src="http://cdn.anruence.com/jsmokuaihua.png" alt="image"></p>
<p>解决了基本开发效率和运行效率之后，开始考虑维护效率了</p>
<p>分而治之（以分解降低复杂度）是软件工程中的重要思想，是复杂系统开发和维护的基石，<font color="red">模块化就是前端的分治手段</font></p>
<p>因此，模块化强调的是<strong>拆分</strong>，最大的价值就是分治，意味着不管你将来是否要复用这块儿代码，都有将他们拆成一个模块的理由</p>
<blockquote>
<p>将一个大问题，不断的拆解为各个小问题进行分析研究，然后再组合到一起 (分而治之原则)</p>
</blockquote>
<h3 id="模块化的方案"><a href="#模块化的方案" class="headerlink" title="模块化的方案"></a>模块化的方案</h3><ul>
<li>JS 模块化 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">无模块化-&gt;函数写法-&gt;对象写法-&gt;自执行函数-&gt;CommonJS/AMD/CMD-&gt;ES6 Module</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>CSS 模块化 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">css模块化是在less，sass等预处理器的支持下实现的</span><br></pre></td></tr></tbody></table></figure>

<h3 id="做到这些就够了吗？"><a href="#做到这些就够了吗？" class="headerlink" title="做到这些就够了吗？"></a>做到这些就够了吗？</h3><p>当然是不够的</p>
<p>模块化强调的是<strong>拆分</strong>，无论是从业务角度还是从架构、技术角度，模块化首先意味着将代码、数据等内容按照其职责不同分离</p>
<p>单纯的横向拆分业务功能模块有一些问题<br><img src="http://cdn.anruence.com/2.png"></p>
<ul>
<li>面向过程的代码 随着业务的发展不利于维护 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">随着业务发展，”过程线“也会越来越长，其他项目成员根据各自需要，在”过程线“ 加插各自逻辑，最终这个页面的逻辑变得难以维护</span><br><span class="line">我们需要摆脱【一泻而下】式的代码编写</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>仅仅有 JS/CSS 模块化是不够的，UI（页面）的分治也比较迫切 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">除了JS和CSS，界面也需要拆分，如何让模块化思想融入HTML语言</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>


<h2 id="4-组件化开发（本文重点）"><a href="#4-组件化开发（本文重点）" class="headerlink" title="4. 组件化开发（本文重点）"></a><font color="red">4. 组件化开发（本文重点）</font></h2><h3 id="组件化开发的演变"><a href="#组件化开发的演变" class="headerlink" title="组件化开发的演变"></a>组件化开发的演变</h3><p>在大肆宣扬组件化开发概念之前，也经历了寻求组件化最佳实践的阶段</p>
<h4 id="页面结构模块化"><a href="#页面结构模块化" class="headerlink" title="页面结构模块化"></a>页面结构模块化</h4><p><img src="http://cdn.anruence.com/jimu" alt="image"><br>简单来说就是把页面想象成乐高机器人，需要不同零件组装，然后将各个部分拼到一起</p>
<p>落实到实际开发中像这样<br><img src="http://cdn.anruence.com/jiegouhua.png"></p>
<p>我们可以发现</p>
<ul>
<li>页面 pageModel 包含了 <code>tabContainer</code>，<code>listContainer</code> 和 <code>imgsContainer</code> 三个模块</li>
<li>我们根据不同的业务逻辑封装了不同类型的 model</li>
<li> 每个 model 有自己的数据，模板，逻辑，已经算是一个完整的功能单元</li>
</ul>
<p><font color="red">咦？嗅到一丝组件化的味道</font></p>
<h4 id="N年前微软的组件化的解决方案-HTML-Component"><a href="#N年前微软的组件化的解决方案-HTML-Component" class="headerlink" title="N年前微软的组件化的解决方案 HTML Component"></a>N 年前微软的组件化的解决方案 HTML Component</h4><p>历史总有遗🐖</p>
<p>早在 N 年前微软提出过一套解决方案，名为 <code>HTML Component</code></p>
<p><img src="http://cdn.anruence.com/4.jpg" alt="jsworke"></p>
<p>事实上已经是一个比较完整的组件化方案了，但最后却没能进入标准，从今天的角度看，它可以说是生不逢时</p>
<h4 id="WebComponents-标准"><a href="#WebComponents-标准" class="headerlink" title="WebComponents 标准"></a>WebComponents 标准</h4><p>当时” 所谓的组件 “</p>
<ul>
<li>此时的组件基本上只能达到某个功能单元上的集合，资源都是资源都是松散地分散在三种资源文件中</li>
<li>而且组件作用域暴露在全局作用域下，缺乏内聚性很容易就会跟其他组件产生冲突（如最简单的 css 命名冲突）</li>
</ul>
<p>于是 W3C 按耐不住了，制定一个 WebComponents 标准，为组件化的未来指引了明路</p>
<p>大致四部分功能</p>
<ul>
<li><code>&lt;template&gt;</code> 定义组件的 HTML 模板能力</li>
<li> Shadow Dom 封装组件的内部结构，并且保持其独立性</li>
<li> Custom Element 对外提供组件的标签，实现自定义标签</li>
<li> import 解决组件结合和依赖加载</li>
</ul>
<p>我们思考一下，可行的实践化方案需要具备哪些能力</p>
<ul>
<li>资源高内聚（组件资源内部高内聚，组件资源由自身加载控制）</li>
<li>作用域独立（内部结构密封，不与全局或其他组件产生影响）</li>
<li>自定义标签（定义组件的使用方式）</li>
<li>可相互组合（组件间组装整合）</li>
<li>接口规范化（组件接口有统一规范，或者是生命周期的管理）</li>
</ul>
<h4 id="三大框架出现"><a href="#三大框架出现" class="headerlink" title="三大框架出现"></a>三大框架出现</h4><p>今天的前端生态里面 React，Angular 和 Vue 三分天下，即使它们定位不同，但核心的共同点就是提供了组件化的能力，算是目前是比较好的组件化实践</p>
<h5 id="1-Vue-js采用了JSON的方法描述一个组件"><a href="#1-Vue-js采用了JSON的方法描述一个组件" class="headerlink" title="1. Vue.js采用了JSON的方法描述一个组件"></a>1. Vue.js 采用了 JSON 的方法描述一个组件</h5><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">import PageContainer from './layout/PageContainer'</span><br><span class="line">import PageFilter from './layout/PageFilter'</span><br><span class="line"></span><br><span class="line">export default {</span><br><span class="line">  install(Vue) {</span><br><span class="line">    Vue.component('PageContainer', PageContainer)</span><br><span class="line">    Vue.component('PageFilter', PageFilter)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>还提供了 SFC（Single File Component，单文件组件）‘.vue’文件格式</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">//...</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default {</span><br><span class="line">    data(){}</span><br><span class="line">  }</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang="scss"&gt;</span><br><span class="line">//...</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></tbody></table></figure>

<h5 id="2-React-js发明了JSX，把CSS和HTML都塞进JS文件里"><a href="#2-React-js发明了JSX，把CSS和HTML都塞进JS文件里" class="headerlink" title="2. React.js发明了JSX，把CSS和HTML都塞进JS文件里"></a>2. React.js 发明了 JSX，把 CSS 和 HTML 都塞进 JS 文件里</h5><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">class Tabs extends React.Component {</span><br><span class="line">    render() {</span><br><span class="line">        if (!this.props.items) {</span><br><span class="line">            console.error('Tabs中需要传入数据');</span><br><span class="line">            return null;</span><br><span class="line">        }</span><br><span class="line">        const propId = this.props.id;</span><br><span class="line">        return (</span><br><span class="line">            &lt;ul className={this.props.className}&gt;</span><br><span class="line">              &lt;li&gt;测试&lt;/li&gt;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">        );</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="Angular-js选择在原本的HTML上扩展"><a href="#Angular-js选择在原本的HTML上扩展" class="headerlink" title="Angular.js选择在原本的HTML上扩展"></a>Angular.js 选择在原本的 HTML 上扩展</h5><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;input type="text" ng-model="firstname"&gt;</span><br><span class="line"></span><br><span class="line">var app = angular.module('myApp', []);</span><br><span class="line">app.controller('formCtrl', function($scope) {</span><br><span class="line">    $scope.firstname = "John";</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<h3 id="标准下的资源整合"><a href="#标准下的资源整合" class="headerlink" title="标准下的资源整合"></a>标准下的资源整合</h3><p><img src="http://cdn.anruence.com/sss.png" alt="image"></p>
<h4 id="具有以下特点"><a href="#具有以下特点" class="headerlink" title="具有以下特点"></a>具有以下特点</h4><ul>
<li>每个组件对应一个目录，组件所需的各种资源都在这个目录下就近维护；（最具软件工程价值）</li>
<li>页面上的每个独立的可视 / 可交互区域视为一个组件；</li>
<li>由于组件具有独立性，可以自由组合；</li>
<li>页面是组件的容器，负责组合组件形成功能完整的界面；</li>
<li>当不需要某个组件，或者想要替换组件时，可以整个目录删除 / 替换</li>
</ul>
<h3 id="应用结构图"><a href="#应用结构图" class="headerlink" title="应用结构图"></a>应用结构图</h3><p><img src="http://cdn.anruence.com/niubi.png" alt="image"></p>
<ul>
<li>分子是由原子组成的，分子分成原子，原子也可以重新组合成新的分子</li>
<li>一个界面是由独立的分子组件搭建而成，分子组件由原子元件构成，这些原子可通过不同的组合方式，组成新分子组件，继而重组构成新的界面</li>
</ul>
<h3 id="模块化与组件化对比"><a href="#模块化与组件化对比" class="headerlink" title="模块化与组件化对比"></a>模块化与组件化对比</h3><p>如果你去网上搜【模块和组件的异同】<br>可能会得到截然不同的答案，大部分描述的都是片面的</p>
<p>它们之间的关系可以从以下三个方面分析：</p>
<h4 id="从整体概念来讲"><a href="#从整体概念来讲" class="headerlink" title="从整体概念来讲"></a>从整体概念来讲</h4><ul>
<li>模块化是一种分治的思想，诉求是解耦，一般指的是 js 模块，比如用来格式化时间的模块</li>
<li>组件化是模块化思想的实现手段，诉求是复用，包含了 <code>template</code>，<code>style</code>，<code>script</code>，script 又可以由各种模块组成</li>
</ul>
<h4 id="从复用的角度来讲"><a href="#从复用的角度来讲" class="headerlink" title="从复用的角度来讲"></a>从复用的角度来讲</h4><ul>
<li>模块一般是项目范围内按照项目业务内容来划分的，比如一个项目划分为子系统、模块、子模块，<strong>代码分开就是模块</strong></li>
<li>组件是按照一些小功能的通用性和可复用性抽象出来的，可以跨项目，是可复用的模块</li>
</ul>
<h4 id="从历史发展角度来讲"><a href="#从历史发展角度来讲" class="headerlink" title="从历史发展角度来讲"></a>从历史发展角度来讲</h4><p>随着前端开发越来越复杂、对效率要求越来高，由项目级模块化开发，进一步提升到通用功能组件化开发，<strong>模块化是组件化的前提，组件化是模块化的演进</strong></p>
<h1 id="组件的设计原则"><a href="#组件的设计原则" class="headerlink" title="组件的设计原则"></a>组件的设计原则</h1><p>组件化方案下，我们需要具有组件化设计思维，它是一种【整理术】帮助我们高效开发整合</p>
<ol>
<li>标准性 </li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">任何一个组件都应该遵守一套标准，可以使得不同区域的开发人员据此标准开发出一套标准统一的组件</span><br><span class="line"></span><br><span class="line">API尽量和已知概念保持一致</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li>独立性 </li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">遵循单一职责原则，保持组件的纯粹性</span><br><span class="line">属性配置等API对外开放，组件内部状态对外封闭，尽可能的少与业务耦合</span><br><span class="line"></span><br><span class="line">避免暴露组件内部实现</span><br><span class="line"></span><br><span class="line">入口处检查参数的有效性，出口处检查返回的正确性</span><br></pre></td></tr></tbody></table></figure>

<ol start="3">
<li>复用与易用，适用 SPOT 法则 </li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">UI差异，消化在组件内部（注意并不是写一堆if/else）</span><br><span class="line">输入输出友好，易用</span><br><span class="line"></span><br><span class="line">Single Point Of Truth，就是尽量不要重复代码，出自《The Art of Unix Programming》</span><br></pre></td></tr></tbody></table></figure>

<ol start="4">
<li>避免直接操作 DOM，避免使用 ref</li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">使用父组件的 state 控制子组件的状态而不是直接通过 ref 操作子组件</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<ol start="5">
<li><strong>无环依赖原则 (ADP)</strong></li>
</ol>
<p>设计不当导致环形依赖示意图<br><img src="http://cdn.anruence.com/1111111111.png" alt="image"></p>
<p><strong>影响</strong></p>
<ul>
<li>组件间耦合度高，集成测试难</li>
<li>一处修改，处处影响，交付周期长</li>
<li>因为组件之间存在循环依赖，变成了 “先有鸡还是先有蛋” 的问题</li>
</ul>
<p><strong>那倘若我们真的遇到了这种问题，就要考虑如何处理？</strong></p>
<p><font color="red">消除环形依赖</font></p>
<blockquote>
<p>我们的追求是沿着逆向的依赖关系即可寻找到所有受影响的组件</p>
</blockquote>
<p>创建一个共同依赖的新组件</p>
<p><img src="http://cdn.anruence.com/xiaochu.png" alt="image"></p>
<ol start="6">
<li>稳定抽象原则 (SAP)</li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">- 组件的抽象程度与其稳定程度成正比，</span><br><span class="line">- 一个稳定的组件应该是抽象的（逻辑无关的）</span><br><span class="line">- 一个不稳定的组件应该是具体的（逻辑相关的）</span><br><span class="line">- 为降低组件之间的耦合度，我们要针对抽象组件编程，而不是针对业务实现编程</span><br></pre></td></tr></tbody></table></figure>
<ol start="7">
<li>避免冗余状态 </li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">如果一个数据可以由另一个 state 变换得到，那么这个数据就不是一个 state，只需要写一个变换的处理函数，在 Vue 中可以使用计算属性</span><br><span class="line"></span><br><span class="line">如果一个数据是固定的，不会变化的常量，那么这个数据就如同 HTML 固定的站点标题一样，写死或作为全局配置属性等，不属于 state</span><br><span class="line"></span><br><span class="line">如果兄弟组件拥有相同的 state，那么这个state 应该放到更高的层级，使用 props 传递到两个组件中</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<ol start="8">
<li>合理的依赖关系 </li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">父组件不依赖子组件，删除某个子组件不会造成功能异常</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<ol start="9">
<li>扁平化参数 </li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">除了数据，避免复杂的对象，尽量只接收原始类型的值</span><br></pre></td></tr></tbody></table></figure>

<ol start="10">
<li>良好的接口设计 <figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">把组件内部可以完成的工作做到极致，虽然提倡拥抱变化，但接口不是越多越好</span><br><span class="line"></span><br><span class="line">如果常量变为 props 能应对更多的场景，那么就可以作为 props，原有的常量可作为默认值。</span><br><span class="line"></span><br><span class="line">如果需要为了某一调用者编写大量特定需求的代码，那么可以考虑通过扩展等方式构建一个新的组件。</span><br><span class="line"></span><br><span class="line">保证组件的属性和事件足够的给大多数的组件使用。</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

</li>
</ol>
<h1 id="组件的职能划分"><a href="#组件的职能划分" class="headerlink" title="组件的职能划分"></a>组件的职能划分</h1><p>那有了组件设计的 “API”，就一定能开发出高质量的组件吗？</p>
<blockquote>
<p>组件最大的不稳定性来自于展现层，一个组件只做一件事，基于功能做好职责划分</p>
</blockquote>
<p>根据以往经验，我将组件分为以下几类</p>
<ul>
<li>基础组件（通常在组件库里就解决了）</li>
<li>容器型组件（Container）</li>
<li>展示型组件（stateless）</li>
<li>业务组件</li>
<li>通用组件<ul>
<li> UI 组件</li>
<li>逻辑组件</li>
</ul>
</li>
<li>高阶组件（HOC）</li>
</ul>
<p><font color="red">除容器组件外，尽量保证组件都是 stateless 的，这并不冲突！</font></p>
<h2 id="基础组件"><a href="#基础组件" class="headerlink" title="基础组件"></a>基础组件</h2><p>为了让开发者更关注业务逻辑，涌现出了很多优秀的 UI 组件库<br>比如 <code>antd</code>，<code>element-ui</code>，我们只需要调用 API 便能满足大部分的业务场景，前端角色后置了，开发变得更简单了</p>
<h2 id="容器型组件"><a href="#容器型组件" class="headerlink" title="容器型组件"></a>容器型组件</h2><p>一个容器性质的组件，一般当作一个业务子模块的入口，比如一个路由指向的组件</p>
<p><img src="http://cdn.anruence.com/RONGQIZUJIAN.png" alt="image"></p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>容器组件内的子组件通常具有业务或数据依赖关系</li>
<li>集中 / 统一的状态管理，向其他展示型 / 容器型组件提供数据（充当数据源）和行为逻辑处理（接收回调）</li>
<li>如果使用了全局状态管理，那么容器内部的业务组件可以自行调用全局状态处理业务</li>
<li>业务模块内子组件的通信等统筹处理，充当子级组件通信的状态中转站</li>
<li>模版基本都是子级组件的集合，很少包含 <code>DOM</code> 标签</li>
<li>辅助代码分离</li>
</ul>
<h3 id="表现形式🌰（vue）"><a href="#表现形式🌰（vue）" class="headerlink" title="表现形式🌰（vue）"></a>表现形式🌰（vue）</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div class="purchase-box"&gt;</span><br><span class="line">  &lt;!-- 面包屑导航 --&gt;</span><br><span class="line">  &lt;bread-crumbs /&gt;</span><br><span class="line">  &lt;div class="scroll-content"&gt;</span><br><span class="line">    &lt;!-- 搜索区域 --&gt;</span><br><span class="line">    &lt;Search v-show="toggleFilter" :form="form"/&gt;</span><br><span class="line">    &lt;!--展开收起区域--&gt;</span><br><span class="line">    &lt;Toggle :toggleFilter="toggleFilter"/&gt;</span><br><span class="line">    &lt;!-- 列表区域--&gt;</span><br><span class="line">    &lt;List :data="listData"/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="展示型（stateless）组件"><a href="#展示型（stateless）组件" class="headerlink" title="展示型（stateless）组件"></a>展示型（stateless）组件</h2><p>主要表现为组件是怎样渲染的，就像一个简单的模版渲染过程</p>
<p><img src="http://cdn.anruence.com/zhanshixing.png" alt="image"></p>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul>
<li>只通过 props 接受数据和回调函数，不充当数据源</li>
<li>可能包含展示和容器组件 并且一般会有 Dom 标签和 css 样式</li>
<li>通常用 props.children (react) 或者 slot (vue) 来包含其他组件</li>
<li>对第三方没有依赖（对于一个应用级的组件来说可以有）</li>
<li>可以有状态，在其生命周期内可以操纵并改变其内部状态，职责单一，将不属于自己的行为通过回调传递出去，让父级去处理（搜索组件的搜索事件 / 表单的添加事件）</li>
</ul>
<h3 id="表现形式🌰（vue）-1"><a href="#表现形式🌰（vue）-1" class="headerlink" title="表现形式🌰（vue）"></a>表现形式🌰（vue）</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"> &lt;template&gt;</span><br><span class="line"> &lt;div class="purchase-box"&gt;</span><br><span class="line">    &lt;el-table</span><br><span class="line">      :data="data"</span><br><span class="line">      :class="{'is-empty': !data ||  data.length ==0 }"</span><br><span class="line">      &gt;</span><br><span class="line">      &lt;el-table-column</span><br><span class="line">        v-for = "(item, index) in listItemConfig"</span><br><span class="line">        :key="item + index" </span><br><span class="line">        :prop="item.prop" </span><br><span class="line">        :label="item.label" </span><br><span class="line">        :width="item.width ? item.width : ''"</span><br><span class="line">        :min-width="item.minWidth ? item.minWidth : ''"</span><br><span class="line">        :max-width="item.maxWidth ? item.maxWidth : ''"&gt;</span><br><span class="line">      &lt;/el-table-column&gt;</span><br><span class="line">      &lt;!-- 操作 --&gt;</span><br><span class="line">      &lt;el-table-column label="操作" align="right" width="60"&gt;</span><br><span class="line">        &lt;template slot-scope="scope"&gt;</span><br><span class="line">          &lt;slot :data="scope.row" name="listOption"&gt;&lt;/slot&gt;</span><br><span class="line">        &lt;/template&gt;</span><br><span class="line">      &lt;/el-table-column&gt;</span><br><span class="line">      &lt;!-- 列表为空 --&gt;</span><br><span class="line">      &lt;template slot="empty"&gt;</span><br><span class="line">        &lt;common-empty /&gt;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line">    &lt;/el-table&gt;</span><br><span class="line">    </span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default {</span><br><span class="line">    props: {</span><br><span class="line">        listItemConfig:{ //列表项配置</span><br><span class="line">        type:Array,</span><br><span class="line">        default: () =&gt; {</span><br><span class="line">            return [{</span><br><span class="line">                prop:'sku_name',</span><br><span class="line">                label:'商品名称',</span><br><span class="line">                minWidth:200</span><br><span class="line">            },{</span><br><span class="line">                prop:'sku_code',</span><br><span class="line">                label:'SKU',</span><br><span class="line">                minWidth:120</span><br><span class="line">            },{</span><br><span class="line">                prop:'product_barcode',</span><br><span class="line">                label:'条形码',</span><br><span class="line">                minWidth:120</span><br><span class="line">            }]</span><br><span class="line">      }</span><br><span class="line">    }}</span><br><span class="line">  }</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure>
<h2 id="业务组件"><a href="#业务组件" class="headerlink" title="业务组件"></a>业务组件</h2><p>通常是根据最小业务状态抽象而出，有些业务组件也具有一定的复用性，但大多数是一次性组件</p>
<p><img src="http://cdn.anruence.com/yewu.png" alt="image"></p>
<h2 id="通用组件"><a href="#通用组件" class="headerlink" title="通用组件"></a>通用组件</h2><p>可以在一个或多个 APP 内通用的组件</p>
<h3 id="UI组件"><a href="#UI组件" class="headerlink" title="UI组件"></a>UI 组件</h3><ul>
<li>界面扩展类组件，比如弹窗</li>
</ul>
<p><img src="http://cdn.anruence.com/UI.png" alt="image"></p>
<p>特点：复用性强，只通过 props、events 和 slots 等组件接口与外部通信</p>
<h4 id="表现形式🌰（vue）-2"><a href="#表现形式🌰（vue）-2" class="headerlink" title="表现形式🌰（vue）"></a>表现形式🌰（vue）</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class="empty"&gt;</span><br><span class="line">    &lt;img src="/images/empty.png" alt&gt;</span><br><span class="line">    &lt;p&gt;暂无数据&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="逻辑组件"><a href="#逻辑组件" class="headerlink" title="逻辑组件"></a>逻辑组件</h3><ul>
<li>不包含 UI 层的某个功能的逻辑集合</li>
</ul>
<h2 id="高阶组件（HOC）"><a href="#高阶组件（HOC）" class="headerlink" title="高阶组件（HOC）"></a>高阶组件（HOC）</h2><p>高阶组件可以看做是函数式编程中的组合<br>可以把高阶组件看做是一个函数，他接收一个组件作为参数，并返回一个功能增强的组件</p>
<p>高阶组件可以抽象组件公共功能的方法而不污染你本身的组件<br>比如 <code>debounce</code> 与 <code>throttle</code></p>
<p>用一张图来表示</p>
<p><img src="http://cdn.anruence.com/hoc.png" alt="jsworke"></p>
<p>React 中高阶组件是比较常用的组件封装形式，Vue 官方内置了一个高阶组件 <a href="https://github.com/vuejs/vue/blob/dev/src/core/components/keep-alive.js">keep-alive</a>，但并未推荐使用 HOC :(</p>
<p><strong>猜想原因</strong></p>
<ul>
<li>React：写组件就是在写函数，函数拥有的功能组件都有</li>
<li> Vue：更像是高度封装的函数，能够让你轻松的完成一些事情的同时损失一定的灵活性，你需要按照一定规则才能使系统更好的运行</li>
</ul>
<h3 id="表现形式🌰（react）"><a href="#表现形式🌰（react）" class="headerlink" title="表现形式🌰（react）"></a>表现形式🌰（react）</h3><p>品牌车系滑动的动画</p>
<p><img src="http://cdn.anruence.com/reacthoc.png"></p>
<h2 id="各类组件协同组成业务模块"><a href="#各类组件协同组成业务模块" class="headerlink" title="各类组件协同组成业务模块"></a>各类组件协同组成业务模块</h2><p><img src="http://cdn.anruence.com/MOKUAITU.png" alt="image"></p>
<h2 id="容器-展示组件"><a href="#容器-展示组件" class="headerlink" title="容器/展示组件"></a>容器 / 展示组件</h2><p>对比图</p>
<p><img src="http://cdn.anruence.com/rongqitu.png" alt="image"></p>
<h3 id="引入容器组件的概念只是一种更好的组织方式"><a href="#引入容器组件的概念只是一种更好的组织方式" class="headerlink" title="引入容器组件的概念只是一种更好的组织方式"></a>引入容器组件的概念只是一种更好的组织方式</h3><ul>
<li>各司其职，不易出错，即使出错，也能快速定位问题</li>
<li>容器组件，一个载体的存在</li>
<li>展示型组件不与 store 耦合，通过 props 接口来定义所需的数据和方法，<strong>复用性与正确性更能保证 </strong></li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">展示型组件直接和store通信的话，那么它就会收到限制，因为你在store里面的字段已经限制他的使用次数和使用的位置</span><br></pre></td></tr></tbody></table></figure>

<p><font color="red">既然如此，那我什么时候引入容器组件，什么时候引入展示组件</font></p>
<h3 id="引入容器组件的时机"><a href="#引入容器组件的时机" class="headerlink" title="引入容器组件的时机"></a>引入容器组件的时机</h3><p>优先考虑展示组件，当你意识到有一些中间组件不使用它继承的 props 而是转而传递给他们的子级，每次子级组件需要更多数据时，都需要 “路过” 这些中间组件时就要考虑引入容器组件！</p>
<p>两者的区别并没有被严格定义，<font color="red">事实上不在技术上而是目的性上</font></p>
<h4 id="这里有几个供参考的点"><a href="#这里有几个供参考的点" class="headerlink" title="这里有几个供参考的点"></a>这里有几个供参考的点</h4><ul>
<li>容器组件倾向于有状态，展示组件倾向于无状态，这不是硬性规定，它们都是可以有状态的</li>
<li>不要把分离容器组件和展示组件当做教条，如果你不确定该组件是容器组件还是展示组件，就暂时不要分离，写成展示组件，也许是为时尚早，别着急！</li>
<li>这是一个持续的重构过程，不用试图一次就把它做好，习惯这种模式就会培养起一种直觉，知道何时引入容器 就像你知道何时封装一个函数那样！</li>
</ul>
<h2 id="进行组件职能划分的利弊"><a href="#进行组件职能划分的利弊" class="headerlink" title="进行组件职能划分的利弊"></a>进行组件职能划分的利弊</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>更好的关注分离 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">用这种方式写组件，你可以更好的理解你的app和你的ui，甚至会逐渐形成你自己的开发套路</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>复用性高 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">一个组件只做一件事，解除了组件的耦合带来更高复用性</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>它是 app 的调色版，设计师可以随意调整它的 ui 而不用改变 app 的逻辑</li>
<li>这会强制你提取 “布局组件”，达到更高的易用性</li>
<li>提高健壮性 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">由于展示组件和容器组件是通过prop接口来连接，可以利用props的校验机制来增强代码的可靠性，混合的组件就没有这种好处</span><br><span class="line"></span><br><span class="line">举个🌰(Vue)</span><br><span class="line">  props: {</span><br><span class="line">    editData: Object,</span><br><span class="line">    statusConfig: {</span><br><span class="line">      type: Object,</span><br><span class="line">      default() {</span><br><span class="line">        return {</span><br><span class="line">          isShowOption: true, //是否有操作栏</span><br><span class="line">          isShowSaveBtn: false</span><br><span class="line">        };</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>可测试性 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">组件做的事情更少了，测试也会变得容易</span><br><span class="line">容器组件不用关心UI的展示，只关心数据和更新</span><br><span class="line">展示组件只是呈现传入的props，写单元测试的时候也非常容易mock数据层</span><br></pre></td></tr></tbody></table></figure>

<h3 id="所谓的缺点"><a href="#所谓的缺点" class="headerlink" title="所谓的缺点"></a>所谓的缺点</h3><ul>
<li>设计组件初期会增加一些学习成本</li>
<li>由于需要封装一个容器，包装一些数据和接口给展示组件，<strong>会增加一些工作量</strong></li>
<li>在展示组件内对 props 的声明会带来少量的工作</li>
</ul>
<p><font color="red">长远来看，利大于弊，特别是项目初期，一定要有一个好的设计习惯</font></p>
<h1 id="组件设计的边界"><a href="#组件设计的边界" class="headerlink" title="组件设计的边界"></a>组件设计的边界</h1><p>物极必反，跃跃欲试前，常常思考以下几个问题以引导完善组件的设计</p>
<h2 id="页面层级不宜嵌套超过三层，切勿过度设计"><a href="#页面层级不宜嵌套超过三层，切勿过度设计" class="headerlink" title="页面层级不宜嵌套超过三层，切勿过度设计"></a>页面层级不宜嵌套超过三层，切勿过度设计</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">原则上组件嵌套超过三层，数据传递的过程就会变得相对复杂</span><br></pre></td></tr></tbody></table></figure>
<h2 id="这个组件可否（有必要）再分？"><a href="#这个组件可否（有必要）再分？" class="headerlink" title="这个组件可否（有必要）再分？"></a>这个组件可否（有必要）再分？</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">划分粒度的根据实际情况权衡，太小会提升维护成本，太大又不够灵活和高复用性</span><br><span class="line"></span><br><span class="line">是否打破了一个逻辑上有意义的实体，倘若抽离的话，这个代码被复用的概率有多大？</span><br><span class="line"></span><br><span class="line">如果它只是几行代码，那么最终可能会创建更多的代码来分离它，有必要吗？我这么做的好处是否超过了成本？</span><br><span class="line"></span><br><span class="line">如果你当前的逻辑不太可能出现在其他地方，那么将它嵌入其中更好，如果需要，你可以随时抽离，毕竟组件化没有终点</span><br><span class="line"></span><br><span class="line">每一个组件都应该有其独特的划分目的的，有的是为了复用实现，有的是为了封装复杂度清晰业务实现</span><br><span class="line">组件划分的依据通常是业务逻辑、功能，要考虑各组件之间的关系是否明确，及可复用度</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="性能会受到影响吗？"><a href="#性能会受到影响吗？" class="headerlink" title="性能会受到影响吗？"></a>性能会受到影响吗？</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">如果状态频繁更改，并且当前在一个较大且关系比较紧密的组件里，为了避免性能受到影响最好抽离出来 与diff策略相关</span><br></pre></td></tr></tbody></table></figure>

<h2 id="这个组件的依赖是否可再缩减？"><a href="#这个组件的依赖是否可再缩减？" class="headerlink" title="这个组件的依赖是否可再缩减？"></a>这个组件的依赖是否可再缩减？</h2><p>缩减组件依赖可以提高组件的可复用度</p>
<h2 id="这个组件是否对其它组件造成侵入？"><a href="#这个组件是否对其它组件造成侵入？" class="headerlink" title="这个组件是否对其它组件造成侵入？"></a>这个组件是否对其它组件造成侵入？</h2><ul>
<li>封装性不足或自身越界操作，就可能对自身之外造成了侵入</li>
<li>一个组件不应对其它兄弟组件造成直接影响 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">常见的一种情况是：组件运行时对window对象添加resize监听事件以实现组件响应视窗尺寸变化事件</span><br><span class="line"></span><br><span class="line">最优的方案：组件提供刷新方法，由父组件实现调用</span><br><span class="line">次优的方案：组件destroy前清理恢复</span><br></pre></td></tr></tbody></table></figure>

<h2 id="接口设计是否兼容大部分场景？"><a href="#接口设计是否兼容大部分场景？" class="headerlink" title="接口设计是否兼容大部分场景？"></a>接口设计是否兼容大部分场景？</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">需要考虑需要适用的不同场景，在组件接口设计时进行必要的兼容</span><br></pre></td></tr></tbody></table></figure>

<h2 id="当别人使用这个组件时，会怎么想？"><a href="#当别人使用这个组件时，会怎么想？" class="headerlink" title="当别人使用这个组件时，会怎么想？"></a>当别人使用这个组件时，会怎么想？</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">接口设计符合规范和大众习惯，尽量让别人用起来简单易上手，易上手是指更符合直觉</span><br></pre></td></tr></tbody></table></figure>

<h2 id="假如业务需要不需要这个功能，是否方便清除？"><a href="#假如业务需要不需要这个功能，是否方便清除？" class="headerlink" title="假如业务需要不需要这个功能，是否方便清除？"></a>假如业务需要不需要这个功能，是否方便清除？</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">各组件之前以组合的关系互相配合，也是对功能需求的模块化抽象，当需求变化时可以将实现以模块粒度进行调整</span><br></pre></td></tr></tbody></table></figure>


<p>上文提到的各种准则仅仅描述了一种开发理念，也可以认为是一种开发规范，倘若你认可这规范，对它的分治策略产生了共鸣，那我们就可以继续聊聊它的具体实现了</p>
<p>问自己一个问题</p>
<p><font color="red">你心中的相对完美的组件是什么样子的？</font></p>
<h1 id="落实到具体业务中如何做"><a href="#落实到具体业务中如何做" class="headerlink" title="落实到具体业务中如何做"></a>落实到具体业务中如何做</h1><h2 id="划分依据"><a href="#划分依据" class="headerlink" title="划分依据"></a>划分依据</h2><p>明确你的组件划分依据，目前是两种</p>
<ul>
<li>根据业务划分</li>
<li>根据技术划分</li>
</ul>
<ol>
<li>我更多的是根据业务去设计我应用中的组件树，可能会画个草图或 xmind，它可以帮我统观全局</li>
<li>明确各个组件的边界，内部 state 的设计，props 的设计以及与其他组件的关系（需要回调出去的事件）</li>
<li>明确各个组件的定位与职能划分，设计好父子组件、兄弟组件的通信机制</li>
<li>搭架子</li>
<li>架子有了，开始填空</li>
</ol>
<h2 id="切割模版（页面结构模块化）"><a href="#切割模版（页面结构模块化）" class="headerlink" title="切割模版（页面结构模块化）"></a>切割模版（页面结构模块化）</h2><p>这是最容易想到的方法，当一个组件渲染了很多元素，就需要尝试分离这些组件的渲染逻辑<br>我们以掘金页面为例</p>
<p><img src="http://cdn.anruence.com/5.png" alt="jsworke"></p>
<p>大体上看，可以分为 Part1，Part2，Part3</p>
<h3 id="初步开发"><a href="#初步开发" class="headerlink" title="初步开发"></a>初步开发</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id="app"&gt;</span><br><span class="line">    &lt;div class="panel"&gt;</span><br><span class="line">      &lt;div class="part1 left"&gt;</span><br><span class="line">        &lt;!--内容--&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div class="part1 right"&gt;</span><br><span class="line">        &lt;!--内容--&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div class="part1 right"&gt;</span><br><span class="line">        &lt;!--内容--&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>问题：</p>
<ul>
<li>代码量大，难以维护，难以测试</li>
<li>有些许重复量</li>
</ul>
<h3 id="化繁为简"><a href="#化繁为简" class="headerlink" title="化繁为简"></a>化繁为简</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id="app"&gt;</span><br><span class="line">      &lt;part1 /&gt;</span><br><span class="line">      &lt;part2 /&gt;</span><br><span class="line">      &lt;part3 /&gt; </span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>好处：</p>
<ul>
<li>同之前的方式相比，这个微妙的改进是革命性的</li>
<li>解决了测试困难，维护困难的问题</li>
</ul>
<p>问题：</p>
<ul>
<li>没有解决代码重复的问题，这种按模块划分，复用性低</li>
</ul>
<p>但我看过很多项目的代码，就是这么干的，认为自己做了组件化，抽象的还不错 (@_@)</p>
<h3 id="组件抽象"><a href="#组件抽象" class="headerlink" title="组件抽象"></a>组件抽象</h3><p>它们有相似的外层，part2 和 part3 更有相似的 titlebar，除了业务内容，完全就是一模一样</p>
<p>🌰（vue）</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class="part"&gt;</span><br><span class="line">    &lt;header&gt;</span><br><span class="line">      &lt;span&gt;{{ title }}&lt;/span&gt;</span><br><span class="line">    &lt;/header&gt;</span><br><span class="line">    &lt;slot name="content" /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>我们将 part 内可以抽象的数据都做成了 props，利用 slot 去做模版<br>那么我们在开发相应 Part1，Part2 时</p>
<p>🌰（vue）</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id="app"&gt;</span><br><span class="line">      &lt;part title="亦舒"&gt;</span><br><span class="line">        &lt;div slot="content"&gt;----&lt;/div&gt;</span><br><span class="line">      &lt;/part&gt;</span><br><span class="line">      &lt;part title="兴隆臻园户型"&gt;</span><br><span class="line">        &lt;div slot="content"&gt;-----&lt;/div&gt;</span><br><span class="line">      &lt;/part&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>更具代表性的示例图</p>
<p><img src="http://cdn.anruence.com/6.png" alt="jsworke"></p>
<ul>
<li>UI 差异在哪里定义？</li>
</ul>
<p>在业务逻辑层处理</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">首先要明确一点，这些差异并不是组件本身造成的，是你自己的业务逻辑造成的，所以容器组件（父组件）应该为此买单</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>数据差异在哪里定义？</li>
</ul>
<p>结合组件本身和业务上下文将差异合理的消除在内部</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">比如part3中，其他的part只有一个类似更多&gt;&gt;的link，但是它却有多个(一居，二居...)</span><br><span class="line">这里我推荐将这种差异体现在组件内部，设计方法也很多：</span><br><span class="line">比如可以将link数组化为links；</span><br><span class="line">比如可以将更多&gt;&gt;看作是一个default的link，而多余的部分则是用户自定义的特殊link，这两者合并组成了links。用户自定义的默认是没有的，需要引用组件时进行传入。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>组件命名规则？</li>
</ul>
<p>组件设计初期，就应该拥有不耦合业务的名字</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">一个通用的或者说未来可能通用的，要有相对合理的命名，比如 Search，List,尽量不要出现与业务耦合过深的业务名词，通用组件与业务无关，只与自身抽象的组件有关</span><br><span class="line">我们在设计组件初期，就应该有这种思想，等到真正可以抽出公用组件了，再去苦逼的名改名字？</span><br><span class="line">库通常都想让广大开发者用，我们在设计组件时，可以降低标准到先做到你的整个APP中通用</span><br></pre></td></tr></tbody></table></figure>

<h2 id="组件划分细粒度的考量（抽之有度）"><a href="#组件划分细粒度的考量（抽之有度）" class="headerlink" title="组件划分细粒度的考量（抽之有度）"></a>组件划分细粒度的考量（抽之有度）</h2><p>组件设计规则明明白白写着我们要遵循单一职责原则，这也带来了上文聊过的<font color="red">过度抽象（组件化）</font>的问题，我们结合具体的业务聊一下</p>
<p><img src="http://cdn.anruence.com/7.png" alt="jsworke"></p>
<p>要实现徽章组件，它有两部分组成</p>
<ul>
<li>按钮</li>
<li>右上角提示（小红点 /icon）</li>
</ul>
<p>两者都是符合单一职责的，可以将其抽离成一个独立组件，但是通常不要这么做</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">因为同一个app的风格必将是统一的，除此之外没别的应用场景了，就像上文所说的，抽离组件之前，多问自己为什么以及投入/产出比，没有绝对的规则</span><br></pre></td></tr></tbody></table></figure>


<h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><p><font color="red">单一职责组件要建立在可复用的基础上，对于不可复用的单⼀职责组件我们仅仅作为独立组件的内部组件即可</font></p>
<h3 id="某二手车网站体现其细粒度的例子"><a href="#某二手车网站体现其细粒度的例子" class="headerlink" title="某二手车网站体现其细粒度的例子"></a>某二手车网站体现其细粒度的例子</h3><p><img src="http://cdn.anruence.com/1.gif" alt="jsworke"></p>
<p>思考，如果让你实现你会如何设计…<br>我当初是这么设计的</p>
<p><img src="http://cdn.anruence.com/8.png" alt="jsworke"></p>
<p>index.js(react)</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;div className="select-brand-box" onTouchStart={touchStartHandler} onTouchMove={touchMoveHandler} onTouchEnd={touchEndHandler.bind(this, touchEndCallback)}&gt;</span><br><span class="line">     &lt;NavBar&gt;&lt;/NavBar&gt;</span><br><span class="line">     &lt;Brand key="brands-list" {...brandsProps} /&gt;</span><br><span class="line">     &lt;Series key="series-list" {...seriesProps} &gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line"> </span><br><span class="line"> export default BrandHoc(index);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>Brand.js(react)</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;div className="brand-box"&gt;</span><br><span class="line">    &lt;div className="brand-wrap" ref="brandWrap"&gt;</span><br><span class="line">        &lt;p className="brands-title hot-brands-title"&gt;热门品牌&lt;/p&gt;</span><br><span class="line">        &lt;FlexLayout onClick={hotBrandClick}&gt;</span><br><span class="line">            &lt;HotBrands HotBrands={hotBrands} /&gt;</span><br><span class="line">        &lt;/FlexLayout&gt;</span><br><span class="line">        {!isHideStar &amp;&amp; &lt;UnlimitType {...unlimitProps} /&gt;}</span><br><span class="line">        &lt;AllBrands {...brandsProps} /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;AsideLetter {...asideProps} /&gt;</span><br><span class="line">    {showPop ? &lt;PopTips key="pop-tips" tip={currentLetter} /&gt; : null}</span><br><span class="line">    {showBrandLoading ? &lt;Loading /&gt; : null}</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">            </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>FlexLayout.js(react)</p>
<p><img src="http://cdn.anruence.com/9.png" alt="jsworke"></p>
<p>这个示例几乎涵盖了所有的规则</p>
<ul>
<li>首先组件的设计是根据业务划分的，所以右侧字母导航（AsideLetter）才没有在最外层的容器组件，否则通信问题会占用一部分篇幅，事实上这是有解的</li>
<li>入口组件是容器组件，事实上把它当做一个规则就行了，业务逻辑的载体</li>
<li>除了容器组件外，其他的组件都被抽成公用的了，二手车平台类似的场景非常多</li>
</ul>
<p><img src="http://cdn.anruence.com/10.png" alt="jsworke"></p>
<ul>
<li>卖车平台类似的图文混排多且形态各不相同，应用场景广泛，抽！UI 差异消化在组件内部，参考 FlexLayout.js，给定 default props</li>
<li> 可提取的组件过多（业务驱动）导致通讯困难如何解决？ 那说明你需要新增可管理状态的容器组件，上例中 Brand，Series 也是容器组件，负责管理子组件的大小事宜</li>
<li>细粒度的考量，考虑付出产出比 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;p className="brands-title hot-brands-title"&gt;热门品牌&lt;/p&gt; 只有一行，直接写就完了</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>组件抽离的过程就是无限向无状态（展示型）组件无限靠近的过程</li>
</ul>
<h2 id="通用性考量"><a href="#通用性考量" class="headerlink" title="通用性考量"></a>通用性考量</h2><p>组件的形态 (UI) 永远是千变万化的，但是其行为 (逻辑) 是固定的，因此通用组件的秘诀之⼀就是<font color="red">将 DOM 结构的控制权交给开发者，组件只负责⾏为和最基本的 DOM 结构</font></p>
<p>这是一个显眼的栗子</p>
<p>某一天，你接到这样儿的需求</p>
<p><img src="http://cdn.anruence.com/12.png" alt="jsworke"></p>
<p>开心，简单，三下五除二写完了</p>
<p>突然有一天又有这样儿的需求</p>
<p><img src="http://cdn.anruence.com/13.png" alt="jsworke"></p>
<p>emm.. 可定制？之前的 select 没法用了，怎么做？要修改上一个或者再写一个吗？<br>一旦出现了这种情况，证明之前的组件需要重新设计了</p>
<p>实现通用性设计的关键一点是<font color="red">放弃对 Dom 的掌控</font></p>
<h3 id="那么问题又来了，那么多需要自定义的地方，那组件会不会很难用？"><a href="#那么问题又来了，那么多需要自定义的地方，那组件会不会很难用？" class="headerlink" title="那么问题又来了，那么多需要自定义的地方，那组件会不会很难用？"></a>那么问题又来了，那么多需要自定义的地方，那组件会不会很难用？</h3><p>通用性设计在将 Dom 结构决定权交给开发者的同时指定默认值</p>
<p>这里是一个新鲜出炉 (vue)🌰</p>
<p>List 组件</p>
<p><img src="http://cdn.anruence.com/14.png" alt="jsworke"></p>
<p>父组件🌰(vue) 及 slot</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">模版（伪代码）</span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;List :data="tableData[item.type]" :loading="loading" @loadMore="loadMore" :noMore="noMore"&gt;</span><br><span class="line">    &lt;a v-if="item.type == 0" slot="listOption" slot-scope="childScope" class="edit-btn" @click="edit(childScope.data)" v-bind:key="childScope.data.id"&gt;{{Status[childScope.data.status]['text']}}&lt;/a&gt;</span><br><span class="line">&lt;/List&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">config(伪代码)</span><br><span class="line">export const Status = {</span><br><span class="line">  //....</span><br><span class="line">  1: {</span><br><span class="line">    label: '草稿',</span><br><span class="line">    type: '',</span><br><span class="line">    text: '编辑',</span><br><span class="line">    class: 'note'</span><br><span class="line">  }}</span><br><span class="line">  //...</span><br></pre></td></tr></tbody></table></figure>

<p>又有一个栗子 (vue)</p>
<p><img src="http://cdn.anruence.com/15.png" alt="jsworke"></p>
<ul>
<li>Dialog 只负责基础的逻辑，交出控制权给到业务，至于你的业务需要什么，在容器组件（业务逻辑层）去处理</li>
</ul>
<p>忍不住放上磐石业务的反面例子</p>
<p><img src="http://cdn.anruence.com/16.png" alt="jsworke"></p>
<p>难用无非是两方面的问题</p>
<ol>
<li>不肯移交控制权</li>
<li>没有 API 文档</li>
</ol>
<p>所有的业务逻辑与场景都包含在组件内部，外界只通过变量来控制，初衷是好的，但是随着业务发展，组件越来越庞大，开发者也越来越力不从心了</p>
<p>刚好现阶段 UI 改版，我们的工作量就由只改样式直接转化为推倒重来了，又没有详细的文档，工作量瞬间翻了 N 倍😭宝宝心里苦宝宝不说</p>
<h2 id="善用设计模式"><a href="#善用设计模式" class="headerlink" title="善用设计模式"></a>善用设计模式</h2><p>其实一开始，我并没有专门去套用设计模式，完全是业务驱使<br>你一定见到过这样儿的</p>
<p><img src="http://cdn.anruence.com/17.png" alt="jsworke"></p>
<p>一旦这样儿的逻辑多了，那是不是就跟业务耦合了，跟业务耦合多了，那组件自然没有什么通用性了，即使我们不考虑到通用性，那写的累吧？</p>
<p>考虑下这样写会不会好一点</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">config（伪代码）</span><br><span class="line">export const Status = {</span><br><span class="line">  4: {</span><br><span class="line">    label: '部分入库',</span><br><span class="line">    type: '',</span><br><span class="line">    text: '查看'</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line">模版(vue)</span><br><span class="line">&lt;a v-if="item.type == 0" slot="listOption" slot-scope="childScope" class="edit-btn" @click="edit(childScope.data)" v-bind:key="childScope.data.id"&gt;{{Status[childScope.data.status]['text']}}&lt;/a&gt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>世界上本没有设计模式，写的人多了，就自成一套脱颖而出进而被历史铭记了！不仅如此，一部分看似复杂的业务如果合理设计配置项，可以会为你省去一大篇 js</p>
<h1 id="一些感悟"><a href="#一些感悟" class="headerlink" title="一些感悟"></a>一些感悟</h1><p>像磐石这种底层的业务支持系统，离不开大量的列表，查询，编辑，详情等，我一般会花 30 秒搭好架子，像但不限于下面这种</p>
<p><img src="http://cdn.anruence.com/18.png" alt="jsworke"></p>
<ul>
<li>index: 模块入口（承担容器职责）</li>
<li>api：整块业务的 API</li>
<li>components 业务组件集合 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1. Form：表单 一般会被add.vue（编辑） 和edit.vue（详情）引用</span><br><span class="line">2. List：列表</span><br><span class="line">3. Search: 搜索组件</span><br><span class="line">4. 其他业务中有但却没看到的基本上都已经抽离到common了 比如面包屑导航，收起展开功能等</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>libs 页面的各种配置</li>
</ul>
<h2 id="具体体现（磐石刚刚重构的模块）"><a href="#具体体现（磐石刚刚重构的模块）" class="headerlink" title="具体体现（磐石刚刚重构的模块）"></a>具体体现（磐石刚刚重构的模块）</h2><p>采购模块结构图</p>
<p><img src="http://cdn.anruence.com/2222323232323.png" alt="image"></p>
<p>Form</p>
<p><img src="http://cdn.anruence.com/edit.png" alt="image"></p>
<p>Edit</p>
<p><img src="http://cdn.anruence.com/form.png" alt="image"></p>
<p>无论有多少种状态，只在 edit 这层容器维护</p>
<h2 id="要这么做的原因"><a href="#要这么做的原因" class="headerlink" title="要这么做的原因"></a>要这么做的原因</h2><ul>
<li>components 中的组件只是暂存，都有可能被升级成通用组件，所以命名要注意，一类的保持了统一，防止业务耦合</li>
<li> bug 有迹可循，数据的问题我一定从外向里排查，样式问题从里向外排查，定位问题快</li>
<li>与重复代码做斗争，时刻保持一种强迫症的心态去整理各个模块，形成自己的编码风格，进而团队风格才有可能统一</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>对于组件设计，充分的准备固然，但在现实世界中，切实的结果才是最重要的，组件设计也不要过度设计更不要停滞不前，该做的时候就去做，发现不好就去改</li>
<li>有空闲时间就去思考早期不够理想的代码，它可以作为我们向前发展的基础</li>
<li>技术在变迁，但组件化的核心并没有改变，目标仍然是在 API 设计尽可能接近原生的情况下完成复用、解耦、封装、抽象的目标，最终服务于开发，提高效率降低错误率</li>
</ul>
<ul>
<li>组件化是对实现的分层，是更有效地代码组合方式</li>
<li>组件化是对资源的重组和优化，从而使项目资源管理更合理，方便拔插、方便集成、方便删除、方便删除后重新加入</li>
<li>这种化繁为简的思想在后端开发中的体现是微服务，而在前端开发中的体现就是组件化</li>
</ul>
<ul>
<li>组件化有利于单元测试与自测效率对重构较友好</li>
<li>新人加入可以直接分配组件进行开发、测试，而非需要熟悉整个项目，可以从一个组件的开发使新进人员比较快速熟悉项目、了解到开发规范</li>
<li>你的直接责任可能是编写代码，但你的终极目标是在创建产品</li>
</ul>
<p>最后说一句</p>
<p><font color="red">组件化没有终点，day day up</font></p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a href="https://engineering.carsguide.com.au/front-end-component-design-principles-55c5963998c9?gi=b5b86599de92">https://engineering.carsguide.com.au/front-end-component-design-principles-55c5963998c9?gi=b5b86599de92</a></li>
<li><a href="https://segmentfault.com/a/1190000009952681">https://segmentfault.com/a/1190000009952681</a></li>
<li><a href="https://juejin.im/post/5a73d6435188257a6a789d0d">https://juejin.im/post/5a73d6435188257a6a789d0d</a></li>
<li><a href="https://medium.com/merrickchristensen/function-as-child-components-5f3920a9ace9">https://medium.com/merrickchristensen/function-as-child-components-5f3920a9ace9</a></li>
<li><a href="http://www.alloyteam.com/2015/11/we-will-be-componentized-web-long-text/">http://www.alloyteam.com/2015/11/we-will-be-componentized-web-long-text/</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>组件设计</tag>
      </tags>
  </entry>
</search>
