<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>搭建服务器亲自体验跨域</title>
    <url>/2019/01/18/COR/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>跨域这两个字就像狗皮膏药一样儿粘在每一个前端er身上 我遇见了很多开发者一般都是为了应付面试 随便背几个方案 知道概念 但是不知道为什么要这么干<br>到了真正的工作 开发环境有 <code>webpack-dev-server</code>搞定 线上有运维大哥会配好，配什么我不管 反正不会跨域就是了<br>但是.. 这样儿混日子 你的良心不会痛吗？</p>
<p>痛定思痛 决心不定时更新 不要再问我 XX 的问题系列 之 <font color="red">不要再问我跨域的问题了</font></p>
<p>其实团队的小伙伴分享过类似的 但是不动手试一下 跟你面试前的死记硬背本质上没有任何区别<br><a id="more"></a></p>
<h2 id="你需要了解的几个概念"><a href="#你需要了解的几个概念" class="headerlink" title="你需要了解的几个概念"></a>你需要了解的几个概念</h2><ul>
<li>什么是跨域？</li>
</ul>
<p><strong>官方解释</strong><br>跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器  让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。</p>
<p>比如，站点 <a href="http://domain-a.com" target="_blank" rel="noopener">http://domain-a.com</a> 的某 HTML 页面通过 <img> 的 src 请求 <a href="http://domain-b.com/image.jpg。网络上的许多页面都会加载来自不同域的CSS样式表，图像和脚本等资源。" target="_blank" rel="noopener">http://domain-b.com/image.jpg。网络上的许多页面都会加载来自不同域的CSS样式表，图像和脚本等资源。</a></p>
<ul>
<li>为什么会产生跨域？</li>
</ul>
<font color="red">出于安全原因，浏览器限制从脚本内发起的跨源HTTP请求（也可能跨站请求可以正常发起，但是返回结果被浏览器拦截了）</font>

<p>跨域的产生来源于现代浏览器所通用的<code>同源策略</code>，所谓同源是指<code>&quot;协议+域名+端口&quot;</code>三者相同的情况下，才允许访问相同的<code>cookie</code>、<code>localStorage</code>或是发送<code>Ajax</code>请求等等</p>
<p><strong>常见的跨域场景</strong></p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">URL                                      说明                    是否允许通信</span><br><span class="line"><span class="symbol">http:</span><span class="comment">//www.domain.com/a.js</span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//www.domain.com/b.js         同一域名，不同文件或路径           允许</span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//www.domain.com/lab/c.js</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//www.domain.com:8000/a.js</span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//www.domain.com/b.js         同一域名，不同端口                不允许</span></span><br><span class="line"> </span><br><span class="line"><span class="symbol">http:</span><span class="comment">//www.domain.com/a.js</span></span><br><span class="line"><span class="symbol">https:</span><span class="comment">//www.domain.com/b.js        同一域名，不同协议                不允许</span></span><br><span class="line"> </span><br><span class="line"><span class="symbol">http:</span><span class="comment">//www.domain.com/a.js</span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//192.168.4.12/b.js           域名和域名对应相同ip              不允许</span></span><br><span class="line"> </span><br><span class="line"><span class="symbol">http:</span><span class="comment">//www.domain.com/a.js</span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//x.domain.com/b.js           主域相同，子域不同                不允许</span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//domain.com/c.js</span></span><br><span class="line"> </span><br><span class="line"><span class="symbol">http:</span><span class="comment">//www.domain1.com/a.js</span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//www.domain2.com/b.js        不同域名                         不允许</span></span><br></pre></td></tr></table></figure>
<ul>
<li>现代的跨域解决方案</li>
</ul>
<ol>
<li>通过jsonp跨域</li>
<li>document.domain + iframe跨域</li>
<li>location.hash + iframe</li>
<li>window.name + iframe跨域</li>
<li>postMessage跨域</li>
<li><font color="red">跨域资源共享（CORS）</font></li>
<li>nginx代理跨域</li>
<li>nodejs中间件代理跨域</li>
<li>WebSocket协议跨域</li>
</ol>
<h2 id="搭建服务尝试还原跨域过程"><a href="#搭建服务尝试还原跨域过程" class="headerlink" title="搭建服务尝试还原跨域过程"></a>搭建服务尝试还原跨域过程</h2><p><strong>通过koa搭建两个本地server 两个server都定义了一个GET请求接口/ajax。除监听port不同外，app.js还设置了静态服务。</strong></p>
<p><img src="/images/cors/koa1.png" alt="koa1"></p>
<p><strong>app.js port:8000</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> index = <span class="built_in">require</span>(<span class="string">'./routes/index'</span>)</span><br><span class="line"><span class="keyword">const</span> views = <span class="built_in">require</span>(<span class="string">'koa-views'</span>)</span><br><span class="line"><span class="keyword">const</span> serve = <span class="built_in">require</span>(<span class="string">'koa-static'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入静态资源</span></span><br><span class="line"><span class="keyword">const</span> staticPath = path.resolve(__dirname, <span class="string">'/public'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置静态服务</span></span><br><span class="line"><span class="keyword">const</span> staticServe = serve(staticPath, &#123;</span><br><span class="line">  setHeaders: <span class="function">(<span class="params">res, path, stats</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.indexOf(<span class="string">'jpg'</span>) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">      res.setHeader(<span class="string">'Cache-Control'</span>, [<span class="string">'private'</span>, <span class="string">'max-age=60'</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(staticServe);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加模版引擎 默认直接渲染html文件</span></span><br><span class="line">app.use(views(__dirname + <span class="string">'/views'</span>));</span><br><span class="line"><span class="comment">// 引入路由配置文件</span></span><br><span class="line">app.use(index.routes(), index.allowedMethods())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/ajax'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'get request'</span>, ctx.request.header.referer);</span><br><span class="line">  ctx.body = <span class="string">'received'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8000</span>,<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'app1 server is listening port 8000'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'demo in run.....'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// route.js</span></span><br><span class="line"></span><br><span class="line"> router.get(<span class="string">'/ajax'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'get request'</span>, ctx.request.header.referer);</span><br><span class="line">    ctx.body = <span class="string">'received'</span>;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p><strong>app2.js port:3000</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> koa();</span><br><span class="line"><span class="keyword">const</span> app2Route = <span class="built_in">require</span>(<span class="string">'./routes/app2Route'</span>)</span><br><span class="line"><span class="keyword">const</span> cors = <span class="built_in">require</span>(<span class="string">'koa2-cors'</span>);</span><br><span class="line"></span><br><span class="line">app.use(app2Route.routes(), app2Route.allowedMethods())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> main = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">ctx,next</span>) </span>&#123;</span><br><span class="line">    ctx.response.body = <span class="string">'3000端口'</span>;</span><br><span class="line"><span class="keyword">await</span> next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.use(main)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'app2 server is listening port 3000'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// route.js</span></span><br><span class="line"></span><br><span class="line"> router.get(<span class="string">'/ajax'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'get request'</span>, ctx.request.header.referer);</span><br><span class="line">    ctx.body = <span class="string">'received'</span>;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p><strong>前端模版</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>cross-origin test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">style</span>=<span class="string">"width: 600px; margin: 200px auto; text-align: center"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"getAjax()"</span>&gt;</span>GET 简单请求<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"getJsonP()"</span>&gt;</span>JSONP<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"corsWithJson()"</span>&gt;</span>POST 非简单请求<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://code.jquery.com/jquery-2.1.1.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">  <span class="keyword">var</span> baseUrl = <span class="string">'http://localhost:3000'</span>;</span></span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">getAjax</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();            </span></span><br><span class="line"><span class="actionscript">    xhr.open(<span class="string">'GET'</span>,  baseUrl + <span class="string">'/ajax'</span>, <span class="literal">true</span>);</span></span><br><span class="line"><span class="actionscript">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="comment">// readyState == 4说明请求已完成</span></span></span><br><span class="line"><span class="actionscript">      <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span> || xhr.status == <span class="number">304</span>) &#123; </span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 从服务器获得数据  </span></span></span><br><span class="line">        alert(xhr.responseText);</span><br><span class="line"><span class="actionscript">      &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(xhr.status);</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    xhr.send();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>很简单 大概长这样儿</p>
<p><img src="/images/cors/koa2.png" alt="koa2"></p>
<p><strong>AJAX</strong></p>
<p>测试case</p>
<ol>
<li><p>同域下请求ajax 不涉及跨域</p>
<p>请求接口：<code>baseUrl = &#39;http://localhost:8000&#39;;</code><br>测试结果👇<br><img src="/images/cors/koa3.png" alt="koa3"></p>
</li>
</ol>
<ol start="2">
<li>跨域ajax请求<br>请求接口：<code>baseUrl = &#39;http://localhost:3000&#39;;</code><br>测试结果👇<br><img src="/images/cors/koa4.png" alt="koa4"><br>很明显 跨域了</li>
</ol>
<h3 id="针对浏览器的Ajax请求跨域的主要解决方案有：JSONP、CORS。"><a href="#针对浏览器的Ajax请求跨域的主要解决方案有：JSONP、CORS。" class="headerlink" title="针对浏览器的Ajax请求跨域的主要解决方案有：JSONP、CORS。"></a>针对浏览器的Ajax请求跨域的主要解决方案有：JSONP、CORS。</h3><ul>
<li><p><strong>JSONP</strong></p>
  <font color="red">原理</font>

<p>  虽然浏览器同源策略限制了XMLHttpRequest请求不同域上的数据。但是，在页面上引入不同域的js脚本是可以的，而且script元素请求的脚本会被浏览器直接运行</p>
  <font color="red">测试</font>

<p>  <code>origin.html</code>添加</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getJsonP</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    script.src = baseUrl + <span class="string">'/jsonp?type=json&amp;callback=onBack'</span>;</span><br><span class="line">    <span class="built_in">document</span>.head.appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onBack</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'JSONP CALLBACK:  '</span> + <span class="built_in">JSON</span>.stringify(res) + <span class="string">''</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getJsonP方法会在当前页面添加一个script，src属性指向跨域的GET请求<br>通过query格式带上请求的参数。callback是关键，用于定义跨域请求回调的函数名称，这个值必须后台和脚本保持一致</p>
<p>在<code>app2.js</code>添加路由</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">router.<span class="keyword">get</span>(<span class="string">'/jsonp'</span>, async (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> req = ctx.request.query;</span><br><span class="line">  console.log(req);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">data</span> = &#123;</span><br><span class="line">    <span class="keyword">data</span>: req.type</span><br><span class="line">  &#125;</span><br><span class="line">  ctx.body = req.callback + <span class="string">'('</span>+ JSON.stringify(<span class="keyword">data</span>) +<span class="string">')'</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(router.routes());</span><br></pre></td></tr></table></figure>
<p>针对jsonp请求，后台要做的是：</p>
<p>获取请求参数中的callback值，如本例中的onBack<br>将callback的值以function(args)的格式作为response。</p>
<p>重启服务 触发页面的 <code>JSONP</code>🔘<br><img src="/images/cors/koa5.png" alt="koa5"></p>
<font color="red">优点</font><br>JSONP方案的兼容性好，IE浏览器也支持。<br><br><font color="red">缺点</font>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">因为是利用的<span class="tag">&lt;<span class="name">script</span>&gt;</span>元素，所以只支持GET请求。</span><br><span class="line">缺乏错误处理机制</span><br></pre></td></tr></table></figure>
<ul>
<li>CORS</li>
</ul>
<p>CORS即跨域资源分享，是W3C制定的标准。</p>
<ol>
<li>特性<br>CORS需要浏览器和服务器同时支持。</li>
</ol>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">大多主流浏览器都支持，IE <span class="number">10</span>以下不支持。</span><br><span class="line">只要服务器端实现了CORS接口，浏览器就能自动实现基于CORS的跨域请求。</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>两种请求</li>
</ol>
<p>浏览器将CORS请求分成两类：简单请求和非简单请求。</p>
<ul>
<li>简单请求<br>满足条件：请求类型为 <font color="red"><code>HEAD，GET，POST之一</code></font>；<br>请求头信息不超出以下几种：</li>
</ul>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">Accept</span><br><span class="line">Accept-Language</span><br><span class="line">Content-Language</span><br><span class="line">Last-Event-ID</span><br><span class="line">Content-<span class="keyword">Type</span>：只限于三个值application/x-www-<span class="keyword">form</span>-urlencoded、multipart/<span class="keyword">form</span>-<span class="keyword">data</span>、text/plain</span><br></pre></td></tr></table></figure>
<p>对于简单请求，浏览器会直接发出，同时在请求头中添加Origin字段。</p>
<p>Origin用来说明请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。<br>如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。</p>
<p>回顾下直接Ajax测试跨域的请求报文：</p>
<p><img src="/images/cors/koa6.png" alt="koa6"><br>浏览器为这个简单的GET请求添加了Origin，而响应头信息中没有Access-Control-Allow-Origin，浏览器判断请求跨域，给出错误提示。</p>
<ul>
<li>非简单请求</li>
</ul>
<p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。</p>
<p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。</p>
<p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。</p>
<p>在<font color="red">origin.html</font>中添加一个post请求：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">corsWithJson</span><span class="params">()</span></span> &#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">      url: baseUrl + <span class="string">'/cors'</span>,</span><br><span class="line">      <span class="built_in">type</span>: <span class="string">'post'</span>,</span><br><span class="line">      contentType: <span class="string">'application/json'</span>,</span><br><span class="line">      data: &#123;</span><br><span class="line">        <span class="built_in">type</span>: <span class="string">'json'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      success: <span class="function"><span class="keyword">function</span><span class="params">(data)</span></span> &#123;</span><br><span class="line">        console.<span class="built_in">log</span>(data);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>通过设置Content-Type为appliaction/json使其成为非简单请求：</p>
<p>启动服务<br><img src="/images/cors/koa7.png" alt="koa7"><br>“预检”请求的方法为OPTIONS，服务器判断Origin为跨域</p>
<p>除了Origin字段，”预检”请求的头信息包括两个特殊字段。</p>
<p>（1）<strong>Access-Control-Request-Method</strong><br>该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。<br>（2）<strong>Access-Control-Request-Headers</strong><br>该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是content-type。</p>
<font color="red">服务端设置CORS</font>

<p>在app2.js引入koa2-cors：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">app.<span class="keyword">use</span>(cors(&#123;</span><br><span class="line">  origin: <span class="function"><span class="keyword">function</span> <span class="params">(ctx)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (ctx.url === <span class="string">'/cors'</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">"*"</span>; <span class="comment">// 允许来自所有域名请求</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'http://localhost:3201'</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  exposeHeaders: [<span class="string">'WWW-Authenticate'</span>, <span class="string">'Server-Authorization'</span>],</span><br><span class="line">  maxAge: <span class="number">5</span>,</span><br><span class="line">  credentials: <span class="keyword">true</span>,</span><br><span class="line">  allowMethods: [<span class="string">'GET'</span>, <span class="string">'POST'</span>, <span class="string">'DELETE'</span>], <span class="comment">//设置允许的HTTP请求类型</span></span><br><span class="line">  allowHeaders: [<span class="string">'Content-Type'</span>, <span class="string">'Authorization'</span>, <span class="string">'Accept'</span>],</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<p>重启服务后，浏览器重新发送POST请求。可以看到浏览器发送了两次请求。</p>
<p><img src="/images/cors/koa8.png" alt="koa8"></p>
<p>（1）<strong>Access-Control-Allow-Methods</strong><br>该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。<br>（2）<strong>Access-Control-Allow-Headers</strong><br>如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。<br>（3）<strong>Access-Control-Allow-Credentials</strong><br>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。<br>（4）<strong>Access-Control-Max-Age</strong><br>该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。</p>
<p>现在为止 默认你已经完全理解跨域了哦</p>
<p>示例中的源代码</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>CORS</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6系列(一)</title>
    <url>/2017/04/20/ES6/</url>
    <content><![CDATA[<p><strong>数组的扩展</strong><br>Array.form() 将两类对象转换为数组<br>1.类似数组的对象<br>2.可遍历的对象</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> arrayLike = &#123;</span><br><span class="line"><span class="string">'0'</span>:<span class="string">'a'</span>,</span><br><span class="line"><span class="string">'1'</span>:<span class="string">'b'</span>,</span><br><span class="line"><span class="string">'2'</span>:<span class="string">'c'</span>,</span><br><span class="line"><span class="string">'3'</span>:<span class="string">'d'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ES5写法</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">var</span> arr1 = []<span class="selector-class">.slice</span><span class="selector-class">.call</span>(arrayLike)</span><br></pre></td></tr></table></figure>
<p>ES6 写法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">Array</span>.form(arrayLike)</span><br></pre></td></tr></table></figure>
<p>任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换。</p>
<p>值得提醒的是，扩展运算符（…）也可以将某些数据结构转为数组。</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="comment">// arguments对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">  var args = [...arguments];</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// NodeList对象</span></span></span><br><span class="line"><span class="function">[...<span class="title">document</span>.<span class="title">querySelectorAll</span><span class="params">(<span class="string">'div'</span>)</span>]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Array</span>.<span class="title">from</span>还可以接受第二个参数，作用类似于数组的<span class="title">map</span>方法</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Array</span>.<span class="title">from</span><span class="params">(arrayLike, x =&gt; x * x)</span>;</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">Array</span>.from(arrayLike).map(x =&gt; x * x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">Array</span>.<span class="keyword">of</span>()</span><br><span class="line"><span class="keyword">Array</span>.<span class="keyword">of</span>方法用于将一组值，转换为数组。</span><br><span class="line"></span><br><span class="line"><span class="keyword">Array</span>.<span class="keyword">of</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3,11,8]</span></span><br><span class="line"><span class="keyword">Array</span>.<span class="keyword">of</span>(<span class="number">3</span>) <span class="comment">// [3]</span></span><br><span class="line"><span class="keyword">Array</span>.<span class="keyword">of</span>(<span class="number">3</span>).length <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].find(<span class="function"><span class="keyword">function</span><span class="params">(value, <span class="keyword">index</span>, arr)</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">  return value &gt; 9;</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span>) <span class="comment">// 10</span></span></span><br></pre></td></tr></table></figure>
<p>fill方法使用给定值，填充一个数组。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].<span class="built_in">fill</span>(<span class="number">7</span>)</span><br></pre></td></tr></table></figure>
<p>ES6提供三个新的方法——<strong>entries()</strong>，<strong>keys()</strong>和<strong>values()</strong>——用于遍历数组</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">2</span>);     <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><strong>for of 循环</strong></p>
<p>ES6 引入 rest 参数（形式为“…变量名”），用于获取函数的多余参数</p>
<p>扩展运算符（spread）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。<br>console.log(…[1, 2, 3])<br>// 1 2 3</p>
<p>函数的name属性，返回该函数的函数名。</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">foo.name <span class="comment">// "foo"</span></span><br></pre></td></tr></table></figure>
<font face="STCAIYUN" color="red" size="4">（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</font>

<p>对象的扩展<br>var bax= {bac} = var baz = {bac:bac}</p>
<figure class="highlight monkey"><table><tr><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line"><span class="function"><span class="keyword">method</span>:</span><span class="function"><span class="keyword">function</span>(</span>)&#123;&#125;</span><br><span class="line">&#125; ==</span><br><span class="line">var o = &#123;</span><br><span class="line"> <span class="function"><span class="keyword">method</span>(</span>)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>let propKey = ‘foo’;</p>
<p>let obj = {<br>  [propKey]: true,<br>  [‘a’ + ‘bc’]: 123<br>};</p>
<p>const person = {<br>  sayName() {<br>    console.log(‘hello!’);<br>  },<br>};</p>
<p>person.sayName.name   // “sayName”</p>
<p>Object.is（）用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.<span class="keyword">is</span>(<span class="string">'foo'</span>, <span class="string">'foo'</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.<span class="keyword">is</span>(&#123;&#125;, &#123;&#125;)</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">不同之处只有两个：一是+<span class="number">0</span>不等于<span class="number">-0</span>，二是NaN等于自身</span><br></pre></td></tr></table></figure>
<font face="STCAIYUN" color="green" size="4">Object.is(+0, -0) // false<br></font>

<font face="STCAIYUN" color="blue" size="4">Object.is(NaN, NaN) // true<br></font>

<p>Object.assign() 实行的是<font face="STCAIYUN" color="red" size="4">浅拷贝不是深拷贝<br></font><br><strong>如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</strong></p>
<p>例子</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = <span class="comment">&#123;a: &#123;b: 1&#125;</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="keyword">Object</span>.assign(<span class="comment">&#123;&#125;</span>, obj1);</span><br><span class="line"></span><br><span class="line">obj1.a.b = <span class="number">2</span>; 如果值更改 则拷贝之后的值也是变化的</span><br><span class="line">obj2.a.b <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">如果该参数不是对象，则会先转成对象，然后返回。</span><br><span class="line"></span><br><span class="line">typeof <span class="keyword">Object</span>.assign(<span class="number">2</span>) <span class="comment">// "object"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Object</span>.assign可以用来处理数组，但是会把数组视为对象。</span><br><span class="line"></span><br><span class="line"><span class="keyword">Object</span>.assign([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="comment">// [4, 5, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Object</span>.assign(someClass.prototype,<span class="comment">&#123;</span></span><br><span class="line"><span class="comment">someMethod()&#123;</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">&#125;</span>,</span><br><span class="line">antherMethod()<span class="comment">&#123;</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">===</span><br><span class="line"><span class="comment">// 等同于下面的写法</span></span><br><span class="line">SomeClass.prototype.someMethod = <span class="function"><span class="keyword">function</span> <span class="params">(arg1, arg2)</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">  ···</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span>;</span></span><br><span class="line">SomeClass.prototype.anotherMethod = <span class="function"><span class="keyword">function</span> <span class="params">()</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">  ···</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span>;</span></span><br></pre></td></tr></table></figure>
<p><strong>克隆对象</strong><br>只能可通他自身的值而不能可通它继承的值</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">clone</span>(origin)&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="type">Object.assign(&#123;&#125;,origin)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">origin</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> originProto = <span class="built_in">Object</span>.getPrototypeOf(origin);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(<span class="built_in">Object</span>.create(originProto), origin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">Object.getOwnPropertyDescriptor</span> <span class="string">获取该属性的描述对象</span></span><br><span class="line"><span class="string">let</span> <span class="string">obj</span> <span class="string">=</span> <span class="string">&#123;</span> <span class="attr">foo:</span> <span class="number">123</span> <span class="string">&#125;;</span></span><br><span class="line"><span class="string">Object.getOwnPropertyDescriptor(obj,</span> <span class="string">'foo'</span><span class="string">)</span></span><br><span class="line"><span class="string">//</span>  <span class="string">&#123;</span></span><br><span class="line"><span class="string">//</span>    <span class="attr">value:</span> <span class="number">123</span><span class="string">,</span></span><br><span class="line"><span class="string">//</span>    <span class="attr">writable:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="string">//</span>    <span class="attr">enumerable:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="string">//</span>    <span class="attr">configurable:</span> <span class="literal">true</span></span><br><span class="line"><span class="string">//</span>  <span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>Object.keys方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">var obj = &#123; foo: <span class="string">'bar'</span>, baz: <span class="number">42</span> &#125;;</span><br><span class="line">Object.keys(obj)</span><br><span class="line"><span class="regexp">//</span> [<span class="string">"foo"</span>, <span class="string">"baz"</span>]</span><br></pre></td></tr></table></figure>
<p><img src="media/14879652049673/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-25%20%E4%B8%8B%E5%8D%8812.58.09.png" alt="屏幕快照 2017-02-25 下午12.58.09"></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; foo: <span class="string">'bar'</span>, baz: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.values(obj)</span><br><span class="line"><span class="comment">// ["bar", 42]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">var obj = &#123; foo: <span class="string">'bar'</span>, baz: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="symbol">Object</span>.entries(obj)</span><br><span class="line">// [ [<span class="string">"foo"</span>, <span class="string">"bar"</span>], [<span class="string">"baz"</span>, <span class="number">42</span>] ]</span><br></pre></td></tr></table></figure>
<p><strong>ES6 中遍历对象的属性</strong></p>
<font face="STCAIYUN" color="red" size="4">for…in </font>循环遍历对象自身的和继承的可枚举属性（不含Symbol属性）<br> <font face="STCAIYUN" color="red" size="4">Object.keys</font>返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含Symbol属性）。<br> <font face="STCAIYUN" color="red" size="4">Object.getOwnPropertyNames</font>返回一个数组，包含对象自身的所有属性（不含Symbol属性，但是包括不可枚举属性）<br> <font face="STCAIYUN" color="red" size="4">Object.getOwnPropertySymbols</font>返回一个数组，包含对象自身的所有Symbol属性。<br><br><font face="STCAIYUN" color="red" size="4"><strong>proto</strong>属性（前后各两个下划线）</font>，用来读取或设置当前对象的prototype对象。目前，所有浏览器（包括 IE11）都部署了这个属性。<br><br><br><br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// es6的写法</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  method: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.__proto__ = someOtherObj;</span><br></pre></td></tr></table></figure><br><br><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">let <span class="keyword">proto</span> = &#123;&#125;;</span><br><span class="line">let obj = &#123; x: <span class="number">10</span> &#125;;</span><br><span class="line">Object.<span class="built_in">set</span>PrototypeOf(obj, <span class="keyword">proto</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">proto</span>.y = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">proto</span>.z = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">obj.x // <span class="number">10</span></span><br><span class="line">obj.y // <span class="number">20</span></span><br><span class="line">obj.z // <span class="number">40</span></span><br><span class="line">上面代码将<span class="keyword">proto</span>对象设为obj对象的原型，所以从obj对象可以读取<span class="keyword">proto</span>对象的属性。</span><br></pre></td></tr></table></figure><br><br><strong>ES6引入的原始类型“</strong><br><font face="STCAIYUN" color="red" size="4">Symbol</font><br>凡是属性名属于Symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。<br>Symbol函数前<font face="STCAIYUN" color="red" size="4">不能使用new命令</font>，否则会报错。这是因为生成的Symbol是一个原始类型的值，不是对象<br>由于Symbol值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。<br>Symbol值不能与其他类型的值进行运算，会报错。<br>但是，Symbol值可以显式转为字符串。<br>另外，Symbol值也可以转为布尔值，但是不能转为数值。<br><br>let s = Symbol();<br><br>typeof s<br><br><strong>数组去重</strong><br><br>新增的数据结构 <font face="STCAIYUN" color="red" size="4">Set Map </font>


<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">const s = new Set();</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>].forEach(x =&gt; s.add(x));</span><br></pre></td></tr></table></figure>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">var <span class="builtin-name">set</span> = new <span class="builtin-name">Set</span>([1, 2, 3, 4, 4]);</span><br><span class="line">[<span class="built_in">..</span>.<span class="builtin-name">set</span>]</span><br></pre></td></tr></table></figure>
<p>// 去除数组的重复成员<br>在Set内部，两个NaN是相等。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">..</span>.new <span class="builtin-name">Set</span>(array)]</span><br><span class="line">var <span class="builtin-name">set</span> = new <span class="builtin-name">Set</span>([1,1,2,2,3,4,5,5,6])</span><br><span class="line">[<span class="built_in">..</span>.<span class="builtin-name">set</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">map</span> = <span class="literal">new</span> <span class="built_in">Map</span>(<span class="meta">[</span></span><br><span class="line">  <span class="meta">[</span><span class="string">'F'</span>, <span class="string">'no'</span><span class="meta">]</span>,</span><br><span class="line">  <span class="meta">[</span><span class="string">'T'</span>,  <span class="string">'yes'</span><span class="meta">]</span>,</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> <span class="built_in">key</span> of <span class="built_in">map</span>.keys()) &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="built_in">key</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<font face="STCAIYUN" color="red" size="4">Proxy（代理器） 元编程（对编程语言进行编程）</font>


<p><strong>在目标对象之前设置一层拦截 外界对它的访问必须先通过这一层拦截</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function (target, key, receiver) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`getting <span class="subst">$&#123;key&#125;</span>!`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span>: function (target, key, value, receiver) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`setting <span class="subst">$&#123;key&#125;</span>!`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>重写了get和set方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function(target, property) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">35</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.time <span class="comment">// 35</span></span><br><span class="line">proxy.name <span class="comment">// 35</span></span><br><span class="line">proxy.title <span class="comment">// 35</span></span><br></pre></td></tr></table></figure>
<font face="STCAIYUN" color="red" size="4">Promise(承诺)</font>

<p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="string">'异步操作成功'</span>)&#123;</span><br><span class="line">resolve(value)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">reject(error)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">成功</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">失败</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>遍历器对象本质上，就是一个指针对象。</p>
<p>回调函数<br>事件监听<br>发布/订阅<br>Promise 对象</p>
<p>Generator函数<br>yield表示执行到此处执行权将交给其它协程也就是说yield 命令部两个阶段的分界线</p>
<p>Generator 函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">try</span>&#123;</span><br><span class="line"> <span class="keyword">var</span> y = <span class="keyword">yield</span> x +<span class="number">2</span>;</span><br><span class="line"> &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(e)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> y</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight qml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fetch = <span class="built_in">require</span>(<span class="string">'node-fetch'</span>);</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="keyword">var</span> <span class="built_in">url</span> = <span class="string">'http://api.github.com/users/github'</span>;</span><br><span class="line"> <span class="keyword">var</span> result = <span class="keyword">yield</span> fetch (<span class="built_in">url</span>);</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'ds'</span>)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p> Thunk 函数是自动执行generator函数的一种方法</p>
<p> 传名调用</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"> f(x + <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 传名调用时，等同于</span></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">(x + <span class="number">5</span>)</span></span></span><br></pre></td></tr></table></figure>
<p> 传值调用</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"> f(x + <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 传值调用时，等同于</span></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">(<span class="number">6</span>)</span></span></span><br></pre></td></tr></table></figure>
<font face="STCAIYUN" color="red" size="4">Thunk是传名调用的实现</font>，将参数放到一个临时的函数中，再将这个临时函数传入函数体<br><br>这个临时函数叫做<strong>Thunk</strong> 函数<br><br><br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(m)</span></span>&#123;</span><br><span class="line"> <span class="keyword">return</span> m*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(x+<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">等同于</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> thunk = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x+<span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">(thunk)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> thunk()*<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><font face="STCAIYUN" color="red" size="4">async ：Generator 函数的语法糖</font>



<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> asyncReadFile = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">await</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">await</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>async 🌧️generator比较</strong></p>
<ol>
<li>async有内置执行器 不需要调用next方法<br>拥有更好的语义（比起星号和yield 语义更清楚了）</li>
<li>async函数返回的是promise对象比 Generator函数返回值是Iterator对象方便多了 可以用then方法指定下一步操作</li>
</ol>
<p><strong>async和await</strong></p>
<ul>
<li>async表示函数中有异步操作</li>
<li>await表示紧跟在后面的表达式需要等待结果</li>
<li>async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。</li>
<li>async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</li>
</ul>
<p>错误处理</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错了'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> val1 = <span class="keyword">await</span> firstStep();</span><br><span class="line">    <span class="keyword">var</span> val2 = <span class="keyword">await</span> secondStep(val1);</span><br><span class="line">    <span class="keyword">var</span> val3 = <span class="keyword">await</span> thirdStep(val1, val2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Final: '</span>, val3);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> somethingThatReturnsAPromise();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="class"><a href="#class" class="headerlink" title="class"></a>class</h3><p><strong>基本形式</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constructor</span>(x,y)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.x = x;</span><br><span class="line"><span class="keyword">this</span>.y = y</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">toString()&#123;</span><br><span class="line"> <span class="keyword">return</span>  <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Class不存在变量提升（hoist），这一点与ES5完全不同。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MyClass = <span class="class"><span class="keyword">class</span> <span class="title">Me</span> </span>&#123;</span><br><span class="line">  getClassName() &#123;</span><br><span class="line">    <span class="keyword">return</span> Me.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>类名是MyClass 而不是me Me只在Class的内部代码可用，指代当前类。</p>
<p>const MyClass = class { /<em> … </em>/ };</p>
<p><strong>模块加载方案</strong></p>
<ul>
<li>CommonJs应用于服务器</li>
<li><p>AMD应用于浏览器</p>
<p>ES6 提供模块功能 尽量的静态化)</p>
</li>
</ul>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;stat，exut，readFile&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br></pre></td></tr></table></figure>
<p> Es6模块是编译时加载<br> ES6的模块自动采用严格模式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">f</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"> <span class="keyword">export</span> &#123;f&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;lastName <span class="keyword">as</span> surname&#125; <span class="keyword">from</span> <span class="string">'./profile'</span></span><br><span class="line"><span class="keyword">import</span>命令具有提升效果</span><br></pre></td></tr></table></figure>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">导出</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span></span><br><span class="line"></span><br><span class="line">引入</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> circle <span class="keyword">from</span> <span class="string">'./circle'</span>; 模块的整体加载</span><br></pre></td></tr></table></figure>
<p>使用import命令的时候用户不需要知道所加载的变量名或者函数名 用这个语法可以为模块指定默认输出</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'foo'</span>)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p> 引入的时候import可以为该匿名函数指定任意的名字，这个时候import 的后面不使用大括号</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> customName <span class="keyword">from</span>  ..</span><br><span class="line"></span><br><span class="line"> <span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">ee</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'foo'</span>)</span><br><span class="line">&#125;</span><br><span class="line">==</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'ee'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> foo;</span><br></pre></td></tr></table></figure>
<p> foo的函数名foo 在模块外部时无效的 视同匿名函数加载</p>
<p> 使用export时，对应的import语句需要使用大括号。</p>
<p> 使用 export default  对应的import语句不需要大括号</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 第一组</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">crc32</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 输出</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> crc32 <span class="keyword">from</span> <span class="string">'crc32'</span>; <span class="comment">// 输入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> xxx &#125; <span class="keyword">from</span> <span class="string">'modules'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二组</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">crc32</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 输出</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;crc32&#125; <span class="keyword">from</span> <span class="string">'crc32'</span>; <span class="comment">// 输入</span></span><br></pre></td></tr></table></figure>
<p>本质上，export default就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。</p>
<p>import { default as xxx } from ‘modules’</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">export</span> &#123;<span class="builtin-name">add</span> as default&#125;;</span><br></pre></td></tr></table></figure>
<p>// 等同于</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">// <span class="keyword">export</span> <span class="keyword">default</span> add;</span><br></pre></td></tr></table></figure>
<p>ES6模块</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"foo.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了<script>标签的defer属性。</p>
<p>拷贝数组</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">const</span> <span class="keyword">itemCopy </span>= []<span class="comment">;</span></span><br><span class="line"><span class="symbol">const</span> <span class="keyword">item </span>= [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">itemCopy </span>= [...<span class="keyword">item]</span></span><br><span class="line"><span class="keyword">console.log(itemCopy)</span></span><br></pre></td></tr></table></figure>
</script></p>]]></content>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>Express框架系列(一)之概述</title>
    <url>/2017/04/17/Express%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97(%E4%B8%80)%E4%B9%8B%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>参考文档：<a href="http://javascript.ruanyifeng.com/nodejs/express.html" target="_blank" rel="noopener">http://javascript.ruanyifeng.com/nodejs/express.html</a><br>Express是目前最流行的基于Node.js的Web开发框架，可以快速地搭建一个完整功能的网站。</p>
<p>创建测试项目<br><code>mkdir hello-world</code></p>
<p>进入该目录，新建一个package.json文件，内容如下。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"hello-world"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"hello world test app"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.0.1"</span>,</span><br><span class="line">  <span class="attr">"private"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"express"</span>: <span class="string">"4.x"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>安装 express<br><code>npm install</code><br>执行上面的命令以后，在项目根目录下，新建一个启动文件，假定叫做<code>index.js。</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="keyword">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.<span class="keyword">use</span>(express.<span class="keyword">static</span>(__dirname + <span class="string">'/public'</span>));</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure>
<p>运行启动脚本<br><code>node index</code><br>访问 <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a><br>它会在浏览器中打开当前目录的<strong>public</strong>子目录（严格来说，是打开public目录的index.html文件）。如果public目录之中有一个图片文件my_image.png，那么可以用<a href="http://localhost:8080/my_image.png访问该文件。" target="_blank" rel="noopener">http://localhost:8080/my_image.png访问该文件。</a></p>
<p>目录结构<br><img src="media/14906850474605/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-28%20%E4%B8%8B%E5%8D%883.55.13.png" alt="屏幕快照 2017-03-28 下午3.55.13"></p>
<p>执行结果<br><img src="media/14906850474605/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-28%20%E4%B8%8B%E5%8D%883.54.14.png" alt="屏幕快照 2017-03-28 下午3.54.14"><br>也可以<a href="http://localhost:8080/WX.jpeg" target="_blank" rel="noopener">http://localhost:8080/WX.jpeg</a></p>
<p>也可以生成动态网页</p>
<figure class="highlight plain"><figcaption><span>express </span></figcaption><table><tr><td class="code"><pre><span class="line">var app = express();</span><br><span class="line">app.get(&apos;/&apos;, function (req, res) &#123;</span><br><span class="line">  res.send(&apos;Hello world!&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure>
<p> 运行启动脚本<br><code>node index</code></p>
<p><img src="media/14906850474605/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-28%20%E4%B8%8B%E5%8D%883.57.07.png" alt="屏幕快照 2017-03-28 下午3.57.07"></p>
<p>启动脚本index.js的<strong>app.get</strong>方法，用于指定不同的访问路径所对应的回调函数，这叫做“<strong>路由</strong>”（routing）。上面代码只指定了根目录的回调函数，因此只有一个路由记录。实际应用中，可能有多个路由记录。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">比如：</span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">'Hello world!'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.get(<span class="string">'/customer'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">  res.send(<span class="string">'customer page'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.get(<span class="string">'/admin'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">  res.send(<span class="string">'admin page'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<p>比较庞大的时候可以单独存放<br>eg：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// routes/index.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">app</span>) </span>&#123;</span><br><span class="line">  app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.send(<span class="string">'Hello world'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  app.get(<span class="string">'/customer'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">'customer page'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  app.get(<span class="string">'/admin'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">'admin page'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>原先的index引入</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="keyword">var</span> routes = <span class="built_in">require</span>(<span class="string">'./routes'</span>)(app);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>DomContentLoaded 与 load</title>
    <url>/2018/03/30/DomContentLoaded%20%E4%B8%8E%20load/</url>
    <content><![CDATA[<h2 id="浏览器渲染原理"><a href="#浏览器渲染原理" class="headerlink" title="浏览器渲染原理"></a>浏览器渲染原理</h2><figure class="highlight qml"><table><tr><td class="code"><pre><span class="line">当我们在浏览器地址输入<span class="built_in">url</span>时，浏览器会发送请求到服务器，服务器将请求的html文档发送回浏览器，浏览器将文档下载下来后 便开始从上到下解析，解析完成后 会生成dom，如果页面中有css 会根据css的内容 形成cssdom 然后 dom和css会生成一个渲染树 最后浏览器会根据渲染树的内容计算出各个节点在页面中的确切大小和位置，并将其绘制在浏览器上</span><br></pre></td></tr></table></figure>
<p><img src="http://oucjferwh.bkt.clouddn.com/746387-20170407181220066-2064922697.png" alt></p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">在解析html的过程中 有时候解析会被中断，这是因为<span class="keyword">javascript会阻塞dom的解析 </span>当解析过程中遇到<span class="keyword">script标签的时候 </span>便会停止解析过程 抓转而去处理脚本 如果脚本是内联的 浏览器会先去执行这段内联的脚本，如果脚本是外链的  那么先去加载脚本 然后执行 在处理完脚本之后  浏览器便继续解析html文档</span><br></pre></td></tr></table></figure>
<h3 id="如何计算DomContentLoaded-加载时间"><a href="#如何计算DomContentLoaded-加载时间" class="headerlink" title="如何计算DomContentLoaded 加载时间"></a>如何计算DomContentLoaded 加载时间</h3><p>当文档中没有脚本时 浏览器解析完成文档便能触发 DomContentLoaded 事件 如果文档包含脚本 则脚本会阻塞文档的解析 而脚本需要等位于前面的css加载完才能执行 在任何情况下  DomContentLoaded 的触发不需要等待图片等其他资源加载完成</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">DOMContentLoaded不同的浏览器对其支持不同，所以在实现的时候我们需要做不同浏览器的兼容。</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>）支持DOMContentLoaded事件的，就使用DOMContentLoaded事件；</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）IE6、IE7不支持DOMContentLoaded，但它支持onreadystatechange事件，该事件的目的是提供与文档或元素的加载状态有关的信息。</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>) 更低的ie还有个特有的方法doScroll， 通过间隔调用：document.documentElement.doScroll(<span class="string">"left"</span>);</span><br><span class="line">可以检测DOM是否加载完成。 当页面未加载完成时，该方法会报错，直到doScroll不再报错时，就代表DOM加载完成了。该方法更接近DOMContentLoaded的实现。</span><br></pre></td></tr></table></figure>
<h3 id="如何计算load-加载时间"><a href="#如何计算load-加载时间" class="headerlink" title="如何计算load 加载时间"></a>如何计算load 加载时间</h3><p>页面上所有的资源（图片，音频，视频等）被加载以后才会触发load事件，简单来说，页面的load事件会在DOMContentLoaded被触发之后才触发。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="我们为什么一再强调将CSS放在头部-将js放在尾部"><a href="#我们为什么一再强调将CSS放在头部-将js放在尾部" class="headerlink" title="我们为什么一再强调将CSS放在头部 将js放在尾部"></a>我们为什么一再强调将CSS放在头部 将js放在尾部</h3><p>因为浏览器生成Dom树的时候是一行一行读html代码的  script标签放在最后面就不会影响前面的页面渲染，那么问题来了<br>既然Dom树完全生成好页面才能渲染出来 浏览器又必须读完全部的html才能生成完成的dom树 script标签放不放在底部是不是也一样 因为dom树的生成需要整个文档解析完成</p>
<font color="red">chrome页面渲染过程中 会有 firstpaint的概念，现代浏览器为了更好的用户体验，渲染引擎将尝试尽快在屏幕上显示的内容 他不会等到所有的html解析完成才开始构建和布局dom树 部分的内容被解析并展示 也就是说 浏览器能够渲染不完整的dom树和cssdom 尽快的减少白屏时间<br></font>

<p>假如我们将js放在header js将会阻塞解析dom dom的内容会影响到 firstpaint 导致firstpaint延后 所以说我们会将js放在后面 以减少firstpaint时间但是不会减少 DomContentLoaded 被触发的时间</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title>Express框架系列(三)之方法</title>
    <url>/2018/04/18/Express%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97(%E4%B8%89)%E4%B9%8B%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="all方法和HTTP动词方法"><a href="#all方法和HTTP动词方法" class="headerlink" title="all方法和HTTP动词方法"></a>all方法和HTTP动词方法</h3><p>针对不同的请求，Express提供了use方法的一些别名。比如，上面代码也可以用别名的形式来写。</p>
<figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line">var express = require(<span class="string">"express"</span>);</span><br><span class="line">var http = require(<span class="string">"http"</span>);</span><br><span class="line">var app = express();</span><br><span class="line"></span><br><span class="line">app.all(<span class="string">"*"</span>, <span class="keyword">function</span>(<span class="built_in">request</span>, <span class="built_in">response</span>, <span class="keyword">next</span>) &#123;</span><br><span class="line">  <span class="built_in">response</span>.writeHead(<span class="number">200</span>, &#123; <span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span> &#125;);</span><br><span class="line">  <span class="keyword">next</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="keyword">get</span>(<span class="string">"/"</span>, <span class="keyword">function</span>(<span class="built_in">request</span>, <span class="built_in">response</span>) &#123;</span><br><span class="line">  <span class="built_in">response</span>.<span class="keyword">end</span>(<span class="string">"Welcome to the homepage!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="keyword">get</span>(<span class="string">"/about"</span>, <span class="keyword">function</span>(<span class="built_in">request</span>, <span class="built_in">response</span>) &#123;</span><br><span class="line">  <span class="built_in">response</span>.<span class="keyword">end</span>(<span class="string">"Welcome to the about page!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="keyword">get</span>(<span class="string">"*"</span>, <span class="keyword">function</span>(<span class="built_in">request</span>, <span class="built_in">response</span>) &#123;</span><br><span class="line">  <span class="built_in">response</span>.<span class="keyword">end</span>(<span class="string">"404!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">http.createServer(app).listen(<span class="number">1337</span>);</span><br></pre></td></tr></table></figure>
<p>除了get方法以外，Express还提供post、put、delete方法，即HTTP动词都是Express的方法，express允许模式匹配</p>
<h3 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h3><p>用于指定变量的值</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">app.<span class="built_in">set</span>(<span class="string">'views'</span>,<span class="variable">_dirname</span>+<span class="string">'/views'</span>)</span><br><span class="line">app.<span class="built_in">set</span>(<span class="string">"view engine"</span>, <span class="string">"jade"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="response-对象"><a href="#response-对象" class="headerlink" title="response 对象"></a>response 对象</h3><p>response.redirect()允许网址的重定向<br><code>response.redirect(&quot;/hello/anime&quot;);</code></p>
<p>response.sendFile()用于发送文件<br><code>response.sendFile(&quot;/path/to/anime.mp4&quot;)</code></p>
<p>response.render() 用于渲染网页模版</p>
<figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line">app.<span class="keyword">get</span>(<span class="string">"/"</span>, <span class="keyword">function</span>(<span class="built_in">request</span>, <span class="built_in">response</span>) &#123;</span><br><span class="line">  <span class="built_in">response</span>.render(<span class="string">"index"</span>, &#123; message: <span class="string">"Hello World"</span> &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>使用render方法，将message变量传入index模版，渲染成HTML网页</p>
<h3 id="request对象"><a href="#request对象" class="headerlink" title="request对象"></a>request对象</h3><p>request.ip:用于获取HTTP请求的IP地址<br>request.files 用于获取上传的文件</p>
<h3 id="搭建HTTPS服务器"><a href="#搭建HTTPS服务器" class="headerlink" title="搭建HTTPS服务器"></a>搭建<a href="http://baike.baidu.com/link?url=RDLn4MhlPev2MMCPjJvGa0aEf2Fg2DzGyz-Eqo7AwmYdYDjPTvyZuku-svVMjAlHcvsZm9PQ4bGPcjFW7VPcDK" target="_blank" rel="noopener">HTTPS</a>服务器</h3><p>使用express搭建https加密服务器</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  key: fs.readFileSync(<span class="string">'E:/ssl/myserver.key'</span>),</span><br><span class="line">  cert: fs.readFileSync(<span class="string">'E:/ssl/myserver.crt'</span>),</span><br><span class="line">  passphrase: <span class="string">'1234'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> https = <span class="built_in">require</span>(<span class="string">'https'</span>);</span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">  res.send(<span class="string">'Hello World Expressjs'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = https.createServer(options, app);</span><br><span class="line">server.listen(<span class="number">8084</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>Express框架系列(二)之运行原理</title>
    <url>/2017/04/18/Express%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97(%E4%BA%8C)%E4%B9%8B%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="底层HTTP模块"><a href="#底层HTTP模块" class="headerlink" title="底层HTTP模块"></a>底层HTTP模块</h3><p>Express框架建立在node.js内置的http模块上，<strong>框架的核心是对HTTP模块的再包装</strong><br>http模块生成服务器的原始代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">  response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>&#125;);</span><br><span class="line">    response.end(<span class="string">" express hahahah"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">4040</span>, <span class="string">"localhost"</span>);</span><br></pre></td></tr></table></figure>
<p>上面的代码关键是http模块的<strong>createServer</strong>方法，表示生成一个http服务器实例，该方法接受一个回调函数，回调函数的两个参数分别代表HTTP请求和HTTP响应的<strong>request</strong>对象和<strong>response</strong>对象</p>
<p><img src="http://oucjferwh.bkt.clouddn.com/node2-1.png" alt></p>
<p>上面的代码用Express改写如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">'Hello world!'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">7000</span>);</span><br></pre></td></tr></table></figure>
<p><img src="http://oucjferwh.bkt.clouddn.com/node2-2.png" alt></p>
<p>可以发现两端代码特别相似，原来是用http.createServer方法新建一个app实例，现在则是用Express的构造方法，生成一个Epress实例，两种方法的回调函数都是相同的，<br>Express等于在HTTP模块之上，加了一个<strong>中间层</strong></p>
<h3 id="什么是中间件"><a href="#什么是中间件" class="headerlink" title="什么是中间件"></a>什么是中间件</h3><p>中间件就是处理HTTP请求的函数，<br>特点：一个中间件处理完再传递给下一个中间件，APP实例在运行中会调用一系列的中间件</p>
<p>每个中间件可以从APP实例接收三个参数 request(代表HTTP请求)，response(代表HTTP响应),next回调函数(代表下一个中间件)，每一个中间件都可以对HTTP请求(request对象)进行加工，并且决定是否调用next方法，将request对象再传给下一个中间件</p>
<p>最简单的中间件</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uselessMiddleware</span><span class="params">(req,res,next)</span></span>&#123;</span><br><span class="line"><span class="built_in">next</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">上面代码的<span class="built_in">next</span>就是下一个中间件。如果它带有参数，则代表抛出一个错误，参数为错误文本。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uselessMiddleware</span><span class="params">(req, res, next)</span></span> &#123;</span><br><span class="line">  <span class="built_in">next</span>(<span class="string">'出错了！'</span>);</span><br><span class="line">&#125;</span><br><span class="line">抛出错误以后，后面的中间件将不再执行，直到发现一个错误处理函数为止。</span><br></pre></td></tr></table></figure>
<h5 id="use方法"><a href="#use方法" class="headerlink" title="use方法"></a>use方法</h5><p>use是express注册中间件的方法，使用app.use方法，注册了两个中间件，收到HTTP请求后，先调用第一个中间件，根据next()确定是否把request对象传递到下一个中间件</p>
<figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line">var express = require(<span class="string">"express"</span>);</span><br><span class="line">var http = require(<span class="string">"http"</span>);</span><br><span class="line"></span><br><span class="line">var app = express();</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">function</span>(<span class="built_in">request</span>, <span class="built_in">response</span>, <span class="keyword">next</span>) &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="string">"In comes a "</span> + <span class="built_in">request</span>.method + <span class="string">" to "</span> + <span class="built_in">request</span>.url);</span><br><span class="line">  <span class="keyword">next</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">function</span>(<span class="built_in">request</span>, <span class="built_in">response</span>) &#123;</span><br><span class="line">  <span class="built_in">response</span>.writeHead(<span class="number">200</span>, &#123; <span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span> &#125;);</span><br><span class="line">  <span class="built_in">response</span>.<span class="keyword">end</span>(<span class="string">"Hello world!\n"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">http.createServer(app).listen(<span class="number">1337</span>);</span><br></pre></td></tr></table></figure>
<p>use方法内部通过<code>request.url</code>的属性可以根据访问路径进行判断，据此就能实现简单的路由，</p>
<figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line">var express = require(<span class="string">"express"</span>);</span><br><span class="line">var http = require(<span class="string">"http"</span>);</span><br><span class="line">var app = express();</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">function</span>(<span class="built_in">request</span>,<span class="built_in">response</span>,<span class="keyword">next</span>)&#123;</span><br><span class="line">     <span class="keyword">if</span>(<span class="built_in">request</span>.url == <span class="string">"/"</span>)&#123;</span><br><span class="line">    <span class="built_in">response</span>.writeHead(<span class="number">200</span>, &#123; <span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span> &#125;);</span><br><span class="line">    <span class="built_in">response</span>.<span class="keyword">end</span>(<span class="string">"Welcome to the homepage!\n"</span>);</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">     <span class="keyword">next</span>();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">function</span>(<span class="built_in">request</span>, <span class="built_in">response</span>, <span class="keyword">next</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">request</span>.url == <span class="string">"/about"</span>) &#123;</span><br><span class="line">    <span class="built_in">response</span>.writeHead(<span class="number">200</span>, &#123; <span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span> &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">next</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">app.use(<span class="keyword">function</span>(<span class="built_in">request</span>, <span class="built_in">response</span>) &#123;</span><br><span class="line">  <span class="built_in">response</span>.writeHead(<span class="number">404</span>, &#123; <span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span> &#125;);</span><br><span class="line">  <span class="built_in">response</span>.<span class="keyword">end</span>(<span class="string">"404 error!\n"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">http.createServer(app).listen(<span class="number">1337</span>);</span><br></pre></td></tr></table></figure>
<p>另外一种比较清晰的方式（上面代码表示，只对根目录的请求，调用某个中间件。<br>）<br><code>app.use(&#39;/path&#39;, someMiddleware);</code><br>按照这个思想，改造中间件</p>
<figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line">var express = require(<span class="string">"express"</span>);</span><br><span class="line">var http = require(<span class="string">"http"</span>);</span><br><span class="line"></span><br><span class="line">var app = express();</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">"/home"</span>, <span class="keyword">function</span>(<span class="built_in">request</span>, <span class="built_in">response</span>, <span class="keyword">next</span>) &#123;</span><br><span class="line">  <span class="built_in">response</span>.writeHead(<span class="number">200</span>, &#123; <span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span> &#125;);</span><br><span class="line">  <span class="built_in">response</span>.<span class="keyword">end</span>(<span class="string">"Welcome to the homepage!\n"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">"/about"</span>, <span class="keyword">function</span>(<span class="built_in">request</span>, <span class="built_in">response</span>, <span class="keyword">next</span>) &#123;</span><br><span class="line">  <span class="built_in">response</span>.writeHead(<span class="number">200</span>, &#123; <span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span> &#125;);</span><br><span class="line">  <span class="built_in">response</span>.<span class="keyword">end</span>(<span class="string">"Welcome to the about page!\n"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">function</span>(<span class="built_in">request</span>, <span class="built_in">response</span>) &#123;</span><br><span class="line">  <span class="built_in">response</span>.writeHead(<span class="number">404</span>, &#123; <span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span> &#125;);</span><br><span class="line">  <span class="built_in">response</span>.<span class="keyword">end</span>(<span class="string">"404 error!\n"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">http.createServer(app).listen(<span class="number">1337</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>面向未来的API-GraphQL</title>
    <url>/2019/12/23/GraphQL/</url>
    <content><![CDATA[<h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p>你有没有遇到以下问题</p>
<ul>
<li>字段冗余</li>
</ul>
<p><img src="http://cdn.anruence.com/%E7%A3%90%E7%9F%B3%E6%95%B0%E6%8D%AE.png" alt="image"></p>
<ul>
<li>若干个不得不发的HTTP请求</li>
</ul>
<p><img src="http://cdn.anruence.com/graphql1.png" alt="image"></p>
<p>发生这些，并不是前端er本意，但是又要承担诸如页面渲染慢等副作用而被用户诟病<br>究其原因，是前端在数据层面没有主动权</p>
<p>针对但不限于以上种种<br>我们需要以前端的设计者和开发者的角度出发 设计新的数据查询方式</p>
<p>Facebook工程师率先提出RESTful架构体系的替代方案</p>
<p>并且应用在了其应用中</p>
<p><a href="https://www.youtube.com/watch?v=WxPtYJRjLL0&amp;t=2s" target="_blank" rel="noopener">Facebook 使用graphql重构他们的pc站</a></p>
<p>接下来 让我们站在巨人的肩膀上，由浅至深聊聊被称之为面向未来的API的-GraphQL</p>
<a id="more"></a>
<h1 id="明确本文的边界"><a href="#明确本文的边界" class="headerlink" title="明确本文的边界"></a>明确本文的边界</h1><p>本文主要介绍接触GraphQL这段时间，觉得必须要掌握的一些核心 适合以下人群</p>
<ul>
<li>完全没听说过GraphQL</li>
<li>听说过GraphQL的读者，想深入了解一下</li>
<li>想系统地学习GraphQL的读者</li>
<li>正在调研GraphQL技术的读者</li>
</ul>
<p>帮助你对GraphQL建立一个统观全局的认知及原理性的解读</p>
<p>你可能会得到以下解答</p>
<ul>
<li>重新思考RESTful</li>
<li>what GraphQL</li>
<li>RESTful &amp; GraphQL</li>
<li>how GraphQL</li>
<li>GraphQL组成链路</li>
<li>阻碍你使用GraphQL的N个问题</li>
<li>现有应用的接入方式</li>
<li>GraphQL不足</li>
<li>基于GraphQL的社区解决方案</li>
<li>小结</li>
</ul>
<h1 id="重新思考RESTful"><a href="#重新思考RESTful" class="headerlink" title="重新思考RESTful"></a>重新思考RESTful</h1><ul>
<li>接口数膨胀，需自行组合多个接口才能获取到完整的数据结构</li>
<li>API文档更新不及时，联调基本靠猜</li>
<li>客户端对接口数据类型校验</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">- 除了服务端要校验客户端传来的参数，客户端自己也需要去校验服务端返回的参数</span><br><span class="line">- 比如客户端要的是数组，你有没有返回数组</span><br><span class="line">- 需要依赖类似出<span class="keyword">var</span> x = <span class="keyword">data</span>?(<span class="keyword">data</span>.obj?<span class="keyword">data</span>.obj.name:<span class="literal">null</span>):<span class="literal">null</span>兼容</span><br></pre></td></tr></table></figure>
<ul>
<li>接口字段冗余，移动/PC需求无法满足</li>
</ul>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>冗余数据的返回浪费了流量</span><br><span class="line"><span class="bullet">- </span>服务端决定有哪些数据获取方式，客户端只能挑选使用，如果数据过于冗余也只能默默接收再对数据进行处理</span><br><span class="line"><span class="bullet">- </span>而数据不能满足需求则需要请求更多的接口</span><br></pre></td></tr></table></figure>
<ul>
<li>前后端字段命名规范不一致，</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">依赖数据层逐量转换</span><br></pre></td></tr></table></figure>
<ul>
<li>维护多版本接口</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">任何的变动都会被视为一种破坏性的改变，而破坏性改变就需要更新API的版本</span><br></pre></td></tr></table></figure>
<h2 id="我的诉求"><a href="#我的诉求" class="headerlink" title="我的诉求"></a>我的诉求</h2><ol>
<li>可不可以客户端要什么字段，服务端就给什么字段的值？</li>
<li>可不可以定义一个返回数据格式与请求的数据格式的一个强类型的约束？</li>
<li>能不能客户端可以问服务端要1、2、3这些数据，服务端一次给我返回就行？</li>
</ol>
<p>GraphQL的出现就是为了解决RESTful的痛点</p>
<h1 id="what-GraphQL"><a href="#what-GraphQL" class="headerlink" title="what GraphQL"></a>what GraphQL</h1><p><a href="http://graphql.org" target="_blank" rel="noopener">GraphQl官网</a></p>
<p><a href="https://graphql.cn/" target="_blank" rel="noopener">GraphQL中文网</a></p>
<blockquote>
<p>它既是一种用于 API 的查询语言(规范) 也是一个满足你数据查询的运行时</p>
</blockquote>
<p>强类型可以在查询执行之前进行验证</p>
<p>用于组织应用程序中数据的创建，读取，更新和删除（是的，CRUD）</p>
<p>脑袋里巨大的问号❓ API怎么就可以查询呢？</p>
<p>这正是其强大之处</p>
<blockquote>
<p>ask exactly what you want.</p>
</blockquote>
<ul>
<li>用已有的代码和技术来进行数据源管理</li>
<li>对API数据提供了一套易于理解的完整描述</li>
<li>非数据库查询语言，不是一门语言/框架 </li>
<li>不绑定任何的数据库或者存储引擎</li>
<li>使得客户端能按需获取数据，无冗余</li>
<li>让API更容易随着时间推移而演进</li>
<li>GraphQL = Graph (图表化/可视化)+ QL (查询语言)</li>
<li>是一种描述客户端如何向服务端请求数据的API语法</li>
</ul>
<h1 id="RESTful-amp-GraphQL"><a href="#RESTful-amp-GraphQL" class="headerlink" title="RESTful &amp; GraphQL"></a>RESTful &amp; GraphQL</h1><h2 id="资源获取"><a href="#资源获取" class="headerlink" title="资源获取"></a>资源获取</h2><p><img src="http://cdn.anruence.com/rest.png" alt="image"></p>
<ul>
<li>RESTful 用不同URL来区分资源，GraphQL 用特有的类型区分资源</li>
<li>获取相同资源REST API需要聚合多个接口</li>
<li>获取相同资源GraphQL只需一次请求获取多组数据</li>
<li>GraphQL更有效率更强大更灵活，对前端更友好</li>
</ul>
<h2 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h2><p><img src="http://cdn.anruence.com/graphql%20%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96.png" alt="image"></p>
<ul>
<li>获取数据的方式由==这里有什么==向 ==你需要什么==转变 </li>
<li>GraphQL可以简化理解成一个灵活的ajax接口</li>
<li>客户端完全自主决定获取信息的内容，服务端负责精确的返回目标数据</li>
</ul>
<h2 id="GraphQL优点"><a href="#GraphQL优点" class="headerlink" title="GraphQL优点"></a>GraphQL优点</h2><ul>
<li>请求你所要的数据，不多不少</li>
</ul>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>向你的 API 发出一个 GraphQL 请求就能准确获得你想要的数据，不多不少。</span><br><span class="line"><span class="bullet">- </span>GraphQL 查询总是返回可预测的结果。使用 GraphQL 的应用可以工作得又快又稳，因为控制数据的是应用，而不是服务器。</span><br></pre></td></tr></table></figure>
<p><img src="http://cdn.anruence.com/graphql-fetchdata.png" alt="image"></p>
<ul>
<li>获取多个资源，只需要一个请求</li>
</ul>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>GraphQL 查询不仅能够获得资源的属性，还能沿着资源间引用进一步查询</span><br><span class="line"><span class="bullet">- </span>典型的 REST API 请求多个资源时得载入多个 URL</span><br><span class="line"><span class="bullet">- </span>GraphQL 可以通过一次请求就获取你应用所需的所有数据</span><br><span class="line"><span class="bullet">- </span>即使是比较慢的移动网络连接下，使用 GraphQL 的应用也能表现得足够迅速。</span><br></pre></td></tr></table></figure>
<p><img src="http://cdn.anruence.com/graphQL-huoqu.png" alt="image"></p>
<ul>
<li>描述所有可能的类型系统（强类型自身）</li>
</ul>
<p>强类型可以在查询执行之前进行验证</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>GraphQL API 基于类型和字段的方式进行组织，而非入口端点</span><br><span class="line"><span class="bullet">- </span>你可以通过一个单一入口端点得到你所有的数据能力</span><br><span class="line"><span class="bullet">- </span>GraphQL 使用类型来保证应用只请求可能的数据</span><br><span class="line"><span class="bullet">- </span>还提供了清晰的辅助性错误信息</span><br><span class="line"><span class="bullet">- </span>应用可以使用类型，而避免编写手动解析代码。</span><br></pre></td></tr></table></figure>
<ul>
<li>强大的开发者工具</li>
</ul>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>代码即文档</span><br><span class="line"><span class="bullet">- </span>不用离开编辑器就能准确知道你可以从 API 中请求的数据</span><br><span class="line"><span class="bullet">- </span>发送查询之前就能高亮潜在问题，高亮代码智能提示</span><br><span class="line"><span class="bullet">- </span>提供了GraphiQL图形界面编写可测试的查询语句</span><br></pre></td></tr></table></figure>
<ul>
<li>无版本约束 平滑演进（<font color="red">GraphQL的设计精髓</font>）</li>
</ul>
<blockquote>
<p>由于仅返回明确的请求数据，所以设计良好的「GraphQL API」不存在「接口突变」的情况，这是从「版本化」到「无版本」的一个明确转变！</p>
</blockquote>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>给你的 GraphQL API 添加字段和类型而无需影响现有查询</span><br><span class="line"><span class="bullet">- </span>老旧的字段可以废弃，从工具中隐藏</span><br><span class="line"><span class="bullet">- </span>通过使用单一演进版本，GraphQL API 使得应用始终能够使用新的特性，并鼓励使用更加简洁、更好维护的服务端代码</span><br></pre></td></tr></table></figure>
<h1 id="GraphQL改善RESTful"><a href="#GraphQL改善RESTful" class="headerlink" title="GraphQL改善RESTful"></a>GraphQL改善RESTful</h1><p>了解了GraphQL的一大堆特点，我们开篇的诉求解决了吗？</p>
<p><img src="http://cdn.anruence.com/graphql99.png" alt="image"></p>
<p>到这里 我们看到了GraphQL 原则上的可行性</p>
<h1 id="How-GraphQL"><a href="#How-GraphQL" class="headerlink" title="How GraphQL"></a>How GraphQL</h1><p>接下来 趁热打铁 来聊聊怎么用GraphQL</p>
<p><img src="http://cdn.anruence.com/graphql-banner.png" alt="image"></p>
<p>官网上特别醒目的一张图，我们可以得到如下信息</p>
<ul>
<li>服务端定义好强类型的数据入参和返回的数据结构</li>
<li>客户端发送一个带有查询语句（GraphQL查询协议）的请求，定义好返回数据的格式及类型</li>
<li>返回符合客户端预期的Json字符串结果</li>
</ul>
<font color="red">再通俗一点</font>

<p>我们拥有UI，并且需要用数据填充它，因此我们向服务器进行查询<br>使用传统的REST API，我们的查询将以GET请求的形式出现 借助GraphQL，我们引入了一种用于请求数据的新语法</p>
<h3 id="一个基础的GraphQL服务"><a href="#一个基础的GraphQL服务" class="headerlink" title="一个基础的GraphQL服务"></a>一个基础的GraphQL服务</h3><h4 id="GraphQL服务-类型（schema）-解析器-（resolve）"><a href="#GraphQL服务-类型（schema）-解析器-（resolve）" class="headerlink" title="GraphQL服务 = 类型（schema） + 解析器 （resolve）"></a>GraphQL服务 = 类型（schema） + 解析器 （resolve）</h4><p>明确以下知识点</p>
<ul>
<li>为了发出GraphQL请求，我们需要有一个GraphQL服务器</li>
<li>GraphQL服务器是附加了GraphQL模式的常规HTTP服务器</li>
<li>类型系统描述了数据的类型与结构，但它只是形状，不包含真正的数据</li>
<li>通过编写Resolver函数，从而去获取真正的数据</li>
</ul>
<p><img src="http://cdn.anruence.com/graphQL%20lizi.png" alt="image"></p>
<ul>
<li>服务端（或中间层）需要描述所有可能的类型系统（schema）</li>
</ul>
<p><img src="http://cdn.anruence.com/graphql.png" alt="image"></p>
<ul>
<li>按你所需请求你所需要的数据，解决了不同客户端不同的渲染需求</li>
</ul>
<p>是不是贼简单～</p>
<p>不知道你没有注意到 上面我们提到了<font color="red">GraphQL查询协议</font></p>
<h2 id="GraphQL查询协议"><a href="#GraphQL查询协议" class="headerlink" title="GraphQL查询协议"></a>GraphQL查询协议</h2><p>GraphQL有三种请求方式</p>
<ul>
<li>query(请求)   </li>
<li>mutation(修改)</li>
<li>subscribe(订阅)</li>
</ul>
<p>GraphQL的核心依赖于简单的GET或POST请求来将数据往返于客户端，而GraphQL只是一个经过修饰的GET或POST请求，通过 <a href="https://myapp.com/graphql" target="_blank" rel="noopener">https://myapp.com/graphql</a><br>之类的URL发送到GraphQL服务器</p>
<p>是的，虽然GraphQL确实引入了一些新的概念来组织数据进行交互，但在幕后，但GraphQL仍然依靠良好的HTTP请求来实现其神奇效果</p>
<p>只需要为类型系统的字段编写函数，GraphQL 就能通过优化并发的方式来调用它们</p>
<p>具体参照如上的demo，建议拷贝代码亲自感受一下</p>
<h1 id="GraphQL组成链路"><a href="#GraphQL组成链路" class="headerlink" title="GraphQL组成链路"></a>GraphQL组成链路</h1><p>当然了 对于开发者来说，我们无非关注两点</p>
<ul>
<li>客户端做什么？</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">向服务端发送查询字符串</span><br></pre></td></tr></table></figure>
<ul>
<li>服务端做什么？</li>
</ul>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">基于GraphQL构建类型系统 </span><br><span class="line">定义与<span class="keyword">Query</span>下字段对应的resolver</span><br><span class="line">可以在resolver获取真正的数据</span><br></pre></td></tr></table></figure>
<h2 id="资源路径图"><a href="#资源路径图" class="headerlink" title="资源路径图"></a>资源路径图</h2><p><img src="http://cdn.anruence.com/ziyuanlujing.png" alt="image"></p>
<p>客户端 Schema 本质上就是一段字符串，服务端如何识别并响应这段字符串？</p>
<h2 id="服务端执行过程"><a href="#服务端执行过程" class="headerlink" title="服务端执行过程"></a>服务端执行过程</h2><p><img src="http://cdn.anruence.com/%E6%9C%8D%E5%8A%A1%E7%AB%AF.png" alt="image"></p>
<p>拿到客户端字符串之后，依赖官方类库graphql-js,服务端具体执行经历三个阶段</p>
<ul>
<li>解析：逐字符扫描，如果不符合服务端定义的AST规范，解析过程会直接跑出语法异常，当然了，是结构化报错</li>
<li>校验：发起了查询，GraphQL会解析我们的查询语句，确保啊我们查询的结构是存在的，参数是足够的，类型是一致的，任何环节出了问题，都将返回错误信息</li>
<li>执行：验证通过后，GraphqL会根据query语句包含的字段结构一一触发对应的Resolver函数，获取查询结果，也就是说 如果前端没有查询某个字段，就不会触发该字段对应的Resolver函数，也就不会产生对数据的获取行为</li>
</ul>
<p>注：如果Reaolver返回的数据结构，大于Schema里描绘的结构，那么多出来的部分会被忽略，这是一个合理的设计，我们可以通过控制Schema 来控制前端的数据访问权限，防止意外的将用户的隐私信息泄漏出去 </p>
<h1 id="阻碍你使用GraphQL的N个问题"><a href="#阻碍你使用GraphQL的N个问题" class="headerlink" title="阻碍你使用GraphQL的N个问题"></a>阻碍你使用GraphQL的N个问题</h1><p>既然GraphQL那么方便，为啥没有大火呢？<br>结合了多篇文章，整理了若干了阻止你使用GraphQL的N个问题</p>
<p>一起来看一看</p>
<h2 id="GraphQL一定要操作数据库？"><a href="#GraphQL一定要操作数据库？" class="headerlink" title="GraphQL一定要操作数据库？"></a>GraphQL一定要操作数据库？</h2><ul>
<li>数据提供方编写GraphQL Schema</li>
<li>数据消费方编写GraphQL Query</li>
<li>GraphQL只是关于schema和resolver的一一对应和调用，它并为对数据的获取方式和来源做任何假设</li>
</ul>
<h2 id="GraphQL-跟-RESTful-api-是对立的？"><a href="#GraphQL-跟-RESTful-api-是对立的？" class="headerlink" title="GraphQL 跟 RESTful api 是对立的？"></a>GraphQL 跟 RESTful api 是对立的？</h2><p>两者不仅不是对立的，还可以相互结合<br>事实上可以把Query 下的字段，理解为一个个 RESTful API</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">Query</span> &#123;</span><br><span class="line">   hello: <span class="type">String</span>,</span><br><span class="line">   sayhi:<span class="type">String</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="GraphQL不一定需要Schema（类型系统）？"><a href="#GraphQL不一定需要Schema（类型系统）？" class="headerlink" title="GraphQL不一定需要Schema（类型系统）？"></a>GraphQL不一定需要Schema（类型系统）？</h2><ul>
<li>GraphQL Type System 是一个静态的类型系统，我们可以称之为静态类型 GraphQL</li>
<li>此外，社区还有一种动态类型的 GraphQL 实践，它跟静态类型的 GraphQL 差别在于，没有了基于 Schema 的数据形状验证阶段，而是直接无脑地根据 query 查询语句里的字段，去触发 Resolver 函数，动态类型的 GraphQL 有一定的便利性，不过，它同时丧失了 GraphQL 的部分精髓</li>
</ul>
<h2 id="GraphQL-一定是后端服务？"><a href="#GraphQL-一定是后端服务？" class="headerlink" title="GraphQL 一定是后端服务？"></a>GraphQL 一定是后端服务？</h2><p>尽管绝大多数 GraphQL，都以 server 的形式存在。 但它并没有限制在后端场景</p>
<p> <a href="https://codesandbox.io/s/youthful-mestorf-r8s38" target="_blank" rel="noopener">在浏览器中运行</a> </p>
<h1 id="现有应用的接入方式"><a href="#现有应用的接入方式" class="headerlink" title="现有应用的接入方式"></a>现有应用的接入方式</h1><h2 id="暴力改造RESTful-Like模式"><a href="#暴力改造RESTful-Like模式" class="headerlink" title="暴力改造RESTful-Like模式"></a>暴力改造RESTful-Like模式</h2><p>RESTful -&gt; GraphQL</p>
<ul>
<li>就是简单粗暴的把 RESTful API 服务，替换成 GraphQL 实现。之前有多少 RESTful 服务，重构后就有多少 GraphQL 服务，</li>
<li>默认情况下，面向两个 GraphQL 服务发起的查询是两次请求，而不是一次</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前端需要产品数据时，从之前调用产品相关的 RESTful API，变成查询产品相关的 GraphQL。不过，需要订单相关的数据时，可能要查询另一个 GraphQL 服务</span><br></pre></td></tr></table></figure>
<ul>
<li>它是一个简单的一对一关系</li>
</ul>
<p>收益甚微 选型失误</p>
<h2 id="作为中间层"><a href="#作为中间层" class="headerlink" title="作为中间层"></a>作为中间层</h2><p>同样是API Gateway角色的GraphQL服务，在实现方式上有不同的分类 </p>
<ul>
<li>1，传统意义上的后端服务（包含大量真实的数据操作和处理的 GraphQL）</li>
<li>2，<font color="red">GraphQL as BFF</font>（转发接口请求，聚合数据结果的GraphQL）</li>
</ul>
<p>我们今天主要讨论 第二种</p>
<p><img src="http://cdn.anruence.com/%E6%8E%A5%E5%85%A5%E6%96%B9%E5%BC%8F.png" alt="image"></p>
<ul>
<li>前端不再直接调用具体的 RESTful 等接口，而是通过 GraphQL 去间接获取产品、订单、搜索等数据</li>
<li>在 GraphQL 这个中间层里，我们将各个微服务，按照它们的数据关联，整合成一个基于 GraphQL Schema 的数据关系网络。前端可以通过 GraphQL 查询语句，同时发起对多个微服务的数据的获取、筛选、裁剪等行为。</li>
<li>作为 API Gateway 的 GraphQL 服务，可以在其 Resolver 内，向前面提到的 RESTful-like 的 GraphQL 发起查询请求</li>
<li>既避免了前端需要一对多的问题，也解决了 API Gateway GraphQL 需要请求 RESTful 全量数据接口的内部冗余问题</li>
</ul>
<p><img src="http://cdn.anruence.com/airbnb.png" alt="image"></p>
<p>将 GraphQL schemas转化为 Thhrift IDL，再统一操作底层数据</p>
<p><img src="http://cdn.anruence.com/%E5%BE%AE%E6%9C%8D%E5%8A%A1..png" alt="image"></p>
<h1 id="GraphQL不足"><a href="#GraphQL不足" class="headerlink" title="GraphQL不足"></a>GraphQL不足</h1><ul>
<li>改造成本：后端服务需要按领域进行重构</li>
<li>存量大：迁移困难</li>
<li>数据库性能</li>
</ul>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>GraphQL 虽然解决将多个 HTTP 请求聚合成了一个请求，但是schema 会逐层解析方式递归获取全部数据</span><br><span class="line"><span class="bullet">- </span>前端请求少了但是query很多 数据库设计影响日后性能</span><br><span class="line"><span class="bullet">- </span>后端对前端改造无感知：前端修改了GraphQL的请求格式，可能会造成深层嵌套，对后端服务有较大影响</span><br></pre></td></tr></table></figure>
<ul>
<li>侵入性：前端利好，却需要服务端鼎力支持</li>
<li>复杂性：学习成本高</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">需要了解GraphQL一整套类型系统</span><br></pre></td></tr></table></figure>
<ul>
<li>典型的N+1问题</li>
</ul>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">使用REST API 是很容易评估 ，识别和解决<span class="built_in">N</span>+<span class="number">1</span>问题的</span><br><span class="line">使用GraphQL会使这个问题变得相对复杂</span><br></pre></td></tr></table></figure>
<ul>
<li>数据缓存问题</li>
</ul>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="built_in">REST</span>强制使用具有缓存机制的HTTP协议 ，可以通过它 避免活回去多余资源</span><br><span class="line">GraphQL没有缓存机制，它把缓存的重任交给了用户</span><br></pre></td></tr></table></figure>
<ul>
<li>可见，整体来看，实际接入GraphQL并非易事，它只是一套规范，各种语言实现不一致，周边生态不够完善，需要后端配合改造，成本大，</li>
<li>除此之外，还有各种错误处理，日志上报及缓存机制的处理办法良莠不齐</li>
</ul>
<p>正因如此，GraphQL很长一段时间还不能发挥其巨大作用</p>
<p>这一切 随着 Apollo 登场 正在逐步改善</p>
<h1 id="基于GraphQL的社区解决方案"><a href="#基于GraphQL的社区解决方案" class="headerlink" title="基于GraphQL的社区解决方案"></a>基于GraphQL的社区解决方案</h1><h2 id="Apollo"><a href="#Apollo" class="headerlink" title="Apollo"></a>Apollo</h2><p>可以把GraphQL理解成NodeJS的http包，那么Apollo-server就类似于在前面基础上封装出来的框架</p>
<h3 id="Apollo-Client"><a href="#Apollo-Client" class="headerlink" title="Apollo-Client"></a>Apollo-Client</h3><p>web，iOS，Android三端的实现</p>
<h3 id="Apollo-Server"><a href="#Apollo-Server" class="headerlink" title="Apollo-Server"></a>Apollo-Server</h3><p>koa，express等NodeJsWeb的实现</p>
<p>还提供了如下能力</p>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>接口格式五花八门，错误处理也没有统一的方案，Apollo会将所有的错误内容格式化统一的错误信息，从此可以摆脱后端带来的束缚，方便我们在前端去处理。</p>
<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>借助GraphQL的makeExecutableSchema和mergeSchemas方法，能够按模块去编写类型定义及resolve，最后使用mergeSchemas将他们合并到一起</p>
<h3 id="错误监控"><a href="#错误监控" class="headerlink" title="错误监控"></a>错误监控</h3><p>Apollo server提供formatError，formatResponse，能够细化到每一次请求，每一次错误的发生，方便我们去上报日志及错误</p>
<p>工作流程</p>
<p><img src="http://cdn.anruence.com/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88wee.png" alt="image"></p>
<p>接入架构设想</p>
<p><img src="http://cdn.anruence.com/jiagoushaxiang.png" alt="image"></p>
<ul>
<li>通过复用现有的REST接口，做到无需后端配合改造</li>
<li>在我们开发的项目里，由于会对接不同的后端团队，伴随着一些历史遗留问题，接口格式五花八门，错误处理也没有统一的方案，Apollo会将所有的错误内容格式化统一的错误信息，从此可以摆脱后端带来的束缚，方便我们在前端去处理</li>
<li>在开发大型应用中，模块是是必不可少的。借助GraphQL的makeExecutableSchema和mergeSchemas方法，能够按模块去编写类型定义及resolve，最后使用mergeSchemas将他们合并到一起</li>
<li>由于接入了node server，那么我们需要监控错误以及请求日志等内容，Apollo server提供formatError，formatResponse，能够细化到每一次请求，每一次错误的发生，方便我们去上报日志及错误</li>
</ul>
<p>接入成果设想<br><img src="http://cdn.anruence.com/chengguoshexiang.png" alt="image"></p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul>
<li><font color="red">更准确的获取你想要的数据</font> - 核心诉求</li>
<li>控制数据的是应用而非服务器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在应用层对数据模型的抽象</span><br></pre></td></tr></table></figure>
<ul>
<li>将你需要的数据汇聚成数据网格</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前端不能通过一次查询直接得到自己所需要的数据，Graphql的查询不仅指定了要查询的信息同时给出了期望的数据结构</span><br></pre></td></tr></table></figure>
<ul>
<li>应对复杂场景的一种新思路 thinking in graph</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">设计 GraphQL接口更像是在建立资源与资源之间的关系，并最终得到一个单一内聚图的过程 GraphQL 给了我们一种基于「图」的设计思路</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>前后端分离的演进</title>
    <url>/2019/03/05/FrontBackSeparation/</url>
    <content><![CDATA[<p>有幸参与了所在项目的架构升级，初次接触到了<code>SSR</code>的概念，就越发感兴趣 我们站在巨人的肩膀上一边享受社区红利，一边躁动不安</p>
<p><strong>鲁迅先生说过</strong></p>
<blockquote>
<p>技术上的问题总有技术去解决<br>没错 比如我现在就学会问 <code>为什么</code><br>为什么会如此发展？为什么会有这个概念？它能解决什么问题？它从哪里来.. 又要到哪里去..emm..</p>
</blockquote>
<hr>
<p>事实上，任何一项技术的发展 都是由<strong>问题</strong>推动的，所以 <code>trouble is friends</code>！</p>
<p>工作时间不短不长，刚好经历了几个阶段.</p>
<a id="more"></a>
<h3 id="第一阶段（静态页面万岁）"><a href="#第一阶段（静态页面万岁）" class="headerlink" title="第一阶段（静态页面万岁）"></a>第一阶段（静态页面万岁）</h3><p>两年前入职的时候，就用的如此神奇的技术，当时<code>react、vue</code>等已经热火朝天了，我表示很惊讶，因为刚毕业就加入<code>react</code>大军了，当时还用的是蚂蚁金服还在<code>degugger</code>阶段的 <code>dva</code>,对于当时的我来讲，这种歌神奇的技术第一次真正接触，写好页面，就扔给后端小哥哥了，还真的不习惯，比较闹心的一点是 没有bug还好，一旦需要调试，会跟后端小哥哥一起看，是真的浪费时间，重点是效率也贼低.</p>
<p>其实现在看来 ，这大概是最初的前后端分离<br>前端负责静态页面和交互，后端可能就要负责数据处理并返回完整的页面<br>一旦涉及到诸如JSP、PHP smarty 模版的编写，就容易职责不清了..以至于互相甩锅！</p>
<p><strong>缺点明显：</strong></p>
<ol>
<li>前后端分工不明，难以实现效率最大化</li>
<li>前端会极度依赖后端环境，数据格式的沟通成本过高</li>
<li>不利于前端技术的发展</li>
</ol>
<h3 id="第二阶段（AJAX时代）"><a href="#第二阶段（AJAX时代）" class="headerlink" title="第二阶段（AJAX时代）"></a>第二阶段（AJAX时代）</h3><p>随着前端技术的发展，尤其是AJAX和Node.js的出现，一种前后端分离的架构模式应运而生，极大的缓解了前后端RD会互相撕逼的bug，前后端分工变得清晰，以AJAX接口当作桥梁，各取所需（😂）</p>
<p>emm..徒手画的还不是特别准确的图来意会一下用户请求页面的过程<br><img src="/images/cache/ssr1.jpeg" alt="cache_detai"></p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li>分工明确，前后端各司其职，后端专注业务逻辑和功能的实现，前端专注页面设计。</li>
<li>接口明确，并行开发，在后端接口没有实现好之前，前端完全可以自己通过Node.js的的Web框架模拟接口<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4></li>
<li>数据请求，处理扽好复杂逻辑被移植到浏览器端，js脚本越来越复杂</li>
<li>不利于<strong>SEO</strong>（后面会解释）存在性能问题</li>
<li>这种模式下，用户必须等待js脚本加载完成，真正执行时发数据请求，等数据返回，脚本完成页面的渲染，才能看到页面，导致<strong>首屏展现时间拉长，特别是在移动互联网下，对首屏加载性能的影响很大</strong></li>
</ol>
<h3 id="第三阶段（SPA）"><a href="#第三阶段（SPA）" class="headerlink" title="第三阶段（SPA）"></a>第三阶段（SPA）</h3><p><strong>SPA</strong>（single page application）：是一种 网络应用程序(WebApp)模型<br>在传统的网站中，不同的页面之间的切换都是直接从服务器加载一整个新的页面，而SPA是通过动态重写页面的部分与用户交互，从而避免了过多的数据交换，响应速度更快</p>
<h4 id="目前常见的SPA框架"><a href="#目前常见的SPA框架" class="headerlink" title="目前常见的SPA框架"></a>目前常见的SPA框架</h4><ul>
<li>AngularJS</li>
<li>React</li>
<li>Vue.js</li>
</ul>
<p>任何技术架构的升级都不可能脱离时代永远存在，技术的演进一定会随着发展愈演愈烈</p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ol>
<li>前后端分离的优点它都有除此之外，它页面之间的切换很快<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4></li>
<li>首屏打开速度很慢，因为用户首次加载需要先下载SPA框架及应用程序的代码，然后再渲染页面</li>
<li>不利于<strong>SEO</strong></li>
</ol>
<p><strong>为什么SPA不利于SEO？</strong><br>目前而言，部分搜索引擎如Google、bing等，它们的爬虫虽然已经支持执行JS甚至是通过AJAX获取数据了，但是对于异步数据的支持也还不足(也可能是搜索引擎提供商觉得没必要)<br>SPA应用中，通常通过AJAX获取数据，而这里就难以保证我们的页面能被搜索引擎正常收录到。并且有一些搜索引擎不支持执行JS和通过AJAX获取数据，那就更不用提SEO了</p>
<h3 id="第四阶段（服务端渲染SSR）"><a href="#第四阶段（服务端渲染SSR）" class="headerlink" title="第四阶段（服务端渲染SSR）"></a>第四阶段（服务端渲染SSR）</h3><h4 id="什么是服务端渲染？"><a href="#什么是服务端渲染？" class="headerlink" title="什么是服务端渲染？"></a>什么是服务端渲染？</h4><p>服务端渲染会把数据请求过程放在服务端，相对于前后端分离的方式，获取数据提前，页面模版结合数据的渲染处理也会在服务端完成</p>
<h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol>
<li>当浏览器初次请求页面后，用户第一次拿到的HTML文档已经进行了初步的内容渲染，<strong>利于SEO优化 也解决了首屏的性能问题</strong></li>
<li>总的请求数并没有变，只是把浏览器的一部分数据请求转移到了服务器上 事实上 <strong>服务端进行数据拉取的成本要小于浏览器端，传输更加高效，这也是性能提升的关键</strong></li>
<li>更快的响应时间，不用等待所有的JS都下载完成，浏览器便能显示比较完整的页面了</li>
<li>更好的SEO，我们可以将SEO的关键信息直接在后台就渲染成HTML，而保证搜索引擎的爬虫都能爬取到关键数据<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4></li>
<li>相对于仅仅需要提供静态文件的服务器，SSR中使用的渲染程序自然会占用更多的CPU和内存资源</li>
<li>一些常用的浏览器API可能无法正常使用，比如window、docment和alert等，如果使用的话需要对运行的环境加以判断</li>
<li>服务器端渲染的结果与浏览器端的结果不一致</li>
</ol>
<p>技术的历史总是惊人的相似，这里的服务端渲染和开始的<code>smarty</code>等模版渲染并没有本质上的区别，当然了这并不是倒退，实际开发项目中，依赖react实现的服务端渲染并不是简单的渲染内容，也可以实现前后端代码复用 -&gt; <font color="red">同构</font></p>
<h3 id="第五阶段（SPA-SSR-同构）"><a href="#第五阶段（SPA-SSR-同构）" class="headerlink" title="第五阶段（SPA+ SSR 同构）"></a>第五阶段（SPA+ SSR 同构）</h3><h4 id="何为同构？"><a href="#何为同构？" class="headerlink" title="何为同构？"></a>何为同构？</h4><p>服务端渲染出最核心，最基本的信息，浏览器端针对交互完成进一步的渲染，事件绑定等增强功能</p>
<p><strong>但是 两端渲染必定有很对冗余代码逻辑（都有fetch数据的过程）</strong></p>
<p>同构：就是前后端共用一套代码逻辑，它就像是服务端与客户端渲染的交集，弥补了服务端和浏览器端的差异</p>
<p>好像很高级的样子</p>
<p>但是优劣也比较明显</p>
<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ol>
<li>更好的性能 渲染更加迅速 首屏展现的时间更快</li>
<li>SEO优化支持，服务端收到请去后 会返回一个相对完整，包含html的文档，所以更有利于搜索引擎爬虫获取信息，同时，更快的加载时间也有利于搜索结果展现排名的提升</li>
<li>实现灵活，服务端渲染做客户端渲染的后续的工作，实现代码复用</li>
<li>可维护性更强（同一套代码逻辑维护成本低）</li>
<li>对于低端机型友好,因为页面内容是在服务端渲染的 不至于出现白屏</li>
<li>弱网有好 不会再等js执行完毕再去呈现页面</li>
<li>更好的用户体验 可以将最重要的先渲染次重要的后渲染</li>
</ol>
<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>服务端逻辑增多</li>
<li>服务端无法完全复用浏览器端代码</li>
<li>增加了服务器的TTFB（time to frist byte）时间</li>
</ol>
<hr>
<p>总结</p>
<p>合理利用SSR 结合SPA 实现同构应用 是我们日后重心<br>下一篇将动手写个同构的demo</p>
<p>就这样。</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title>React陷阱</title>
    <url>/2017/07/02/React%E9%99%B7%E9%98%B1/</url>
    <content><![CDATA[<ul>
<li>不要改变props</li>
</ul>
<p>错误例子：</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">var <span class="keyword">component</span> = &lt;<span class="keyword">Component</span> /&gt;;</span><br><span class="line"><span class="keyword">component</span>.props.foo = x; // bad</span><br><span class="line"><span class="keyword">component</span>.props.bar = y; // also bad</span><br></pre></td></tr></table></figure>
<p>这样写是错误的，因为我们手动直接添加的属性React后续没办法检查到属性类型错误，也就是说，当我们手动添加的属性发生类型错误时，在控制台是看不到错误信息的</p>
<p>在React的设定中，初始化完props后，props是不可变的。改变props会引起无法想象的后果</p>
<p>正确写法：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">var</span> <span class="built_in">props</span> = &#123;&#125;;</span><br><span class="line"><span class="built_in">props</span>.foo = x;</span><br><span class="line"><span class="built_in">props</span>.bar = y;</span><br><span class="line"><span class="built_in">var</span> component = &lt;Component &#123;...<span class="built_in">props</span>&#125; /&gt;;</span><br></pre></td></tr></table></figure>
<p>当需要拓展我们的属性的时候，定义个一个属性对象，并通过{…props}的方式引入，React会帮我们拷贝到组件的props属性中。<br>重要的是—这个过程是由React操控的，不是手动添赋值的属性</p>
<p>需要覆盖的时候可以这么写</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">var props</span> = &#123; foo: <span class="string">'default'</span> &#125;;</span><br><span class="line"><span class="attribute">var component</span> = &lt;Component &#123;...props&#125; foo=&#123;<span class="string">'override'</span>&#125; /&gt;;</span><br></pre></td></tr></table></figure>
<ul>
<li>React默认会进行HTML的转义如下</li>
</ul>
<p>输入：</p>
<figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml">var content='<span class="tag">&lt;<span class="name">strong</span>&gt;</span>content<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>';</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">React.render(</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><span class="template-variable">&#123;content&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span>,</span></span><br><span class="line"><span class="xml">    document.body</span></span><br><span class="line"><span class="xml">);</span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">stonrg</span>&gt;</span>content<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>避免转义：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> content=<span class="string">'&lt;strong&gt;content&lt;/strong&gt;'</span>;    </span><br><span class="line"></span><br><span class="line">React.render(</span><br><span class="line">    &lt;div dangerouslySetInnerHTML=&#123;&#123;<span class="attr">__html</span>: content&#125;&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>,</span><br><span class="line">    <span class="built_in">document</span>.body</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ul>
<li>如果在编写时使用了react自定义属性  react是不会渲染的</li>
</ul>
<p>错误做法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">React.render(</span><br><span class="line">    &lt;div dd=<span class="string">'xxx'</span>&gt;content&lt;<span class="regexp">/div&gt;,</span></span><br><span class="line"><span class="regexp">    document.body</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure>
<p>正确做法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">React.render(</span><br><span class="line">    &lt;div data-dd=<span class="string">'xxx'</span> aria-dd=<span class="string">'xxx'</span>&gt;content&lt;<span class="regexp">/div&gt;,</span></span><br><span class="line"><span class="regexp">    document.body</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>你不知道的JS系列-作用域、变量提升、闭包</title>
    <url>/2019/03/25/actionScope/</url>
    <content><![CDATA[<p>来看几个既基本又重要的概念查漏补缺<br><a id="more"></a></p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>几乎所有编程语言最基础的功能之一 就是存储变量当中的值，并能在之后对这个值进行访问和修改<br>引出下面两个问题</p>
<ul>
<li>那这些变量存储在哪里？</li>
<li>程序需要的时候 如何找到他们？</li>
</ul>
<p>我们需要一套设计良好的规则来存储变量，并且之后可以方便的找到这些变量,它叫 <font color="red">作用域</font></p>
<h3 id="js程序编译原理"><a href="#js程序编译原理" class="headerlink" title="js程序编译原理"></a>js程序编译原理</h3><p>js是一门编译语言,但是与传统的编译语言不同，他不是提前编译的</p>
<p>js引擎进行编译的步骤和传统的编译语言非常相似,但是某些环节会更加复杂 例如：在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化,包括对冗余元素的优化</p>
<ul>
<li>分词/词法分析</li>
<li>解析/语法分析 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将词法单元流（数组）转化为AST（抽象语法树）</span><br></pre></td></tr></table></figure>
<ul>
<li>代码生成 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将AST转化为可执行代码</span><br></pre></td></tr></table></figure>
<p>js引擎执行一段可执行代码时，会创建对应的执行上下文，对于每个执行上下文，都有三个重要属性：</p>
<ul>
<li><p>变量对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">每一个执行上下文都会分配一个变量对象，变量对象的属性由变量和函数声明构成，在函数上下文的情况下，参数列表也会被加入到变量对象作为属性,不同作用域的变量对象互不相同，它保存了当前作用域的所有函数和变量</span><br></pre></td></tr></table></figure>
</li>
<li><p>作用域链</p>
</li>
<li><p>this指向</p>
<p>当你看到<code>var a = 2</code> 程序内部的工作过程</p>
</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">编译器将这端程序分解成词法单元 <span class="selector-tag">var</span> <span class="selector-tag">a</span>, a=<span class="number">2</span> 然后将词法单元解析成一个树结构</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>.遇到<span class="selector-tag">var</span> <span class="selector-tag">a</span> 编译器会询问作用域是否已经有该变量的名称存在于同一个作用域中,如果是，编译器忽略该声明 否则会要求作用域在当前作用域的集合中声明一个新的变量 命名为a</span><br><span class="line"><span class="number">2</span>.当为引擎生成运行时所需要的代码 a=<span class="number">2</span> js引擎运行时会询问作用域，当前作用域的集合中是否存在<span class="selector-tag">a</span> 存在 就是用 不存在就继续查找 如果还是找不到 就抛出异常</span><br></pre></td></tr></table></figure>
<p>总结：变量的赋值操作会执行两个过程</p>
<ul>
<li>编译器会在当前作用域中生成一个变量（之前没有生成过）这会在代码执行前进行</li>
<li>运行时js引擎会在作用域中查找（LHS查询）该变量能找到就给他赋值</li>
</ul>
<h4 id="js引擎是如何查找变量的？"><a href="#js引擎是如何查找变量的？" class="headerlink" title="js引擎是如何查找变量的？"></a>js引擎是如何查找变量的？</h4><p>LHS 查询 （赋值操作的目标是谁）<br>RHS查询 （谁是赋值操作的源头）</p>
<h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><p>大部分的标准语言编译器的第一个工作就叫词法化<br>词法化的过程会对源代码进行检查<br>词法作用域就是定义在词法阶段的作用域<br>词法作用域意味着作用域是由书写代码时函数声明的位置决定的</p>
<h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><p>函数是js中最常见的作用域单元 声明在一个函数内部的变量或函数会在所处的作用域中隐藏起来 这符合最小授权（暴露）原则</p>
<h4 id="最小授权（暴露）原则的好处？"><a href="#最小授权（暴露）原则的好处？" class="headerlink" title="最小授权（暴露）原则的好处？"></a>最小授权（暴露）原则的好处？</h4><ol>
<li>隐藏内部实现 API友好</li>
<li>规避冲突 （同名标识符之间的冲突）</li>
</ol>
<h3 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h3><p>块作用域是指变量和函数不仅可以属于所处的作用域也可以属于某个代码块儿{…}<br>ES3开始 try/catch结构在catch分句中具有块作用域<br>ES6引入了let const 可以用在循环中 会将当前的值重新绑定到了循环的每一个迭代中</p>
<hr>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>作用域是一套规则，用于确定在何处以及如何查找变量，如果查找的目的是对变量进行赋值，那么就会使用LHS查询，如果目的是为了获取变量的值 那就进行RHS查询 赋值操作会导致LHS查询</li>
<li>LHS与RHS查询都会从当前作用域中开始，如果有需要就会向上级作用域继续查找目标标识符。这样儿每次上升一级作用域，最后抵达迁居作用域 无论找到没找到都会停止</li>
<li>不成功的RHS引用会抛出异常 不成功的RHS引用会导致自动隐式创建一个全局变量</li>
<li>词法作用域意味着作用域是由书写代码时函数声明的位置决定的。编译的词法分析阶段基本能够知道全部标识符在哪里以及如何声明的，从而能够在执行过程中如何对他们进行查找</li>
<li>eval()与with() 可以扩充词法作用域 但是会有性能问题</li>
<li>函数是常见但不是唯一的作用域单元，函数作用域与块作用域的行为是一样儿的 任何声明在某个作用域内的变量都将附属于这个作用域</li>
<li>ES6中引入了let关键字 用来在任意代码块中声明变量</li>
</ul>
<h2 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h2><ul>
<li>先有声明 后有赋值</li>
<li>只有声明本身会被提升，而赋值等其他运行逻辑会留在原地，提升不会改变代码的执行顺序</li>
<li>注意避免重复声明</li>
<li>每个作用域都会进行提升操作</li>
<li>函数声明会被提升，函数表达式不会被提升</li>
<li>函数提升优先于变量提升</li>
<li>一个普通块内部的函数声明通常会被提升到所在作用域的顶部</li>
<li>无论作用域中的声明出现在什么地方，都将会在代码本身被执行前首先被处理（所有的变量声明和函数声明）都会被移动到各自作用域的最顶端</li>
</ul>
<hr>
<h2 id="作用域闭包"><a href="#作用域闭包" class="headerlink" title="作用域闭包"></a>作用域闭包</h2><ul>
<li>闭包无处不在 你需要的是识别并且拥抱它</li>
<li>闭包是基于词法作用域书写代码时产生的自然结果</li>
<li>当函数可以记住并访问所在的词法作用域时就产生了闭包 即使函数是在当前词法作用域之外执行</li>
<li>闭包可以使得函数可以继续访问定义时的词法作用域</li>
<li>如果将函数当作第一级的值类型并到处传递 就会看到闭包在这些函数中的应用</li>
<li>在定时器，事件监听器ajax请求 或者任何其他的异步任务重 之要使用了回调函数 实际上就是在使用闭包</li>
<li>闭包 就是关于如何在函数作为值按需传递的词法环境中书写代码的</li>
</ul>
<h3 id="循环与闭包"><a href="#循环与闭包" class="headerlink" title="循环与闭包"></a>循环与闭包</h3><p>块作用域和闭包联手便可天下无敌</p>
<p>使用IIFE（自执行函数）</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(var <span class="built_in">i</span> =<span class="number">1</span>; <span class="built_in">i</span>&lt;=<span class="number">5</span>;<span class="built_in">i</span>++)&#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span><span class="params">(j)</span>&#123;</span></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span><span class="params">()</span>&#123;</span></span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">'j'</span>,<span class="built_in">j</span>);</span><br><span class="line">  &#125;,<span class="built_in">i</span>*<span class="number">100</span>)</span><br><span class="line">  &#125;)(<span class="built_in">i</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let用来劫持块作用域 并且在这个块作用域中声明一个变量</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(var <span class="built_in">i</span> =<span class="number">1</span>; <span class="built_in">i</span>&lt;=<span class="number">5</span>;<span class="built_in">i</span>++)&#123;</span><br><span class="line">  let <span class="built_in">j</span> = <span class="built_in">i</span></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span><span class="params">()</span>&#123;</span></span><br><span class="line">    console.<span class="built_in">log</span>(<span class="built_in">j</span>);</span><br><span class="line">  &#125;,<span class="built_in">i</span>*<span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>循环头部的let声明 每次迭代都会声明</span><br><span class="line"><span class="keyword">for</span>(let <span class="built_in">i</span> =<span class="number">1</span>; <span class="built_in">i</span>&lt;=<span class="number">5</span>;<span class="built_in">i</span>++)&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span><span class="params">()</span>&#123;</span></span><br><span class="line">    console.<span class="built_in">log</span>(<span class="built_in">i</span>);</span><br><span class="line">  &#125;,<span class="built_in">i</span>*<span class="number">100</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>作用域</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title>实现一个SSR同构应用</title>
    <url>/2019/03/06/SSRDemo/</url>
    <content><![CDATA[<p>纸上得来终觉浅，我们来实现一个简易的服务端渲染流程，意在体会SSR带来的红利<br><a id="more"></a><br>页面源码来自<a href>React状态管理与同构实战</a></p>
<h2 id="几个重要的概念"><a href="#几个重要的概念" class="headerlink" title="几个重要的概念"></a>几个重要的概念</h2><p>实现<code>SSR</code>是依靠<code>React</code>提供的<code>ReactDomServer</code>对象</p>
<p>它主要提供了只能在服务端使用的<code>renderToString()</code>与<code>renderToStaticMarkup()</code>方法</p>
<h3 id="renderToString-renderToStaticMarkup"><a href="#renderToString-renderToStaticMarkup" class="headerlink" title="renderToString()/renderToStaticMarkup()"></a>renderToString()/renderToStaticMarkup()</h3><p><strong>使用方法：</strong> <code>ReactDomServer.renderTostring(element)</code>/<br><code>ReactDomServer.renderToStaticMarkup(element)</code></p>
<h4 id="共同点："><a href="#共同点：" class="headerlink" title="共同点："></a>共同点：</h4><ul>
<li>都接收一个React Element 并<strong>将此 Element 转化为HTML字符串,通过浏览器返回</strong>，实现了在服务端将页面拼接字符串插入HTML文档中并返回给浏览器 完成初步服务端渲染的目的</li>
</ul>
<h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><ul>
<li>renderToString(<font color="red">注：React 15</font>) 生成的HTML字符串的每个Dom节点都有<code>data-react-id</code>属性，根节点会有一个<code>data-react-checkSum</code>属性</li>
<li>renderToStaticMarkup 不带<code>data-react-checkSum</code>属性 浏览器渲染时必会重新渲染组件</li>
</ul>
<hr>
<p><font color="red">关于data-react-checkSum</font>：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">如果两个组件有相同的props和<span class="type">Dom</span>结构，这个值是一样的</span><br><span class="line"></span><br><span class="line">我们知道 服务端渲染完页面内容难过之后，浏览器端也会渲染以完成组件的交互等能力，浏览器端会生成组件的<span class="class"><span class="keyword">data</span>-react-checkSum值 然后跟服务端渲染组件的值做对比，如果相等，则不再重复渲染</span></span><br></pre></td></tr></table></figure>
<p>这里有一张草图能大概描述这个过程嘤嘤嘤.<br><img src="/images/ssr/ssrcc.png" alt="cache_detai"></p>
<hr>
<h3 id="ReactDom-hydrate"><a href="#ReactDom-hydrate" class="headerlink" title="ReactDom.hydrate()"></a>ReactDom.hydrate()</h3><p>React 16以后通过<br><code>renderToString</code>渲染的组件不再带有<code>data-react-*</code>属性，因此浏览器端的渲染方式无法简单通过<code>data-react-checksum</code>来判断是否需要重新渲染</p>
<p>基于这样儿的背景下<code>ReactDom</code>提供了一个新的API <code>ReactDom.hydrate()</code> 用法同<code>render()</code>在浏览器端渲染组件</p>
<p>当然，react是向下兼容的，浏览器端在渲染组件时使用render()仍然没有问题，但不论是面向未来，还是基于性能的考虑，都应该采用更好的模式</p>
<hr>
<h3 id="renderToNodeStream-renderToStaticNodeStream"><a href="#renderToNodeStream-renderToStaticNodeStream" class="headerlink" title="renderToNodeStream()/renderToStaticNodeStream()"></a>renderToNodeStream()/renderToStaticNodeStream()</h3><p><font color="red">React 16 </font>为了优化页面的初始加载速度缩短TTFB时间,提供了这两个方法</p>
<p><strong>概念</strong><br>该方法持续产生子节流 返回 <code>Readable stream</code> 最终<strong>通过流形式返回的HTML字符串</strong><br>这样 服务端处理内容时是实时向浏览器端传输数据而不是一次性处理完成后才开始返回结果的</p>
<p><code>renderToStaticNodeStream</code> 之于 <code>renderToNodeStream</code> 也是不会产生<code>data-react-*</code>属性，对于静态页面 可以采用此方法。</p>
<h2 id="实际开发中可能存在的问题"><a href="#实际开发中可能存在的问题" class="headerlink" title="实际开发中可能存在的问题"></a>实际开发中可能存在的问题</h2><ol>
<li>服务端不存在支持组件挂载的浏览器环境，所以react组件只有<code>componentDidMount</code>之前的生命周期方法有效，所以在其之前的生命周期方法中不能用到浏览器的特性，比如 <code>window、localStorage</code>.</li>
<li>双端可能都有拉取数据的需求，所以为了实现代码的复用，一种典型的做法就是把请求数据的逻辑放到React组件的静态方法中 然后双端共用，双端请求方法不一致的问题可以通过服务端与浏览器端的判断来封装一下 <strong>比如根据window是浏览器特有对象</strong></li>
</ol>
<h2 id="React-16-在服务端渲染上的惊喜"><a href="#React-16-在服务端渲染上的惊喜" class="headerlink" title="React 16 在服务端渲染上的惊喜"></a>React 16 在服务端渲染上的惊喜</h2><p>前面也有混杂说过，在此总结一下</p>
<ul>
<li>在浏览器渲染组件需要配合服务端使用<code>hydrate</code>方法</li>
<li>提供了<code>stream</code>方式的接口</li>
<li>与浏览器的新特性相似，除了能处理<code>React Element</code> 也能处理别的类型，比如<code>string number</code></li>
<li>因为在返回结果Dom中废除了<code>data-react-checksum</code>等属性，所以服务端生成HTML更加高效</li>
<li>允许在渲染Dom中加入非标准Dom属性</li>
</ul>
<hr>
<p>好了 测试一下，基于Node.js实现一个小demo</p>
<p><code>Express4.15.3 进行服务端处理</code></p>
<p><img src="/images/ssr/ssrvs1.png" alt="ssrvs1"><br>browser: 浏览器端渲染<br>server：服务端逻辑<br>share：同构的部分</p>
<p>运行效果：<br><img src="/images/ssr/ssrvs100.png" alt="ssr"><br><strong>share/app.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> logo <span class="keyword">from</span> <span class="string">"./logo.svg"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"./App.css"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    alert(<span class="string">'我被触发辣'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">        &lt;div className=<span class="string">"App-header"</span>&gt;</span><br><span class="line">          &lt;img src=&#123;logo&#125; className=<span class="string">"App-logo"</span> alt=<span class="string">"logo"</span> /&gt;</span><br><span class="line">          &lt;h2&gt;Welcome to React <span class="keyword">in</span> the Server&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">        &lt;p className=<span class="string">"App-intro"</span>&gt;点击按钮体验&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;e =&gt; this.handleClick()&#125;&gt; 我是按钮 &lt;/</span>button&gt;  </span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure>
<p><strong>browser/index.js</strong></p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; hydrate &#125; <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">"../shared/App"</span>;</span><br><span class="line"></span><br><span class="line">hydrate(&lt;App /&gt;, <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>));</span><br></pre></td></tr></table></figure>
<p><strong>server/index.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> express <span class="keyword">from</span> <span class="string">"express"</span>;</span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; renderToString &#125; <span class="keyword">from</span> <span class="string">"react-dom/server"</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">"../shared/App"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(express.static(<span class="string">"public"</span>));</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">"*"</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> htmlMarkup = renderToString(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">  res.send(`</span></span><br><span class="line"><span class="xml">      <span class="meta">&lt;!DOCTYPE html&gt;</span></span></span><br><span class="line">      &lt;head&gt;</span><br><span class="line">        &lt;title&gt;Universal Reacl&lt;/title&gt;</span><br><span class="line">        &lt;link rel="stylesheet" href="/css/main.css"&gt;</span><br><span class="line">        &lt;script src="/bundle.js" defer&gt;&lt;/script&gt;</span><br><span class="line">      &lt;/head&gt;</span><br><span class="line"></span><br><span class="line">      &lt;body&gt;</span><br><span class="line">        &lt;div id="root"&gt;$&#123;htmlMarkup&#125;&lt;/div&gt;</span><br><span class="line">      &lt;/body&gt;</span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml">  `);</span></span><br><span class="line"><span class="xml">&#125;);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">app.listen(process.env.PORT || 3000, () =&gt; &#123;</span></span><br><span class="line"><span class="xml">  console.log("Server is listening");</span></span><br><span class="line"><span class="xml">&#125;);</span></span><br></pre></td></tr></table></figure>
<p><strong>server端：</strong>使用 <code>renderToString</code>生成的字符串，使用<code>res.send</code>发送给浏览器<br><strong>client端：</strong> id为root的Dom节点就来自服务端返回的结果，用了<code>React.hydrate</code>完成了浏览器端的逻辑处理部分</p>
<h3 id="假设一-client端渲染仍然使用render"><a href="#假设一-client端渲染仍然使用render" class="headerlink" title="假设一 client端渲染仍然使用render()"></a>假设一 client端渲染仍然使用render()</h3><p><strong>测试</strong></p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;render &#125; <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">"../shared/App"</span>;</span><br><span class="line"></span><br><span class="line">render(&lt;App /&gt;, <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>));</span><br></pre></td></tr></table></figure>
<p><strong>结果</strong><br>由于实现了向下兼容，所以是可以的，但是会给如下警告⚠️<br><img src="/images/ssr/hydrate_to_render.png" alt="hydrate_to_rende"></p>
<p><strong>结论</strong> 尽量使用新特性</p>
<hr>
<h3 id="假设二-完全依赖服务端渲染会发生什么"><a href="#假设二-完全依赖服务端渲染会发生什么" class="headerlink" title="假设二 完全依赖服务端渲染会发生什么"></a>假设二 完全依赖服务端渲染会发生什么</h3><p><strong>测试</strong><br>将<code>browser/index.js</code>代码注释掉<br><strong>结果</strong><br>页面正常显示，但是点击按钮没有不会弹窗<br><strong>结论</strong> 需要双端一起完成页面的展示与交互</p>
<hr>
<h3 id="假设三-使用React-16-renderToNodeStream渲染"><a href="#假设三-使用React-16-renderToNodeStream渲染" class="headerlink" title="假设三 使用React 16 renderToNodeStream渲染"></a>假设三 使用React 16 renderToNodeStream渲染</h3><p><strong>测试 更改 server/index.js</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import express from "express";</span><br><span class="line">import React from "react";</span><br><span class="line">import &#123; renderToNodeStream &#125; from "react-dom/server";</span><br><span class="line">import App from "../shared/App";</span><br><span class="line"></span><br><span class="line">const app = express();</span><br><span class="line"></span><br><span class="line">app.use(express.static("public"));</span><br><span class="line"></span><br><span class="line">app.get("*", (req, res) =&gt; &#123;</span><br><span class="line">  res.write(`</span><br><span class="line">      <span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"content-type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Universal Reacl<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/css/main.css"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/bundle.js"</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">head</span>&gt;</span>`</span><br><span class="line">  );</span><br><span class="line">  res.write("<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'root'</span>&gt;</span>"); </span><br><span class="line">  const stream = renderToNodeStream(<span class="tag">&lt;<span class="name">App</span>/&gt;</span>);</span><br><span class="line">  stream.pipe(res, &#123; end: false &#125;);</span><br><span class="line">  stream.on('end', () =&gt; &#123;</span><br><span class="line">    res.write("<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span>");</span><br><span class="line">    res.end();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong> 为了配合返回一个流，使用<code>res.write</code>方法代替先前的<code>res.end</code></p>
<p><strong>好处</strong><br>使用<code>renderToString</code>页面TTFB时间</p>
<p><img src="/images/ssr/TTFB2.png" alt="TTFB2"><br>使用<code>renderToNodeStream</code>页面TTFB时间</p>
<p><img src="/images/ssr/TTFB1.png" alt="TTFB1"></p>
<p><strong>结论</strong><br>采用渐进式流渲染可以最大限度的缩短服务器响应水间，从而使浏览器可以更快的接收到信息</p>
<hr>
<h3 id="假设三-同构应用与浏览器渲染优势对比"><a href="#假设三-同构应用与浏览器渲染优势对比" class="headerlink" title="假设三 同构应用与浏览器渲染优势对比"></a>假设三 同构应用与浏览器渲染优势对比</h3><p>浏览器渲染：<br><img src="/images/ssr/client_render.png" alt="client_rende"></p>
<p>同构应用：<br><img src="/images/ssr/ssr.png" alt="ss"></p>
<hr>
<h3 id="假设三-react16比react15渲染更加高效"><a href="#假设三-react16比react15渲染更加高效" class="headerlink" title="假设三 react16比react15渲染更加高效"></a>假设三 react16比react15渲染更加高效</h3><p>React 15<br><img src="/images/ssr/react15_render.png" alt="react15_rende"><br>React 16<br><img src="/images/ssr/react16.png" alt="react16"></p>
<h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><ol>
<li>鉴于<code>renderToNodeStream()/renderToStaticNodeStream()</code>与<br><code>renderToString()/renderToStaticMarkup()</code><br>React 16之后都不存在<code>data-react-*</code>了 双方还有什么区别？</li>
<li>react 16之后 如何做双端对比？ 官方说是根据<code>ReactDom.hydrate()</code>与<code>renderToString()</code>结合判断.. 一脸懵逼</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>模拟实现JS的bind方法</title>
    <url>/2019/03/13/bind/</url>
    <content><![CDATA[<h2 id="为什么要实现一个bind函数？"><a href="#为什么要实现一个bind函数？" class="headerlink" title="为什么要实现一个bind函数？"></a>为什么要实现一个bind函数？</h2><p><code>bind()</code>函数在 <code>ECMA-262 第五版</code>才被加入<br>它可能无法在所有浏览器上运行，为了世界和平,必要的时候我们要手动实现它</p>
<a id="more"></a>
<h2 id="现有bind函数的功能？"><a href="#现有bind函数的功能？" class="headerlink" title="现有bind函数的功能？"></a>现有bind函数的功能？</h2><p>改造之前要清楚现有<code>bind()</code>函数做了哪些事儿</p>
<p>从<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="noopener">MDN</a>上找到一些关于它的定义</p>
<p>bind()方法创建一个新的函数，在调用时设置this关键字为提供的值。并在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项</p>
<p><strong>语法</strong> <code>function.bind(thisArg[, arg1[, arg2[, ...]]])</code></p>
<p>函数会创建一个新绑定函数,它包装了原函数对象<br><code>ceshiFn.bind(myObject)</code></p>
<p>绑定函数也可以使用<code>new</code>运算符构造，此时提供的<code>this</code>值会被忽略，但前置参数（arg1,arg2）仍会提供给模拟函数</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">var <span class="function"><span class="keyword">Fn</span> </span>= ceshiFn.bind(myObject,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="function"><span class="keyword">Fn</span>(<span class="params"></span>)</span></span><br></pre></td></tr></table></figure>
<p>此时 <code>myObject</code> 被忽略 但是 参数依然会传递给<code>ceshiFn</code>令其初始化</p>
<p><strong>参数：</strong></p>
<ul>
<li><font color="red">thisArg</font>：当被绑定的函数被调用时，将它的<code>this</code>关键字设置为<code>thisArg</code></li>
<li><font color="red">arg1，arg2</font>:被调用时，这些参数将传递给被绑定的方法</li>
</ul>
<p><strong>返回值：</strong><br>指定的<code>this</code>值和初始化参数改造过原函数拷贝</p>
<h3 id="继续探索bind函数的功能"><a href="#继续探索bind函数的功能" class="headerlink" title="继续探索bind函数的功能"></a>继续探索bind函数的功能</h3><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">'obj'</span>,obj)</span><br><span class="line">console.<span class="built_in">log</span>(typeof <span class="function"><span class="keyword">Function</span>.<span class="title">prototype</span></span>.<span class="keyword">bind</span>)  // <span class="keyword">bind</span></span><br><span class="line">console.<span class="built_in">log</span>(typeof <span class="function"><span class="keyword">Function</span>.<span class="title">prototype</span></span>.<span class="keyword">bind</span>()) //<span class="keyword">bind</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="function"><span class="keyword">Function</span>.<span class="title">prototype</span></span>.<span class="keyword">bind</span>.<span class="keyword">name</span>) //<span class="keyword">bind</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="function"><span class="keyword">Function</span>.<span class="title">prototype</span></span>.<span class="keyword">bind</span>().<span class="keyword">name</span>) // bound</span><br></pre></td></tr></table></figure>
<p>由此我们可以得到得出以下结论</p>
<ol>
<li><code>bind</code>是 <code>Function</code>原型链中 <code>Function.prototype</code>的一个属性，每个函数都可以调用它</li>
<li><code>bind</code>本身是一个函数名为<code>bind</code>的函数，返回值是一个名为<code>bound</code> 的函数</li>
</ol>
<p>下面这个例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'yishu'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">original</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    <span class="built_in">console</span>.log([a, b]);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bound = original.bind(obj, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> boundResult = bound(<span class="number">2</span>); <span class="comment">// 'yishu', [1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(boundResult); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(original.bind.name); <span class="comment">// 'bind'</span></span><br><span class="line"><span class="built_in">console</span>.log(original.bind.length); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(original.bind().length); <span class="comment">// 2 返回original函数的形参个数</span></span><br><span class="line"><span class="built_in">console</span>.log(bound.name); <span class="comment">// 'bound original'</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;).bind().name); <span class="comment">// 'bound '</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;).bind().length); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<ol>
<li><code>bind</code>是函数可被传参数，返回值<code>bound</code>也是函数，也可以传参数</li>
<li>被<code>bind()</code>绑定的函数的this关键字是<code>bind()</code>的第一个参数</li>
<li>传递<code>bind</code>的其他参数被接收处理了，<code>bind()</code>之后返回的函数<code>bound</code>函数的参数也被接收处理了，也就是说被合并处理了</li>
<li>并且<code>bind()</code>后的<code>name</code>为<code>bound + 空格 + 调用bind的函数名</code>。如果是匿名函数则是<code>bound + 空格</code></li>
<li>bind后的返回值函数<code>bound</code>，执行后返回值是原函数（original）的返回值</li>
<li>bind函数形参（即函数的length）是1。bind后返回的bound函数形参根据绑定的函数原函数（original）形参个数确定</li>
</ol>
<p>到这里 我们根据得出的结论 就可以模拟一个简单版本的bind函数了</p>
<h3 id="核心功能的bindFn函数"><a href="#核心功能的bindFn函数" class="headerlink" title="核心功能的bindFn函数"></a>核心功能的bindFn函数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bindFn = <span class="function"><span class="keyword">function</span>(<span class="params">thisArg</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//保证是一个函数调用了bindFn函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> != <span class="string">'function'</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="keyword">this</span> + <span class="string">'must be a function'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//保存除了thisArg之外的其他形参 转成数组</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'bindFn'</span>,<span class="built_in">arguments</span>)</span><br><span class="line">    <span class="keyword">let</span> arg = [].slice.call(<span class="built_in">arguments</span> ,<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> bound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// bind返回的函数 的参数转成数组</span></span><br><span class="line">        <span class="keyword">var</span> boundArgs = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="comment">// apply修改this指向，把两个函数的参数合并传给self函数，并执行self函数，返回执行结果</span></span><br><span class="line">        <span class="keyword">return</span> self.apply(thisArg, arg.concat(boundArgs));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bound;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'yishu'</span>,</span><br><span class="line">    age:<span class="number">18</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">original</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log([].slice.call(<span class="built_in">arguments</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bound = original.bindFn(obj,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">bound(<span class="number">7</span>); <span class="comment">// [3, 4, 5, 7]</span></span><br></pre></td></tr></table></figure>
<p>到这里基本上把bind的核心功能写完了，也能够适用大部分场景了<code>bindFn</code>只能能做到的只是永久地绑定指定的<code>this</code> ，但是我们发现<code>MDN</code>上关于<code>bind函数</code>描述 还有一种情况，那就是<font color="red">当你使用<code>new操作符</code>调用绑定函数时</font><br>是这么说的</p>
<blockquote>
<p>thisArg：当使用new 操作符调用绑定函数时，该参数无效。<br>一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的<code>this</code>值被忽略，同时调用时的参数被提供给模拟函数</p>
</blockquote>
<p>我们可以通过一个实例来看原生的bind对于使用new的情况是怎么样的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'yishu'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">original</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this'</span>, <span class="keyword">this</span>.name,[].slice.call(<span class="built_in">arguments</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bound = original.bind(obj,<span class="number">1</span>);</span><br><span class="line">bound(<span class="number">2</span>,<span class="number">3</span>) <span class="comment">//this yishu (3) [1, 2, 3]</span></span><br><span class="line"><span class="keyword">new</span> bound(<span class="number">2</span>,<span class="number">3</span>) <span class="comment">//this undefined (3) [1, 2, 3]s</span></span><br></pre></td></tr></table></figure>
<p>此时 <code>this</code>指向了<code>new bound()</code>生成的新对象，所以找不到<code>name</code>为<code>yishu</code>的值了，但是参数依然传递的</p>
<p><strong>结论</strong></p>
<ul>
<li><code>bind</code>原先指向<code>obj</code>的失效了，其他参数有效。</li>
<li><code>new bound</code>的返回值是以<code>original</code>原函数构造器生成的新对象。<code>original</code>原函数的<code>this</code>指向的就是这个新对象</li>
</ul>
<p>我们看到 又涉及到<code>new</code>操作了，<a href="http://maying.ink/2019/03/13/new/">写过关于模拟new的文章</a><br>简单摘要 new 做了什么</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>创建了一个全新的对象。</span><br><span class="line"><span class="number">2.</span>这个对象会被执行<span class="string">[[Prototype]]</span>（也就是__proto__）链接。</span><br><span class="line"><span class="number">3.</span>生成的新对象会绑定到函数调用的this。</span><br><span class="line"><span class="number">4.</span>通过new创建的每个对象将最终被<span class="string">[[Prototype]]</span>链接到这个函数的prototype对象上。</span><br><span class="line"><span class="number">5.</span>如果函数没有返回对象类型Object(包含Functoin, Array, Date, RegExg, Error)，那么new表达式中的函数调用会自动返回这个新的对象。</span><br></pre></td></tr></table></figure>
<p>所以 ，当使用<code>new</code>调用的时候，<code>bind</code>的返回值函数<code>bound</code>内部要模拟实现<code>new</code>实现的操作,似曾相识了</p>
<h3 id="bindFn函数的升级"><a href="#bindFn函数的升级" class="headerlink" title="bindFn函数的升级"></a>bindFn函数的升级</h3><p>区分是否是new调用 当使用new调用需要在bind函数返回值函数里实现模拟<code>new</code>的操作</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bindFn = <span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">thisArg</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="keyword">this</span> + <span class="string">' must be a function'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存储调用bind的函数本身</span></span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 去除thisArg的其他参数 转成数组</span></span><br><span class="line">    <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> bound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// bind返回的函数 的参数转成数组</span></span><br><span class="line">        <span class="keyword">var</span> boundArgs = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">var</span> finalArgs = args.concat(boundArgs);</span><br><span class="line">        <span class="comment">// new 调用时，其实this instanceof bound判断也不是很准确。es6 new.target就是解决这一问题的。</span></span><br><span class="line">        <span class="comment">//new.target属性允许你检测函数或构造方法是否是通过new运算符被调用的</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">new</span>.target)&#123; <span class="comment">//检测函数或构造方法是否是通过new运算符被调用的</span></span><br><span class="line">            <span class="comment">// 这里是实现上文描述的 new 的第 1, 2, 4 步</span></span><br><span class="line">            <span class="comment">// 1.创建一个全新的对象</span></span><br><span class="line">            <span class="comment">// 2.并且执行[[Prototype]]链接</span></span><br><span class="line">            <span class="comment">// 4.通过`new`创建的每个对象将最终被`[[Prototype]]`链接到这个函数的`prototype`对象上。</span></span><br><span class="line">            <span class="comment">// self可能是ES6的箭头函数，没有prototype，所以就没必要再指向做prototype操作。</span></span><br><span class="line">            <span class="keyword">if</span>(self.prototype)&#123;</span><br><span class="line">                <span class="comment">// ES5 提供的方案 Object.create()</span></span><br><span class="line">                <span class="comment">// bound.prototype = Object.create(self.prototype);</span></span><br><span class="line">                <span class="comment">// 但既然是模拟ES5的bind，那浏览器也基本没有实现Object.create()</span></span><br><span class="line">                <span class="comment">// 所以采用 MDN ployfill方案 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create</span></span><br><span class="line">                <span class="function"><span class="keyword">function</span> <span class="title">Empty</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">                Empty.prototype = self.prototype;</span><br><span class="line">                bound.prototype = <span class="keyword">new</span> Empty();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这里是实现上文描述的 new 的第 3 步</span></span><br><span class="line">            <span class="comment">// 3.生成的新对象会绑定到函数调用的`this`。</span></span><br><span class="line">            <span class="keyword">var</span> result = self.apply(<span class="keyword">this</span>, finalArgs);</span><br><span class="line">            <span class="comment">// 这里是实现上文描述的 new 的第 5 步</span></span><br><span class="line">            <span class="comment">// 5.如果函数没有返回对象类型`Object`(包含`Functoin`, `Array`, `Date`, `RegExg`, `Error`)，</span></span><br><span class="line">            <span class="comment">// 那么`new`表达式中的函数调用会自动返回这个新的对象。</span></span><br><span class="line">            <span class="keyword">var</span> isObject = <span class="keyword">typeof</span> result === <span class="string">'object'</span> &amp;&amp; result !== <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">var</span> isFunction = <span class="keyword">typeof</span> result === <span class="string">'function'</span>;</span><br><span class="line">            <span class="keyword">if</span>(isObject || isFunction)&#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="comment">//不使用new操作符时</span></span><br><span class="line">            <span class="comment">// apply修改this指向，把两个函数的参数合并传给self函数，并执行self函数，返回执行结果</span></span><br><span class="line">            <span class="keyword">return</span> self.apply(thisArg, finalArgs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> bound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>bind是Function原型链中的Function.prototype的一个属性，它是一个函数，修改this指向，合并参数传递给原函数，返回值是一个新的函数。</li>
<li>bind返回的函数可以通过new调用，这时提供的this的参数被忽略，指向了new生成的全新对象。内部模拟实现了new操作符。</li>
<li>bindFn</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最终版 删除注释 详细注释版请看上文</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="built_in">Function</span>.prototype.bind || <span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">thisArg</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="keyword">this</span> + <span class="string">' must be a function'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> bound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> boundArgs = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">var</span> finalArgs = args.concat(boundArgs);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">new</span>.target)&#123;</span><br><span class="line">            <span class="keyword">if</span>(self.prototype)&#123;</span><br><span class="line">                <span class="function"><span class="keyword">function</span> <span class="title">Empty</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">                Empty.prototype = self.prototype;</span><br><span class="line">                bound.prototype = <span class="keyword">new</span> Empty();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> result = self.apply(<span class="keyword">this</span>, finalArgs);</span><br><span class="line">            <span class="keyword">var</span> isObject = <span class="keyword">typeof</span> result === <span class="string">'object'</span> &amp;&amp; result !== <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">var</span> isFunction = <span class="keyword">typeof</span> result === <span class="string">'function'</span>;</span><br><span class="line">            <span class="keyword">if</span>(isObject || isFunction)&#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> self.apply(thisArg, finalArgs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> bound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>bind</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟实现apply和call方法</title>
    <url>/2019/03/13/apply-call/</url>
    <content><![CDATA[<h2 id="先来通过MDN认识下call和apply"><a href="#先来通过MDN认识下call和apply" class="headerlink" title="先来通过MDN认识下call和apply"></a>先来通过MDN认识下call和apply</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p><code>func.apply(thisArg, [argsArray])</code></p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p><strong>thisArg</strong>：可选的，<code>func</code>函数运行的时使用的<code>this</code>值</p>
<a id="more"></a>
<p>⚠️ </p>
<ul>
<li>如果这个函数处于<font color="red">非严格模式下</font> 指定其为<code>null</code> 或者 <code>undefined</code>时 this绑定会应用<code>默认规则</code>（<font color="red">这在<a href="http://maying.ink/2019/03/11/this/#more">分析js指向问题</a>时有提到</font>）</li>
<li>如果thisArg是原始值会被包装称对象 <code>.apply(2)</code>会被包装成<code>.apply(Number(2))</code></li>
</ul>
<hr>
<p><strong>argsArray</strong>：可选的。一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 func 函数。如果该参数的值为 null 或  undefined，则表示不需要传入任何参数。从ECMAScript 5 开始可以使用类数组对象</p>
<hr>
<p><strong>返回值</strong>：<br>调用有指定this值和参数的函数的结果</p>
<hr>
<p>几个有用的例子感受下apply的魔力</p>
<p><strong>求数组最大最小值</strong></p>
<p>聪明的apply用法允许你在某些本来需要写成遍历数组变量的任务中使用内建的函数</p>
<p>使用<code>Math.max/Math.min</code>来找出一个数组中的最大/最小值</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">var</span> numbers = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>];</span><br><span class="line"><span class="built_in">var</span> <span class="built_in">max</span> = Math.<span class="built_in">max</span>.<span class="built_in">apply</span>(null, numbers);</span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">max</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">var</span> <span class="built_in">min</span> = Math.<span class="built_in">min</span>.<span class="built_in">apply</span>(null, numbers);</span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">min</span>);</span><br></pre></td></tr></table></figure>
<p><strong>apply设置的this值</strong></p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">var doSth = function(a, b)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">console</span>.log([a, b]);</span><br><span class="line">&#125;</span><br><span class="line">doSth.apply(<span class="literal">null</span>, [<span class="number">1</span>, <span class="number">2</span>]); <span class="regexp">//</span> <span class="keyword">this</span>是<span class="built_in">window</span>  <span class="regexp">//</span> [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">doSth.apply(<span class="number">0</span>, [<span class="number">1</span>, <span class="number">2</span>]); <span class="regexp">//</span> <span class="keyword">this</span> 是 Number(<span class="number">0</span>) <span class="regexp">//</span> [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">doSth.apply(<span class="literal">true</span>); <span class="regexp">//</span> <span class="keyword">this</span> 是 Boolean(<span class="literal">true</span>) <span class="regexp">//</span> [<span class="literal">undefined</span>, <span class="literal">undefined</span>]</span><br><span class="line">doSth.call(<span class="literal">undefined</span>, <span class="number">1</span>, <span class="number">2</span>); <span class="regexp">//</span> <span class="keyword">this</span> 是 <span class="built_in">window</span> <span class="regexp">//</span> [<span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<p><strong>用apply将一个数组添加到另一个数组</strong></p>
<p>如果我们传递一个数组来推送，它实际上会将该数组作为单个元素添加，而不是单独添加元素，因此我们最终得到一个数组内的数组<br><code>concat</code>确实具有我们想要的行为，但它实际上并不附加到现有数组，而是创建并返回一个新数组<br>用<code>apply</code>就能简单实现</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">var</span> <span class="built_in">array</span> = ['a', 'b'];</span><br><span class="line"><span class="built_in">var</span> elements = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="built_in">array</span>.<span class="built_in">push</span>.<span class="built_in">apply</span>(<span class="built_in">array</span>,elements) // [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">//<span class="built_in">array</span>.<span class="built_in">push</span>(elements) //) [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, Array(<span class="number">3</span>)]</span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">array</span>);</span><br></pre></td></tr></table></figure>
<p>call()与apply()非常相似</p>
<p><code>fun.call(thisArg, arg1, arg2, ...)</code></p>
<p><strong>call和apply的不同点</strong></p>
<ul>
<li><code>apply</code>只接收两个参数，第二个参数可以是<code>数组</code>也可以是<code>类数组</code>，其实也可以是对象，后续的参数忽略不计</li>
<li><code>call</code>接收第二个及以后一系列的参数</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>重新认识了call和apply会发现<br>它们作用都是一样的，改变函数里的this指向为第一个参数<code>thisArg</code>，如果明确有多少参数，那可以用<code>call</code>，不明确则可以使用<code>apply</code>。也就是说完全可以不使用<code>call</code>，而使用<code>apply</code>代替，我们只需要模拟实现<code>apply</code>，<code>call</code>可以根据参数个数都放在一个数组中，给到<code>apply</code>即可</p>
<hr>
<h2 id="模拟实现的准备工作"><a href="#模拟实现的准备工作" class="headerlink" title="模拟实现的准备工作"></a>模拟实现的准备工作</h2><p>模拟之前 我们先得看看<a href="http://yanhaijing.com/es5/#book" target="_blank" rel="noopener">ES5规范</a> 关于apply 摘抄以下几条</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">Function.prototype.apply (thisArg, argArray)</span><br><span class="line"></span><br><span class="line">当以 thisArg 和 argArray 为参数在一个 func 对象上调用 apply 方法，采用如下步骤：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>如果 IsCallable(func) 是 <span class="literal">false</span>, 则抛出一个 TypeError 异常。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>如果 argArray 是 null 或 undefined, 则返回提供 thisArg 作为 this 值并以空参数列表调用 func 的 <span class="string">[[Call]]</span> 内部方法的结果。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>返回提供 thisArg 作为 this 值并以空参数列表调用 func 的 <span class="string">[[Call]]</span> 内部方法的结果。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>如果 Type(argArray) 不是 Object, 则抛出一个 TypeError 异常。</span><br><span class="line">...</span><br><span class="line"><span class="number">9.</span>提供 thisArg 作为 this 值并以 argList 作为参数列表，调用 func 的 <span class="string">[[Call]]</span> 内部方法，返回结果。</span><br><span class="line"></span><br><span class="line">apply 方法的 length 属性是 <span class="number">2</span>。</span><br><span class="line"></span><br><span class="line"><span class="number">10.</span>在外面传入的 thisArg 值会修改并成为 this 值。thisArg 是 undefined 或 null 时它会被替换成全局对象，所有其他值会被应用 ToObject 并将结果作为 this 值，这是第三版引入的更改</span><br></pre></td></tr></table></figure>
<p>结合上文和规范 ，明确了要解决的问题，<strong>我们如何将函数里的this（一般指向window）指向第一个参数thisArg呢</strong><br>不由得想起来了<a href="http://maying.ink/2019/03/11/this/">介绍this指向那一篇文章</a><br>那就采用隐式绑定呀，也就是说 既然他现有的上下文环境是window（全局作用域）,那我们就手动给他创建一个<code>非全局上下文</code></p>
<p>看看这个熟悉的例子</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> doSth = <span class="keyword">function</span>()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    <span class="built_in">console</span>.log(arguments);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> student = &#123;</span><br><span class="line">    name: <span class="string">'yishu'</span>,</span><br><span class="line">    doSth: doSth,</span><br><span class="line">&#125;;</span><br><span class="line">student.doSth(<span class="number">1</span>, <span class="number">2</span>); <span class="regexp">// this === student //</span> <span class="literal">true</span> <span class="regexp">// 'yishu' //</span> [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">doSth.apply(student, [<span class="number">1</span>, <span class="number">2</span>]); <span class="regexp">// this === student //</span> <span class="literal">true</span> <span class="regexp">// 'yishu' //</span> [<span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<p>你能看出来什么？<br> 在对象<code>student</code>上加一个函数doSth，再执行这个函数，这个函数里的<code>this</code>就指向了这个对象</p>
<p> 那我们就模拟这个对象，给他添加一个函数,使用函数调用之后再删除它</p>
<p> 第一版本</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 浏览器环境 非严格模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getGlobalObject</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.applyFn = <span class="function"><span class="keyword">function</span> <span class="title">apply</span>(<span class="params">thisArg,argsArray</span>)</span>&#123;</span><br><span class="line">   <span class="comment">// 1.如果 `IsCallable(func)` 是 `false`, 则抛出一个 `TypeError` 异常。</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span> !=<span class="string">'function'</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="keyword">this</span> + <span class="string">'is not function'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 1.如果 `IsCallable(func)` 是 `false`, 则抛出一个 `TypeError` 异常。</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> argsArray === <span class="string">'undefined'</span> || argsArray === <span class="literal">null</span>)&#123;</span><br><span class="line">    argsArray = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//3.如果 Type(argArray) 不是 Object, 则抛出一个 TypeError 异常 .</span></span><br><span class="line">   <span class="keyword">if</span>(argsArray !== <span class="keyword">new</span> <span class="built_in">Object</span>(argsArray))&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'CreateListFromArrayLike called on non-object'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//4.改变this的指向 在外面传入的 thisArg 值会修改并成为 this 值 如果传入的是 undefined或者null 则this指向应用默认绑定</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> thisArg === <span class="string">'undefined'</span> || thisArg === <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">// ES3: thisArg 是 undefined 或 null 时它会被替换成全局对象 浏览器里是window</span></span><br><span class="line">        thisArg = getGlobalObject();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始表演</span></span><br><span class="line">    thisArg = <span class="keyword">new</span> <span class="built_in">Object</span>(thisArg);</span><br><span class="line">    thisArg.fn = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">//接收返回值</span></span><br><span class="line">    <span class="keyword">var</span> fnResult = thisArg.fn(...argsArray);</span><br><span class="line">    <span class="keyword">delete</span> thisArg.fn;</span><br><span class="line">    <span class="keyword">return</span> fnResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> doSth = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> student = &#123;</span><br><span class="line">    name: <span class="string">'马小莹'</span>,</span><br><span class="line">    <span class="comment">//doSth: doSth, //我们主要模拟了这个函数</span></span><br><span class="line">&#125;;</span><br><span class="line">doSth.applyFn(student, [<span class="number">1</span>, <span class="number">2</span>]); </span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;name: "马小莹", doSth: ƒ, fn: ƒ&#125;</span></span><br><span class="line"><span class="comment">// 马小莹</span></span><br><span class="line"><span class="comment">// Arguments(2) [1, 2, callee: ƒ, Symbol(Symbol.iterator): ƒ]</span></span><br></pre></td></tr></table></figure>
<p>看起来很完美，那它有没有问题呢？ 其实是有的</p>
<p><strong>.fn函数同名覆盖问题，<code>thisArg</code>对象上有<code>fn</code>，那就被覆盖了然后被删除了</strong></p>
<p>那我们就找一个唯一值的函数名</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">thisArg = new Object(thisArg);</span><br><span class="line">var <span class="emphasis">_fn = '_</span>_fn' + new Date().getTime();</span><br><span class="line">thisArg[_fn] = this;</span><br><span class="line">//接收返回值</span><br><span class="line">var fnResult = thisArg[<span class="string">_fn</span>](<span class="link">...argsArray</span>);</span><br><span class="line">delete thisArg[_fn];</span><br><span class="line">return fnResult;</span><br></pre></td></tr></table></figure>
<p>到现在 简单版本的<code>apply</code>已经实现了，现实业务场景不需要去模拟实现<code>call和apply</code>,毕竟是<code>ES3</code>就提供的方法</p>
<p>既然实现了<code>apply</code>,<code>call</code>也就简单了，<strong>原理就是</strong>拿到<code>call</code>的参数 转换成数组，然后调用<code>applyFn</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.applyFn = <span class="function"><span class="keyword">function</span> <span class="title">apply</span>(<span class="params">thisArg</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> argsArray = [];</span><br><span class="line">  <span class="keyword">var</span> argumentsLength = <span class="built_in">arguments</span>.length;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; argumentsLength - <span class="number">1</span>; i++)&#123;</span><br><span class="line">    argsArray.push(<span class="built_in">arguments</span>[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.applyFn(thisArg, argsArray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>通过MDN认识call和apply，阅读ES5规范，到模拟实现apply，再实现call</li>
</ol>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>call</tag>
        <tag>apply</tag>
      </tags>
  </entry>
  <entry>
    <title>你不知道的JS系列-理解JS中 赋值，浅拷贝，深拷贝</title>
    <url>/2019/03/25/clone/</url>
    <content><![CDATA[<h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>又回到了这个老生常谈，新生绝望的问题上，通常遇到这种大家都比较熟悉的问题，反而不知道怎么列大纲，怕不够深入也怕脱离主题～<br>emm..<br>此文系 不要再问我XX系列之 <font color="red">不要再问我JS Clone的问题了</font></p>
<a id="more"></a>
<h2 id="为什么会存在这三种情况？三者有何差异"><a href="#为什么会存在这三种情况？三者有何差异" class="headerlink" title="为什么会存在这三种情况？三者有何差异"></a>为什么会存在这三种情况？三者有何差异</h2><p><code>clone</code>本来很简单，只是因为JS中不同的数据类型存储方式(<strong>堆和栈</strong>)的差异，我们才会觉得它貌似有点‘复杂’</p>
<p><img src="/images/clone/clone1.png" alt="clone1"></p>
<p>基本类型和引用类型的差异如上图所示了<br>它们共同的目标就是<font color="red">以一个对象为原型clone出另外一个新对象，因为自身的问题产生一些副作用，三者的差异其实就体现在副作用的差异上</font></p>
<h3 id="差异（堆和栈）"><a href="#差异（堆和栈）" class="headerlink" title="差异（堆和栈）"></a>差异（堆和栈）</h3><ul>
<li>栈（stack）为自动分配的内存空间，它由系统自动释放</li>
<li>而堆（heap）则是动态分配的内存，大小不定也不会自动释放</li>
</ul>
<hr>
<font color="red">基础类型：</font> 值存放在栈中，<strong>比较是值的比较</strong><br><font color="red">引用类型：</font> 值存放在堆中，变量实际上是一个存放在栈内存的指针，这个指针指向堆内存中的地址。每个空间大小不一样，要根据情况开进行特定的分配，<strong>引用类型的比较是引用的比较</strong><br><br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">var person1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">var person2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">console.log(a === b); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><br><br>### 赋值<br><br>赋值的概念 即使刚入行也不陌生，每天都在用的<code>&#39;=&#39;</code><br><br>#### 原理<br><br><em> 基本类型：在内存中新开辟一段栈内存，然后再把再将值赋值到新的栈中,是两个独立相互不影响的变量
</em> 引用类型：赋值是传址，是对象保存在栈中的地址的赋值，这样的话两个变量就指向堆内存的同一个对象，因此两者之间操作互相有影响<br><br>#### Demo<br><br><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">var obj1 = &#123;</span><br><span class="line">  name:<span class="symbol">'maying</span>',</span><br><span class="line">  age:<span class="number">22</span>,</span><br><span class="line">  sex:<span class="string">'女'</span>,</span><br><span class="line">  language : [1,[2,3],[4,5],[9,0]]</span><br><span class="line">&#125;</span><br><span class="line">var sringD = <span class="symbol">'pre</span>';</span><br><span class="line">var obj3 = sringD;</span><br><span class="line">sringD = <span class="symbol">'post</span>';</span><br><span class="line"></span><br><span class="line">var obj2 = obj1;</span><br><span class="line">obj1.name = <span class="symbol">'gaile</span>',</span><br><span class="line">obj1.language[<span class="number">0</span>] = <span class="symbol">'jjj</span>'</span><br><span class="line">console.log(<span class="symbol">'obj1</span>',obj1)</span><br><span class="line">       /*</span><br><span class="line">        &#123;</span><br><span class="line">            age: <span class="number">22</span></span><br><span class="line">            language: (<span class="number">4</span>) [<span class="string">"jjj"</span>, <span class="keyword">Array</span>(<span class="number">2</span>), <span class="keyword">Array</span>(<span class="number">2</span>), <span class="keyword">Array</span>(<span class="number">2</span>)]</span><br><span class="line">            name: <span class="string">"gaile"</span></span><br><span class="line">            sex: <span class="string">"女"</span></span><br><span class="line">        &#125;</span><br><span class="line">       */</span><br><span class="line">console.log(<span class="symbol">'obj2</span>',obj2)</span><br><span class="line">        /*</span><br><span class="line">            age: <span class="number">22</span></span><br><span class="line">            language: (<span class="number">4</span>) [<span class="string">"jjj"</span>, <span class="keyword">Array</span>(<span class="number">2</span>), <span class="keyword">Array</span>(<span class="number">2</span>), <span class="keyword">Array</span>(<span class="number">2</span>)]</span><br><span class="line">            name: <span class="string">"gaile"</span></span><br><span class="line">            sex: <span class="string">"女"</span></span><br><span class="line">        */</span><br><span class="line">console.log(<span class="symbol">'sringD</span>',sringD) //post</span><br><span class="line">console.log(<span class="symbol">'obj3</span>',obj3) //pre</span><br></pre></td></tr></table></figure><br><br>### 理解浅拷贝<br><br>之前的很多年，我认为<strong>赋值差不多等于浅拷贝</strong><br>写个小demo 发现它们之间的差异<br><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj2 = obj1;</span><br><span class="line"><span class="keyword">var</span> obj3 = &#123;...obj1&#125;;</span><br><span class="line">obj1.name = <span class="string">'gaile'</span>,</span><br><span class="line">obj1.language[<span class="number">0</span>] = <span class="string">'jjj'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'obj1'</span>,obj1)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'obj2'</span>,obj2)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'obj3'</span>,obj3)</span><br></pre></td></tr></table></figure><br><br><img src="/images/clone/qiankaobei2.png" alt="qiankaobei2"><br>赋值对象，是将对象指针直接赋值给另一个变量<br>浅拷贝，是重新创建了新对象，所以你更改<code>obj1.name</code>的时候不会影响到它,但是改变引用类型时就不能幸免了<br><br><strong>所谓的浅拷贝就是：</strong><br><br><em> 当对简单的数据类型进行赋值的时候，其实就是直接在栈中新开辟一个地方专门来存储一样的值
</em> 当对引用类型进行浅拷贝，后面的对象和前面的对象在第一层数据结构中指向同一个堆地址，但是如果前面的数据不止有一层（<font color="red">属性值是一个指向对象的引用只拷贝那个引用值</font>），类似<br><br><figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">language : <span class="comment">[1,<span class="comment">[2,3]</span>,<span class="comment">[4,5]</span>,<span class="comment">[9,0]</span>]</span></span><br></pre></td></tr></table></figure><br><br><strong>内部的子对象的指针还是同一个地址</strong><br><br>如果要实现一直往下复制 就引出了接下来要说的<font color="red">深拷贝</font>

<p><strong>结论：浅复制要比复制来的深刻一点，至少它开辟了一个新对象，一块儿新的堆内存</strong></p>
<h4 id="目前可行的实现方式"><a href="#目前可行的实现方式" class="headerlink" title="目前可行的实现方式"></a>目前可行的实现方式</h4><p>站在巨人的肩膀上，我们可以轻松实现浅拷贝</p>
<ul>
<li>数组的浅拷贝</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="selector-tag">b</span> = [...a]</span><br><span class="line"><span class="number">2</span>. <span class="selector-tag">b</span> = <span class="selector-tag">a</span>.slice(<span class="number">0</span>) / []<span class="selector-class">.slice</span><span class="selector-class">.call</span>(<span class="selector-tag">a</span>,<span class="number">0</span>)</span><br><span class="line"><span class="number">3</span>. <span class="selector-tag">b</span> = <span class="selector-tag">a</span>.concat() / []<span class="selector-class">.concat</span><span class="selector-class">.call</span>(a)</span><br></pre></td></tr></table></figure>
<ul>
<li>对象的浅拷贝</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="selector-tag">b</span> = Object.assign(&#123;&#125;,a)</span><br><span class="line"><span class="number">2</span>. <span class="selector-tag">b</span> = &#123;...a&#125;</span><br></pre></td></tr></table></figure>
<h4 id="如果要你自己实现呢"><a href="#如果要你自己实现呢" class="headerlink" title="如果要你自己实现呢"></a>如果要你自己实现呢</h4><p>原理：遍历对象的每个属性进行逐个拷贝</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy</span></span>(obj) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!obj || typeof obj !== <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> <span class="keyword">new</span><span class="type">Obj</span> = obj.constructor === <span class="keyword">Array</span> ? [] : <span class="type"></span>&#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">       <span class="keyword">if</span>(obj.hasOwnProperty(key))&#123;</span><br><span class="line">          <span class="keyword">new</span><span class="type">Obj</span>[key] = obj[key]</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span><span class="type">Obj</span></span><br><span class="line"><span class="type"></span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="理解深拷贝"><a href="#理解深拷贝" class="headerlink" title="理解深拷贝"></a>理解深拷贝</h3><p>深拷贝的意义，就是完全复制，如果你读了上文，应该就没有什么疑问了</p>
<p>将a对象复制一份给对象b，不管a中的数据结构嵌套有多深，当改变a对象中的任意深度的某个值后，b中的该值不会受任何影响</p>
<h4 id="目前可行的实现方式-1"><a href="#目前可行的实现方式-1" class="headerlink" title="目前可行的实现方式"></a>目前可行的实现方式</h4><ul>
<li><code>JSON.stringify()`</code>和JSON.parse()`的混合配对使用 </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj4 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj1)) </span><br><span class="line"></span><br><span class="line">obj1.name=<span class="string">'yishu'</span>,</span><br><span class="line"></span><br><span class="line">obj1.language[<span class="number">1</span>] = [<span class="string">"二"</span>,<span class="string">"三"</span>];</span><br><span class="line">obj4.language[<span class="number">2</span>] = [<span class="string">"四"</span>,<span class="string">"五"</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj1);   </span><br><span class="line"><span class="built_in">console</span>.log(obj4);</span><br></pre></td></tr></table></figure>
<p><img src="/images/clone/deepclone.png" alt="deepclone"><br><code>obj1</code>,<code>obj4</code> 是两个独立的对象，更改数据互不影响，达到了我们要的目的</p>
<p><strong>它粗暴，有用，但是也有缺点</strong></p>
<ol>
<li><code>在JSON.stringify()</code>做序列化时，<code>undefined</code>、<code>function</code>以及<code>symbol</code>值，会被忽略</li>
</ol>
<p>例如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: &#123;<span class="attr">b</span>: <span class="string">'old'</span>&#125;, </span><br><span class="line">  c:<span class="literal">undefined</span>, </span><br><span class="line">  d: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  e:  <span class="built_in">Symbol</span>(<span class="string">''</span>)</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">var</span> newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj))</span><br><span class="line">newObj.a.b = <span class="string">'new'</span></span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br><span class="line"><span class="built_in">console</span>.log(newObj)</span><br></pre></td></tr></table></figure>
<p>结果<br><img src="/images/clone/jsonquedian.png" alt="jsonquedian"></p>
<h4 id="如果要你自己实现呢-1"><a href="#如果要你自己实现呢-1" class="headerlink" title="如果要你自己实现呢"></a>如果要你自己实现呢</h4><p>原理：使用递归，遍历每一个对象属性进行拷贝</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: &#123;<span class="attr">b</span>: <span class="string">'old'</span>&#125;, </span><br><span class="line">  c:<span class="literal">undefined</span>, </span><br><span class="line">  d: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  e:  <span class="built_in">Symbol</span>(<span class="string">''</span>)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!obj || <span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> newObj = obj.constructor === <span class="built_in">Array</span> ? [] : &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> obj[key] === <span class="string">'object'</span> &amp;&amp; obj[key]) &#123;</span><br><span class="line">        newObj[key] = copy(obj[key])</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newObj[key] = obj[key]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newObj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newObj = copy(obj)</span><br><span class="line">newObj.a.b = <span class="string">'new'</span></span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br><span class="line"><span class="built_in">console</span>.log(newObj)</span><br></pre></td></tr></table></figure>
<p><img src="/images/clone/jsonquedian.png" alt="jsonquedian"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>赋值：引用复制 执向同一个对象</li>
<li>浅拷贝 ：生成一个新对象，只能拷贝一层，当属性值是一个指向对象的引用只拷贝那个引用值</li>
<li>深拷贝：完全拷贝，前后对象没有任何关系</li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.zhihu.com/question/23031215" target="_blank" rel="noopener">https://www.zhihu.com/question/23031215</a><br><a href="https://segmentfault.com/a/1190000018204798" target="_blank" rel="noopener">https://segmentfault.com/a/1190000018204798</a></p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>clone</tag>
      </tags>
  </entry>
  <entry>
    <title>React diff 算法</title>
    <url>/2019/04/01/diff/</url>
    <content><![CDATA[<p>理解react的diff算法</p>
<a id="more"></a>
<p><img src="/images/passive/diff.png" alt="jsworke"></p>
<h2 id="同级节点的移动-增加-删除的具体实现"><a href="#同级节点的移动-增加-删除的具体实现" class="headerlink" title="同级节点的移动 增加 删除的具体实现"></a>同级节点的移动 增加 删除的具体实现</h2><h3 id="场景一-新旧集合中存在相同节点但位置不同时，如何移动节点"><a href="#场景一-新旧集合中存在相同节点但位置不同时，如何移动节点" class="headerlink" title="场景一 新旧集合中存在相同节点但位置不同时，如何移动节点"></a>场景一 新旧集合中存在相同节点但位置不同时，如何移动节点</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">旧  <span class="selector-tag">a</span> <span class="selector-tag">b</span> c d</span><br><span class="line">新  <span class="selector-tag">b</span> <span class="selector-tag">a</span> d c</span><br></pre></td></tr></table></figure>
<p>React先从新组合中取得b，然后判断旧中是否存在相同节点b，当发现存在节点b后，就去判断是否移动b<br>涉及到两个变量 index 和lastIndex</p>
<ul>
<li>index:b在集合里下标 此时 index = 1</li>
<li>lastIndex：类似于一个map的索引，一开始默认值是0，它会与map中的元素进行比较，比较完后，更新当前的值（取index和lastIndex的较大数）</li>
</ul>
<h4 id="比较规则："><a href="#比较规则：" class="headerlink" title="比较规则："></a>比较规则：</h4><p>如果 index &lt; lastIndex 那此元素就需要移动<br>在旧组合里将该元素移动到下标为lastIndex的位置</p>
<p>具体的计算过程看下图</p>
<p><img src="/images/passive/diff2.jpeg" alt="jsworke"></p>
<h3 id="场景一-新集合中有新加入的节点，旧集合中有删除的节点"><a href="#场景一-新集合中有新加入的节点，旧集合中有删除的节点" class="headerlink" title="场景一 新集合中有新加入的节点，旧集合中有删除的节点"></a>场景一 新集合中有新加入的节点，旧集合中有删除的节点</h3><p>规则同上</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">旧  <span class="selector-tag">a</span> <span class="selector-tag">b</span> c d</span><br><span class="line">新  <span class="selector-tag">b</span> e c a</span><br></pre></td></tr></table></figure>
<p>比较b 此时 index = 1 lastindex = 0  1&gt;0 b不移动 更新 lastindex为1<br>当比较到e的时候，发现旧组合中不存在，故在旧组合下标为1的位置 创建E，更新lastIndex=1<br>…<br>对比到a 因为是最后一个 所以 diff操作结束</p>
<p>新组合对比完成后 再去对旧集合遍历 判断新集合没有，但旧集合有的元素（如d），删除d，diff操作结束</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title>Dom操作成本 浏览器的重排和重绘</title>
    <url>/2018/05/16/dom%E6%93%8D%E4%BD%9C%E6%88%90%E6%9C%AC/</url>
    <content><![CDATA[<p>操作Dom的成本很高 不要轻易去操作Dom 这句话从开始入门就听说，那么这里说的成本是指什么？<br>由此引出今天的问题</p>
<p>首先我们要清楚几个概念</p>
<h3 id="什么是DOM？"><a href="#什么是DOM？" class="headerlink" title="什么是DOM？"></a>什么是DOM？</h3><ul>
<li>DOM全称 Document Object Model 文档对象模型</li>
<li>它是为HTML（XML）提供的API</li>
<li>HTML是一种标记语言 HTML在DOM模型标准中被视为对象</li>
<li>DOM只提供编程接口却无法实际操作HTML里面的内容 </li>
<li>在浏览器中 前端工程师可以通过脚本语言（js）通过DOM去操作HTML内容<br>（不只js能调用DOM这个API Python也可以）</li>
<li>ps：也存在CSSOM：CSS Object Model 浏览器将CSS代码解析成树形的数据结构与DOM是两个独立的数据机构</li>
</ul>
<h3 id="浏览器渲染过程"><a href="#浏览器渲染过程" class="headerlink" title="浏览器渲染过程"></a>浏览器渲染过程</h3><p>讨论DOM操作成本 首先要了解下该成本的来源 那么就离不开浏览器渲染<br>浏览器渲染前需要先构建DOM和CSS树 因此我们需要尽快将HTML和CSS都提供给浏览器</p>
<p>这里只讨论浏览器拿到HTML之后开始解析 渲染 </p>
<font color="red">之前的一些另开一篇</font><br>1. 解析HTML 构建DOM树 （这里遇到外链 会发起请求）<br>2. 解析CSS 生成CSS规则树<br>3. 合并DOM树和CSS规则 生成render（渲染）树<br>4. 布局render树（Layout/reflow）负责各元素的尺寸，位置的计算<br>5. 绘制render树（paint）绘制页面像素信息<br>6. 浏览器会将各层的信息发送给GPU GPU将各层合成(composite) 显示在屏幕上<br>##### 构建DOM树<br><font color="red">HTML 标记转换成文档对象模型 (DOM)</font><br>DOM树构建过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点<br>##### 构建CSSOM树<br><font color="red">CSS 标记转换成 CSS 对象模型 (CSSOM)</font><br>在最终计算各个2节点的样式时 浏览器都会先从该节点的普遍属性（比如全局样式）开始  再去应用该节点的具体属性<br><br>每个浏览器都有自己的默认样式表因此很多时候这颗CSSOM树只是对这张默认样式表的部分替换<br><br>DOM 和CSSOM都要经过<br><code>Bytes→characters→tokens→nodes→objectmodel</code>这个过程<br>DOM和CSSOM是独立的数据结构<br>此处需要一张图片<br><br><br>##### 生成render（渲染）树 由此 浏览器中会解析并生成两个内部数据结构<br><em> Dom树表示页面结构
</em> DOM树和CSSOM合并生成render树（渲染树），渲染树表示Dom节点在页面中如何显示（宽高 位置等）<br><br><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在dom树中每一个需要显示的节点在渲染树种至少存在一个对应的节点 渲染树中的节点被称之为“帧”或者“盒” 符合css模型的定义 一旦Dom树和渲染树构建完成  浏览器就开始 显示（绘制paint）页面元素</span><br></pre></td></tr></table></figure><br><br>简单描述下render的过程<br><br><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">DOM树从根节点开始遍历可见节点</span><br><span class="line">设置了类似 <span class="attribute">display</span>：<span class="attribute">none</span> （则该节点不可见） 在render过程中是被跳过的</span><br><span class="line"><span class="attribute">visibility</span>:hidden; <span class="attribute">opacity</span>:<span class="number">0</span> 这种仍旧占据空间的节点不会被跳过render  保存各个节点的样式信息及其余节点的从属关系</span><br></pre></td></tr></table></figure><br><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Layout布局</span><br><span class="line">有了各个节点的信息属性 但不知道各个节点的确切位置和大小 所以要通过布局将样式信息和属性转换为实际可视窗口的相对大小和位置</span><br><span class="line">（DOM 树捕获文档标记的属性和关系，但并未告诉我们元素在渲染后呈现的外观。那是 CSSOM 的责任）</span><br></pre></td></tr></table></figure><br><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Paint绘制</span><br><span class="line">最后只要将确定好位置大小的各节点通过GPU渲染到屏幕的实际像素</span><br></pre></td></tr></table></figure><br><br>TIPS：<br><br><em> 在上述渲染过程中 前三点可能要多次执行 比如js脚本去操作DOM 更改CSS样式 浏览器又要重新构建DOM CSSOM树 重新render 重新layout paint
</em> 因为layout在paint之前 因此每次layput重新布局（reflow回流）后都要重新触发paint渲染 这时又要去消耗GPU<br><em> paint不一定会触发layout 比如改个颜色改个背景（repaint重绘）
</em> 图片下载完也会重新触发Layout和paint<br><br><br>##### 何时触发reflow（重排）和repaint（重绘）<br><br><br><font color="red">reflow(重排)：</font>当dom树的变化影响了元素的集合属性 =》 意味着元素的内容，结构 位置或者尺寸发生了变化，同样其他元素的集合属性和位置也会因此受到影响，浏览器会使渲染树（render树）中受到影响的部分失效  需要重新计算样式和渲染树，这个过程称为重排（reflow）<br><br><font color="red">repaint(重绘)：</font> 意味着元素发生的改变只你影响了节点的一些样式（背景色 边框颜色 文字元素等）只需要应用新样式绘制这个元素就可以了 （完成重排后 浏览器会重新绘制受影响的部分到屏幕中 这个过程叫做重绘）<br><br>并不是所有的dom辩护都会影响几何属性 例如  改变元素的背景色不会影响 宽和高 这种情况下 只会发生一次重绘（不需要重排）因为元素的布局没有改变<br><br><font color="red">重排一定会引起浏览器的重绘 重绘则不一定伴随重排</font>

<font color="red">重排</font>的成本开销要高于<font color="red">重绘</font>一个节点的重排往往导致子节点以及同级节点的重排<br><br><br><br>###### 触发重排的情况<br><br>当页面布局的几何属性改变时就需要重排 下列情况会导致重排<br><br><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">页面第一次渲染（初始化）</span><br><span class="line"></span><br><span class="line">DOM树变化（如：增删节点）</span><br><span class="line">元素位置改变</span><br><span class="line">元素尺寸改变（外边距 内边距 边框厚度 宽度 高度等）</span><br><span class="line">Render树变化（如：<span class="attribute">padding</span>改变）</span><br><span class="line">浏览器窗口<span class="attribute">resize</span></span><br><span class="line">获取元素的某些属性：</span><br><span class="line">当滚动条出现时，会触发整个页面的重排</span><br></pre></td></tr></table></figure><br><br>由于每次重排都会产生计算消耗，大多数浏览器通过队列化修改并批量执行来优化重排的过程<br><br>但是  我们经常会不知不觉强制刷新队列并要求计划任务立即执行<br>获取布局信息的操作会到最后队列刷新  比如<br><br><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">offsetTop , offsetLeft , offsetWidth , offsetHeight</span><br><span class="line"></span><br><span class="line"><span class="keyword">scrollTop </span>, <span class="keyword">scrollLeft </span>, <span class="keyword">scrollWidth </span>, <span class="keyword">scrollHeight</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">clientTop </span>, clientLeft , clientWidth , clientHeight</span><br><span class="line"></span><br><span class="line">getComputedStyle() ( currentStyle in IE )</span><br></pre></td></tr></table></figure><br><br>当获取以上的属性和方法时 浏览器为了获取最新的布局信息 不得不立即触发重排以返回正确的值<br><br>###### 最小化重绘和重排<br>重绘和重排代价很昂贵 因此一个号的提高程序响应熟读的策略就是减少此类操作的发生<br><br>###### 优化方式<br><br>1. 合并多次对样式属性的操作<br><br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">思考</span><br><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'mydiv'</span>);</span><br><span class="line">el.style.borderLeft = <span class="string">'1px'</span>;</span><br><span class="line">el.style.borderRight = <span class="string">'2px'</span>;</span><br><span class="line">el.style.padding = <span class="string">'5px'</span>;</span><br><span class="line"></span><br><span class="line">即使有浏览器有重排机制优化 但最坏的情况也是进行三次重排</span><br><span class="line"></span><br><span class="line">修改后</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'mydiv'</span>);</span><br><span class="line">el.style.cssText = <span class="string">'border-left: 1px; border-right: 2px; padding: 5px;'</span>;</span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'mydiv'</span>);</span><br><span class="line">el.className = <span class="string">'active'</span>;</span><br></pre></td></tr></table></figure><br><br>2. 批量修改dom<br>当需要对dom元素进行一系列的操作时候 可以通过以下的步骤来减少重绘和重排的次数<br><br><font color="green"> <em> 使元素脱离文本流</em></font><br><font color="green">  操作元素</font><br><font color="green"> * 操作完成后 将元素带回文档中</font><br>这样儿 只有第一步和第三部触发两次重排<br><br>有三种方式可以实现上面的步骤<br><br><br><font color="red"> 1.隐藏元素（display:none）操作元素 重新展示</font>

<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">var</span> ul = document.getElementById('mylist');</span><br><span class="line">ul.<span class="built_in">style</span>.<span class="built_in">display</span> = 'none';</span><br><span class="line">appendDataToElement(ul, data);</span><br><span class="line">ul.<span class="built_in">style</span>.<span class="built_in">display</span> = '<span class="built_in">block</span>';</span><br></pre></td></tr></table></figure>
<font color="red"> 2.使用文档片段（document fragment）在当前 DOM 之外构建一个子树，再把它拷贝回文档<br></font>

<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">appendDataToElement(fragment, data);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'mylist'</span>).appendChild(fragment);</span><br></pre></td></tr></table></figure>
<font color="red"> 3.将原始元素拷贝到一个脱离文档的节点中，修改副本，完成后再替换原始元素<br></font>

<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">old</span> = document.getElementById(<span class="string">'mylist'</span>);</span><br><span class="line"><span class="keyword">var</span> clone = <span class="keyword">old</span>.cloneNode(<span class="keyword">true</span>);</span><br><span class="line">appendDataToElement(clone, data);</span><br><span class="line"><span class="keyword">old</span>.parentNode.replaceChild(clone, <span class="keyword">old</span>);</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong>推荐尽可能的使用文档片段（第二个方案），因为它们所产生的 DOM 遍历和重排次数最少。唯一潜在的问题是文档片段未被充分利用，很多人可能并不熟悉这项技术。</p>
<ol start="3">
<li>缓存布局信息</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">浏览器获取元素的offsetLeft等属性值时会导致重排 将需要获取的保护局信息的属性值 赋值给变量 然后再操作变量</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>定位</li>
</ol>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">将需要多次重排的元素，<span class="attribute">position</span> 属性设置为 absolute 或 fixed，这样元素就脱离了文档流，它的变化不会影响到其他元素。例如有动画效果的元素就最好设置为绝对定位。</span><br></pre></td></tr></table></figure>
<font color="red">操作DOM具体的成本，说到底是造成浏览器重排和重绘，从而消耗GPU资源</font>


















<p>s</p>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Flexbox</title>
    <url>/2019/03/14/flex/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>过去，我们总是不得不忍受<code>float、display:table</code>这些布局方式带来的痛苦，不过现在是时候去拥抱一个更简洁的制作智能布局的现代语法 <code>Flexbox</code></p>
<h2 id="Flexbox是什么"><a href="#Flexbox是什么" class="headerlink" title="Flexbox是什么"></a>Flexbox是什么</h2><p>根据规范中的描述可知道，<code>Flexbox</code>模块提供了一个有效的布局方式，即使不知道视窗大小或者未知元素情况之下都可以智能的，灵活的调整和分配元素和空间两者之间的关系</p>
<a id="more"></a>
<h2 id="如何开始使用Flexbox"><a href="#如何开始使用Flexbox" class="headerlink" title="如何开始使用Flexbox"></a>如何开始使用Flexbox</h2><p>幸运的是，入门超级简单<br>你要做的第一件事就是声明一个<code>Flex</code>容器</p>
<p>就像这样儿，声明了<code>Flex</code>容器之后，一个<code>Flexbox</code>格式化上下文就立即启动了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;ul <span class="class"><span class="keyword">class</span></span>=<span class="string">"oul"</span>&gt;</span><br><span class="line">  &lt;li&gt;<span class="number">1</span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">  &lt;li&gt;2&lt;/</span>li&gt;</span><br><span class="line">  &lt;li&gt;<span class="number">3</span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br></pre></td></tr></table></figure>
<p>正常情况下div在CSS中垂直堆栈的，也就是说从上到下排列显示</p>
<p>图一<br><img src="/images/flex/flex2.png" alt="flex2"></p>
<p>声明<code>Flex容器</code></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.oul</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="attribute">display</span>: flex</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在已经是一个Flexbox格式化上下文<br>图二<br><img src="/images/flex/flex1.png" alt="flex1"></p>
<p><strong>很简单 一行代码就能看到布局改变了子元素就像你使用了float一样是水平排列的</strong></p>
<p>拿这个例子来说此时<code>ul</code>自动变成了<code>Flex</code>，而 <code>li</code>变成了<code>Flex</code>项目</p>
<p>记住这些名词，它们是<code>Flexbox</code>模块的基础</p>
<h2 id="Flex容器属性"><a href="#Flex容器属性" class="headerlink" title="Flex容器属性"></a>Flex容器属性</h2><p><code>flex-direction || flex-wrap || flex-flow || justify-content || align-items || align-content</code><br>解释这些属性之前，先来看一张flex世界比较重要的概念</p>
<p><img src="/images/flex/flex3.png" alt="flex3"></p>
<ul>
<li><code>Main-Axis</code>就是水平方向，从左到右，这也是默认方向</li>
<li><code>Cross-Axis</code>是垂直方向，从上往下</li>
</ul>
<h3 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h3><p>属性值</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> &#123; <span class="attribute">flex-direction</span>: row || column || row-reverse || column-reverse; &#125;</span><br></pre></td></tr></table></figure>
<p>默认值是<code>row</code>它让Flex项目沿着Main-Axis排列（从左向右，水平排列） 这也解释了图二的效果</p>
<h3 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h3><p>属性值</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> &#123; <span class="attribute">flex-wrap</span>: wrap || nowrap || wrap-reverse; &#125;</span><br><span class="line"></span><br><span class="line">*  <span class="selector-tag">nowrap</span>: <span class="selector-tag">Flex</span>容器内的<span class="selector-tag">Flex</span>项目不换行排列 （默认值）</span><br><span class="line">*  <span class="selector-tag">wrap</span>:换行排列 这种情况下，一行不能包含所有列表项的默认宽度，它们就会多行排列</span><br><span class="line">*  <span class="selector-tag">wrap-reverse</span>:反向换行</span><br></pre></td></tr></table></figure>
<h3 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">flex-flow</span>是<span class="selector-tag">flex-direction</span>和<span class="selector-tag">flex-wrap</span>两个属性的速记属性</span><br></pre></td></tr></table></figure>
<p>语法<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> &#123; <span class="attribute">flex-flow</span>: row wrap; &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h3><p>接下来感受来自<code>flex</code>容器的魔法</p>
<p>它主要定义了Flex项目在<code>Main-Axis</code>上的对齐方式</p>
<p>属性值</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> &#123; <span class="attribute">justify-content</span>: flex-start || flex-end || center || space-between || space-around &#125;</span><br><span class="line">* <span class="selector-tag">flex-start</span> 元素位于容器的开头。弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。</span><br><span class="line">* <span class="selector-tag">flex-end</span> 元素位于容器的结尾，弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界</span><br><span class="line">* <span class="selector-tag">center</span>：居中对齐</span><br><span class="line">* <span class="selector-tag">space-between</span>：让除了第一个和最一个<span class="selector-tag">Flex</span>项目的两者间间距相同（两端对齐）</span><br><span class="line">* <span class="selector-tag">space-around</span>：让每个<span class="selector-tag">Flex</span>项目具有相同的空间</span><br></pre></td></tr></table></figure>
<p><strong>space-between</strong><br><img src="/images/flex/between.png" alt="between"><br><strong>space-around</strong></p>
<p>和space-between有点不同，第一个Flex项目和最后一个Flex项目距Main-Axis开始边缘和结束边缘的的间距是其他相邻Flex项目间距的一半<br><img src="/images/flex/around.png" alt="around"></p>
<h3 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h3><p>它主要用来控制Flex项目在侧轴上的对齐方式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> &#123; <span class="attribute">align-items</span>: flex-start || flex-end || center || stretch || baseline &#125;</span><br><span class="line"></span><br><span class="line">* <span class="selector-tag">stretch</span> 默认值 让所有的<span class="selector-tag">Flex</span>项目高度和<span class="selector-tag">Flex</span>容器高度一样。</span><br><span class="line">* <span class="selector-tag">flex-start</span> 元素位于容器的开头。弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。</span><br><span class="line">* <span class="selector-tag">flex-end</span> 元素位于容器的结尾，弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界</span><br><span class="line">* <span class="selector-tag">center</span> 元素位于容器的中心</span><br><span class="line">* <span class="selector-tag">baseline</span> 让所有<span class="selector-tag">Flex</span>项目在<span class="selector-tag">Cross-Axis</span>上沿着他们自己的基线对齐</span><br></pre></td></tr></table></figure>
<p><strong>baseline</strong><br>效果类似<code>flex-start</code>但略有不同<br>区别就在于<code>baseline</code><br><img src="/images/flex/base.png" alt="base"></p>
<h3 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h3><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">ul &#123; align-items: stretch|center|flex-start|flex-<span class="keyword">end</span>|<span class="literal">space</span>-<span class="keyword">between</span>|<span class="literal">space</span>-<span class="keyword">around</span>&#125;</span><br><span class="line"></span><br><span class="line">* stretch 默认值 元素被拉伸以适应容器</span><br><span class="line">* flex-start 元素位于容器的开头。弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。</span><br><span class="line">* flex-<span class="keyword">end</span> 元素位于容器的结尾，弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界</span><br><span class="line">* center 元素位于容器的中心</span><br><span class="line">* <span class="literal">space</span>-<span class="keyword">between</span>：让除了第一个和最一个Flex项目的两者间间距相同（两端对齐）</span><br><span class="line">* <span class="literal">space</span>-<span class="keyword">around</span>：让每个Flex项目具有相同的空间</span><br></pre></td></tr></table></figure>
<p><strong>stretch</strong><br><img src="/images/flex/align-content.png" alt="align-content"><br>flex-end<br><img src="/images/flex/ennd.png" alt="ennd"></p>
<p><strong>flex-start</strong></p>
<p><img src="/images/flex/align-content-start.png" alt="align-content-start"></p>
<p><strong>center</strong><br><img src="/images/flex/center.png" alt="cente"></p>
<h2 id="Flex项目属性"><a href="#Flex项目属性" class="headerlink" title="Flex项目属性"></a>Flex项目属性</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">order || flex-grow || flex-shrink || flex-basis</span><br></pre></td></tr></table></figure>
<h3 id="order"><a href="#order" class="headerlink" title="order"></a>order</h3><p>允许Flex项目在一个Flex容器中重新排序。基本上，你可以改变Flex项目的顺序，从一个位置移动到另一个地方而不改变源代码，所有Flex项目的order值都是0，Flex项目会根据order值从低到高重新排序</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.oul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(1)</span> &#123;</span><br><span class="line">    <span class="attribute">order</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/*设置一个比0更大的值*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Flex项目2、3、4的order值为0。现在Flex项目1的order值为1</p>
<p><img src="/images/flex/order.png" alt="orde"></p>
<p>Flex项目<code>2、3和4的order</code>值都是<code>0</code>。HTML源代码秩序并没有修改过。如果给<code>Flex</code>项目2的<code>order</code>设置为<code>2</code><br><img src="/images/flex/order2.png" alt="orde"></p>
<p>可见 它也增加堆栈。现在代表<code>Flex</code>项目的最高的<code>order</code>值</p>
<p>当两个Flex项目具有相同的order值呢？在下面的示例中，把Flex项目1和3设置相同的order值。<br><img src="/images/flex/order3.png" alt="orde"><br>现在仍是从低到高排列。这次<code>Flex</code>项目<code>3</code>排在<code>Flex</code>项目<code>1</code>后面，那是因为在<code>HTML</code>文档中<code>Flex</code>项目<code>3</code>出现在<code>Flex</code>项目<code>1</code>后面。</p>
<p>如果两个以下<code>Flex</code>项目有相同的<code>order</code>值时，<code>Flex</code>项目重新排序是基于<code>HTML</code>源文件的位置进行排序</p>
<h3 id="flex-grow-和-flex-shrink"><a href="#flex-grow-和-flex-shrink" class="headerlink" title="flex-grow 和 flex-shrink"></a>flex-grow 和 flex-shrink</h3><ul>
<li>flex-grow ：控制<code>Flex</code>项目在容器有多余的空间如何放大（扩展）默认值是0 表示开关是关闭的，即如果存在剩余空间，也不放大</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: &lt;number&gt;; <span class="comment">/* default 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/flex/flow-grow.png" alt="flow-gro"><br>属性值为1时<br><img src="/images/flex/flow-grow1.png" alt="flow-gro"></p>
<p>现在<code>Flex</code>项目扩展了，占据了Flex容器所有可用空间。也就是说开关打开了。如果你试着调整你浏览器的大小，<code>Flex</code>项目也会缩小，以适应新的屏幕宽度</p>
<p>如果所有项目的<code>flex-grow</code>属性都为<code>1</code>，则它们将等分剩余空间（如果有的话）<br>如果一个项目的<code>flex-grow</code>属性为<code>2</code>，其他项目都为<code>1</code>，则前者占据的剩余空间将比其他项多一倍</p>
<ul>
<li>flex-shrink：属性定义了项目的缩小比例，默认为<code>1</code>（默认开启），即如果空间不足，该项目将缩小</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: &lt;number&gt;; <span class="comment">/* default 1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h3><p>它用于设置或检索弹性盒伸缩基准值<br><code>浏览器</code>根据这个属性，计算主轴是否有多余空间一般配合 <code>flex-wrap</code>一起使用，flex容器根据 <code>flex-basis</code> 计算是否需要换行</p>
<p>一些特性</p>
<h4 id="1-它的属性值可以是长度单位-em-rem-px-或百分比-，百分比是按照父元素的width为标准"><a href="#1-它的属性值可以是长度单位-em-rem-px-或百分比-，百分比是按照父元素的width为标准" class="headerlink" title="1.它的属性值可以是长度单位(em || rem || px)或百分比(%)，百分比是按照父元素的width为标准"></a>1.它的属性值可以是<strong>长度单位(em || rem || px)</strong>或<strong>百分比(%)</strong>，<font color="red">百分比是按照父元素的width为标准</font></h4><h4 id="2-默认值为-auto-MDN"><a href="#2-默认值为-auto-MDN" class="headerlink" title="2.默认值为 auto  MDN"></a>2.默认值为 <font color="red">auto</font>  <a href="https://drafts.csswg.org/css-flexbox/#flexibility" target="_blank" rel="noopener">MDN</a></h4> <figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">取值为**<span class="attribute">auto</span>**时，它的值就等于当前项的**<span class="attribute">width</span>**（或者默认的大小，<span class="attribute">width</span>没有设置的话）" </span><br><span class="line"><span class="attribute">flex-basis</span>:auto<span class="string">" 的含义是 "</span>参照我的width和height属性</span><br></pre></td></tr></table></figure>
<h4 id="当flex-item没有自身宽高，其默认大小由flex-basis决定"><a href="#当flex-item没有自身宽高，其默认大小由flex-basis决定" class="headerlink" title="当flex-item没有自身宽高，其默认大小由flex-basis决定"></a>当flex-item没有自身宽高，其默认大小由flex-basis决定</h4><p>即优先级： <font color="red">flex-basis &gt; width(非auto)</font></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.oul2-li</span>&#123;</span><br><span class="line">      <span class="attribute">flex-basis</span>: <span class="number">200px</span>;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">10px</span>;</span><br><span class="line">      <span class="attribute">margin</span>: <span class="number">0px</span> <span class="number">4px</span>;</span><br><span class="line">      <span class="attribute">background</span>: red;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/flex/shiliflex1.png" alt="shiliflex1"></p>
<h4 id="4-当元素存在默认宽高（input）"><a href="#4-当元素存在默认宽高（input）" class="headerlink" title="4.当元素存在默认宽高（input）"></a>4.当元素存在默认宽高（<font color="red">input</font>）</h4><p>并且设置了 <code>flex-basis</code>，那么它的初始大小<code>以固定宽高为下限</code>，如果<code>flex-basis</code>超过了固定宽高，那么以<code>flex-basis</code>设置大小为准，如果<code>flex-basis</code>比固定宽高小，那么以固定宽高为准</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.Myinput</span> &#123;</span><br><span class="line">     <span class="attribute">background</span>: greenyellow;</span><br><span class="line">     <span class="attribute">flex-basis</span>: <span class="number">200px</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/flex/gfdsdf.png" alt="gfdsdf"><br>当将<code>flex-basis</code>设置的比默认宽度大</p>
<p><img src="/images/flex/swqs.png" alt="swqs"></p>
<p>当将<code>flex-basis</code>设置的比默认宽度小 100<br><img src="/images/flex/jnjjjuuu.png" alt="jnjjjuuu"></p>
<h4 id="5-当元素存在-min-width-height-或者-max-width-height"><a href="#5-当元素存在-min-width-height-或者-max-width-height" class="headerlink" title="5.当元素存在 min-width[height] 或者 max-width[height]"></a>5.当元素存在 min-width[height] 或者 max-width[height]</h4><figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">如果 `flex-basis` 的值 大于 `min-width[min-height]`，`flex-item content`的值为 `flex-basis`</span><br><span class="line">如果`flex-basis `的值小于` min-width[min-height]` 那么`flex-item content`以`min-width[min-height]`计算</span><br></pre></td></tr></table></figure>
<p><img src="/images/flex/jsjjsjsjjjsjsjs.png" alt="jsjjsjsjjjsjsjs"></p>
<h4 id="6-元素设置width-height-auto"><a href="#6-元素设置width-height-auto" class="headerlink" title="6.元素设置width[height]: auto;"></a>6.元素设置<code>width[height]: auto;</code></h4><p>CSS解析器对比两者的值，两者<strong>谁大取谁</strong>作为<code>item</code>的基本尺寸，如果一个<code>item</code>没有内容，flex-item 初始大小就会以<code>flex-basis</code>来决定<br>但是如果<code>item</code>有了内容，且内容撑开的尺寸比<code>flex-basis</code>大，那么<code>flex-item</code>初始大小就会以<code>width[height]: auto;</code>来决定<br><br>优先级：<font color="red">width[height]: auto == flex-basis</font></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"> &lt;<span class="selector-tag">ul</span> class=<span class="string">"oul2"</span>&gt;</span><br><span class="line">      &lt;<span class="selector-tag">li</span> class=<span class="string">"li1"</span>&gt;<span class="number">666666666666666666666666666666666666666666666666666666666666666666666666666666666666</span>&lt;/li&gt;</span><br><span class="line">      &lt;<span class="selector-tag">li</span> class=<span class="string">"li2"</span>&gt;<span class="number">77777</span>&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    </span><br><span class="line">    .li1&#123;</span><br><span class="line">    <span class="attribute">flex-basis</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">background</span>: greenyellow;</span><br><span class="line">    <span class="attribute">width</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line">.li2&#123;</span><br><span class="line">    <span class="attribute">flex-basis</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">width</span>: auto;</span><br><span class="line">    <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.oul2&#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">list-style</span>: none;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/flex/uuxsuudhdusd.png" alt="uuxsuudhdusd"></p>
<h2 id="绝对和相对Flex项目"><a href="#绝对和相对Flex项目" class="headerlink" title="绝对和相对Flex项目"></a>绝对和相对Flex项目</h2><p>绝对Flex项目的宽度只基于 flex 属性，而相对Flex项目的宽度基于内容大小</p>
<p><strong>相对项目</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.oul</span> &#123;</span><br><span class="line">     <span class="attribute">display</span>: flex;</span><br><span class="line">     <span class="comment">/*触发弹性盒*/</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="selector-class">.oul</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">     //flex-basis: auto;</span><br><span class="line">     <span class="selector-tag">flex</span>: <span class="selector-tag">auto</span>; <span class="comment">/*记住这与 flex: 1 1 auto; 相同*/</span></span><br><span class="line">     <span class="selector-tag">border</span>: 2<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-tag">red</span>;</span><br><span class="line">     <span class="selector-tag">margin</span>: 2<span class="selector-tag">rem</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/flex/xianngdui.png" alt="xianngdui"></p>
<p>Flex项目的初始宽度是被自动计算的（<code>flex-basis: auto</code>），然后会伸展以适应可用空间（<code>flex-grow: 1</code>）</p>
<p>像这样 当<code>Flex</code>项目因为被设置为 <code>flex-basis: auto</code>，而导致宽度被自动计算时，是基于<code>Flex</code>项目内包含的内容的大小而计算的就是相对项目</p>
<p><strong>绝对项目</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.oul</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">     <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">     <span class="attribute">flex-shrink</span>: <span class="number">1</span>;</span><br><span class="line">     <span class="attribute">flex-basis</span>: <span class="number">0</span>;</span><br><span class="line">     <span class="comment">/*与 flex: 1 1 0 相同*/</span></span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> solid red;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">2rem</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/flex/juedui.png" alt="juedui"></p>
<p><code>Flex</code>项目的初始宽度是零（<code>flex-basis: 0</code>），并且它们会伸展以适应可用空间。当有两到多个<code>Flex</code>项目的 <code>flex-basis</code> 取值为<code>0</code>时，它们会基于<code>flex-grow</code>值共享可用空间</p>
<h3 id="flex组合属性"><a href="#flex组合属性" class="headerlink" title="flex组合属性"></a>flex组合属性</h3><p>flex是<code>flex-grow、flex-shrink和flex-basis</code>三个属性的速记（简写）顺序缩写为 GSB </p>
<h4 id="一些取值规律"><a href="#一些取值规律" class="headerlink" title="一些取值规律"></a>一些取值规律</h4><p><strong>当 flex 取值为一个非负数字，则该数字为 flex-grow 值，flex-shrink 取 1，flex-basis 取 0%，例如：flex: 1; 相当于</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">flex-basis</span>: <span class="number">0%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>⚠️ <code>flex-basis的</code>默认值为<code>auto</code>，为什么此时是<code>0%</code>？<br>当你创建一个flexbox上下文而不给flex项目设置任何属性，此时的默认值<br><img src="/images/flex/wwwaaaa111.png" alt="wwwaaaa111"><br>此时它是<font color="red">相对项目</font><br>一旦你设置了<code>flex:1</code>简写属性</p>
<p>参考MDN所说<br><img src="/images/flex/flexjianxie.png" alt="flexjianxie"><br>浏览器使其变成了<font color="red">绝对项目</font></p>
<p><strong>flex: auto;</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">li</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">flex-basis</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>当 flex 取值为一个长度或百分比，则视为 flex-basis 值，flex-grow 取 1，flex-shrink 取 1，有如下等同情况（注意 0% 是一个百分比而不是一个非负数字）</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;<span class="attribute">flex</span>: <span class="number">0%</span>;&#125;</span><br><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">flex-basis</span>: <span class="number">0%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item-2</span> &#123;<span class="attribute">flex</span>: <span class="number">24px</span>;&#125;</span><br><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">flex-basis</span>: <span class="number">24px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>当 flex 取值为两个非负数字，则分别视为 flex-grow 和 flex-shrink 的值，flex-basis 取 0%，如下是等同的：</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;<span class="attribute">flex</span>: <span class="number">2</span> <span class="number">3</span>;&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">2</span>;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: <span class="number">3</span>;</span><br><span class="line">    <span class="attribute">flex-basis</span>: <span class="number">0%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>当 flex 取值为一个非负数字和一个长度或百分比，则分别视为 flex-grow 和 flex-basis 的值，flex-shrink 取 1，如下是等同的：</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;<span class="attribute">flex</span>: <span class="number">2333</span> <span class="number">3222px</span>;&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">2333</span>;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">flex-basis</span>: <span class="number">3222px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="深入flex"><a href="#深入flex" class="headerlink" title="深入flex"></a>深入flex</h2><p>到这里 关于<code>Flex</code>的基础知识已经结束了,你可以用它们处理几乎任何问题<br>但是</p>
<font color="red">Flexbox是如何弹性的计算子级项目的大小的，它有没有什么规则 </font><br>令我费解<br><br>好了，小🌻课堂开始了<br><br>flex是应用在X轴和Y轴上的<br>每一根轴都包括三个东西 <code>维度、方向、尺寸</code><br><br><em> 维度：子元素横着排(X轴)还是竖着排(Y轴)
</em> 方向：子元素的顺序(顺序还是逆序)<br><em> 尺寸：即父元素的<code>width</code>，子元素在当前轴方向所占的位置的总和<br><br>如下图所示（来自W3C规范）<br><br><img src="/images/flex/w3c.png" alt="w3"><br><br>## FFC(flex formatting context)<br>Flexbox 布局新定义了格式化上下文，类似 BFC（block formatting context）<br>定义了<code>display: flex;</code> 或 <code>display: inline-flex</code>的元素，和<code>BFC</code>一样，不会被浮动的元素遮盖，不会垂直外边距坍塌等等<br><br>## 与BFC的细微区别

</em> vertical-align 对 Flexbox 中的子元素 是没有效果的<br><em> float 和 clear 属性对 Flexbox 中的子元素是没有效果的，也不会使子元素脱离文档流(但是对Flexbox 是有效果的！)
</em> Flexbox 下的子元素不会继承父级容器的宽<br><br>## flex item（flex 子元素）<br>CSS解析器会把 定义了 <code>display: flex;</code> 和 <code>display: inline-flex;</code> 的 <code>Flexbox</code>下的子元素外部装进一个看不见的盒子里，我们通过排列这些盒子来达到排序、布局、 伸缩的目的<br><br>### flex-item-size 是如何计算的<br>子元素的尺寸为主轴方向上元素的的自身宽度 再加上自身的<code>margin 、 border 和 padding</code><br><br>W3C规范中介绍了  <code>flex-item content</code> 的计算规则<br><br>### 隐藏属性对 items-size 的影响<br><br>针对 <code>display: none; visibility: hidden; visibility: collapse; transform: scale;</code>进行测试<br><br>结论<br><em> 如果设置了 <code>visibility: hidden; | visibility: collapse; | transform: scale;</code>的<code>flex-item content</code>依然被算进主轴尺寸，CSS 解析器依然将可用空间分配给他们
</em> 如果设置了<code>display: none;</code> CSS解析器不会对该<code>item</code>的空间进行计算<br><br>### 关于position: absolute 对item影响<br><br><code>position: absolute</code>也是适用 <code>Flexbox</code> 中的子元素的，并且，设置了<code>position: absolute</code>属性的子元素，也会受到 <code>Flexbox</code> 排列的影响<br><br><br>absolute 的子元素重叠在了一起，但是依然会受到 <code>align-items: center;</code>的影响而居中<br><br><img src="/images/flex/jjjjjdsd.png" alt="jjjjjdsd"><br><br>并且根据一系列的实验得知<br><br><code>flexbox</code> 下设置了<code>absolute</code>：<br><br><em> flexbox 流下面的 <code>justify-content</code> 和 <code>align-items</code>
</em> <code>item</code>的 <code>top、left、right、bottom</code><br><em> <code>margin</code>自始至终都会影响<code>item</code>的位置
</em> 脱离了文档流的 <code>item</code> 不会影响正常的<code>flex</code> 布局<br><br><strong>小结</strong><br><code>justify-content、align-items</code> 和 <code>top、left、right、bottom</code>都是位置属性 且 <code>top、left、right、bottom</code>的值会覆盖 <code>justify-content、align-items</code>的值<br><br><code>margin</code>的优先级是和 <code>top、left、right、bottom</code> 一样的，也就是说 <code>margin 和 top、left、right、bottom</code>所设置的值会<strong>同时生效</strong><br><br><br>## flex-basis、flex-grow、flex-shrink 以及相应的计算<br><br>这三个属性只有父级元素设置了 <code>display: flex | inline-flex;</code> 才会生效，并且只针对主轴方向生效<br><br><em> 如果 主轴是水平的，即 <code>flex-direction: row</code>; 那么 <code>flex-basis、flex-grow、flex-shrink</code>控制的就是单个<code>item</code>的宽度
</em> 如果 主轴是垂直的，即 <code>flex-direction: column</code>; 那么 <code>flex-basis、flex-grow、flex-shrink</code> 控制的就是单个item的高度<br><br>——-<br><br><br>那么所有<code>items</code>都会在主轴方向上的一条线上排列，<code>CSS解析器</code>会计算<code>items</code>在主轴方向上所占的空间 相对于<code>Flexbox</code>在主轴方向的所占的空间进行比较计算<br><br><em> 如果 <code>items</code> 所占的空间是小于<code>Flexbox</code>的 那么说明<code>Flexbox</code> 还没有填满，<code>CSS解析器</code>就会计算还有多少空间没有填满，根据每一个<code>item</code>所设置的<code>flex-grow</code> 设置的值，将这些空间分配按比例分配给每一个<code>item</code><br><br><img src="/images/flex/wwwqwq.png" alt="wwwqwq">

</em> 如果 <code>items</code> 所占的空间是大于<code>Flexbox</code>的 那么说明<code>Flexbox</code> 被填满了，<code>CSS解析器</code>就会计算超出了多少空间，根据每一个<code>item</code>所设置的<code>flex-shrink</code>设置的值，将这些空间分配按比例缩小每一个<code>item</code><br> <img src="/images/flex/fukeyongkongjian.png" alt="fukeyongkongjian"><br><br><br>### 超出的空间是如何计算的<br><br><strong><code>flow-grow</code>的计算流程</strong><br><br><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">可用空间 = 将flexbox-content - 每个<span class="built_in">item</span>-size的总和</span><br></pre></td></tr></table></figure><br><br>将元素设置的<code>flow-grow</code>值加起来设置为 <code>growSize</code><br><code>单位分配空间 = 可用空间/growSize</code><br>然后真正分配的时候根据自己的比例计算增加的值<br><code>应该增加的值 = 自己的grow值 *  单位分配空间</code><br><br><img src="/images/flex/growfencdc.png" alt="growfencd"><br><br><br><strong><code>flow-shrink</code>的计算流程</strong><br><br>它的流程与<code>flow-grow</code>的计算流程<font color="red">不同</font>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">shrink比例 = flex-shrink * item-size / 之前的总和</span><br><span class="line"></span><br><span class="line">应该缩减的值：超出的空间 <span class="selector-tag">-</span> <span class="selector-tag">shrink</span>比例 * <span class="selector-tag">item-size</span></span><br></pre></td></tr></table></figure>
<p>如图所示</p>
<p><img src="/images/flex/shrinksw.png" alt="shrinks"></p>
<p><strong>max-width[height] 情况下 flex-grow 的计算流程</strong></p>
<p>由于可能存在某一个或多个<code>item</code> 设置了有<code>max-width[height]</code>。所以，CSS引擎会先进行一次分配，分配后，统计那些有<code>max-width[height]的items</code>, 分配后是否有超出的剩余空间，然后对这些剩余空间再分配给那些没有设置<code>max-width[height]</code>的<code>item</code></p>
<p><img src="/images/flex/sandjandjnsjdwednjsedf.png" alt="sandjandjnsjdwednjsedf"></p>
<p><strong>min-width[height] 情况下 flex-shrink</strong></p>
<p>由于可能存在某一个或多个item 设置了有<code>min-width[height]</code>。所以，<code>CSS引擎</code>会先进行一次 <code>shrink</code>， <code>shrink</code>后，统计那些有<code>min-width[height]</code>的<code>items</code>, <code>shrink</code>后是否有的剩余的未<code>shrink</code>空间，然后对这些剩余空间再分配给那些没有设置<code>min-width[height]</code>的<code>item</code></p>
<p><img src="/images/flex/iiisjindndnjsndjsdnxjksndj.png" alt="iiisjindndnjsndjsdnxjksndj"></p>
<h2 id="Flexbox的浏览器支持"><a href="#Flexbox的浏览器支持" class="headerlink" title="Flexbox的浏览器支持"></a>Flexbox的浏览器支持</h2><p>让我们求助于 <a href="https://caniuse.com/#search=flex" target="_blank" rel="noopener">caniuse</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>深入理解Flex 还是挺不容易的。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.w3cplus.com/css3/understanding-flexbox-everything-you-need-to-know.html" target="_blank" rel="noopener">理解flexbox，你需要知道的一切</a><br><a href="https://www.w3cplus.com/css3/flexbox-adventures.html" target="_blank" rel="noopener">探索Flexbox</a><br><a href="https://www.w3cplus.com/css3/flexbox-layout-and-calculation.html?from=groupmessage" target="_blank" rel="noopener">理解flex</a></p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title>js冷知识</title>
    <url>/2018/01/16/javascript%E5%86%B7%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<!-- <blockquote class="blockquote-center">blah blah blah</blockquote> -->
<ol>
<li><p><strong>去除input[type=’number’]时的右侧上下箭头</strong></p>
<p>   /<em>在chrome下：</em>/</p>
<pre><code>input::-webkit-outer-spin-button,
input::-webkit-inner-spin-button{
    -webkit-appearance: none !important;
    margin: 0;
    padding-left:5px;
}

/*Firefox下：*/
input[type=&quot;number&quot;]{-moz-appearance:textfield;}
</code></pre></li>
</ol>
<ol start="2">
<li><p><strong>判断小数不能大于两位</strong></p>
<pre><code>var hopePriceLength = hopePrice.toString().split(&quot;.&quot;)[1].length;
  if(hopePriceLength&gt;2){
      notify(&apos;请输入正数，最多两位小数&apos;,&apos;error&apos;);
      $(`#${mid}jp-hope-price`).focus();
      return false;
  }
</code></pre></li>
</ol>
<a id="more"></a>
<p>3.<strong>去掉ios手机上tap时的黑色背景</strong></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span>,<span class="selector-tag">img</span>,<span class="selector-tag">button</span>,<span class="selector-tag">input</span>,textarea</span><br><span class="line">&#123;-webkit-tap-highlight-<span class="attribute">color</span>:rgba(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.另外，如何去掉<span class="selector-tag">textarea</span>,input的默认样式：</span><br><span class="line"><span class="selector-tag">input</span>,textarea&#123;-webkit-appearance:<span class="attribute">none</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>4.<strong>判断数据的类型</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isType = <span class="function"><span class="keyword">function</span>(<span class="params"> type </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"> obj </span>)</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call( obj ) === <span class="string">'[object '</span>+ type +<span class="string">']'</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> isString = isType( <span class="string">'String'</span> );</span><br><span class="line"> <span class="keyword">var</span> isArray = isType( <span class="string">'Array'</span> );</span><br><span class="line"> <span class="keyword">var</span> isNumber = isType( <span class="string">'Number'</span> );</span><br><span class="line"><span class="built_in">console</span>.log( isArray( [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ] ) );</span><br></pre></td></tr></table></figure>
<p>4.<strong>HTML5去除input [type=search] 的默认边框和删除按钮</strong></p>
<p> x-webkit-speech  属性：在GOOGLE浏览器上  还会显示一个小话筒<br> autocomplete=”off”  属性  关闭浏览器自动记录之前输入的值</p>
<p>webkit内核浏览器里 input 框类型如果是 type=”search”<br>那么将会有边框问题，border:0px 也不能起到作用；</p>
<p>解决方案</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type="search"]</span>&#123;<span class="attribute">-webkit-appearance</span>:none;&#125;</span><br></pre></td></tr></table></figure>
<p>移除 重置默认的Webkit引擎下的Input样式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=search]</span> &#123;</span><br><span class="line"><span class="attribute">-webkit-appearance</span>: textfield;</span><br><span class="line"><span class="attribute">-webkit-box-sizing</span>: content-box;</span><br><span class="line"><span class="attribute">font-family</span>: inherit;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">::-webkit-search-decoration</span>,</span><br><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">::-webkit-search-cancel-button</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5.禁止ios和android用户选中文字</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">css</span>&#123;<span class="attribute">-webkit-touch-callout</span>: none&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>issue</tag>
      </tags>
  </entry>
  <entry>
    <title>你不知道的JS系列-细说JS继承</title>
    <url>/2019/03/15/jsIInheritance/</url>
    <content><![CDATA[<p>面向对象语言支持两种继承方式：接口继承（只继承方法签名）和实现继承（继承实际的方法）由于函数没有签名，ECMAScript只支持实现继承，而实现继承主要是依靠原型链实现的</p>
<p>下面就当下几种继承方式做一个对比参考<br><a id="more"></a></p>
<h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><p><font color="red">核心思想：</font>利用原型让一个引用类型继承另一个引用类型的属性和方法（将父类的实例作为子类的原型）</p>
<hr>
<h3 id="举个🌰"><a href="#举个🌰" class="headerlink" title="举个🌰"></a>举个🌰</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'yishu'</span>;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">25</span>;</span><br><span class="line">&#125; </span><br><span class="line"> <span class="comment">//原型链继承</span></span><br><span class="line"> SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line"> SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.age</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">var</span> instance = <span class="keyword">new</span> SubType(); <span class="comment">//原型链继承</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'age'</span>,instance.age) <span class="comment">// 25</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'name'</span>,instance.name) <span class="comment">//yishu</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'sayName'</span>,instance.sayName()) <span class="comment">//yishu</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'sayAge'</span>,instance.sayAge()) <span class="comment">//25</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">' instance.toString()'</span>, instance.toString()) <span class="comment">//[object Object]</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>纯粹的继承关系，实例是子类的实例，也是父类的实例</li>
<li>父类新增原型方法/原型属性，子类都能访问到</li>
<li>简单 易于实现</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>无法实现多继承</li>
<li>创建子类型的实例时，不能向超类型的构造函数中传递参数</li>
<li><strong>包含引用类型值的原型会被所有的实例共享</strong>，通过原型来实现继承的时候，原型实际上会变成另一个类型的实例，于是原来的实例属性也就变成了现在的原型属性了(<font color="red">来自原型对象的所有属性被所有实例共享</font>)</li>
<li>想要为子类添加属性或方法 只能在<code>new SubType()</code>之后</li>
</ul>
<hr>
<p>推荐指数：❤️ （3，4问题比较致命）</p>
<h2 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h2><p><font color="red">核心思想：</font>使用父类的构造函数来增强子类实例，相当于复制父类的实例属性给子类（没用到原型） （<strong>不涉及到原型</strong>）</p>
<p><font color="red">技术原理：</font><br>在子类型构造函数的内部调用超类型构造函数</p>
<p><strong>插播:</strong>函数只不过是在特定环境中执行代码的对象，因此 你可以通过使用<code>apply</code>或者<code>call</code>方法也可以在将来新创建的对象上执行构造函数</p>
<p>举个🌰</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.colors = [<span class="string">'red'</span>,<span class="string">'blue'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">SuperType.call(<span class="keyword">this</span>) <span class="comment">//继承了SuperType</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">'black'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors) <span class="comment">//["red", "blue", "black"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors)  <span class="comment">//["red", "blue"]</span></span><br></pre></td></tr></table></figure>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul>
<li>解决实例共享问题</li>
</ul>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">这样儿会在`SubType`对象上执行`SuperType`函数中定义的所有对象初始化代码，`SubType`的每个实例就都会具有自己`colors`属性的副本了</span><br></pre></td></tr></table></figure>
<ul>
<li>解决传递参数的问题</li>
</ul>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span><span class="params">(name)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name= name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span><span class="params">(name,age)</span></span>&#123;</span><br><span class="line">SuperType.call(<span class="keyword">this</span>,name) <span class="comment">//继承了SuperType 同时传递了参数</span></span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType(<span class="string">'yishu'</span>,<span class="number">18</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>可以实现多继承（call多个父类对象）</li>
</ul>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>只能继承父类的实例属性和方法，不能继承原型属性和方法</li>
<li>无法实现函数复用，每个子类都有父类实例函数的副本，影响性能</li>
</ul>
<hr>
<p>推荐指数：❤️❤️（缺点2比较致命）</p>
<h2 id="组合继承（最常用的继承模式）"><a href="#组合继承（最常用的继承模式）" class="headerlink" title="组合继承（最常用的继承模式）"></a>组合继承（最常用的继承模式）</h2><p><font color="red">核心思想：</font>将原型链和构造函数的技术组合到一起 从而发挥二者之长</p>
<p><font color="red">技术原理：</font><br>使用原型链实现对原型属性和方法的继承<br>使用构造函数来实现对实例属性的继承<br>这样能实现<strong>在原型上定义方法实现了函数的服用又能保证每个实例有它自己的属性</strong></p>
<h3 id="举个🌰-1"><a href="#举个🌰-1" class="headerlink" title="举个🌰"></a>举个🌰</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">'red'</span>,<span class="string">'blue'</span>,<span class="string">'green'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span> (<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">  SuperType.call(<span class="keyword">this</span>,name); <span class="comment">//继承实例属性 （第二次调用SuperType()）</span></span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"> SubType.prototype = <span class="keyword">new</span> SuperType(); <span class="comment">//继承原型属性和方法（第一次调用SuperType()）</span></span><br><span class="line"> SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">'yishu'</span>,<span class="number">25</span>);</span><br><span class="line">instance1.colors.push(<span class="string">'yellow'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'instance1.colors'</span>,instance1.colors); <span class="comment">// ["red", "blue", "green", "yellow"]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'instance1.name'</span>,instance1.sayName()); <span class="comment">//yishu</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'instance1.age'</span>,instance1.sayAge());<span class="comment">//25</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">'Grei'</span>,<span class="number">29</span>);</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'instance2.colors'</span>,instance2.colors); <span class="comment">//["red", "blue", "green"]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'instance2.name'</span>,instance2.sayName());<span class="comment">//Grei</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'instance2.age'</span>,instance2.sayAge());<span class="comment">//29</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ul>
<li>可以继承实例属性/方法，也可以继承原型属性/方法</li>
<li>不存在引用属性共享问题</li>
<li>可传参</li>
<li>函数可复用</li>
</ul>
<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><p>调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">具体的过程</span><br><span class="line"></span><br><span class="line">第一次调用的时候 <span class="keyword">SubType</span>.prototype 会得到两个属性  name和colors  他们都来自于 SuperType 但是现在位于 <span class="keyword">SubType</span>的原型中 当调用<span class="keyword">SubType</span>构造函数时 又会调用一次</span><br><span class="line">SuperType的构造函数 这一次又在新对象<span class="keyword">SubType</span>上创建了实例属性 name和colors  于是这两个属性屏蔽了原型中同名属性</span><br></pre></td></tr></table></figure>
<hr>
<p>推荐指数：❤️❤️❤️❤️（仅仅多消耗了一点内存）</p>
<h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><p><font color="red">核心原理：</font>借助原型可以基于已有的对象创建新的对象 同时还不必因此创建自定义类型</p>
<p><strong>ES5以前</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ObjectCreate</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">//创建了一个临时性的构造函数</span></span><br><span class="line">  F.prototype = o;<span class="comment">//将传入的对象当作这个构造函数的原型</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F(); <span class="comment">//返回这个临时类型的新实例</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ObjectCreate 方法本质上对传入其中的对象执行了一次浅复制</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name:<span class="string">'yishu'</span>,</span><br><span class="line">  friends:[<span class="string">'xiaohong'</span>,<span class="string">'xiaoming'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = ObjectCreate(person);</span><br><span class="line">instance1.age = <span class="number">45</span>;</span><br><span class="line">instance1.friends.push(<span class="string">'xiaolan'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'instance1'</span>,instance1.age); <span class="comment">//45</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'instance1'</span>,instance1.friends);<span class="comment">// ["xiaohong", "xiaoming", "xiaolan"]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'person.friends'</span>,person.friends)<span class="comment">//["xiaohong", "xiaoming", "xiaolan"]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'person.age'</span>,person.age)<span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = ObjectCreate(person);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'instance2'</span>,instance2.age); <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'instance2'</span>,instance2.friends);<span class="comment">//["xiaohong", "xiaoming", "xiaolan"]</span></span><br></pre></td></tr></table></figure>
<p><strong>ES5以后</strong></p>
<p>通过新增 <code>Object.create(obj1，obj2)</code>规范化了原型式继承</p>
<ul>
<li>obj1：用做新对象原型的对象</li>
<li>obj2（可选）为新对象定义额外属性的对象 在传入一个参数的情况下与<code>ObjectCreate</code>函数功能相同</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name:<span class="string">'yishu'</span>,</span><br><span class="line">  friends:[<span class="string">'xiaohong'</span>,<span class="string">'xiaoming'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> otherPerson = <span class="built_in">Object</span>.create(person);</span><br><span class="line"></span><br><span class="line">otherPerson.name=<span class="string">'maying'</span>;</span><br><span class="line">otherPerson.friends.push(<span class="string">'wqs'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'otherPerson'</span>,otherPerson.name) <span class="comment">// maying</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'otherPerson'</span>,otherPerson.friends) <span class="comment">// ["xiaohong", "xiaoming", "wqs"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> otherPerson1 = <span class="built_in">Object</span>.create(person,&#123;<span class="attr">name</span>:&#123;<span class="attr">value</span>:<span class="string">'dsdd'</span>&#125;&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'otherPerson1'</span>,otherPerson1.name) <span class="comment">//dsdd</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'otherPerson1'</span>,otherPerson1.friends)<span class="comment">// ["xiaohong", "xiaoming", "wqs"]</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>不是类式继承，而是原型式基础，缺少了类的概念</li>
<li>对于引用类型值的属性依然是 共享状态的，这相当于创建了两个person的副本</li>
</ul>
<h2 id="寄生式组合继承（最理想的继承范式）"><a href="#寄生式组合继承（最理想的继承范式）" class="headerlink" title="寄生式组合继承（最理想的继承范式）"></a>寄生式组合继承（最理想的继承范式）</h2><p><font color="red">核心原理：</font><br>借用构造函数来继承属性<br>通过原型链的<strong>混成形式</strong>来继承方法</p>
<p><font color="red">技术原理：</font> 不必为了指定子类型的原型而调用超类型的构造函数 我们所需要的无非就是超类型原型的一个副本而已（使用寄生式来继承超类型的原型 然后再将结果指定给子类型的原型 ）</p>
<p>举个🌰</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inhertPrototype</span>(<span class="params">SubType, SuperType</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> prototype = <span class="built_in">Object</span>.create(SuperType.prototype); <span class="comment">//创建对象</span></span><br><span class="line">  prototype.constructor = SubType; <span class="comment">//如果你创建了一个新对象并替换了函数默认的.prototype对象引用,那么新对象不会自动获得.constructor属性</span></span><br><span class="line">  SubType.prototype = prototype;<span class="comment">//指定对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">'red'</span>,<span class="string">'blue'</span>,<span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, name);<span class="comment">//第二次调用SuperType()</span></span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inhertPrototype(SubType, SuperType);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.age);         </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dd = <span class="keyword">new</span> SubType(<span class="string">'yishu'</span>,<span class="number">22</span>);</span><br><span class="line">dd.colors.push(<span class="string">'gold'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'dd'</span>,dd.colors);  <span class="comment">//["red", "blue", "green", "gold"]</span></span><br><span class="line">dd.sayAge(); <span class="comment">//22</span></span><br><span class="line">dd.sayName(); <span class="comment">//yishu</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cc = <span class="keyword">new</span> SubType(<span class="string">'xiaogou'</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'cc'</span>,cc.colors); [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]</span><br><span class="line">cc.sayAge(); <span class="comment">//10</span></span><br><span class="line">cc.sayName();<span class="comment">//xiaogou</span></span><br></pre></td></tr></table></figure>
<h3 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h3><p>完美</p>
<ul>
<li>它只调用了一次构造函数 避免了在SubType.prototype上创建不必要的属性 与此同时 原型链还能保持不变<h3 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h3></li>
<li>实现不如组合式继承简单</li>
</ul>
<hr>
<p>推荐指数：❤️❤️❤️❤️（复杂度扣掉一颗心）</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ECMAscript支持面向对象编程 但是不使用类或者接口 对象可以在代码执行过程中创建或增强 因此具有动态性而非严格定义的实体 在没有类的情况下 可以采用下列模式创建对象</p>
<ul>
<li>工厂模式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用简单的函数创建对象 为对象天假属性和方法 然后返回对象被构造函数模式取代</span><br></pre></td></tr></table></figure>
<ul>
<li>构造函数模式</li>
</ul>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">可以创建自定义引用类型 </span><br><span class="line">可以像创建内置对象实例一样使用<span class="keyword">new</span><span class="type"></span></span><br><span class="line"><span class="type"></span></span><br><span class="line"><span class="type"></span>缺点：成员无法复用 包括函数</span><br></pre></td></tr></table></figure>
<ul>
<li>原型模式</li>
</ul>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">使用构造函数的proto<span class="keyword">type</span>属性来指定那些应该共享的属性和方法</span><br><span class="line"></span><br><span class="line">组合使用 构造函数模式和原型模式 分别定义属性和方法</span><br></pre></td></tr></table></figure>
<p>js主要通过原型链实现继承 原型链的构建是通过<strong>将一个类型的实例复制给另一个构造函数的原型</strong>实现的，这样子类型就能访问到超类型所有的属性和方法 这一点与基于类的继承很相似。</p>
<p>原型链的问题是<strong>对象实例共享所有的属性和方法</strong> 因此不适合单独使用<br>解决这个问题的技术是借助构造函数 （在子类型构造函数中的内部调用超类型的构造函数） 这样就能做到每个实例具有自己的属性 同时还能保证只使用构造函数模式来定义类型</p>
<p>使用最多的继承模式是<strong>组合继承</strong><br>通过原型链继承共享的属性和方法<br>而通过借用构造函数继承实例属性</p>
<p>还有其他继承模式</p>
<ul>
<li>原型式继承</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">可以在不必预先定义构造函数的情况下实现继承 本质是执行对给定对象的浅复制 而复制的副本还可以进行进一步的加强 改造</span><br></pre></td></tr></table></figure>
<ul>
<li>寄生式继承</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">与 原型式继承相似</span><br></pre></td></tr></table></figure>
<ul>
<li>寄生组合式继承</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">集寄生式继承和组合继承的优点与一身</span><br><span class="line">是实现基于类型继承的最有效的方式</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>JavaScript 高级程序设计（第三版）</p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>js模块化编程系列（一）</title>
    <url>/2017/04/23/js%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<ol>
<li>原始写法</li>
</ol>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m2</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p> 缺点：污染了全局变量，容易与其它模块发生命名冲突，而且模块之间看不出直接关系</p>
<ol start="2">
<li>对象写法</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> moudle = <span class="keyword">new</span> <span class="built_in">Object</span>(&#123;</span><br><span class="line"> _count = <span class="number">0</span>;</span><br><span class="line"> m1:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line"> m2:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>缺点：会暴露所有模块成员，内部状态可以被外部改写</p>
<ol start="3">
<li>立即执行函数的写法(达到不暴露私有成员的目的)</li>
</ol>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> moudle1 = (<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> m1 = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> m2 = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">         m1:m1,</span><br><span class="line">         m2:m2</span><br><span class="line">       &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p> moudle1就是javascript模块的基本写法</p>
<ol start="4">
<li>放大模式<br>背景：如果一个模块很大必须分为几个部分，或者一个模块需要继承另外一个模块时</li>
</ol>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> moudle1 = (<span class="function"><span class="keyword">function</span><span class="params">(mod)</span></span>&#123;</span><br><span class="line">   mod.m3 = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> mod;</span><br><span class="line">  &#125;)(moudle1);</span><br></pre></td></tr></table></figure>
<p>  上面的代码为 moudle1 添加了一个新方法m3，然后返回新的moudle1模块</p>
<ol start="5">
<li>宽放大模式<br>背景：在浏览器环境中，模块的各个部分都是从网上获取的，有时候无法知道哪个部分会先加载，如果单纯采用放大模式，第一个执行的 部分有可能加载一个不存在的空对象</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> moudle1 = (<span class="function"><span class="keyword">function</span>(<span class="params">mod</span>)</span>&#123;</span><br><span class="line">  mod.m3 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mod;</span><br><span class="line"> &#125;)(<span class="built_in">window</span>.moudle1 || &#123;&#125;);</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>输入全局变量<br>背景：保持模块独立性，内部最好不要与程序的其他部分直接交互</li>
</ol>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> moudle1 = (<span class="function"><span class="keyword">function</span><span class="params">($,YAHOO)</span></span>&#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">  &#125;)(jQuery, YAHOO);</span><br></pre></td></tr></table></figure>
<p>  保持独立的同时，模块的依赖关系变的更明显</p>
<ol start="7">
<li>模块的规范<br>CommonJS和AMD<br>CommonJS：nodejs的模块系统，是参照 CommonJS 规范实现的，在CommonJS中，有一个全局方法 require()，用于加载模块</li>
</ol>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">eg:</span><br><span class="line">var <span class="built_in">math</span> = <span class="built_in">require</span>(<span class="string">'math'</span>);</span><br><span class="line">  调用<span class="built_in">math</span>模块提供的方法：</span><br><span class="line">  <span class="built_in">math</span>.add(<span class="number">2</span>,<span class="number">3</span>); // <span class="number">5</span></span><br></pre></td></tr></table></figure>
<ol start="8">
<li>浏览器环境<br>局限使CommonJS规范不适用于浏览器环境</li>
</ol>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> math = require(<span class="string">'math'</span>);</span><br><span class="line">math.<span class="keyword">add</span>(<span class="number">2</span>,<span class="number">3</span>); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p>  在浏览器中运行，第二行在第一行之后运行，也就是说必须得等到math模块加载完成，如果加载时间很长，整个应用都会停在那里等，对于服务器端来说，所有模块都放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间，但是对于浏览器，这就是致命的问题，取决于网速，<br>  所以，浏览器端的模块不能采用同步加载，要采用<strong>异步加载</strong></p>
<ol start="9">
<li>AMD<br>‘异步模块定义’，采用异步方式加载模块，所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，回调函数才执行<br>AMD也采用require()语句加载模块，不同于CommonJS，它要求两个参数
　</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="built_in">module</span>], callback)</span><br><span class="line"><span class="built_in">require</span>([<span class="string">'math'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">math</span>) </span>&#123;</span><br><span class="line">　　　　math.add(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>js模块化编程系列（二）</title>
    <url>/2017/04/24/js%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89require.js/</url>
    <content><![CDATA[<p><strong>require.js</strong></p>
<p>出现背景：所有的javascript代码都在一个文件中，代码越来越多时必须分成多个文件，依次加载，问题：加载js的时候浏览器停止渲染，加载文件越多，网页的响应时间就越长，由于js之间有依赖关系，因此必须严格保证加载顺序，当依赖关系变的复杂时，代码的编写和维护都会变的异常困难</p>
<ol>
<li>加载require.js</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">"js/require.js"</span> defer <span class="keyword">async</span>=<span class="string">'true'</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="keyword">async</span>   表明这个文件需要异步加载</span><br><span class="line">在<span class="built_in">require</span>.js的基础上加载自己的 main.js</span><br><span class="line">&lt;script src=<span class="string">"require.js"</span> data-main=<span class="string">"js/main"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">ata-main:指定程序的主模块，这个人间会第一个被<span class="built_in">require</span>.js加载，由于<span class="built_in">require</span>.js默认的文件后缀名是js，所以可以把main.js 简写成main</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>([<span class="string">'moduleA'</span>, <span class="string">'moduleB'</span>, <span class="string">'moduleC'</span>],   <span class="function"><span class="keyword">function</span> (<span class="params">moduleA, moduleB, moduleC</span>)</span>&#123;</span><br><span class="line">　　　　<span class="comment">// some code here</span></span><br><span class="line">　　&#125;)<span class="string">``</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>模块的加载<br>当加载不同路径下的模块可以使用 require.config()可以对模块的加载进行自定义， require.config()就写在主模块(main.js)的头部，参数就是一个对象，这个对象的path属性指定各个模块的加载路径</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">　　<span class="selector-tag">require</span><span class="selector-class">.config</span>(&#123;</span><br><span class="line">　　　　<span class="attribute">paths</span>: &#123;</span><br><span class="line">　　　　　　<span class="string">"jquery"</span>: <span class="string">"lib/jquery.min"</span>,</span><br><span class="line">　　　　　　<span class="string">"underscore"</span>: <span class="string">"lib/underscore.min"</span>,</span><br><span class="line">　　　　　　<span class="string">"backbone"</span>: <span class="string">"lib/backbone.min"</span></span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;);</span><br><span class="line">　　</span><br><span class="line">　　另一种形式</span><br><span class="line">　　</span><br><span class="line">　　　<span class="selector-tag">require</span><span class="selector-class">.config</span>(&#123;</span><br><span class="line">　　　　<span class="attribute">baseUrl</span>: <span class="string">"js/lib"</span>,</span><br><span class="line">　　　　paths: &#123;</span><br><span class="line">　　　　　　<span class="string">"jquery"</span>: <span class="string">"jquery.min"</span>,</span><br><span class="line">　　　　　　<span class="string">"underscore"</span>: <span class="string">"underscore.min"</span>,</span><br><span class="line">　　　　　　<span class="string">"backbone"</span>: <span class="string">"backbone.min"</span></span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;);</span><br><span class="line">　　</span><br><span class="line">　　再或者</span><br><span class="line">　　　<span class="selector-tag">require</span><span class="selector-class">.config</span>(&#123;</span><br><span class="line">　　　　<span class="attribute">paths</span>: &#123;</span><br><span class="line">　　　　　　<span class="string">"jquery"</span>: <span class="string">"https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min"</span></span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>AMD模块的写法<br>require.js 加载的模块采用AMD规范<br>具体来说，就是模块必须采用特定的define()函数来定义，如果一个模块不依赖其他模块，那么可以直接定义在define函数中</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//math.js 定义了一个math模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line"> add:add</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">加载方法：</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line">　　<span class="built_in">require</span>([<span class="string">'math'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">math</span>)</span>&#123;</span><br><span class="line">　　　　alert(math.add(<span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line">　　&#125;);</span><br><span class="line">　　</span><br><span class="line">　　如果这个模块还依赖其他模块，那么那么define()函数的第一个参数，必须是一个数组，指明该模块的依赖性。</span><br><span class="line">　　　define([<span class="string">'myLib'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">myLib</span>)</span>&#123;</span><br><span class="line">　　　　<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　　　myLib.doSomething();</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　<span class="keyword">return</span> &#123;</span><br><span class="line">　　　　　　foo : foo</span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　&#125;);</span><br><span class="line">　　当<span class="built_in">require</span>()函数加载上面这个模块的时候，就会先加载myLib.js文件。</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>AMD模块的写法<br>加载非规范的模块<br>理论上 require.js加载的模块，必须是按照AMD规范、用define()函数定义的模块<br>加载非规范模块，必须先用require.config()方法定义它们的一些特征</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">eg：加载非AMD规范模块 underscore，backbone</span><br><span class="line">　　require.config(&#123;</span><br><span class="line">　　　　shim: &#123;</span><br><span class="line"></span><br><span class="line">　　　　　　<span class="string">'underscore'</span>:&#123;</span><br><span class="line">　　　　　　　　<span class="keyword">exports</span>: <span class="string">'_'</span></span><br><span class="line">　　　　　　&#125;,</span><br><span class="line">　　　　　　<span class="string">'backbone'</span>: &#123;</span><br><span class="line">　　　　　　　　deps: [<span class="string">'underscore'</span>, <span class="string">'jquery'</span>],</span><br><span class="line">　　　　　　　　<span class="keyword">exports</span>: <span class="string">'Backbone'</span></span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;);</span><br><span class="line">　　</span><br><span class="line">　　shim属性：专门用来配置不兼容的模块。具体来说，每个模块要定义</span><br><span class="line">　　（<span class="number">1</span>）<span class="keyword">exports</span>值（输出的变量名），表明这个模块外部调用时的名称；</span><br><span class="line">　　（<span class="number">2</span>）deps数组，表明该模块的依赖性。</span><br><span class="line">　　</span><br><span class="line">　　eg：</span><br><span class="line">　　   jQuery的插件可以这样定义：</span><br><span class="line">　　　　shim: &#123;</span><br><span class="line">　　　　<span class="string">'jquery.scroll'</span>: &#123;</span><br><span class="line">　　　　　　deps: [<span class="string">'jquery'</span>],</span><br><span class="line">　　　　　　<span class="keyword">exports</span>: <span class="string">'jQuery.fn.scroll'</span></span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><p>require插件<br>domready插件，可以让回调函数在页面DOM结构加载完成后再运行。</p>
<p>　</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">'domready!'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">doc</span>)</span>&#123;</span><br><span class="line">　　　　<span class="comment">// called once the DOM is ready</span></span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>text和image插件，则是允许require.js加载文本和图片文件。</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">define([</span><br><span class="line">　　　　'text!review.txt',</span><br><span class="line">　　　　'image!cat.jpg'</span><br><span class="line">　　　　],</span><br><span class="line"></span><br><span class="line">　　　　function(<span class="name">review</span>,cat)&#123;</span><br><span class="line">　　　　　　console.log(<span class="name">review</span>)<span class="comment">;</span></span><br><span class="line">　　　　　　document.body.appendChild(<span class="name">cat</span>)<span class="comment">;</span></span><br><span class="line">　　　　&#125;</span><br><span class="line">　　)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>类似的插件还有json和mdown，用于加载json文件和markdown文件</p>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>js面向对象</title>
    <url>/2017/04/21/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p><strong>工厂模式</strong><br>解决了重复实例化的问题</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObject</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.name= name;</span><br><span class="line">obj.age = age;</span><br><span class="line">obj.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="keyword">this</span>.age + <span class="string">'运行中'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> box1 = createObject（‘lee’,<span class="number">100</span>）</span><br><span class="line"><span class="keyword">var</span> box2 = createObject（‘jack’,<span class="number">200</span>）</span><br></pre></td></tr></table></figure>
<p>工厂模式的缺点：<br>无法区分实例是哪个对象的实例</p>
<p><strong>构造函数模式</strong></p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Box</span><span class="params">(name,age)</span></span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.name= name;</span><br><span class="line"> <span class="keyword">this</span>.age = age;</span><br><span class="line"> <span class="keyword">this</span>.run = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="keyword">this</span>.age + <span class="string">'运行中'</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> box3 = <span class="keyword">new</span> Box（‘lee’,<span class="number">100</span>）</span><br><span class="line"><span class="keyword">var</span> box4 = <span class="keyword">new</span> Box（‘jack’,<span class="number">200</span>）</span><br></pre></td></tr></table></figure>
<p>如何识别了对象？<br>构造函数没有new Object，但是它后台回自动var obj = new Object();<br>this指的就是obj<br>没有返回值</p>
<p>console.log(box4 instanceof Box)</p>
<p><strong>对象冒充</strong><br>把o冒充成box对象</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>  o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">Box.call(o,<span class="string">'Lee'</span>,<span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<p><strong>原型</strong></p>
<p>prototype原型属性是一个对象</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Box</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p> 这里如果有属性或者方法 叫做实例属性和实例方法</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">Box<span class="selector-class">.prototypr</span><span class="selector-class">.name</span> 原型属性</span><br><span class="line">Box<span class="selector-class">.prototypr</span><span class="selector-class">.run</span>=function()&#123;&#125; 原型方法</span><br></pre></td></tr></table></figure>
<p><strong><em>proto</em>：</strong> 实际上是一个指向原型对象的一个指针，它的作用就是指向构造函数的原型属性constructor</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">var</span> box1 = new Box()</span><br><span class="line">box1<span class="selector-class">.constructor</span> 指向构造函数</span><br><span class="line">box1._proto_指向原型对象</span><br></pre></td></tr></table></figure>
<p>判断一个对象实例是不是指向了对象的原型对象，实例化之后是自动指向的</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="type">Box</span>.proto<span class="keyword">type</span>.isPrototypeOf(box1)</span><br></pre></td></tr></table></figure>
<p><strong>什么叫闭包？ 有什么用</strong></p>
<p>闭包是指有权访问另一个作用域中的变量和函数，常见的形式是在<font face="STCAIYUN" color="red" size="4">某个作用域中定义的函数</font></p>
<p>闭包的作用域链包括三部分：</p>
<ol>
<li>函数本身作用域</li>
<li>闭包定义的作用域</li>
<li>全局作用域</li>
</ol>
<p><font face="STCAIYUN" color="green" size="4">闭包的常见用途？</font></p>
<ol>
<li>读取函数内部的变量</li>
<li>将变量始终保持在内存中</li>
<li>模拟面向对象的代码风格</li>
</ol>
<p><strong>匿名执行函数</strong></p>
<p>不加<strong>var</strong>关键字 默认回呗添加到全局对象的属性中去，类似的临时变量的属性加入全局对象有很多坏处<br>比如：<br>别的函数可能误用这些变量 造成全局变量过于庞大，影响访问速度（因为变量的取值是需要从圆形链上遍历的）</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> datamodel = &#123;    </span><br><span class="line">    table : [],    </span><br><span class="line">    tree : &#123;&#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span><span class="params">(dm)</span></span>&#123;    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; dm.table.rows; i++)&#123;    </span><br><span class="line">       <span class="keyword">var</span> row = dm.table.rows[i];    </span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; row.cells; i++)&#123;    </span><br><span class="line">           drawCell(i, j);    </span><br><span class="line">       &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//build dm.tree      </span></span><br><span class="line">&#125;)(datamodel);  </span><br><span class="line"></span><br><span class="line">创建了一个匿名的函数并立即执行它，由于外部无法引用它内部的变量，因此在执行之后很快就会被释放 不会污染全局对象</span><br></pre></td></tr></table></figure>
<p><strong>缓存</strong></p>
<p>设想我们有一个处理过程很耗时的函数对象，每次调用都会花费很长时间，<br>那么我们就需要将计算出来的值存储起来，当调用这个函数的时候，首先在缓存中查找，如果找不到，则进行计算，然后更新缓存并返回值，如果找到了，直接返回查找到的值即可。闭包正是可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得以保留。</p>
<p><strong>实现封装</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;    </span><br><span class="line">    <span class="comment">//变量作用域为函数内部，外部无法访问    </span></span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"default"</span>;       </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;    </span><br><span class="line">       getName : <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;    </span><br><span class="line">           <span class="keyword">return</span> name;    </span><br><span class="line">       &#125;,    </span><br><span class="line">       setName : <span class="function"><span class="keyword">function</span><span class="params">(newName)</span></span>&#123;    </span><br><span class="line">           name = newName;    </span><br><span class="line">       &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;();    </span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span>(person.name);<span class="comment">//直接访问，结果为undefined    </span></span><br><span class="line"><span class="keyword">print</span>(person.getName());    </span><br><span class="line">person.setName(<span class="string">"abruzzi"</span>);    </span><br><span class="line"><span class="keyword">print</span>(person.getName());</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript 设计模式系列</title>
    <url>/2018/01/16/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="面向对象的-Javascript"><a href="#面向对象的-Javascript" class="headerlink" title="面向对象的 Javascript"></a>面向对象的 Javascript</h2><p>不同于传统面向对象语言中的类式继承 js通过 <strong>原型委托</strong> 的方式实现对象与对象之间的继承</p>
<p>编程语言分为 ：<br><strong>静态类型语言</strong>：编译时已确定变量的类型<br>  优点：在编译时就能发现类型不匹配的错误，编译器可以针对不同的数据类型对程序做一些优化工作 提高程序之心速度<br>  缺点：程序员依照契约来编写程序<br><strong>动态类型语言</strong>：要到程序运行的时候 待变量被赋予某个值之后 才会具有某种类型<br>  优点：代码数量少<br>  缺点：程序在运行期间有可能发生跟类型相关的错误</p>
<p>  Javascript 是一门典型的动态类型语言</p>
<p>  多态：给不同的对象发送同一条消息的时候 这些对象会根据这个消息分别给出不同的反馈</p>
<p> 多态：<br> 多种形态 在面向对象语言中，接口的多种不同的实现方式即为多态<br> 多态指同一个实体同时具有多种形式<br> 思想：把做什么 和 谁去做 分开<br> 同一个函数 传入不同的参数 可以实现不同的结果</p>
<p> js的多态是与生俱来的<br> 它作为一门动态类型语言 他在编译时没有类型检查的类型</p>
<p> 多态的好处：你不必再向对象询问‘你是什么类型’而后根据得到的答案  调用对象的某个行为 你只管调用该行为就是了</p>
<p> 最根本的作用就是通过把过程话的条件分支语句转化为对象的多态性  从而消除这些条件分支语句</p>
<p> 面向对象编程的优点<br> 将行为分布在各个对象中，并且让这些对象各自负责自己的行为</p>
<p> 当我们对一些函数发出 调用的指令时 这些函数会返回不同的结果<br> 这也是多态的一些体现</p>
<p> 封装：封装的目的是将信息隐藏  </p>
<p> 封装数据<br> 封装实现<br> 封装类型<br> 封装变化<br>         把系统中不变的和变的分离开 只替换变化的 如果变化的也是封装好的 就好替换多了 保证程序的稳定性和可扩展性</p>
<p> 隐藏数据 隐藏实现细节 设计细节以及隐藏对象的类型<br> 其他对象或者用户不关心他的具体实现 封装使对象之前的耦合变得松散 对象之间只暴露APi接口来通信</p>
<h2 id="原型模式和基于原型继承的Javascript-对象系统"><a href="#原型模式和基于原型继承的Javascript-对象系统" class="headerlink" title="原型模式和基于原型继承的Javascript 对象系统"></a><strong>原型模式和基于原型继承的Javascript 对象系统</strong></h2><h5 id="使用克隆的原型模式"><a href="#使用克隆的原型模式" class="headerlink" title="使用克隆的原型模式"></a>使用克隆的原型模式</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Plane = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.blood=<span class="number">100</span>;</span><br><span class="line">	<span class="keyword">this</span>.ss = <span class="number">11</span>;</span><br><span class="line">	<span class="keyword">this</span>.tt =<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> plane = <span class="keyword">new</span> Plane();  </span><br><span class="line"></span><br><span class="line">	<span class="built_in">Object</span>.create = <span class="built_in">Object</span>.create ||<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">		 F.prototype= value;</span><br><span class="line">		 <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> clonePlane = <span class="built_in">Object</span>.create(plane)</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'clonePlane'</span>,clonePlane)</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'clonePlane'</span>,clonePlane.blood)  <span class="number">100</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'clonePlane'</span>,clonePlane.ss)  <span class="number">11</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'clonePlane'</span>,clonePlane.tt) <span class="number">2</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h5 id="javascript的原型继承"><a href="#javascript的原型继承" class="headerlink" title="javascript的原型继承"></a>javascript的原型继承</h5><p>所有的js对象都是从某个对象上克隆而来的</p>
<p> 原型编程范程的规则</p>
<ol>
<li><p>所有的数据都是对象</p>
<p>javascript根对象是 <code>Object.prototype</code>空对象</p>
</li>
</ol>
<pre><code><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;&#125;;</span><br></pre></td></tr></table></figure>
</code></pre><ol start="2">
<li>要得到一个对象 不是通过实例化类 而是找到一个对象作为一个原型并克隆他</li>
</ol>
<p>当我们调用 <code>var obj1 = new Object();</code> 引擎内部会从<code>Object.prototype</code>克隆一个对象出来</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    	<span class="keyword">this</span>.name =name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">'maying'</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">console</span>.log(p.name)</span><br><span class="line">	<span class="built_in">console</span>.log(p.getName())</span><br></pre></td></tr></table></figure>
<p>js没有类的概念 但是为什么还调用了 <code>new Person(&#39;maying&#39;);</code></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">在这里Person 并不是类 而是函数构造器</span><br><span class="line">Javascript的函数既可以作为普通函数被调用 也可以作为函数构造器被调用</span><br><span class="line">当使用 <span class="keyword">new</span> <span class="type"></span>运算符来调用函数时 此时的函数就是一个构造器</span><br><span class="line"></span><br><span class="line">用<span class="keyword">new</span><span class="type"></span>运算符来创建对象的过程 实际上也是先克隆 Object.prototype 对象</span><br></pre></td></tr></table></figure>
<p><strong>抛出问题：js通过 Object.prototype得到一个新的对象 但实际上并不是每次都真正的克隆了一个对象</strong></p>
<ol start="3">
<li>对象会记住他的原型</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">就javascript 真正实现来说并不能说对象有原型 而只能说是对象的构造器有原型 对于对象把请求委托给它自己的原型 更好的说法是对象把请求委托给它的构造器的原型。</span><br><span class="line"> 那么对象是如何委托给它的构造器的原型呢</span><br><span class="line"></span><br><span class="line"> 对象通过 _proto_的隐藏属性指向 &#123;Constructor&#125;.prototype</span><br><span class="line"></span><br><span class="line"> _proto_就是跟构造器的原型联系起来的纽带</span><br><span class="line"></span><br><span class="line"> js的对象最初都是由object.prototype创建的 但是对象构造器的原型并不局限于object.prototype上 二是可以动态指定其他对象</span><br><span class="line"></span><br><span class="line"> 应用</span><br><span class="line"> 当对象a需要借用对象b的能力时 可以有选择性的把对象a的构造器的原型指向对象b 从而达到继承的效果</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> A = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	 	<span class="keyword">this</span>.name=<span class="string">"buyiyang"</span></span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line">	 A.prototype = &#123;</span><br><span class="line">	 	<span class="keyword">constructor</span>: A, //手动指定 不指定的话   console.log(A.prototype.<span class="keyword">constructor</span>)=object()</span><br><span class="line">	 	name:'maying'</span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line"> var B = function()&#123;&#125;</span><br><span class="line"> B.prototype = <span class="keyword">new</span> A()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> a = <span class="keyword">new</span> A();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'a'</span>,a.name)</span><br><span class="line">  <span class="built_in">console</span>.log(A.prototype.constructor)  </span><br><span class="line"></span><br><span class="line">  <span class="comment">//  function()&#123;</span></span><br><span class="line">	 <span class="comment">// 	this.name="buyiyang"</span></span><br><span class="line">	 <span class="comment">// &#125;</span></span><br><span class="line">  <span class="built_in">console</span>.log(a.__proto__)    <span class="comment">// &#123;name: "maying",  constructor: ƒ&#125;</span></span><br><span class="line">  <span class="built_in">console</span>.log(A.prototype)  <span class="comment">// &#123;name: "maying", constructor: ƒ&#125;</span></span><br><span class="line"></span><br><span class="line">原型链并不是无限长的</span><br><span class="line"></span><br><span class="line">当请求达到 A.prototype，并且在 A.prototype 中也没有找到 address 属性的时候， 请求会被传递给 A.prototype 的构造器原型 <span class="built_in">Object</span>.prototype，显然 <span class="built_in">Object</span>.prototype 中也没有 address 属性，但 <span class="built_in">Object</span>.prototype 的原型是 <span class="literal">null</span>，说明这时候原型链的后面已经没有别的节点了。 所以该次请求就到此打住，a.address 返回 <span class="literal">undefined</span>。</span><br><span class="line"></span><br><span class="line">通过 <span class="built_in">Object</span>.create(<span class="literal">null</span>) 可以创建出没有原型的对象</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">通过<span class="type">ES6</span> <span class="class"><span class="keyword">class</span> <span class="title">创建对象</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">	 <span class="title">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">	 	constructor(name)&#123;</span><br><span class="line">	 		<span class="keyword">this</span>.name = name</span><br><span class="line">	 	&#125;</span><br><span class="line">	 	getName()&#123;</span><br><span class="line">		 		<span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">		 	&#125;</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">	 	constructor(name)&#123;</span><br><span class="line">	 		<span class="comment">// console.log('this',this)</span></span><br><span class="line">	 		console.log(<span class="symbol">'supe</span>r',<span class="keyword">super</span>()) <span class="comment">//不调用 super() 就没有绑定this super()只能调用一次</span></span><br><span class="line">	 		<span class="comment">// Dog &#123;name: undefined&#125;</span></span><br><span class="line">	 		console.log(<span class="symbol">'thi</span>s',<span class="keyword">this</span>) <span class="comment">// Dog &#123;name: undefined&#125;</span></span><br><span class="line">	 		console.log(<span class="symbol">'nam</span>e',name)</span><br><span class="line">	 		<span class="comment">// super(name)</span></span><br><span class="line">	 	&#125;</span><br><span class="line">	 	speak()&#123;</span><br><span class="line">	 		<span class="keyword">return</span> <span class="symbol">'woo</span>f'</span><br><span class="line">	 	&#125;</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="keyword">var</span> dog = <span class="keyword">new</span> <span class="type">Dog</span>(<span class="symbol">'scam</span>p')</span><br><span class="line"></span><br><span class="line">     console.log(dog.getName()+'----say-----'+dog.speak()) <span class="comment">//undefined----say-----woof</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>如果对象无法响应某个请求 它会把这个请求委托给自己的原型</li>
</ol>
<h2 id="this-call-apply"><a href="#this-call-apply" class="headerlink" title="this call apply"></a><strong>this call apply</strong></h2><p><strong>this</strong><br>js的this总是指向一个对象 在运行时基于函数的执行环境动态绑定的 而非函数被声明时的环境</p>
<p>this的指向可以分为下面四种</p>
<p>作为对象的方法调用</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>指向当前对象</span><br></pre></td></tr></table></figure>
<p>作为普通函数调用</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>指向<span class="built_in">window</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.name=<span class="string">'maying'</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span>  <span class="keyword">this</span>.name</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">console</span>.log(getName()) <span class="comment">//maying</span></span><br><span class="line"></span><br><span class="line">	或者</span><br><span class="line"></span><br><span class="line">		<span class="built_in">window</span>.name=<span class="string">'maying'</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> myObject = &#123;</span><br><span class="line">		name:<span class="string">'stven'</span>,</span><br><span class="line">		getName :<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="string">'this'</span>,<span class="keyword">this</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> a = myObject.getName;</span><br><span class="line">	  <span class="built_in">console</span>.log(a()) <span class="comment">//maying 此时用另外一个变量a来引用myObject.getName 并且调用 a() 时 此时是普通函数的调用函数 this是指向全局的</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">console</span>.log(myObject.getName()) <span class="comment">// stven  getName是作为对象的属性被调用的 此时的this指向 myObject</span></span><br><span class="line"></span><br><span class="line">	在ES5 的 strict模式下 <span class="keyword">this</span>已经被规定为不会指向全局对象 而是<span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123; <span class="string">"use strict"</span></span><br><span class="line">    alert ( <span class="keyword">this</span> );</span><br><span class="line">    func();</span><br></pre></td></tr></table></figure>
<p>构造器调用<br>当使用new运算符调用函数时 该函数总会返回一个对象<br>通常情况下 构造器里的this就指向返回的这个对象<br>如果 构造器显示返回了一个object类型的对象 那么此次元算结果最终会返回这个对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Preson = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	 	<span class="keyword">this</span>.name=<span class="string">'maying'</span></span><br><span class="line">	 	<span class="keyword">return</span> &#123;</span><br><span class="line">	 		name:<span class="string">'anne'</span></span><br><span class="line">	 	&#125;</span><br><span class="line"></span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line">	   <span class="keyword">var</span> p =<span class="keyword">new</span> Preson()</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'p'</span>,p.name)  <span class="comment">//anne</span></span><br><span class="line"></span><br><span class="line">     如果不显示返回数据会这返回一个非对象的类型 构造器里的<span class="keyword">this</span>就指向返回的这个对象</span><br><span class="line"></span><br><span class="line">     	 <span class="keyword">var</span> Preson = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	 	<span class="keyword">this</span>.name=<span class="string">'maying'</span></span><br><span class="line">	 	<span class="keyword">return</span> <span class="string">'swe'</span>	 	</span><br><span class="line">	 &#125;</span><br><span class="line">	  <span class="keyword">var</span> p =<span class="keyword">new</span> Preson()</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'p'</span>,p.name)  <span class="comment">//maying</span></span><br></pre></td></tr></table></figure>
<p><code>Function.prototype.call</code> 或者 <code>Function.prototype.apply</code>调用</p>
<p> 作用：可以动态地改变传入函数的this<br> ES3给Function原型定义的两个方法<br> call 和apply区别只是在传递参数的不同</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="function"><span class="keyword">func</span> = <span class="title">function</span><span class="params">( a, b, <span class="built_in">c</span> )</span></span>&#123;</span><br><span class="line">alert ( [ a, b, <span class="built_in">c</span> ] ); <span class="comment">// 输出 [ 1, 2, 3 ]</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">func</span>.<span class="title">apply</span><span class="params">( null, [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ] )</span></span>;</span><br><span class="line">第一个参数：函数体内this的指向 传null时 指向 默认的宿主对象 浏览器默认window</span><br><span class="line">第二个参数： 数组或者类数组 apply方法把这个集合中的元素作为参数传递给被调用的函数</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="function"><span class="keyword">func</span> = <span class="title">function</span><span class="params">( a, b, <span class="built_in">c</span> )</span></span>&#123;</span><br><span class="line">alert ( [ a, b, <span class="built_in">c</span> ] ); <span class="comment">// 输出 [ 1, 2, 3 ]</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">func</span>.<span class="title">call</span><span class="params">( null, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> )</span></span>;</span><br><span class="line">第一个参数：函数体内this的指向</span><br><span class="line">第二个参数：第二个参数开始往后，每个参数被依次传入函数</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">		name:<span class="string">'maying'</span>,</span><br><span class="line">		getInfo :<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">		name:<span class="string">'anne'</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	  <span class="built_in">console</span>.log(<span class="string">'obj1'</span>,obj1.getInfo()) <span class="comment">//maying</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'obj2'</span>,obj1.getInfo.call(obj2)) <span class="comment">//anne 此刻getInfo函数体内的this指向obj2对象</span></span><br><span class="line">    相当于</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">		name:<span class="string">'maying'</span>,</span><br><span class="line">		getInfo :<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> obj2.name</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Math</span>.max.apply( <span class="literal">null</span>, [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span> ] ) <span class="comment">// 输出:5</span></span><br></pre></td></tr></table></figure>
<p><code>Function.prototype.bind()</code><br> 用来指定函数内部的this指向</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">     <span class="comment">// js原生模拟 Function.prototype.bind 函数实现</span></span><br><span class="line"> Function.prototype.bind =  function(context)&#123;</span><br><span class="line"> 	  <span class="keyword">var</span> self = <span class="keyword">this</span> <span class="comment">//this当前指向 fun函数</span></span><br><span class="line"> 	  console.log(<span class="string">'self'</span>,self)</span><br><span class="line"> 	  <span class="keyword">return</span> function()&#123;</span><br><span class="line"> 	 	<span class="keyword">return</span> self.apply(context,arguments)</span><br><span class="line"> 	 	<span class="comment">// 将fun函数内部的this指向obj</span></span><br><span class="line"> 	 	<span class="comment">// 相当于 function()&#123;</span></span><br><span class="line">				<span class="comment">//  console.log('obj1.name',obj1.name)</span></span><br><span class="line">				<span class="comment">// &#125;</span></span><br><span class="line"> 	  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">	name:<span class="string">'maxiaoyin'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="function"><span class="keyword">fun</span> = <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line"> console.log(<span class="string">'this.name'</span>,<span class="keyword">this</span>.name)</span><br><span class="line">&#125;.bind(obj1)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">fun</span><span class="params">()</span></span>; <span class="comment">//maxiaoyin</span></span><br></pre></td></tr></table></figure>
<p>借用其他对象的方法实现继承</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">     	<span class="keyword">this</span>.name=<span class="string">'maying'</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     	A.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>)</span><br><span class="line">     	<span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     		<span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">     	&#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">var</span> b = <span class="keyword">new</span> B();</span><br><span class="line"></span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'b'</span>,b.getName()) <span class="comment">//maying</span></span><br></pre></td></tr></table></figure>
<p>想往 arguments 中添加一个新的元素</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line"> (<span class="name">function</span> abc ()&#123;</span><br><span class="line"> 		// arguments.push(<span class="symbol">'1</span>') 因为arguments不是数组 没办法执行数组有的push方法</span><br><span class="line"> 	    // [].push.call(<span class="name">arguments</span>,<span class="symbol">'1</span>') 或者</span><br><span class="line"> 	    Array.prototype.push.call(<span class="name">arguments</span>,<span class="symbol">'7</span>')</span><br><span class="line">     	console.log(<span class="symbol">'arguments</span>',arguments)</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   再操作 arguments 时候 我们通常会借用</span><br><span class="line">Array.prototype的各种方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Array.prototype.push 实际上是属性复制的过程</span><br><span class="line"> 可以推断 我们可以把**任意**的对象 传入  Array.prototype.push</span><br><span class="line"></span><br><span class="line"> 这个任意的限制</span><br><span class="line"> 对象本身可以存取书香</span><br><span class="line"> 对象的length可读写</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> var a= &#123;&#125;</span><br><span class="line"> Array.prototype.push.call(<span class="name">a</span>,<span class="symbol">'first</span>')</span><br><span class="line"> console.log(<span class="name">a</span>) //&#123;<span class="number">0</span>: <span class="string">"first"</span>, length: <span class="number">1</span>&#125;</span><br><span class="line"> console.log(<span class="name">a</span> instanceof Object) //true</span><br><span class="line"> console.log(<span class="name">a</span>[<span class="name">0</span>]) // 并非数组的用法 first</span><br></pre></td></tr></table></figure>
<h3 id="闭包和高阶函数"><a href="#闭包和高阶函数" class="headerlink" title="闭包和高阶函数"></a>闭<strong>包和高阶函数</strong></h3><p>js的函数作用域 就像一层半透明的玻璃 从里面可以看到外面 从外面不能看到里面<br>变量的搜索是从内往外而不是从外往内的</p>
<p>带有var关键字的局部变量 会随着函数调用的结束而销毁</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">一个有趣的问题</span><br><span class="line">	  &lt;div&gt;<span class="number">1</span>&lt;/div&gt;</span><br><span class="line">	  &lt;div&gt;<span class="number">2</span>&lt;/div&gt;</span><br><span class="line">	  &lt;div&gt;<span class="number">3</span>&lt;/div&gt;</span><br><span class="line">	  &lt;div&gt;<span class="number">4</span>&lt;/div&gt;</span><br><span class="line">	  &lt;div&gt;<span class="number">5</span>&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">	var nodes = document.getElementsByTagName( <span class="string">'div'</span> );</span><br><span class="line">	<span class="keyword">for</span> ( var <span class="built_in">i</span> = <span class="number">0</span>, len = nodes.<span class="built_in">length</span>; <span class="built_in">i</span> &lt; len; <span class="built_in">i</span>++ )&#123;</span><br><span class="line"></span><br><span class="line">			 nodes[ <span class="built_in">i</span> ].onclick = <span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line"></span><br><span class="line">				alert ( <span class="built_in">i</span> );</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">结果是每次都是<span class="number">5</span></span><br><span class="line">原因是： div的click是被异步触发的 当<span class="keyword">for</span>循环被触发的时候 <span class="keyword">for</span>循环早已经结束 此时<span class="built_in">i</span>变量的值已经是<span class="number">5</span>了 这个时候 click事件的函数顺着作用域链向上找变量<span class="built_in">i</span>的时候 找到的始终是<span class="number">5</span></span><br><span class="line"></span><br><span class="line">解决方式</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> ( var <span class="built_in">i</span> = <span class="number">0</span>, len = nodes.<span class="built_in">length</span>; <span class="built_in">i</span> &lt; len; <span class="built_in">i</span>++ )&#123;</span><br><span class="line">            (<span class="function"><span class="keyword">function</span><span class="params">(i)</span>&#123;</span></span><br><span class="line">            	       console.<span class="built_in">log</span>(<span class="string">'i'</span>,<span class="built_in">i</span>)</span><br><span class="line">	            	   nodes[ <span class="built_in">i</span> ].onclick = <span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">					   alert ( <span class="built_in">i</span> );</span><br><span class="line">			       &#125;</span><br><span class="line">            &#125;)(<span class="built_in">i</span>)</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>闭包的作用</strong></p>
<ol>
<li>封装变量<br>闭包可以把一些不需要暴漏在全局的变量封装成私有变量</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">改造之前</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cache = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mult = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.join.call( <span class="built_in">arguments</span>, <span class="string">','</span> );</span><br><span class="line"></span><br><span class="line">		 <span class="keyword">if</span> ( cache[ args ] )&#123;</span><br><span class="line">		   <span class="keyword">return</span> cache[ args ];</span><br><span class="line">		  &#125;</span><br><span class="line">       <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, l = <span class="built_in">arguments</span>.length; i &lt; l; i++ )&#123;</span><br><span class="line"></span><br><span class="line">		    a = a * <span class="built_in">arguments</span>[i];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> cache[ args ] = a;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">alert ( mult( <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> ) );</span><br><span class="line">alert ( mult( <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> ) );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">改造原理：如果大函数里面又可以复用的小函数 可以提炼出来 但是这些小函数不需要在其他地方调用的话最好用闭包封闭起来</span><br><span class="line">改造之后</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> mult = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="keyword">var</span> cache=&#123;&#125;</span><br><span class="line"></span><br><span class="line">	 	  <span class="keyword">var</span> calculate = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			    	<span class="keyword">var</span> a =<span class="number">1</span>;</span><br><span class="line">			    	<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="built_in">arguments</span>.length; i++)&#123;</span><br><span class="line">			    		a = a *<span class="built_in">arguments</span>[i];</span><br><span class="line">			    	 &#125;   </span><br><span class="line">		            <span class="keyword">return</span> a;</span><br><span class="line">	 	  &#125;</span><br><span class="line"></span><br><span class="line">	 	  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	 	  	     <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.join.call(<span class="built_in">arguments</span>,<span class="string">','</span>)</span><br><span class="line">		         <span class="comment">// 如果存在的话</span></span><br><span class="line">			 	 <span class="keyword">if</span>(cache[args])&#123;</span><br><span class="line">			 		 	<span class="keyword">return</span>  cache[args]</span><br><span class="line">			 	  &#125;</span><br><span class="line">			 	  <span class="keyword">return</span> cache[args] = 	calculate.apply(<span class="built_in">window</span>,<span class="built_in">arguments</span>)    </span><br><span class="line"> &#125;&#125;)();</span><br><span class="line"> <span class="built_in">console</span>.log(mult(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<p>2.延续局部变量的寿命</p>
<p><strong>闭包和面向对象的设计</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 用闭包实现一个面向对象系统</span></span><br><span class="line"> <span class="keyword">var</span> extent = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> 	  <span class="keyword">var</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            call: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                   value++;</span><br><span class="line">                   <span class="built_in">console</span>.log( value );</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 面向对象的写法</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">var</span> extend = &#123;</span><br><span class="line">     	<span class="keyword">this</span>.value = <span class="number">0</span>;</span><br><span class="line">     	<span class="keyword">this</span>.call = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     		<span class="keyword">this</span>.value ++;</span><br><span class="line">     		<span class="built_in">console</span>.log(<span class="string">'this.value'</span>,<span class="keyword">this</span>.value)</span><br><span class="line">     	&#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Extend = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.value = <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line">Extend.prototype.call=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.value ++;</span><br><span class="line">     		<span class="built_in">console</span>.log(<span class="string">'this.value'</span>,<span class="keyword">this</span>.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>高阶函数</strong><br>满足下列条件之一<br>函数可以作为参数被传递<br>函数可以作为返回值输出</p>
<p>判断数据的类型</p>
<p>Object.prototype.toString.call<br>对象的原生扩展函数 更精确的区分数据类型</p>
<p>15.2.4.2 Object.prototype.toString()<br>在toString方法被调用时,会执行下面的操作步骤:</p>
<ol>
<li><p>获取this对象的[[Class]]属性的值。</p>
</li>
<li><p>计算出三个字符串”[object “, 第一步的操作结果Result(1), 以及 “]”连接后的新字符串。</p>
</li>
<li><p>返回第二步的操作结果Result(2)。<br>[[Class]]是一个内部属性,所有的对象(原生对象和宿主对象)都拥有该属性.在规范中,[[Class]]是这么定义的:<br>内部属性 描述<br>[[Class]] 一个字符串值,表明了该对象的类型。<br>其过程简单说来就是：1、获取对象的类名（对象类型）。2、然后将[object、获取的类名、]组合并返回。</p>
</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"> <span class="selector-tag">Object</span><span class="selector-class">.prototype</span><span class="selector-class">.toString</span><span class="selector-class">.call</span>( <span class="selector-attr">[1,2,3]</span> )</span><br><span class="line">"<span class="selector-attr">[object Array]</span>"</span><br></pre></td></tr></table></figure>
<p><strong>判断数据的类型</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isType = <span class="function"><span class="keyword">function</span>(<span class="params"> type </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"> obj </span>)</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call( obj ) === <span class="string">'[object '</span>+ type +<span class="string">']'</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isString = isType( <span class="string">'String'</span> );</span><br><span class="line"> <span class="keyword">var</span> isArray = isType( <span class="string">'Array'</span> );</span><br><span class="line"> <span class="keyword">var</span> isNumber = isType( <span class="string">'Number'</span> );</span><br><span class="line"><span class="built_in">console</span>.log( isArray( [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ] ) );</span><br></pre></td></tr></table></figure>
<p>高阶函数实现AOP<br>（AOP）面向切面编程 主要作用是把一些跟核心业务逻辑的代码抽离出来</p>
<p>函数节流</p>
<p>函数被频繁调用的场景<br>window.onresize 事件<br>mousemove 事件<br>图片或者视频的上传进度</p>
<p>函数节流的原理</p>
<p> setTimeout 来完成这件事情</p>
<p> 分时函数<br> 惰性加载函数</p>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title=" 设计模式"></a><strong> 设计模式</strong></h2><h5 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h5><p>定义：保证一个类仅有一个实例，并且提供一个访问他的全局访问点</p>
<h6 id="实现单例模式"><a href="#实现单例模式" class="headerlink" title="实现单例模式"></a>实现单例模式</h6><p> 原理： 用一个对象来表示当前是否已经为这个类创建过对象，如果是 则在下一次获取该类的实例的时 直接返回之前创建的对象</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">  var Singleton = function(name)&#123;</span><br><span class="line">  	this.name=name,</span><br><span class="line">  	this.create = null;</span><br><span class="line">  &#125;</span><br><span class="line">Singleton.prototype.sayName = function()&#123;</span><br><span class="line">  console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var sayFn = function(name)&#123;</span><br><span class="line">	if(!this.create)&#123;</span><br><span class="line">		this.create =<span class="built_in"> new </span>Singleton(name)</span><br><span class="line">	&#125;</span><br><span class="line">   <span class="built_in"> return </span>this.create</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = sayFn('maxiaoying').sayName(); //maxiaoying</span><br><span class="line">var b = sayFn('lujing').sayName() //maxiaoying</span><br><span class="line">console.log(a ===b).  //true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">另一种闭包的实现方式</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var Sngal = function(name)&#123;</span><br><span class="line">	this.name=name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Sngal.prototype.sayname =function()&#123;</span><br><span class="line">     consoel.log('this.name',this.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// var getName= function()&#123;</span><br><span class="line">// 	var<span class="built_in"> instance </span>= null;</span><br><span class="line">// <span class="built_in">	return </span>function(name)&#123;</span><br><span class="line">// 		if(!instance)&#123;</span><br><span class="line">// 		<span class="built_in">	instance </span>=<span class="built_in"> new </span>Sngal(name)</span><br><span class="line">// 		&#125;</span><br><span class="line">// 	<span class="built_in">	return </span> instance</span><br><span class="line">// 	&#125;</span><br><span class="line">// &#125;(name);</span><br><span class="line"></span><br><span class="line">// 或者</span><br><span class="line"></span><br><span class="line">var getName= function()&#123;</span><br><span class="line">	var<span class="built_in"> instance </span>= null;</span><br><span class="line"><span class="built_in">	return </span>function(name)&#123;</span><br><span class="line">		if(!instance)&#123;</span><br><span class="line">		<span class="built_in">	instance </span>=<span class="built_in"> new </span>Sngal(name)</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="built_in">	return </span> instance</span><br><span class="line">	&#125;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line">先让getName 自执行才能得到  然后接收参数 理解闭包</span><br><span class="line">	-------------------------------------</span><br><span class="line">return function(name)&#123;</span><br><span class="line">		if(!instance)&#123;</span><br><span class="line">		<span class="built_in">	instance </span>=<span class="built_in"> new </span>Sngal(name)</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="built_in">	return </span> instance</span><br><span class="line">	&#125;</span><br><span class="line">	-------------------------------------</span><br><span class="line">var a = getName('maxiaogiou');</span><br><span class="line">console.log('a',a)</span><br><span class="line">var b = getName('xiaoxioamao');</span><br><span class="line">console.log('b',b)</span><br><span class="line">console.log('a ===b',a===b)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>design_mode</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟实现JS的new操作符</title>
    <url>/2019/03/13/new/</url>
    <content><![CDATA[<p><code>JS</code>中 <code>new</code>关键字用来实例化构造函数，那么它背后到底做了什么,能否被模拟实现<br>答案是肯定的</p>
<h2 id="new关键字做了什么"><a href="#new关键字做了什么" class="headerlink" title="new关键字做了什么"></a>new关键字做了什么</h2><p>你一定从别的文章或者在实际开发中感受到<code>new</code>的妙处，不错,总结下来它主要支持了四个功能</p>
<a id="more"></a>
<ol>
<li>创建了一个全新的对象</li>
<li>这个对象会被执行[[prototype]]（也就是<strong>proto</strong>）链接</li>
<li>生成的新对象会绑定到函数调用的this</li>
<li>通过<code>new</code>创建的每个对象将最终被来接到这个函数的prototype对象上</li>
<li>如果函数没有返回对象类型Object(包含Functoin, Array, Date, RegExg, Error)，那么new表达式中的函数调用会自动返回这个新的对象</li>
</ol>
<h2 id="模拟实现new"><a href="#模拟实现new" class="headerlink" title="模拟实现new"></a>模拟实现new</h2><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newOperator</span></span>(ctor)&#123;</span><br><span class="line">    <span class="keyword">if</span>(typeof ctor !== <span class="string">'function'</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">'newOperator function the first param must be a function'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ES6 new.target 是指向构造函数</span></span><br><span class="line">    <span class="keyword">new</span><span class="type">Operator</span>.target = ctor;</span><br><span class="line">    <span class="comment">// 1.创建一个全新的对象，</span></span><br><span class="line">    <span class="comment">// 2.并且执行[[Prototype]]链接</span></span><br><span class="line">    <span class="comment">// 4.通过`new`创建的每个对象将最终被`[[Prototype]]`链接到这个函数的`prototype`对象上。</span></span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">new</span><span class="type">Obj</span> = Object.create(ctor.prototype);</span><br><span class="line">    <span class="comment">// ES5 arguments转成数组 当然也可以用ES6 [...arguments], Aarry.from(arguments);</span></span><br><span class="line">    <span class="comment">// 除去ctor构造函数的其余参数</span></span><br><span class="line">    <span class="keyword">var</span> argsArr = [].slice.call(arguments, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 3.生成的新对象会绑定到函数调用的`this`。</span></span><br><span class="line">    <span class="comment">// 获取到ctor函数返回结果</span></span><br><span class="line">    <span class="keyword">var</span> ctorReturnResult = ctor.apply(<span class="keyword">new</span><span class="type">Obj</span>, argsArr);</span><br><span class="line">    <span class="comment">// 小结4 中这些类型中合并起来只有Object和Function两种类型 typeof null 也是'object'所以要不等于null，排除null</span></span><br><span class="line">    <span class="keyword">var</span> isObject = typeof ctorReturnResult === <span class="string">'object'</span> &amp;&amp; ctorReturnResult !== <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">var</span> isFunction = typeof ctorReturnResult === <span class="string">'function'</span>;</span><br><span class="line">    <span class="keyword">if</span>(isObject || isFunction)&#123;</span><br><span class="line">        <span class="keyword">return</span> ctorReturnResult;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.如果函数没有返回对象类型`Object`(包含`Functoin`, `Array`, `Date`, `RegExg`, `Error`)，那么`new`表达式中的函数调用会自动返回这个新的对象。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span><span class="type">Obj</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实例验证"><a href="#实例验证" class="headerlink" title="实例验证"></a>实例验证</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="comment">// this.doSth();</span></span><br><span class="line">    <span class="comment">// return Error();</span></span><br><span class="line">&#125;</span><br><span class="line">Student.prototype.doSth = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> student1 = newOperator(Student, <span class="string">'轩辕'</span>, <span class="number">18</span>);</span><br><span class="line"><span class="keyword">var</span> student2 = newOperator(Student, <span class="string">'Rowboat'</span>, <span class="number">18</span>);</span><br><span class="line"><span class="comment">// var student1 = new Student('轩辕');</span></span><br><span class="line"><span class="comment">// var student2 = new Student('Rowboat');</span></span><br><span class="line"><span class="built_in">console</span>.log(student1, student1.doSth()); <span class="comment">// &#123;name: '轩辕'&#125; '轩辕'</span></span><br><span class="line"><span class="built_in">console</span>.log(student2, student2.doSth()); <span class="comment">// &#123;name: 'Rowboat'&#125; 'Rowboat'</span></span><br><span class="line"></span><br><span class="line">student1.__proto__ === Student.prototype; <span class="comment">// true</span></span><br><span class="line">student2.__proto__ === Student.prototype; <span class="comment">// true</span></span><br><span class="line"><span class="comment">// __proto__ 是浏览器实现的查看原型方案。</span></span><br><span class="line"><span class="comment">// 用ES5 则是：</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(student1) === Student.prototype; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(student2) === Student.prototype; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>模拟<code>new</code>最大的功臣当属于<code>Object.create()</code>这个ES5提供的API</p>
<p><code>Object.create(proto, [propertiesObject])</code>方法创建一个新对象，使用现有的对象来提供新创建的对象的<code>__proto__</code> 它接收两个参数，不过第二个可选参数是属性描述符（不常用，默认是<code>undefined</code>）</p>
<p>对于不支持ES5的浏览器，MDN上提供了ployfill方案。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Object</span>.create !== <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span> (<span class="params">proto, propertiesObject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> proto !== <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> proto !== <span class="string">'function'</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Object prototype may only be an Object: '</span> + proto);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (proto === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"This browser's implementation of Object.create is a shim and doesn't support 'null' as the first argument."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> propertiesObject != <span class="string">'undefined'</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"This browser's implementation of Object.create is a shim and doesn't support a second argument."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">        F.prototype = proto;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>##总结</p>
<p>模拟new洁净版</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 去除了注释</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newOperator</span></span>(ctor)&#123;</span><br><span class="line">    <span class="keyword">if</span>(typeof ctor !== <span class="string">'function'</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">'newOperator function the first param must be a function'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">new</span><span class="type">Operator</span>.target = ctor;</span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">new</span><span class="type">Obj</span> = Object.create(ctor.prototype);</span><br><span class="line">    <span class="keyword">var</span> argsArr = [].slice.call(arguments, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> ctorReturnResult = ctor.apply(<span class="keyword">new</span><span class="type">Obj</span>, argsArr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> isObject = typeof ctorReturnResult === <span class="string">'object'</span> &amp;&amp; ctorReturnResult !== <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">var</span> isFunction = typeof ctorReturnResult === <span class="string">'function'</span>;</span><br><span class="line">    <span class="keyword">if</span>(isObject || isFunction)&#123;</span><br><span class="line">        <span class="keyword">return</span> ctorReturnResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span><span class="type">Obj</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Node.js实战-技术预研</title>
    <url>/2020/03/23/node/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>以一种要开发Node.js实战项目为最终目标<br>进行一系列的技术预研过程</p>
<p>有特点，有针对性，有目标</p>
<p>培养Node领域的全局观</p>
<h1 id="1-关于Nodejs"><a href="#1-关于Nodejs" class="headerlink" title="1 关于Nodejs"></a>1 关于Nodejs</h1><h2 id="1-1-什么是Node-js"><a href="#1-1-什么是Node-js" class="headerlink" title="1.1 什么是Node.js"></a>1.1 什么是Node.js</h2><p>官网的话：</p>
<ul>
<li>Node.js是基于ChromeV8执行引擎的JS运行时环境</li>
<li>Node.js使用了一个事件驱动，非阻塞式I/O的模型，使其轻量又高效</li>
</ul>
<p>每一个字其实都看得懂，聚合到一起就有点懵了</p>
<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1584894283204&amp;di=6e87b25c91207a1929250f11285d3a2c&amp;imgtype=0&amp;src=http%3A%2F%2Fimg2.biaoqingjia.com%2Fbiaoqing%2F201608%2Fa70d12bb1f409850857c8d930cf2d6d1.gif" alt="image"></p>
<p>我们先不来说nodejs是什么，先根据以往的经验抛出问题</p>
<h3 id="1-1-1-在Node-js里运行Js跟在Chrome运行Js有啥不同？"><a href="#1-1-1-在Node-js里运行Js跟在Chrome运行Js有啥不同？" class="headerlink" title="1.1.1 在Node.js里运行Js跟在Chrome运行Js有啥不同？"></a>1.1.1 在Node.js里运行Js跟在Chrome运行Js有啥不同？</h3><p>已知Chrome浏览器用的是同样的Javascript引擎和模型</p>
<blockquote>
<p>其实，在Node.js里写Js和在Chrome里写Js，<font color="red">几乎一样</font></p>
</blockquote>
<p>晃眼的<font color="red">几乎一样</font> 那就是有不一样的地方呗！</p>
<ul>
<li>Nodejs没有浏览器API，即(Document,window等)</li>
<li>相应的，也增加了它专属的API，比如文件系统，进程.</li>
</ul>
<p>有了这些差别，其实就不难理解了</p>
<h4 id="对于开发者来说"><a href="#对于开发者来说" class="headerlink" title="对于开发者来说"></a>对于开发者来说</h4><ul>
<li>你在chrome里写js<strong>控制浏览器</strong></li>
<li>Node.js让你用类似的方式，<strong>控制整个计算机</strong></li>
</ul>
<p>Node.js的真谛，也就是官方抽象的释义，我们完全可以在不断深入的过程中慢慢理解～</p>
<a id="more"></a>
<h2 id="1-2-Node-js可以用来做什么？"><a href="#1-2-Node-js可以用来做什么？" class="headerlink" title="1.2 Node.js可以用来做什么？"></a>1.2 Node.js可以用来做什么？</h2><h3 id="1-2-1-提供Web服务"><a href="#1-2-1-提供Web服务" class="headerlink" title="1.2.1 提供Web服务"></a>1.2.1 提供Web服务</h3><ul>
<li>搜索引擎优化 + 首屏速度优化 = 服务端渲染</li>
<li>服务端渲染 + 前后端同构 = Node.js</li>
</ul>
<h3 id="1-2-2-构建工作流"><a href="#1-2-2-构建工作流" class="headerlink" title="1.2.2 构建工作流"></a>1.2.2 构建工作流</h3><p>在<code>gulp webpack</code>之间，前端是如何做构建工具呢？</p>
<p>可能用java,ruby等</p>
<p>但</p>
<ul>
<li>构建工具不会永远不出问题</li>
<li>构建工具不会永远满足需求</li>
</ul>
<p>前端同学很难对这些工具进行修改或者升级</p>
<p>所以</p>
<blockquote>
<p>用Node.js做js的构建工具，是最保险的选择</p>
</blockquote>
<h3 id="1-2-3-开发工具"><a href="#1-2-3-开发工具" class="headerlink" title="1.2.3 开发工具"></a>1.2.3 开发工具</h3><p>VScode</p>
<p>在nodejs的基础上封装了chrome的内核，使nodejs具有控制计算机得到能力</p>
<h3 id="1-2-3-可扩展性较强大的沙盒游戏"><a href="#1-2-3-可扩展性较强大的沙盒游戏" class="headerlink" title="1.2.3 可扩展性较强大的沙盒游戏"></a>1.2.3 可扩展性较强大的沙盒游戏</h3><p>需要给使用者自定义模块的能力</p>
<p>使用Nodejs做复杂的本地应用</p>
<ul>
<li>可以利用js大的灵活性实现外部扩展</li>
<li>Js庞大的的开发者基数让他们的灵活性得到利用</li>
</ul>
<h3 id="1-2-4-客户端应用"><a href="#1-2-4-客户端应用" class="headerlink" title="1.2.4 客户端应用"></a>1.2.4 客户端应用</h3><p>在已有网站的基础上需要开发新的客户端应用<br>使用Node.js客户端技术实现，可以最大限度的复用现有工程</p>
<h1 id="2-Node-js-初探"><a href="#2-Node-js-初探" class="headerlink" title="2 Node.js 初探"></a>2 Node.js 初探</h1><h2 id="2-1-实现剪刀石头布"><a href="#2-1-实现剪刀石头布" class="headerlink" title="2.1 实现剪刀石头布"></a>2.1 实现剪刀石头布</h2><ul>
<li>node运行方式游戏</li>
<li>全局变量</li>
</ul>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">var <span class="attr">playerAction</span> = process.argv[process.argv.length - <span class="number">1</span>];</span><br><span class="line">console.log(<span class="string">"playerAction"</span>, playerAction);</span><br><span class="line"></span><br><span class="line">var <span class="attr">random1</span> = Math.random() * <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (random1 &lt; <span class="number">1</span>) &#123;</span><br><span class="line">  var <span class="attr">computerAction</span> = <span class="string">"rock"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (random1 &gt; <span class="number">2</span>) &#123;</span><br><span class="line">  var <span class="attr">computerAction</span> = <span class="string">"scissor"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  var <span class="attr">computerAction</span> = <span class="string">"paper"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="attr">computerAction</span> === playerAction) &#123;</span><br><span class="line">  console.log(<span class="string">"平局"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">  (<span class="attr">computerAction</span> === <span class="string">"rock"</span> &amp;&amp; <span class="attr">playerAction</span> === <span class="string">"paper"</span>) ||</span><br><span class="line">  (<span class="attr">computerAction</span> === <span class="string">"scissor"</span> &amp;&amp; <span class="attr">playerAction</span> === <span class="string">"rock"</span>) ||</span><br><span class="line">  (<span class="attr">computerAction</span> === <span class="string">"paper"</span> &amp;&amp; <span class="attr">playerAction</span> === <span class="string">"scissor"</span>)</span><br><span class="line">) &#123;</span><br><span class="line">  console.log(<span class="string">"你赢了！"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  console.log(<span class="string">"你输了！"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-1-使用Node-js模块规范改造游戏"><a href="#2-1-使用Node-js模块规范改造游戏" class="headerlink" title="2.1 使用Node.js模块规范改造游戏"></a>2.1 使用Node.js模块规范改造游戏</h2><h3 id="2-1-1-如何加载js"><a href="#2-1-1-如何加载js" class="headerlink" title="2.1.1 如何加载js"></a>2.1.1 如何加载js</h3><p>浏览器端</p>
<ul>
<li>使用<code>&lt;script/&gt;</code>标签</li>
<li>脚本变多时，需要手动管理加载顺序</li>
<li>不同脚本之间的逻辑调用需要全局变量</li>
</ul>
<p>Node端</p>
<ul>
<li>没有html文件，无法使用<code>&lt;script/&gt;</code>标签</li>
</ul>
<p><img src="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=45975645,3909583844&amp;fm=11&amp;gp=0.jpg" alt="image"></p>
<p>所以Node.js 要重新去搞一个模块管理机制来管理js的加载，就是现在我们熟悉的<font color="red">CommonJS规范</font></p>
<h3 id="2-1-2-重构剪刀石头布游戏"><a href="#2-1-2-重构剪刀石头布游戏" class="headerlink" title="2.1.2 重构剪刀石头布游戏"></a>2.1.2 重构剪刀石头布游戏</h3><p>games.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">playerAction</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ([<span class="string">"rock"</span>, <span class="string">"scissor"</span>, <span class="string">"paper"</span>].indexOf(playerAction) == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"invalid playerAction"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 计算电脑出的东西</span></span><br><span class="line">  <span class="keyword">var</span> computerAction;</span><br><span class="line">  <span class="keyword">var</span> random = <span class="built_in">Math</span>.random() * <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">if</span> (random &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    computerAction = <span class="string">"rock"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"电脑出了石头"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (random &gt; <span class="number">2</span>) &#123;</span><br><span class="line">    computerAction = <span class="string">"scissor"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"电脑出了剪刀"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    computerAction = <span class="string">"paper"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"电脑出了布"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (computerAction == playerAction) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"平局"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    (computerAction == <span class="string">"rock"</span> &amp;&amp; playerAction == <span class="string">"scissor"</span>) ||</span><br><span class="line">    (computerAction == <span class="string">"scissor"</span> &amp;&amp; playerAction == <span class="string">"paper"</span>) ||</span><br><span class="line">    (computerAction == <span class="string">"paper"</span> &amp;&amp; playerAction == <span class="string">"rock"</span>)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"你输了"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"你赢了"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>index.js</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">const game = require(<span class="string">"./game.js"</span>);</span><br><span class="line"></span><br><span class="line">var winCount = <span class="number">0</span>;</span><br><span class="line"><span class="regexp">//</span> 获取进程的标准输入</span><br><span class="line">process.stdin.on(<span class="string">"data"</span>, buffer =&gt; &#123;</span><br><span class="line">  <span class="regexp">//</span> 回调的是buffer，需要处理成string</span><br><span class="line">  const action = buffer.toString().trim();</span><br><span class="line">  const result = game(action);</span><br><span class="line">  <span class="keyword">if</span> (result == <span class="number">1</span>) &#123;</span><br><span class="line">    winCount++;</span><br><span class="line">    <span class="keyword">if</span> (winCount == <span class="number">3</span>) &#123;</span><br><span class="line">      console.log(<span class="string">"我不玩儿了！哼！"</span>);</span><br><span class="line">      process.<span class="keyword">exit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="3-Node内置模块"><a href="#3-Node内置模块" class="headerlink" title="3 Node内置模块"></a>3 Node内置模块</h1><p><a href="http://nodejs.cn/api/" target="_blank" rel="noopener">内置模块合集</a></p>
<h2 id="3-1-Node-js系统架构图"><a href="#3-1-Node-js系统架构图" class="headerlink" title="3.1 Node.js系统架构图"></a>3.1 Node.js系统架构图</h2><p><img src="http://cdn.anruence.com/node-system-1.png" alt="image"></p>
<h2 id="3-2-理解Node-js精髓"><a href="#3-2-理解Node-js精髓" class="headerlink" title="3.2 理解Node.js精髓"></a>3.2 理解Node.js精髓</h2><blockquote>
<p>Node.js是基于ChromeV8执行引擎的JS运行时环境</p>
</blockquote>
<p><font color="red">ChromeV8执行引擎的JS运行时环境</font>：架构图的左侧部分就是其体现</p>
<ul>
<li>application 代表你写的nodejs的代码</li>
<li>通过V8引擎来来运行，里面会涉及到一些关于操作系统调用，这部分就由V8引擎帮你转发到操作系统层面</li>
<li>从操作系统层面得到返回结果之后再通过V8引擎返回到Js里去</li>
</ul>
<ol>
<li>从Js到V8再到操作系统的能力，大部分都是通过Node.js的内置模块来提供的</li>
<li>还有一些数据是从操作系统底层通知到我们的Node.js层</li>
</ol>
<p>示例</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将进程设置为长期存在并且监听用户的输入</span></span><br><span class="line">process.stdin.<span class="keyword">on</span>('data',<span class="keyword">e</span>=&gt;&#123;</span><br><span class="line">  <span class="keyword">const</span> playerAction = <span class="keyword">e</span>.<span class="keyword">toString</span>().<span class="built_in">trim</span>();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>此时依赖的是Node的内置模块</p>
<ul>
<li>EventEmitter</li>
</ul>
<p>process实际上是EventEmitter的实例，继承了EventEmitter使其具备了向上抛事件的能力</p>
<p>引出</p>
<h2 id="3-3-EventEmitter"><a href="#3-3-EventEmitter" class="headerlink" title="3.3 EventEmitter"></a>3.3 EventEmitter</h2><h3 id="3-3-1-解决了什么问题"><a href="#3-3-1-解决了什么问题" class="headerlink" title="3.3.1 解决了什么问题"></a>3.3.1 解决了什么问题</h3><ul>
<li>解决两个对象之间的通信问题<ul>
<li>函数调用</li>
<li>观察者模式（事件收发模式）- 抛事件<ul>
<li>addEventListener</li>
<li>removeEventListener</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-3-2-普通调用应用场景"><a href="#3-3-2-普通调用应用场景" class="headerlink" title="3.3.2 普通调用应用场景"></a>3.3.2 普通调用应用场景</h3><ul>
<li>老板通知秘书</li>
<li>说是通知，但是直接调用比较合适<h3 id="3-3-3-观察者模式应用场景"><a href="#3-3-3-观察者模式应用场景" class="headerlink" title="3.3.3 观察者模式应用场景"></a>3.3.3 观察者模式应用场景</h3></li>
<li>通知消息的人并不知道被通知者的存在（极客时间并不知道我的存在）</li>
<li>没有人接收事件，它还能继续下去（今天没有接收到Geek上新课的消息，但是它还是可以上新课）</li>
</ul>
<p>lib.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Geektime</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>()&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.emit(<span class="string">'newlesson'</span>,&#123;<span class="attr">price</span>:<span class="built_in">Math</span>.random()* <span class="number">100</span>&#125;) <span class="comment">//触发事件</span></span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> geektime = <span class="keyword">new</span> Geektime;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = geektime</span><br></pre></td></tr></table></figure>
<p>index.js</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">const geektime = <span class="built_in">require</span>(<span class="string">'./lib.js'</span>)</span><br><span class="line">geektime.addListener(<span class="string">'newlesson'</span>,<span class="function"><span class="params">(res)</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(res.price &lt; <span class="number">50</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'buy!当前价格为---'</span>,res)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="4-Nodejs非阻塞I-O及异步编程"><a href="#4-Nodejs非阻塞I-O及异步编程" class="headerlink" title="4 Nodejs非阻塞I/O及异步编程"></a>4 Nodejs非阻塞I/O及异步编程</h1><p>值得拿出来单独说，<a href="http://maying.ink/2019/03/19/promise/">戳此一览</a></p>
<h1 id="5-实现网页版石头剪刀布游戏"><a href="#5-实现网页版石头剪刀布游戏" class="headerlink" title="5 实现网页版石头剪刀布游戏"></a>5 实现网页版石头剪刀布游戏</h1><p>技术前置</p>
<h2 id="5-1-什么是HTTP服务"><a href="#5-1-什么是HTTP服务" class="headerlink" title="5.1 什么是HTTP服务"></a>5.1 什么是HTTP服务</h2><p>一个网页请求，包含两次HTTP包交换</p>
<ul>
<li>浏览器向HTTP服务器发送请求HTTP包</li>
<li>HTTP服务器向浏览器返回HTTP包</li>
</ul>
<h2 id="5-2-HTTP服务要做什么事情"><a href="#5-2-HTTP服务要做什么事情" class="headerlink" title="5.2 HTTP服务要做什么事情"></a>5.2 HTTP服务要做什么事情</h2><ul>
<li>解析进来的HTTP请求报文</li>
<li>返回对应的HTTP返回报文 </li>
</ul>
<h2 id="5-3-实现一个简单的HTTP服务器"><a href="#5-3-实现一个简单的HTTP服务器" class="headerlink" title="5.3 实现一个简单的HTTP服务器"></a>5.3 实现一个简单的HTTP服务器</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line">http</span><br><span class="line">.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>);</span><br><span class="line">    res.end(<span class="string">'hello'</span>)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">.listen(<span class="number">8888</span>)</span><br></pre></td></tr></table></figure>
<h2 id="5-4-server端加载模版"><a href="#5-4-server端加载模版" class="headerlink" title="5.4 server端加载模版"></a>5.4 server端加载模版</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line">http</span><br><span class="line">.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>);</span><br><span class="line">    res.end(<span class="string">'hello'</span>)</span><br><span class="line">    fs.createReadStream(__dirname + <span class="string">'/index.html'</span>)</span><br><span class="line">    .pipe(res)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">.listen(<span class="number">8888</span>)</span><br></pre></td></tr></table></figure>
<h3 id="5-5-游戏逻辑"><a href="#5-5-游戏逻辑" class="headerlink" title="5.5 游戏逻辑"></a>5.5 游戏逻辑</h3><p>index.js  <a href="https://github.com/maying2020/nodejs-in-action/tree/master/http/nodeNative" target="_blank" rel="noopener">源码点击</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">"url"</span>);</span><br><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">"queryString"</span>);</span><br><span class="line"><span class="keyword">const</span> game = <span class="built_in">require</span>(<span class="string">"./game.js"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> playerLastAction = <span class="literal">null</span>; <span class="comment">//玩家上次出的</span></span><br><span class="line"><span class="keyword">let</span> playerWon = <span class="number">0</span>; <span class="comment">//玩家赢得次数</span></span><br><span class="line"><span class="keyword">let</span> sameCount = <span class="number">0</span>; <span class="comment">//统计相同操作统计次数</span></span><br><span class="line"></span><br><span class="line">http</span><br><span class="line">  .createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 通过内置模块url，转换发送到该http服务上的http请求包的url，</span></span><br><span class="line">    <span class="comment">// 将其分割成 协议(protocol)://域名(host):端口(port)/路径名(pathname)?请求参数(query)</span></span><br><span class="line">    <span class="keyword">const</span> parsedUrl = url.parse(req.url);</span><br><span class="line">    <span class="keyword">if</span> (parsedUrl.pathname == <span class="string">"/game"</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> query = querystring.parse(parsedUrl.query);</span><br><span class="line">      <span class="comment">// 玩家出的</span></span><br><span class="line">      <span class="keyword">const</span> playerAction = query.action;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 需求2:如果玩家赢了三次或者玩家作弊，则电脑不给他玩了</span></span><br><span class="line">      <span class="keyword">if</span> (playerWon &gt;= <span class="number">3</span> || sameCount == <span class="number">9</span>) &#123;</span><br><span class="line">        res.writeHead(<span class="number">500</span>);</span><br><span class="line">        res.end(<span class="string">"我再也不和你玩了！"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 需求1:如果玩家操作连续三次相同，视为玩家作弊</span></span><br><span class="line">      <span class="keyword">if</span> (playerLastAction &amp; (playerLastAction == playerAction)) &#123;</span><br><span class="line">        sameCount++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sameCount++;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      playerLastAction = playerAction;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (sameCount &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">        res.writeHead(<span class="number">400</span>);</span><br><span class="line">        res.end(<span class="string">"你作弊"</span>);</span><br><span class="line">        <span class="comment">// 将sameCount设置为9</span></span><br><span class="line">        sameCount = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 执行游戏逻辑</span></span><br><span class="line">      <span class="keyword">var</span> gameResult = game(playerAction);</span><br><span class="line">      res.writeHead(<span class="number">200</span>);</span><br><span class="line">      <span class="keyword">if</span> (gameResult == <span class="number">0</span>) &#123;</span><br><span class="line">        res.end(<span class="string">"平局！"</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (gameResult == <span class="number">1</span>) &#123;</span><br><span class="line">        res.end(<span class="string">"你赢了！"</span>);</span><br><span class="line">        <span class="comment">// 玩家胜利次数统计+1</span></span><br><span class="line">        playerWon++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res.end(<span class="string">"你输了！"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果请求url是浏览器icon，比如 http://localhost:3000/favicon.ico的情况</span></span><br><span class="line">    <span class="comment">// 就返回一个200就好了</span></span><br><span class="line">    <span class="keyword">if</span> (parsedUrl.pathname == <span class="string">"/favicon.ico"</span>) &#123;</span><br><span class="line">      res.writeHead(<span class="number">200</span>);</span><br><span class="line">      res.end();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果访问的是根路径，就把游戏页面读出来返回出去</span></span><br><span class="line">    <span class="keyword">if</span> (parsedUrl.pathname == <span class="string">"/"</span>) &#123;</span><br><span class="line">      fs.createReadStream(__dirname + <span class="string">"/index.html"</span>).pipe(res);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .listen(<span class="number">6001</span>);</span><br></pre></td></tr></table></figure>
<h1 id="6-使用express优化石头剪刀布游戏"><a href="#6-使用express优化石头剪刀布游戏" class="headerlink" title="6 使用express优化石头剪刀布游戏"></a>6 使用express优化石头剪刀布游戏</h1><h2 id="6-1-了解express"><a href="#6-1-了解express" class="headerlink" title="6.1 了解express"></a>6.1 了解express</h2><p>要了解一个框架，最好的方法是 </p>
<ol>
<li>了解它的关键功能</li>
<li>推导出它要解决的问题是什么</li>
</ol>
<p>核心功能</p>
<ul>
<li>路由</li>
<li>request/response 简化<ul>
<li>request:pathname、query等</li>
<li>response:send()、json()、jsonp()等</li>
</ul>
</li>
<li>中间件<ul>
<li>更好地组织流程代码</li>
<li>异步会打破Express的洋葱模型</li>
</ul>
</li>
</ul>
<h2 id="6-2-游戏逻辑"><a href="#6-2-游戏逻辑" class="headerlink" title="6.2 游戏逻辑"></a>6.2 游戏逻辑</h2><p>index.js <a href="https://github.com/maying2020/nodejs-in-action/tree/master/http/express" target="_blank" rel="noopener">源码点击</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">const</span> game = <span class="built_in">require</span>(<span class="string">"./game"</span>);</span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 玩家胜利次数，如果超过3，则后续往该服务器的请求都返回500</span></span><br><span class="line"><span class="keyword">var</span> playerWinCount = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 玩家的上一次游戏动作</span></span><br><span class="line"><span class="keyword">var</span> lastPlayerAction = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 玩家连续出同一个动作的次数</span></span><br><span class="line"><span class="keyword">var</span> sameCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过app.get设定 /favicon.ico 路径的路由</span></span><br><span class="line"><span class="comment">// .get 代表请求 method 是 get，所以这里可以用 post、delete 等。这个能力很适合用于创建 rest 服务</span></span><br><span class="line">app.get(<span class="string">"/favicon.ico"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 一句 status(200) 代替 writeHead(200); end();</span></span><br><span class="line">  response.status(<span class="number">200</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设定 /game 路径的路由</span></span><br><span class="line">app.get(</span><br><span class="line">  <span class="string">"/game"</span>,</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">request, response, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (playerWinCount &gt;= <span class="number">3</span> || sameCount == <span class="number">9</span>) &#123;</span><br><span class="line">      response.status(<span class="number">500</span>);</span><br><span class="line">      response.send(<span class="string">"我不会再玩了！"</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过next执行后续中间件</span></span><br><span class="line">    next();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当后续中间件执行完之后，会执行到这个位置</span></span><br><span class="line">    <span class="keyword">if</span> (response.playerWon) &#123;</span><br><span class="line">      playerWinCount++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">request, response, next</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// express自动帮我们把query处理好挂在request上</span></span><br><span class="line">    <span class="keyword">const</span> query = request.query;</span><br><span class="line">    <span class="keyword">const</span> playerAction = query.action;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!playerAction) &#123;</span><br><span class="line">      response.status(<span class="number">400</span>);</span><br><span class="line">      response.send();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lastPlayerAction == playerAction) &#123;</span><br><span class="line">      sameCount++;</span><br><span class="line">      <span class="keyword">if</span> (sameCount &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">        response.status(<span class="number">400</span>);</span><br><span class="line">        response.send(<span class="string">"你作弊！我再也不玩了"</span>);</span><br><span class="line">        sameCount = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      sameCount = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    lastPlayerAction = playerAction;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把用户操作挂在response上传递给下一个中间件</span></span><br><span class="line">    response.playerAction = playerAction;</span><br><span class="line">    next();</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">req, response</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> playerAction = response.playerAction;</span><br><span class="line">    <span class="keyword">const</span> result = game(playerAction);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果这里执行setTimeout，会导致前面的洋葱模型失效</span></span><br><span class="line">    <span class="comment">// 因为playerWon不是在中间件执行流程所属的那个事件循环里赋值的</span></span><br><span class="line">    <span class="comment">// setTimeout(()=&gt; &#123;</span></span><br><span class="line">    response.status(<span class="number">200</span>);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">      response.send(<span class="string">"平局"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">      response.send(<span class="string">"你输了"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      response.send(<span class="string">"你赢了"</span>);</span><br><span class="line">      response.playerWon = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// &#125;, 500)</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">"/"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// send接口会判断你传入的值的类型，文本的话则会处理为text/html</span></span><br><span class="line">  <span class="comment">// Buffer的话则会处理为下载</span></span><br><span class="line">  response.send(fs.readFileSync(__dirname + <span class="string">"/index.html"</span>, <span class="string">"utf-8"</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">6001</span>);</span><br></pre></td></tr></table></figure>
<h1 id="7-使用koa优化石头剪刀布游戏"><a href="#7-使用koa优化石头剪刀布游戏" class="headerlink" title="7 使用koa优化石头剪刀布游戏"></a>7 使用koa优化石头剪刀布游戏</h1><h2 id="7-1-了解koa"><a href="#7-1-了解koa" class="headerlink" title="7.1 了解koa"></a>7.1 了解koa</h2><p>核心功能:</p>
<ul>
<li>比 Express 更极致的 request/response 简化<ul>
<li>ctx.status=200</li>
<li>ctx.body=’helloworld’</li>
</ul>
</li>
<li>使用 async function 实现的中间件<ul>
<li>有“暂停执行”的能力</li>
<li>在异步的情况下也符合洋葱模型</li>
</ul>
</li>
<li>精简内核，所有额外功能都移到中间件里实现</li>
</ul>
<h2 id="7-2-Express-vs-Koa"><a href="#7-2-Express-vs-Koa" class="headerlink" title="7.2 Express vs Koa"></a>7.2 Express vs Koa</h2><ul>
<li>Express 门槛更低，Koa 更强大优雅。</li>
<li>Express 封装更多东西，开发更快速，Koa 可定制型更高</li>
</ul>
<h2 id="7-3-孰“优”孰“劣”"><a href="#7-3-孰“优”孰“劣”" class="headerlink" title="7.3 孰“优”孰“劣”"></a>7.3 孰“优”孰“劣”</h2><ul>
<li>框架之间其实没有优劣之分</li>
<li>不同的框架有不同的适用场景</li>
</ul>
<h2 id="7-4-游戏逻辑"><a href="#7-4-游戏逻辑" class="headerlink" title="7.4 游戏逻辑"></a>7.4 游戏逻辑</h2><p>index.js <a href="https://github.com/maying2020/nodejs-in-action/tree/master/http/koa" target="_blank" rel="noopener">源码点击</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">const</span> game = <span class="built_in">require</span>(<span class="string">"./game"</span>);</span><br><span class="line"><span class="keyword">const</span> koa = <span class="built_in">require</span>(<span class="string">"koa"</span>);</span><br><span class="line"><span class="keyword">const</span> mount = <span class="built_in">require</span>(<span class="string">"koa-mount"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 玩家胜利次数，如果超过3，则后续往该服务器的请求都返回500</span></span><br><span class="line"><span class="keyword">var</span> playerWinCount = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 玩家的上一次游戏动作</span></span><br><span class="line"><span class="keyword">var</span> lastPlayerAction = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 玩家连续出同一个动作的次数</span></span><br><span class="line"><span class="keyword">var</span> sameCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> koa();</span><br><span class="line"></span><br><span class="line">app.use(</span><br><span class="line">  mount(<span class="string">"/favicon.ico"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// koa比express做了更极致的response处理函数</span></span><br><span class="line">    <span class="comment">// 因为koa使用异步函数作为中间件的实现方式</span></span><br><span class="line">    <span class="comment">// 所以koa可以在等待所有中间件执行完毕之后再统一处理返回值，因此可以用赋值运算符</span></span><br><span class="line">    ctx.status = <span class="number">200</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gameKoa = <span class="keyword">new</span> koa();</span><br><span class="line">app.use(mount(<span class="string">"/game"</span>, gameKoa));</span><br><span class="line">gameKoa.use(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">ctx, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (playerWinCount &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">    ctx.status = <span class="number">500</span>;</span><br><span class="line">    ctx.body = <span class="string">"我不会再玩了！"</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用await 关键字等待后续中间件执行完成</span></span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 就能获得一个准确的洋葱模型效果</span></span><br><span class="line">  <span class="keyword">if</span> (ctx.playerWon) &#123;</span><br><span class="line">    playerWinCount++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">gameKoa.use(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">ctx, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> query = ctx.query;</span><br><span class="line">  <span class="keyword">const</span> playerAction = query.action;</span><br><span class="line">  <span class="keyword">if</span> (!playerAction) &#123;</span><br><span class="line">    ctx.status = <span class="number">400</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (sameCount == <span class="number">9</span>) &#123;</span><br><span class="line">    ctx.status = <span class="number">500</span>;</span><br><span class="line">    ctx.body = <span class="string">"我不会再玩了！"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (lastPlayerAction == playerAction) &#123;</span><br><span class="line">    sameCount++;</span><br><span class="line">    <span class="keyword">if</span> (sameCount &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">      ctx.status = <span class="number">400</span>;</span><br><span class="line">      ctx.body = <span class="string">"你作弊！我再也不玩了"</span>;</span><br><span class="line">      sameCount = <span class="number">9</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    sameCount = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  lastPlayerAction = playerAction;</span><br><span class="line">  ctx.playerAction = playerAction;</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">&#125;);</span><br><span class="line">gameKoa.use(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">ctx, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> playerAction = ctx.playerAction;</span><br><span class="line">  <span class="keyword">const</span> result = game(playerAction);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对于一定需要在请求主流程里完成的操作，一定要使用await进行等待</span></span><br><span class="line">  <span class="comment">// 否则koa就会在当前事件循环就把http response返回出去了</span></span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      ctx.status = <span class="number">200</span>;</span><br><span class="line">      <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">        ctx.body = <span class="string">"平局"</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">        ctx.body = <span class="string">"你输了"</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ctx.body = <span class="string">"你赢了"</span>;</span><br><span class="line">        ctx.playerWon = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;, <span class="number">500</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(</span><br><span class="line">  mount(<span class="string">"/"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">    ctx.body = fs.readFileSync(__dirname + <span class="string">"/index.html"</span>, <span class="string">"utf-8"</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line">app.listen(<span class="number">6001</span>);</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Node.js系列(一)之安装</title>
    <url>/2017/04/13/nodeJs%E7%B3%BB%E5%88%97%E4%B8%80/</url>
    <content><![CDATA[<h2 id="node简介"><a href="#node简介" class="headerlink" title="node简介"></a>node简介</h2><p>node是javascript语言的服务器运行环境<br>所谓的运行环境有两层意思：</p>
<ol>
<li>javascript语言通过node在服务器运行，在这个意义上，node是<strong>javascriprt的虚拟机</strong><br>2.node提供大量的工具库，使得javascript语言与操作系统互动（比如读写文件，新建子进程），在这个意义上，node又是<strong>javascrip的工具库</strong><br>Node内部采用<a href="http://baike.baidu.com/link?url=1kFBYYp0gB7_P6YD0d1s3sqF64zK41APPhCywsEG9qTKgguFTwwYPZTohqZzd82j" target="_blank" rel="noopener">Google公司的V8引擎</a>，作为JavaScript语言解释器；通过自行开发的libuv库，调用操作系统资源。<h2 id="什么是Google-V8-JavaScript引擎"><a href="#什么是Google-V8-JavaScript引擎" class="headerlink" title="什么是Google V8 JavaScript引擎"></a>什么是Google V8 JavaScript引擎</h2>V8是一个由丹麦Google开发的开源JavaScript引擎，V8就是chrome浏览器用的js解释引擎，主要是C编写的<br>V8在执行之前将JavaScript编译成了机器码，而非位元组码或是直译它，以此提升效能。更进一步，有了这些功能，JavaScript程序与V8引擎的速度媲美二进制编译。[4]<h2 id="安装相关"><a href="#安装相关" class="headerlink" title="安装相关"></a>安装相关</h2>访问官方网站nodejs.org<br>安装完成查看node版本</li>
</ol>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">node</span> <span class="title">--version</span></span><br><span class="line"> 或者</span><br><span class="line">$ <span class="keyword">node</span> <span class="title">-v</span></span><br></pre></td></tr></table></figure>
<p><img src="http://oucjferwh.bkt.clouddn.com/node1-1.png" alt="wunai"></p>
<p>更新node版本，可以通过node.js的n模块完成，<br>更新为最新发布的稳定版。</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>sudo npm install n -g</span><br><span class="line"><span class="variable">$ </span>sudo n stable</span><br></pre></td></tr></table></figure>
<p><img src="http://oucjferwh.bkt.clouddn.com/node1-2.png" alt="node-1-2"></p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">$ sudo n <span class="number">0.10</span><span class="number">.21</span></span><br></pre></td></tr></table></figure>
<h3 id="安装版本管理工具nvm"><a href="#安装版本管理工具nvm" class="headerlink" title="安装版本管理工具nvm"></a>安装版本管理工具nvm</h3><p>如果想在同一台机器同时安装多个版本的node，就需要用到嗯本管理工具nvm，nvm全称<strong>Node Version Manager</strong>，它与n的实现方式不同，其是通过shell脚本实现的。</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git clone <span class="symbol">https:</span>/<span class="regexp">/github.com/creationix</span><span class="regexp">/nvm.git ~/</span>.nvm</span><br><span class="line"><span class="variable">$ </span>source ~<span class="regexp">/.nvm/nvm</span>.sh</span><br></pre></td></tr></table></figure>
<p><img src="http://oucjferwh.bkt.clouddn.com/node1-3.png" alt="node-1-3"></p>
<h6 id="安装最新版本"><a href="#安装最新版本" class="headerlink" title="安装最新版本"></a>安装最新版本</h6><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ nvm install <span class="keyword">node</span><span class="title"></span></span><br></pre></td></tr></table></figure>
<p><img src="http://oucjferwh.bkt.clouddn.com/node1-4.png" alt="node-1-4"></p>
<h6 id="安装指定版本"><a href="#安装指定版本" class="headerlink" title="安装指定版本"></a>安装指定版本</h6><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">$ nvm install <span class="number">0.12</span><span class="number">.1</span></span><br></pre></td></tr></table></figure>
<p>######使用已安装的最新版本</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ nvm use <span class="keyword">node</span><span class="title"></span></span><br></pre></td></tr></table></figure>
<h6 id="使用指定版本的node"><a href="#使用指定版本的node" class="headerlink" title="使用指定版本的node"></a>使用指定版本的node</h6><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>nvm <span class="keyword">use</span> <span class="number">0</span>.<span class="number">12</span></span><br></pre></td></tr></table></figure>
<h6 id="查看本地安装的所有版本"><a href="#查看本地安装的所有版本" class="headerlink" title="查看本地安装的所有版本"></a>查看本地安装的所有版本</h6><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>nvm ls</span><br></pre></td></tr></table></figure>
<p><img src="http://oucjferwh.bkt.clouddn.com/node1-5.png" alt="node-1-5"></p>
<h6 id="退出已经激活的nvm，使用deactivate命令。"><a href="#退出已经激活的nvm，使用deactivate命令。" class="headerlink" title="退出已经激活的nvm，使用deactivate命令。"></a>退出已经激活的nvm，使用deactivate命令。</h6><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>nvm deactivate</span><br></pre></td></tr></table></figure>
<p>######卸载nvm</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">rm -rf ~<span class="string">/.nvm</span></span><br></pre></td></tr></table></figure>
<p>######查看nvm帮助</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nvm -h</span></span><br></pre></td></tr></table></figure>
<p>详细文档请参考官方文档<br><a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">https://github.com/creationix/nvm</a></p>
]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>addEventListener 中的 passive 用法</title>
    <url>/2018/12/21/passive/</url>
    <content><![CDATA[<h2 id="引出问题"><a href="#引出问题" class="headerlink" title="引出问题"></a>引出问题</h2><p>一个很简单的需求 页面有一张小图 点击是个swiper实现的图集 同时有一个灰色的蒙层 蒙层底部页面不可滑动 关闭蒙层 页面可恢复正常</p>
<p>实现方式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bodyScroll</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_switchTag</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type === <span class="string">'on'</span>) &#123;</span><br><span class="line">        <span class="built_in">window</span>.addEventListener(<span class="string">'touchmove'</span>, bodyScroll);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">window</span>.removeEventListener(<span class="string">'touchmove'</span>, bodyScroll);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_switchTag(on) 页面不可滑动</span><br><span class="line">_switchTag(off) 页面恢复滑动</span><br></pre></td></tr></table></figure>
<p>移动端的效果如下<br>android<br><img src="/images/passive/passive1.gif" alt="jsworke"></p>
<p>ios<br><img src="/images/passive/iOSqian.gif" alt="jsworke"></p>
<p>我不知道为什么无效 直到我在模拟器上看到了</p>
<p><img src="/images/passive/webqian.gif" alt="jsworke"></p>
<p>啊哦 报错了🦢</p>
<p><font color="red">Unable to preventDefault inside passive event listener due to target being treated as passive</font><br>来自 google 的解释 <a href="https://developers.google.com/web/updates/2017/01/scrolling-intervention" target="_blank" rel="noopener">https://developers.google.com/web/updates/2017/01/scrolling-intervention</a></p>
<p>大概的意思是说</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">由于浏览器必须要在执行事件处理函数之后，才能知道有没有调用过 preventDefault() ，这就导致了浏览器不能及时响应滚动，略有延迟。</span><br><span class="line"></span><br><span class="line">所以为了让页面滚动的效果如丝般顺滑，从 chrome56 开始，在 window、document 和 body 上注册的 touchstart 和 touchmove 事件处理函数，会默认为是 passive: <span class="literal">true</span>。浏览器忽略 preventDefault() 就可以第一时间滚动了。</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">wnidow.addEventListener(<span class="string">'touchmove'</span>, <span class="function"><span class="keyword">func</span>) 效果和下面一句一样</span></span><br><span class="line">wnidow.addEventListener(<span class="string">'touchmove'</span>, <span class="function"><span class="keyword">func</span>, &#123; <span class="title">passive</span>: <span class="title">true</span> &#125;)</span></span><br></pre></td></tr></table></figure>
<p>这就导致了这个问题</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">如果在以上这 3 个元素的 <span class="selector-tag">touchstart</span> 和 <span class="selector-tag">touchmove</span> 事件处理函数中调用 <span class="selector-tag">e</span><span class="selector-class">.preventDefault</span>() ，会被浏览器忽略掉，并不会阻止默认行为</span><br></pre></td></tr></table></figure>
<p>所以出现了以上视频中问题</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>那么我们如何来解决这个问题 即不要让浏览器忽略掉e.preventDefault()？</p>
<ol>
<li>window.addEventListener(‘touchmove’, func, { passive: false })</li>
</ol>
<p>设置passive: false之后的结果<br>android<br><img src="/images/passive/androdhou.gif" alt="jsworke"><br>ios<br><img src="/images/passive/iOShou.gif" alt="jsworke"><br>浏览器<br><img src="/images/passive/webhou.gif" alt="jsworke"><br>问题完美解决</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">你看到这里可以结束了 如果你还想再了解一点点</span><br><span class="line">👇👇👇👇</span><br><span class="line"></span><br><span class="line">#### 你可能不知道的<span class="keyword">addEventListener</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">很久之前addEventListener的参数是这样儿的</span></span><br><span class="line"><span class="keyword">`addEventListener(type, </span>listener, useCapture)`</span><br><span class="line"></span><br><span class="line">后来也就是控制监听器是在捕获阶段执行还是在冒泡阶段执行的 useCapture 参数，变成了可选参数</span><br><span class="line">`<span class="keyword">addEventListener(type, </span>listener [,useCapture])`</span><br><span class="line"></span><br><span class="line">再后来 DOM 规范做了修订<span class="keyword">addEventListener() </span>的第三个参数可以是个对象值了，也就是说第三个参数现在可以是两种类型的值了 变成这样儿式儿的</span><br></pre></td></tr></table></figure>
<p>addEventListener(type, listener[, useCapture ])<br>addEventListener(type, listener[, options ])<br><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">扩展新的选项，从而自定义更多的行为，目前规范中 <span class="keyword">options</span> 对象可用的属性有三个：</span><br></pre></td></tr></table></figure></p>
<p>addEventListener(type, listener, {<br>    capture: false, 等价于 useCapture 默认值false<br>    passive: false, 是否让阻止默认事件失效 true:失效 false：不失效<br>    once: false //表明该监听器是一次性的，执行一次后就被自动 removeEventListener 掉，还没有浏览器实现它 默认值false<br>})<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">还想再说一点 那我设置了 passive的事件 这么移除呢 这里给出了方法</span><br></pre></td></tr></table></figure></p>
<p>你可以直接省略第三个参数<br>window.removeEventListener(‘touchmove’, func)</p>
<p>如果添加了 第一个参数 capture 可以这样移除</p>
<p>window.removeEventListener(‘touchmove’, func, true)<br>window.removeEventListener(‘touchmove’, func, {capture :true})</p>
<h3 id="为什么会有-passive这个概念"><a href="#为什么会有-passive这个概念" class="headerlink" title="为什么会有 passive这个概念"></a>为什么会有 passive这个概念</h3><p>像这样儿的代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"touchstart"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    ... <span class="comment">// 浏览器不知道这里会不会有 e.preventDefault()</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>由于 touchstart 事件对象的 cancelable 属性为 true，也就是说它的默认行为可以被监听器通过 preventDefault() 方法阻止，那它的默认行为是什么呢，通常来说就是滚动当前页面（还可能是缩放页面），如果它的默认行为被阻止了，页面就必须静止不动。但浏览器无法预先知道一个监听器会不会调用 preventDefault()，它能做的只有等监听器执行完后再去执行默认行为，而监听器执行是要耗时的，有些甚至耗时很明显，这样就会导致页面卡顿。视频里也说了，即便监听器是个空函数，也会产生一定的卡顿，毕竟空函数的执行也会耗时。</p>
<p>有 80% 的滚动事件监听器是不会阻止默认行为的，也就是说大部分情况下，浏览器是白等了。所以，passive 监听器诞生了，passive 的意思是“顺从的”，表示它不会对事件的默认行为说 no，浏览器知道了一个监听器是 passive 的，它就可以在两个线程里同时执行监听器中的 JavaScript 代码和浏览器的默认行为了</p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>异步编程方案的演进</title>
    <url>/2019/03/19/promise/</url>
    <content><![CDATA[<p>程序中<strong>现在运行的部分</strong>和<strong>将来运行的部分</strong>就是<strong>异步编程的核心</strong></p>
<p>异步编程的演进大致分以下几个时期</p>
<ul>
<li>回调函数时期</li>
<li>promise时期</li>
<li>生成器(ES6) + promise时期</li>
<li>async/await时期(ES7)</li>
</ul>
<a id="more"></a>
<h1 id="你必须要知道的基本概念"><a href="#你必须要知道的基本概念" class="headerlink" title="你必须要知道的基本概念"></a>你必须要知道的基本概念</h1><h2 id="异步、并行，并发的区别"><a href="#异步、并行，并发的区别" class="headerlink" title="异步、并行，并发的区别"></a>异步、并行，并发的区别</h2><ul>
<li>异步：是关于现在和将来的事件间隙</li>
<li>并行：是关于同时完成多个任务的概念</li>
<li>并发：是指分别由任务a和任务b 在一段时间内通过任务间的切换完成了这两个任务，<strong>单线程事件循环是并发的一种形式</strong></li>
</ul>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">并发是指两个或者多个事件随着时间发展交替执行，以至于从更高的层次上看是同时在运行（尽管在任意时刻只处理一个事件）</span><br><span class="line"></span><br><span class="line">实际的并发场景</span><br><span class="line">比如社交网站，随着用户向下滚动列表加载更多资源 （一边触发ajax一边响应数据）..</span><br></pre></td></tr></table></figure>
<h2 id="js里的完整运行特性"><a href="#js里的完整运行特性" class="headerlink" title="js里的完整运行特性"></a>js里的完整运行特性</h2><p>js从不跨线程共享数据，并且由于js单线程的特性，函数块儿中的代码具有完整运行机制，也就是说，一旦<code>foo()</code>开始运行，它的所有代码都会在<code>bar()</code>中的任意代码运行之前完成</p>
<h2 id="事件循环队列与任务队列的区别"><a href="#事件循环队列与任务队列的区别" class="headerlink" title="事件循环队列与任务队列的区别"></a>事件循环队列与任务队列的区别</h2><p>ES6中，有一个任务队列的概念，它是挂载在事件循环队列的每个<code>tick</code>之后的一个队列</p>
<p>js引擎运行在宿主环境中（浏览器，node端等），这些环境都有线程的概念，他们都提供了一种机制来处理程序中多个块儿的执行，且执行每块儿时调用js引擎，这种机制被称之为<strong>事件循环</strong></p>
<p>一旦有事件需要运行，事件循环就会运行，直到队列清空，事件循环的每一轮称为一个tick，用户交互 IO和定时器会向事件队列中加入事件，任意时刻，一次只能从队列中处理一个事件，执行事件的时候，可能直接或者间接地引发一个或者多个后续事件</p>
<p>一个比较形象的比喻</p>
<ul>
<li>事件循环队列：类似于一个游乐场游戏，玩过了一个游戏之后，你需要重新到队尾排队才能再玩一次</li>
<li>任务队列：玩过了游戏之后，插队接着玩</li>
</ul>
<h1 id="第一阶段-回调函数时期"><a href="#第一阶段-回调函数时期" class="headerlink" title="第一阶段(回调函数时期)"></a>第一阶段(回调函数时期)</h1><p>任何时候，只要把一段代码包装成一个函数，并指定它在响应某个事件时执行，你就是在代码中创建了一个将来执行的块儿，也由此在这个程序中引入了异步机制。</p>
<h2 id="回调实现异步的特性"><a href="#回调实现异步的特性" class="headerlink" title="回调实现异步的特性"></a>回调实现异步的特性</h2><ul>
<li>回调函数是<code>js</code>异步的基本单元，但是随着js越来越成熟，对于异步编程的发展，回调已经不够用了以至于产生可怕的<strong>回调地狱</strong>，嵌套函数存在耦合性，一大有所改动就会牵一发而动全身，而且嵌套过多导致错误难以处理</li>
<li>回调表达异步流程的方式是非线性的，非顺序的，这使得正确推理这样儿的代码难度很大，难以理解，我们需要一种更同步更顺序更阻塞的方式来表达异步，就像我们的大脑一样。</li>
<li>回调会受到<strong>控制反转</strong>的影响，因为回调函数中把控制权交给第三方比如<code>ajax()</code>，会造成一系列麻烦的<strong>信任问题</strong> </li>
</ul>
<font color="red">可能产生的信任问题</font>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1. </span>调用回调过早</span><br><span class="line"><span class="bullet">2. </span>调用回调过晚（或者不被调用）</span><br><span class="line"><span class="bullet">3. </span>调用回调次数过多或者过少</span><br><span class="line"><span class="bullet">4. </span>未能传递所需的环境和参数</span><br><span class="line"><span class="bullet">5. </span>吞掉可能出现的错误和异常</span><br></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我们需要一个通用的方案来解决这些信任问题，不管我们创建多少回调，这一方案都可以复用，且没有重复代码的开销 引出了<strong>Promise</strong></p>
<h1 id="第二阶段-Promise时期"><a href="#第二阶段-Promise时期" class="headerlink" title="第二阶段(Promise时期)"></a>第二阶段(Promise时期)</h1><p>直到<code>ES6 Promise</code>的引入JS才真正有内建的异步概念</p>
<p>我们开篇就了解到了 异步编程分现在运行部分 和将来运行部分的概念</p>
<ul>
<li>回调函数的模式是关于<strong>如何处理将来值</strong></li>
<li><code>Promise</code> 是把现在和将来归一化了 把他们都变成了将来，也就是说 它把所有的操作都变成了异步的</li>
</ul>
<h2 id="Promise的特点"><a href="#Promise的特点" class="headerlink" title="Promise的特点"></a>Promise的特点</h2><ul>
<li>我们通过某种方式在函数完成时候得到通知，以便我们可以继续下一步</li>
<li>类似于事件订阅 我们不需要关注谁订阅了这些事件，实现了关注点分离</li>
<li>Promise 封装了依赖时间的状态-它等待底层值的完成或者拒绝 所以promise本身是与时间无关的</li>
<li>它可以按照可预测的方式组合 而不用关心底层代码如何结束</li>
<li>一旦 <code>promise</code>决议，它就永远保持在这个状态</li>
<li>promise是一种封装和组合未来值的易于复用的机制</li>
</ul>
<h2 id="Promise基本用法"><a href="#Promise基本用法" class="headerlink" title="Promise基本用法"></a>Promise基本用法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line"> <span class="comment">//resolve()用于完成</span></span><br><span class="line"> <span class="comment">//reject() 用于拒绝</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"> 他有三个状态 </span><br><span class="line"> pending,fulfilled，rejected </span><br><span class="line"> </span><br><span class="line"> 两个过程</span><br><span class="line"> </span><br><span class="line"> pending -&gt; fulfilled</span><br><span class="line"> pending -&gt; rejected</span><br><span class="line"> </span><br><span class="line">resolve：会将传入的真正的promise直接返回，对传入的thenable会展开,如果这个thenable展开是一个拒绝状态，那么从promise.resolve()返回的promise实际上就是这同一个拒绝状态</span><br><span class="line">所以resolve实际上的结果可能是完成或拒绝</span><br><span class="line"></span><br><span class="line">rejected ：拒绝状态</span><br></pre></td></tr></table></figure>
<p>实例的调用</p>
<figure class="highlight scilab"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">promise.<span class="keyword">then</span>(resolveFn,rejectFn)</span><br><span class="line">如下：</span><br><span class="line">promise.<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(value)</span> &#123;</span></span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span><span class="params">(error)</span> &#123;</span></span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="如何确定某个值是不是真正的promise（或者说thenable）"><a href="#如何确定某个值是不是真正的promise（或者说thenable）" class="headerlink" title="如何确定某个值是不是真正的promise（或者说thenable）"></a>如何确定某个值是不是真正的promise（或者说thenable）</h3><p>利用鸭子模型<br>如果一个函数或对象具有.then()方法，我们认为这样儿的值就是<code>Promise</code>一致的<code>thenable</code></p>
<p>所以不要给函数或者对象添加<code>.then</code><br>方法，否则这个值就会误认为是一个<code>thenable</code> 导致难以追踪的<code>bug</code></p>
<p>既然我们已经知道亟待解决的问题，把回调的缺陷解决了，否则引入<code>Promise</code>没有任何意义</p>
<h2 id="解决控制反转问题"><a href="#解决控制反转问题" class="headerlink" title="解决控制反转问题"></a>解决控制反转问题</h2><p>之前 我们用回调函数封装程序中的代码，然后将其交给第三方等（比如ajax），接着期待其能调用回调实现功能<br>现在我们要能够把控制反转再反转回来<br>我们希望第三方<strong>给我们提供其任务何时结束的能力</strong>，然后由我们自己的代码来决定下一步做什么</p>
<font color="red">老实说 绝大多数JS/DOM新增的异步API都是基于Promise构建的</font><br>## 解决信任问题<br>### promise解决调用过早<br>对一个<code>promise</code>调用then的时候，即使这个<code>promise</code>已经决议，提供给<code>then()</code>的回调总会被异步调用<br>### promise解决调用过晚<br><code>promise</code>对象创建<code>resolve</code>或者<code>reject</code>时，这个promise的then注册的观察回调就会被自动调度，可以确信，这些被调度的回调在下一个异步事件点上依次被立即调用，这些回调中的任意一个都无法影响或延误对其他回调的调用，这是promise的运作方式<br>### 回调未调用<br>没有任何东西（甚至是js错误）能阻止promise向你通知他的决议，promise在决议时总是会调用其中一个<br><br>如果promise本身永远不被决议。promise也提供了解决方案<br><br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">用于一个超时的promise</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeoutpromise</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> promise(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line"> setTimeout(functiion()&#123;</span><br><span class="line">  reject(<span class="string">'timeout'</span>)</span><br><span class="line"> &#125;,delay)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>### 调用次数过多或过少<br>promise定义方式使得它只能被决议一次<br>如果试图调用多次或者resolve和reject都调用，那么这个promise只接受第一个决议，并默默的忽略任何后续调用<br>当然了，如果你把同一个回调注册了不止一次(p.then(f);p.then(f))那么它被调用的次数就会和注册次数相等<br><br>### 未能传递参数/环境值<br>promise至多只能有一个决议值（完成或拒绝）<br>如果使用多个参数调用resolve或者reject 第一个参数之后的所有参数都会默默忽略<br><br>如果要传递多个值，就必须把他们封装在单个值中传递 比如一个数组或者对象<br><br>### 吞掉错误或者异常<br>如果在<code>Promise</code>的创建过程中或者查看决议结果过程中的任何时间点上出现了js的异常错误，那么这个异常就会被捕捉，并且会使这个<code>Promise</code>拒绝<code>reject</code><br><br>promise甚至把js的异常也变成了异步行为，进而极大降低了静态条件出现的可能<br><br>但是如果promise完成后的回调中出现了js异常<br><br>因为p.then()本身返回了另外一个promise 正是这个promise(下一个promise)将会因TypeError异常而被拒绝<br><br><font color="red">注意：为什么它不是简单的调用我们的错误处理函数呢？</font><br>如果这样儿的话就违背了promise的基本原则：promise一旦决议就不可改变<br>也会造成有些回调会调用，有些回调不会调用情况会非常不透明<br><br>### 是可信任的Promise<br><br><strong>promise并没有完全摆脱回调，他们只是改变了传递回调的位置</strong><br><br><em> 如果你向<code>promise.resolve()</code>传递一个<code>非promise</code> 就会得到用这个值填充的Promise

</em> 如果你向promise.resolve()传递一个真正的promise 就会返回同一个promise<br><br><em> <code>promise.resolve()</code>可以接受任何<code>thenable</code>，得到的是一个真正的Promise 是一个可信任的值，如果你传入的已经是真的Promise 那么就更值得信任了
</em> 对于用promise.resolve()为所有函数的返回值（不管是不是thenable）都封装一层，这样儿做很容易把函数调用规范为定义良好的异步任务<br><br><em> <code>Promise</code>这种模式通过可信任的语义把回调当参数传递，使得这种行为更加可靠合理，通过把回调的控制反转回来，我们把控制权放在了一个可信任的系统，这种系统的设计目的就是为了使得异步编码更清晰<br><br><br>——-<br>以上 promise解决了回调函数的致命问题<br>接下来 我们将展示基于promise的链式流作用<br><br><br>## Promise的链式流<br>Promise并不是一个单步遵循<code>this-then-that</code>操作的机制，我们可以将多个Promise链接在一起表示一系列异步步骤<br><br>这种方式实现的有以下特性

</em> 每次你对promise调用then()它会创建并返回一个新的promise,我们可以将其链接起来<br><em> 不管从then()调用的完成回调（第一个参数）返回的值是什么，他都会被自动设置为被链接promise（第一点中的）的完成
</em> 调用promise的then()会自动创建一个新的promise从调用返回<br><em> 在完成或拒绝处理函数内部，如果返回一个值或者抛出一个异常。新返回的promise（可链接的）就相应的决议
</em> 如果返回或拒绝处理函数返回一个promise,它将会被展开，这样儿一来，不管它的决议值是什么，都会成为当前then()返回的链接promise的决议值<br><br>如下<br><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve(<span class="number">21</span>);</span><br><span class="line"> p.then(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v * <span class="number">2</span>)  <span class="comment">//42</span></span><br><span class="line">  <span class="keyword">return</span> v + <span class="number">2</span> <span class="comment">// ***</span></span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'ceshi'</span>,v) <span class="comment">//23</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br><br>第一个then就是异步序列的第一步<br><br>第二个then是第二步,<strong>只要保证把先前的then(..)连到自动创建的每一个promise即可</strong><br><br>在这个demo 中 我们用了立即返回的return语句<br><br>但是我们如果需要步骤二等待步骤一异步来完成一些事情怎么办？<br>也就是说我们想要使promise序列真正能够在每一步有异步能力？<br><br><br><figure class="highlight mercury"><table><tr><td class="code"><pre><span class="line">我们可以给<span class="keyword">promise</span>.resolve()传递非（最终值）即 **真正的<span class="keyword">promise</span>或thenable**，Promise会直接返回真正的<span class="keyword">promise</span> 或展开接收到的thenable值，并在持续展开`thanable`的同时递归前进</span><br></pre></td></tr></table></figure><br><br>如下<br><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve(<span class="number">21</span>);</span><br><span class="line"> p.then(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">    resolve(v*<span class="number">2</span>) <span class="comment">//42</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v) <span class="comment">//42</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br><br>我们把42封装到了返回的promise中，但是它仍然会被展开并最终成为链接的promise的决议，因此第二个.then函数中的到的仍然是42<br><br>此时，如果向封装的promise中引入异步，仍然会正常工作<br><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve(<span class="number">21</span>);</span><br><span class="line"> p.then(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      resolve(v*<span class="number">2</span>)</span><br><span class="line">    &#125;,<span class="number">200</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v) <span class="comment">//42</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br><br>完美 我们可以实现一系列个异步步骤<br><br>在这些例子中，一步一步传递的值是可选的，不传的话就是隐式返回<code>undefined</code>并且这些<code>Promise</code>仍然会以同样的方式链接到一起 每一个<code>Promise</code>的决议就成了继续下一个步骤的信号<br><br>### 存在默认的resolve和reject回调<br>默认的reject<br><br>如果你调用.then()函数并且只传入一个完成处理函数，一个默认拒绝处理函数就会顶替上来，默认拒绝处理函数只是把错误重新抛出，这使得错误可以继续沿着Promise链传播下去，直到遇到显式定义的拒绝处理函数<br><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">  reject(<span class="string">'ooPs'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = p.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//不会执行到这里</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//默认的拒绝处理函数 当你没有传时</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><br><br>默认的reject<br><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = p.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">v</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//不会执行到这里</span></span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//默认的拒绝处理函数 当你没有传时</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'ss'</span>,v) <span class="comment">//2</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br><br>默认的完成处理函数只是把接受到的任何传入值传递给下一个步骤的<code>promise</code>而已<br><br><br>## 关于错误处理<br><br>### 之前同步的错误处理<br><br>——-<br><br>我们通常使用try catch处理异常<br>但是它只能是同步的，<strong>无法用于异步代码模式</strong><br>即使你在异步代码 比如setTimeout中谁用try catch 仍然是有问题的，他们采用error-first回调风格，无法很好的组合，多级error-first回调交织，导致了回调地狱的风险<br><br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(cb)</span></span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> x = baz.bar();</span><br><span class="line">      cb(<span class="literal">null</span>,x)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(err)&#123;</span><br><span class="line">      cb(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">只有在 baz.bar()调用会同步地立即成功或失败的情况下，这里的<span class="keyword">try</span> <span class="keyword">catch</span>才能工作</span><br></pre></td></tr></table></figure><br><br>### promise的错误处理 增加 .catch(..)方法<br>.catch(..)会创建并返回新的promise，这个promise可用于实现promise链式流程控制<br>它没有采用error-first回调设计风格，而是使用了分离回调风格<br><code>一个回调用于完成情况
一个回调用于拒绝情况</code><br><br>我们了解到 在完成或拒绝处理函数内部，如果返回一个值或者抛出一个异常。新返回的promise（可链接的）就相应的决议，默认情况下，如果你没有捕捉<code>.then</code>的异常，它假定你想要promise状态吞掉所有的错误，如果你忘记查看这个状态，这个错误就会默默地在暗处凋零<br><br>所以为了避免被忽略的错误，<code>promise</code>链的最佳实践就是最后总以一个<code>catch</code>结束<br><br>诸如<br><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve(<span class="number">42</span>);</span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(msg.toLowerCase())</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'捕获错误'</span>,error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br><br>这样儿可以成功的捕获错误<br><br>但是 <code>reject()</code>函数的任何异常都会被作为一个全局未处理的错误抛出<br>## Promise其他的API<br><br>### Promise.done(..)<br>标示promise链的结束<br>done()不会创建和返回promise<br><br>### Promise.all([])<br>在异步序列中，任意时刻都只能有一个异步任务正在执行<br>但是我们如果想要同时执行两个或更多步骤（“并行执行”）的时候，<code>Promise.all([])</code>的魅力就体现出来<br>了<br><br>Promise.all([]) 接收一个数组，值可以是（promise，thenable，甚至是立即值），列表里的每个值都要经过Promise.resolve()过滤，以确保要等待的是一个真正的promise，<br>从返回的promise数据也是一个数组，与传入的顺序一致<br><br>如果返回的主promise在且仅在所有成员promise都完成后才会完成 如果有热和一个被拒绝，主promise就会立即被拒绝，并丢弃来自其他所有promise的结果<br><br>所以 要为每个promise关联一个错误处理函数<br><br>传入空数组时，它会立即完成<br><br>### Promise.race([])<br>与promise.all类似<br>它一旦有人黑一个promise决议为完成，promise.race就会完成，一旦有任何一个promise决议为拒绝，它就会拒绝<br><br>它的完成值是单个消息，并不像promise.all那样儿是一个数组，其他的promise会被丢弃或者忽略<br><br>两者都会创建一个promise作为他们的返回值，这个promise的决议完全由传入的promise数组控制<br><br>传入空数组时，它会挂住，且永远不会决议<br><br>### Promise.finally()<br><br>从行为的角度上 有些开发者提出，promise需要一个<code>finally()</code>的回调注册，这个回调在<code>promise</code>决议后总是会被调用，并且允许你执行任何必要的清理工作<br><br>如下<br><br><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">var p = Promise.resolve(<span class="number">42</span>);</span><br><span class="line">p.<span class="keyword">then</span>(<span class="function"><span class="params">()</span>=&gt;</span>&#123;&#125;)</span><br><span class="line">.<span class="keyword">finally</span>(cleanup)</span><br><span class="line">.<span class="keyword">then</span>(<span class="function"><span class="params">()</span>=&gt;</span>&#123;&#125;)</span><br><span class="line">.<span class="keyword">finally</span>(cleanup)</span><br></pre></td></tr></table></figure><br><br>finally会创建并返回一个新的promise以支持链接继续<br><br><br><br>### new Promise(..)构造器<br><br>构造器 Promise必须和new一起使用，并且必须提供一个函数回调，这个回调是同步的，这个函数接收到两个函数回调，用以支持promise的决议<br><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br><br>#### 创建两种决议的快捷方式<br><br>1. Promise.resolve //用于创建一个已完成的promise<br>2. Promise.reject //用于拒绝这个promise<br><br>以下是等价的<br><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">reject(<span class="string">'oop'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.reject(<span class="string">'oop'</span>)</span><br></pre></td></tr></table></figure><br><br>##promise的局限性<br><br><em> 顺序错误处理<br><br><figure class="highlight mercury"><table><tr><td class="code"><pre><span class="line">他们链接的方式 <span class="keyword">promise</span>链中的错误容易被无意中忽略掉</span><br></pre></td></tr></table></figure>

</em> 单一值<br><br><figure class="highlight mercury"><table><tr><td class="code"><pre><span class="line"><span class="keyword">promise</span>只能有一个完成值或一个拒绝理由 对于复杂的场景信息有点局限</span><br></pre></td></tr></table></figure><br><br><em>  单决议
</em> 无法取消的promise<br><br><figure class="highlight mercury"><table><tr><td class="code"><pre><span class="line">一旦创建了一个<span class="keyword">promise</span>并为其注册了完成和拒绝处理函数，如果出现某种情况使得这个任务悬而未决的话 你也没有办法从外部停止它的进程</span><br></pre></td></tr></table></figure><br><br><em> promise性能<br><br><figure class="highlight mercury"><table><tr><td class="code"><pre><span class="line">更多的工作更多的保护 <span class="keyword">promise</span>与回调相比 会慢一点</span><br><span class="line">但是作为交换你得到的是大量内建的可信任性</span><br></pre></td></tr></table></figure><br><br>## 小结
</em> promise非常好 他们解决了我们因只用回调的代码而备受困扰的控制反转的问题<br><em> 它并没有摒弃回调，只是把回调的安排转交给了一个位于我么和其他工具之间的可信任的中介机制

</em> promise也开始提供（尽管不完美）以顺序的方式表达异步流的一个更好的办法，这有助于我们的大脑更好的几乎是和维护异步js代码<br><br><br>——-<br><br>#第二阶段(生成器 Generator时期)<br><br>先来回顾一下 回调表达异步控制流程的两个关键缺陷<br><br>1. 基于回调的异步不符合大脑对任务步骤的规划方式<br>2. 由于控制反转回调并不是可信任的<br><br>然后我们用<code>Promise</code>解决了如何把回调的控制反转 反转回来,恢复了可信任性<br>但是它不会暂停<br>现在我们寻求一种顺序，看似同步的异步流程控制表达这个(.then()钱嵌套多了也受不了)，引出了<font color="red">ES6 生成器</font>的概念<br><br>Generator最大的特点就是可以控制函数的执行<br>它会创建出一个迭代器<br>Generator 函数是一个状态机，封装了多个内部状态。<br>调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是遍历器对象（Iterator Object）<br><br>它打破了完整执行 我们不再依赖<strong>一个函数一旦开始执行，就会运行到结束，期间不会有其他代码能够打破它并插入其间</strong>的假定<br><br>ES6中指定暂停点的语法是<code>yield</code> 这样礼貌的表达了一种合作式的控制放弃<br><br>如下<br><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  x++;</span><br><span class="line">  <span class="keyword">yield</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'x:'</span>,x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  x++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = foo(); <span class="comment">//构建了一个迭代器 并没有执行foo</span></span><br><span class="line">it.next(); <span class="comment">//启动生成器 *foo 并运行了第一行的 x++  *foo在yield处暂停</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'sws'</span>,x) <span class="comment">//2</span></span><br><span class="line">bar();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'二'</span>,x) <span class="comment">//3</span></span><br><span class="line">it.next(); <span class="comment">//最后从暂停处恢复了生成器 *foo的执行 运行了  console.log('x:',x); //3</span></span><br></pre></td></tr></table></figure><br><br>生成器是一种特殊的函数，可以一次或者多次的启动和停止 构建生成器是作为异步流程控制的代码模式的基础构件之一<br><br>我们可以看到 我们在暂停之后做了我们想做的操作 还执行了我们想要执行的函数<code>bar</code><br><br><br>### 生成器的输入和输出<br><code>var it = foo();</code> 这行只是创建了一个生成器对象，把它赋给了变量it，用于控制生成器，它是特殊的函数，也具有函数的特质，可以传递参数<br><code>it.next()</code> 指定生成器从当前位置开始继续运行，停在下一个<code>yield</code>处或者直到生成器结束，它调用的结果是一个对象，有一个value属性，持有从<code>*foo</code>返回的值（如果有的话）也就是说<code>yield</code>会导致生成器在执行过程中发送出一个值(类似<code>return</code>)<br><br>如下<br><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = foo(<span class="number">6</span>,<span class="number">7</span>); </span><br><span class="line"><span class="keyword">var</span> obj = it.next(); </span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">//&#123;value: 42, done: true&#125;</span></span><br></pre></td></tr></table></figure><br><br>### 迭代消息传递<br><br>通过<code>yield</code>和<code>next</code>实现的内建消息输入输出能力<br><br><code>next()</code>调用要比<code>yield</code>语句多一个<br>因为第一个<code>next()</code>总是启动一个生成器，并运行到第一个<code>yield</code>处，执行第一次<code>next</code>时候，传递参数值会被忽略<br><br><br>第一个yield基本上是提出了一个问题：我的值是多少？<br>谁来回答这一个问题 显然第一个next已经执行，因此由第二个next调用回答第一个yield提出的这个问题<br><br>从迭代器的角度看问题<br><br>消息是双向传递的 next也可以向暂停的yield表达式发送值 yield作为一个表达式可以发出消息响应next的调用<br><br>这里有一个例子能帮助你理解generator的执行<br><br><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">//<span class="built_in">yield</span>基本上就是提出了个问题 我的值等于什么 然后由下一个<span class="built_in">next</span>()传递的参数回答</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span><span class="params">(x)</span></span>&#123;</span><br><span class="line">  let y = <span class="number">2</span> *(<span class="built_in">yield</span>(x+<span class="number">1</span>));</span><br><span class="line">  let z = <span class="built_in">yield</span>(y/<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> x + y + z </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let it = foo(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(it.<span class="built_in">next</span>()) //&#123;value: <span class="number">6</span>, done: <span class="literal">false</span>&#125;</span><br><span class="line">console.<span class="built_in">log</span>(it.<span class="built_in">next</span>(<span class="number">12</span>)) //&#123;value: <span class="number">8</span>, done: <span class="literal">false</span>&#125;</span><br><span class="line">console.<span class="built_in">log</span>(it.<span class="built_in">next</span>(<span class="number">13</span>)) //&#123;value: <span class="number">42</span>, done: <span class="literal">true</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">解析</span><br><span class="line">generator函数调用和普通函数不同 它会返回一个迭代器</span><br><span class="line"></span><br><span class="line">执行第一次<span class="built_in">next</span>时候，传递参数值会被忽略，并且函数暂停在<span class="built_in">yield</span>(x+<span class="number">1</span>)处 所以返回 <span class="number">5</span>+<span class="number">1</span></span><br><span class="line">执行第二次<span class="built_in">next</span>时，传入的参数等于上一个<span class="built_in">yield</span>的返回值 如果你不传参，<span class="built_in">yield</span>永远返回undefined，此时  let y = <span class="number">2</span> * <span class="number">12</span> = <span class="number">24</span>，所以第二个z是<span class="number">24</span>/<span class="number">3</span> =<span class="number">8</span></span><br><span class="line">当执行第三次<span class="built_in">next</span>时 传递的参数会传递给z，所以z=<span class="number">13</span> x = <span class="number">5</span> y = <span class="number">24</span> 相加等于<span class="number">42</span></span><br><span class="line">*/</span><br></pre></td></tr></table></figure><br><br><strong>多个迭代器</strong><br>每次构建一个迭代器实际上就是隐式构建生成器的一个实例 通过这个迭代器控制的是这个生成器的实例<br><br>同一个生成器的多个实例可以同时运行它们甚至可以彼此交互<br><br><br>#### 生产者与迭代器<br>假设你要产生一系列值，其中每个值都与前面一个有特定的关系  需要一个有状态的生产者能够记住其生成的最后一个值<br>在此之前 我们可以使用函数闭包来实现<br><br>迭代器是一个定义良好的接口，用于从一个生产者一步步得到一系列值，js迭代器的接口与多数语言类似，就是每次想要从生产者得到下一个值的时候调用next()<br>next调用返回一个对象有两个属性<br><br><figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">done</span>是一个布尔值 表示迭代器的完成状态</span><br><span class="line"><span class="keyword">value</span>中放置迭代值</span><br></pre></td></tr></table></figure><br><br>#### 同步错误处理<br>类似<br><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> text = <span class="keyword">yield</span> foo(<span class="number">11</span>,<span class="number">31</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(text)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(err)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>生成器<code>yield</code>暂停的特性意味着我们不仅能从异步函数调用的到看似同步的返回值，还可以同步捕获来自这些异步函数调用的错误 它使得生成器能够捕获错误是一个很大的进步<br><br># 第四阶段（async/await时期 ES7）<br>ES6中最完美的时间就是生成器（看似同步的代码）和promise（可信任可组合）的结合<br><br>我们不再<code>yield</code>出<code>Promise</code>而是用<code>await</code>等待它决议<br>它其实就是把前面的经验写进规范<br><br><br>## ES7的esync函数对于ES6的generator函数的改进体现了哪些方面<br><br><em> 内置执行器<br><br><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">generator函数的执行必须依赖于执行器，而<span class="keyword">async</span>函数自带执行器，也就是说<span class="keyword">async</span>函数的执行，与普通函数一模一样，只需要一行</span><br><span class="line">asyncReadFile();</span><br><span class="line"></span><br><span class="line">像这样 直接调用函数 就可以直接得出结果 不像generator函数，需要调用next方法或者co模块 才能真正执行得到最后的结果</span><br></pre></td></tr></table></figure>

</em> 更好的语义<br><br><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span>和<span class="keyword">await</span>比起 * 和 <span class="keyword">yield</span> 语义更清楚了<span class="keyword">async</span>表示函数有异步操作，<span class="keyword">await</span>表示紧跟在后面的表达式需要等待的结果</span><br></pre></td></tr></table></figure><br><br><em> 更广的适用性<br><br><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">co模块规定 <span class="keyword">yield</span>命令后面只能是thunk函数或者promise对象，而<span class="keyword">async</span>函数的<span class="keyword">await</span>后面 可以是promise对象和原始类型的值（数值，布尔等但这等同于同步操作）</span><br></pre></td></tr></table></figure>

</em> 返回值是promise<br><br><figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span>函数返回的是promise对象，这比generator函数的返回值是 <span class="keyword">Iterator</span>对象方便多了，你可以用<span class="keyword">then</span>方法指定下一步的操作</span><br><span class="line"></span><br><span class="line">进一步说 <span class="keyword">async</span>函数可以看作是多个异步操作包装成的一个promise对象，而<span class="keyword">await</span>命令就是内部<span class="keyword">then</span>命令的语法糖</span><br></pre></td></tr></table></figure><br><br>## 特点<br><br><em> 一个函数如果加上async那么它就会返回promise
</em> async 就是将函数返回值使用 Promise.resolve()包裹了下，和then中处理返回值一样<br><em> await是异步操作，它内部实现了generator,如果后来的表达式不返回promise的话，它就会被包装成Promise.resolve(返回值)，然后去执行函数的同步代码<br><br>看下面这个等价的例子<br><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">await</span> async2();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async2 end'</span>)</span><br><span class="line">&#125;</span><br><span class="line">async1();</span><br><span class="line"></span><br><span class="line">等价于</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async2 end'</span>)</span><br><span class="line">  resolve(<span class="built_in">Promise</span>.resolve()) <span class="comment">//Promise.resolve()决议之后将then代码插入到微任务队列的尾部</span></span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</em>  async及await 配合使用<br><em>  await就是<code>generator</code>加上<code>promise</code>的语法糖
</em>  <code>async/await</code>是异步的终极解决方案<br><br><br><br>###  优缺点<br> <font color="red">优势</font> 

<ul>
<li>处理then的调用链，能更清晰的写出来代码，毕竟写一堆then也很</li>
<li>能解决回调地狱的问题</li>
</ul>
<font color="red">缺点</font>

<ul>
<li>因为<code>await</code>将异步代码改造成了同步代码,如果多个异步代码没有依赖性却使用了<code>await</code>导致性能上的降低</li>
</ul>
<p>如下</p>
<figure class="highlight qml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="keyword">await</span> fetch(<span class="built_in">url</span>)</span><br><span class="line"> <span class="keyword">await</span> fetch(url2)</span><br><span class="line"> <span class="keyword">await</span> fetch(url3)</span><br><span class="line">&#125;</span><br><span class="line">这样儿的代码 如果没有依赖最好用promise.all</span><br></pre></td></tr></table></figure>
<p>#总结</p>
<ul>
<li><p>生成器是ES6的一个新的函数类型 它并不像普通函数那样总是运行到结束，取而代之的是生成器可以在运行当中（完全保持其状态）暂停 并且将来再从咱题ing的地方恢复运行</p>
</li>
<li><p>这种简体的暂停和恢复是合作型的不是抢占型的，这意味着生成器具有独一无二的能力来暂停自身，这是通过关键字<code>yield</code>来实现的 不过 只有控制生成器的迭代器具有恢复生成器的能力（next(..)）</p>
</li>
<li><p>yield/next 不只是控制机制 实际上也是一种双向消息传递机制 yield表达式备注上是暂停下来等待某个值 接下来的next调用则是会向被暂停的yield表达式传回一个值</p>
</li>
<li><p>在异步控制流程方便生成器的关键优点是 生成器内部的代码是以自然的同步/顺序方式表达任务的一系列步骤，其技巧在于 我们把可能的异步隐藏在关键字yield的后面 把异步移动到控制生成器的迭代器的代码部分</p>
</li>
<li>换句话说 生成器为异步代码保持了顺序同步 阻塞的代码模式 这使得大脑可以更自然的追踪代码 解决了基于回调的异步的缺陷</li>
</ul>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title>看完这篇，我奶奶都会设计组件了</title>
    <url>/2019/07/29/part/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://juejin.im/post/5d566e82f265da03f77e653c" target="_blank" rel="noopener">掘金链接</a></p>
<p>组件化思想并不是前端独有的，但却是前端技术的延伸</p>
<p>随着三大框架崛起，前端组件化逐渐成为前端开发的迫切需求，一种主流，一种共识，它不仅提高开发效率，同时也降低了维组件内聚原则护成本<br>开发者们不需要再面对一堆晦涩难懂的代码，转而只需要关注以组件⽅式存在的代码⽚段</p>
<p>这是一场新的挑战！</p>
<h2 id="文章开始之前，明确本文的边界"><a href="#文章开始之前，明确本文的边界" class="headerlink" title="文章开始之前，明确本文的边界"></a>文章开始之前，明确本文的边界</h2><ul>
<li>从前端工程谈到组件化开发</li>
<li>组件的设计原则</li>
<li>组件的职能划分及利弊</li>
<li>组件设计的边界</li>
<li>落实到具体业务中如何做</li>
<li>一些感悟</li>
<li>总结</li>
</ul>
<h1 id="一个面试题引发的思考"><a href="#一个面试题引发的思考" class="headerlink" title="一个面试题引发的思考"></a>一个面试题引发的思考</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">面试官通常会问 写过前端通用组件吗？</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>你可能会自信的表示： sure！</p>
<p>emm..是的吗？</p>
<h1 id="从前端工程谈到组件化开发"><a href="#从前端工程谈到组件化开发" class="headerlink" title="从前端工程谈到组件化开发"></a>从前端工程谈到组件化开发</h1><p>前端工程经历的三个阶段</p>
<h2 id="1-库-框架选型"><a href="#1-库-框架选型" class="headerlink" title="1. 库/框架选型"></a>1. 库/框架选型</h2><p><img src="http://cdn.anruence.com/ku.png" alt="image"><br>确定技术选型，为项目节省许多工程量<br>后来三大框架的横空出世，解放了不少生产力</p>
<h2 id="2-简单构建优化"><a href="#2-简单构建优化" class="headerlink" title="2. 简单构建优化"></a>2. 简单构建优化</h2><p><img src="http://cdn.anruence.com/tools.png" alt="image"></p>
<p>解决完开发效率，还需要兼顾运行性能，<br>故而选择某种构建工具，对代码进行压缩，校验，之后再以页面为单位进行简单的资源合并</p>
<h2 id="3-JS-CSS模块化开发"><a href="#3-JS-CSS模块化开发" class="headerlink" title="3. JS/CSS模块化开发"></a>3. JS/CSS模块化开发</h2><p><img src="http://cdn.anruence.com/jsmokuaihua.png" alt="image"></p>
<p>解决了基本开发效率和运行效率之后，开始考虑维护效率了</p>
<p>分而治之（以分解降低复杂度）是软件工程中的重要思想，是复杂系统开发和维护的基石,<font color="red">模块化就是前端的分治手段</font></p>
<p>因此,模块化强调的是<strong>拆分</strong>，最大的价值就是分治，意味着不管你将来是否要复用这块儿代码，都有将他们拆成一个模块的理由</p>
<blockquote>
<p>将一个大问题，不断的拆解为各个小问题进行分析研究，然后再组合到一起(分而治之原则)</p>
</blockquote>
<h3 id="模块化的方案"><a href="#模块化的方案" class="headerlink" title="模块化的方案"></a>模块化的方案</h3><ul>
<li>JS模块化</li>
</ul>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">无模块化-&gt;函数写法-&gt;对象写法-&gt;自执行函数-&gt;CommonJS/AMD/CMD-&gt;ES6 <span class="keyword">Module</span></span><br></pre></td></tr></table></figure>
<ul>
<li>CSS模块化</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">css模块化是在<span class="keyword">less</span>，sass等预处理器的支持下实现的</span><br></pre></td></tr></table></figure>
<h3 id="做到这些就够了吗？"><a href="#做到这些就够了吗？" class="headerlink" title="做到这些就够了吗？"></a>做到这些就够了吗？</h3><p>当然是不够的</p>
<p>模块化强调的是<strong>拆分</strong>，无论是从业务角度还是从架构、技术角度，模块化首先意味着将代码、数据等内容按照其职责不同分离</p>
<p>单纯的横向拆分业务功能模块有一些问题<br><img src="http://cdn.anruence.com/2.png" alt></p>
<ul>
<li>面向过程的代码 随着业务的发展不利于维护</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">随着业务发展，”过程线“也会越来越长，其他项目成员根据各自需要，在”过程线“ 加插各自逻辑，最终这个页面的逻辑变得难以维护</span><br><span class="line">我们需要摆脱【一泻而下】式的代码编写</span><br></pre></td></tr></table></figure>
<ul>
<li>仅仅有JS/CSS模块化是不够的，UI（页面）的分治也比较迫切</li>
</ul>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">除了<span class="keyword">JS</span>和CSS，界面也需要拆分，如何让模块化思想融入HTML语言</span><br></pre></td></tr></table></figure>
<h2 id="4-组件化开发（本文重点）"><a href="#4-组件化开发（本文重点）" class="headerlink" title="4. 组件化开发（本文重点）"></a><font color="red">4. 组件化开发（本文重点）</font></h2><h3 id="组件化开发的演变"><a href="#组件化开发的演变" class="headerlink" title="组件化开发的演变"></a>组件化开发的演变</h3><p>在大肆宣扬组件化开发概念之前，也经历了寻求组件化最佳实践的阶段</p>
<h4 id="页面结构模块化"><a href="#页面结构模块化" class="headerlink" title="页面结构模块化"></a>页面结构模块化</h4><p><img src="http://cdn.anruence.com/jimu" alt="image"><br>简单来说就是把页面想象成乐高机器人，需要不同零件组装，然后将各个部分拼到一起</p>
<p>落实到实际开发中像这样<br><img src="http://cdn.anruence.com/jiegouhua.png" alt></p>
<p>我们可以发现</p>
<ul>
<li>页面pageModel包含了 <code>tabContainer</code>，<code>listContainer</code> 和 <code>imgsContainer</code> 三个模块</li>
<li>我们根据不同的业务逻辑封装了不同类型的model</li>
<li>每个model有自己的数据，模板，逻辑，已经算是一个完整的功能单元</li>
</ul>
<font color="red">咦？嗅到一丝组件化的味道</font>

<h4 id="N年前微软的组件化的解决方案-HTML-Component"><a href="#N年前微软的组件化的解决方案-HTML-Component" class="headerlink" title="N年前微软的组件化的解决方案 HTML Component"></a>N年前微软的组件化的解决方案 HTML Component</h4><p>历史总有遗🐖</p>
<p>早在N年前微软提出过一套解决方案，名为<code>HTML Component</code></p>
<p><img src="http://cdn.anruence.com/4.jpg" alt="jsworke"></p>
<p>事实上已经是一个比较完整的组件化方案了，但最后却没能进入标准，从今天的角度看，它可以说是生不逢时</p>
<h4 id="WebComponents-标准"><a href="#WebComponents-标准" class="headerlink" title="WebComponents 标准"></a>WebComponents 标准</h4><p>当时”所谓的组件“</p>
<ul>
<li>此时的组件基本上只能达到某个功能单元上的集合，资源都是资源都是松散地分散在三种资源文件中</li>
<li>而且组件作用域暴露在全局作用域下，缺乏内聚性很容易就会跟其他组件产生冲突（如最简单的 css 命名冲突）</li>
</ul>
<p>于是 W3C 按耐不住了，制定一个 WebComponents 标准，为组件化的未来指引了明路</p>
<p>大致四部分功能</p>
<ul>
<li><code>&lt;template&gt;</code> 定义组件的 HTML模板能力</li>
<li>Shadow Dom 封装组件的内部结构，并且保持其独立性</li>
<li>Custom Element 对外提供组件的标签，实现自定义标签</li>
<li>import 解决组件结合和依赖加载</li>
</ul>
<p>我们思考一下，可行的实践化方案需要具备哪些能力</p>
<ul>
<li>资源高内聚（组件资源内部高内聚，组件资源由自身加载控制）</li>
<li>作用域独立（内部结构密封，不与全局或其他组件产生影响）</li>
<li>自定义标签（定义组件的使用方式）</li>
<li>可相互组合（组件间组装整合）</li>
<li>接口规范化（组件接口有统一规范，或者是生命周期的管理）</li>
</ul>
<h4 id="三大框架出现"><a href="#三大框架出现" class="headerlink" title="三大框架出现"></a>三大框架出现</h4><p>今天的前端生态里面 React，Angular和Vue三分天下，即使它们定位不同，但核心的共同点就是提供了组件化的能力，算是目前是比较好的组件化实践</p>
<h5 id="1-Vue-js采用了JSON的方法描述一个组件"><a href="#1-Vue-js采用了JSON的方法描述一个组件" class="headerlink" title="1. Vue.js采用了JSON的方法描述一个组件"></a>1. Vue.js采用了JSON的方法描述一个组件</h5><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> PageContainer <span class="keyword">from</span> <span class="string">'./layout/PageContainer'</span></span><br><span class="line"><span class="keyword">import</span> PageFilter <span class="keyword">from</span> <span class="string">'./layout/PageFilter'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  install(Vue) &#123;</span><br><span class="line">    Vue.component(<span class="string">'PageContainer'</span>, PageContainer)</span><br><span class="line">    Vue.component(<span class="string">'PageFilter'</span>, PageFilter)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还提供了SFC（Single File Component，单文件组件）‘.vue’文件格式</p>
<figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">//...</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">  export default </span><span class="template-variable">&#123;</span></span><br><span class="line"><span class="template-variable">    data()&#123;&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">"scss"</span>&gt;</span></span></span><br><span class="line"><span class="xml">//...</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h5 id="2-React-js发明了JSX，把CSS和HTML都塞进JS文件里"><a href="#2-React-js发明了JSX，把CSS和HTML都塞进JS文件里" class="headerlink" title="2. React.js发明了JSX，把CSS和HTML都塞进JS文件里"></a>2. React.js发明了JSX，把CSS和HTML都塞进JS文件里</h5><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tabs</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.props.items) &#123;</span><br><span class="line">            console.error(<span class="symbol">'Tabs</span>中需要传入数据');</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        const propId = <span class="keyword">this</span>.props.id;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;ul className=&#123;<span class="keyword">this</span>.props.className&#125;&gt;</span><br><span class="line">              &lt;li&gt;测试&lt;/li&gt;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Angular-js选择在原本的HTML上扩展"><a href="#Angular-js选择在原本的HTML上扩展" class="headerlink" title="Angular.js选择在原本的HTML上扩展"></a>Angular.js选择在原本的HTML上扩展</h5><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">"text"</span> ng-model=<span class="string">"firstname"</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = angular.module(<span class="string">'myApp'</span>, []);</span><br><span class="line">app.controller(<span class="string">'formCtrl'</span>, <span class="function"><span class="keyword">function</span><span class="params">($scope)</span> </span>&#123;</span><br><span class="line">    $scope.firstname = <span class="string">"John"</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="标准下的资源整合"><a href="#标准下的资源整合" class="headerlink" title="标准下的资源整合"></a>标准下的资源整合</h3><p><img src="http://cdn.anruence.com/sss.png" alt="image"></p>
<h4 id="具有以下特点"><a href="#具有以下特点" class="headerlink" title="具有以下特点"></a>具有以下特点</h4><ul>
<li>每个组件对应一个目录，组件所需的各种资源都在这个目录下就近维护；（最具软件工程价值）</li>
<li>页面上的每个独立的可视/可交互区域视为一个组件；</li>
<li>由于组件具有独立性，可以自由组合；</li>
<li>页面是组件的容器，负责组合组件形成功能完整的界面；</li>
<li>当不需要某个组件，或者想要替换组件时，可以整个目录删除/替换</li>
</ul>
<h3 id="应用结构图"><a href="#应用结构图" class="headerlink" title="应用结构图"></a>应用结构图</h3><p><img src="http://cdn.anruence.com/niubi.png" alt="image"></p>
<ul>
<li>分子是由原子组成的，分子分成原子，原子也可以重新组合成新的分子</li>
<li>一个界面是由独立的分子组件搭建而成，分子组件由原子元件构成，这些原子可通过不同的组合方式，组成新分子组件，继而重组构成新的界面</li>
</ul>
<h3 id="模块化与组件化对比"><a href="#模块化与组件化对比" class="headerlink" title="模块化与组件化对比"></a>模块化与组件化对比</h3><p>如果你去网上搜【模块和组件的异同】<br>可能会得到截然不同的答案，大部分描述的都是片面的</p>
<p>它们之间的关系可以从以下三个方面分析：</p>
<h4 id="从整体概念来讲"><a href="#从整体概念来讲" class="headerlink" title="从整体概念来讲"></a>从整体概念来讲</h4><ul>
<li>模块化是一种分治的思想，诉求是解耦，一般指的是js模块，比如用来格式化时间的模块</li>
<li>组件化是模块化思想的实现手段，诉求是复用，包含了<code>template</code>，<code>style</code>，<code>script</code>，script又可以由各种模块组成</li>
</ul>
<h4 id="从复用的角度来讲"><a href="#从复用的角度来讲" class="headerlink" title="从复用的角度来讲"></a>从复用的角度来讲</h4><ul>
<li>模块一般是项目范围内按照项目业务内容来划分的，比如一个项目划分为子系统、模块、子模块，<strong>代码分开就是模块</strong></li>
<li>组件是按照一些小功能的通用性和可复用性抽象出来的，可以跨项目，是可复用的模块</li>
</ul>
<h4 id="从历史发展角度来讲"><a href="#从历史发展角度来讲" class="headerlink" title="从历史发展角度来讲"></a>从历史发展角度来讲</h4><p>随着前端开发越来越复杂、对效率要求越来高，由项目级模块化开发，进一步提升到通用功能组件化开发，<strong>模块化是组件化的前提，组件化是模块化的演进</strong></p>
<h1 id="组件的设计原则"><a href="#组件的设计原则" class="headerlink" title="组件的设计原则"></a>组件的设计原则</h1><p>组件化方案下，我们需要具有组件化设计思维，它是一种【整理术】帮助我们高效开发整合</p>
<ol>
<li>标准性</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">任何一个组件都应该遵守一套标准，可以使得不同区域的开发人员据此标准开发出一套标准统一的组件</span><br><span class="line"></span><br><span class="line">API尽量和已知概念保持一致</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>独立性</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">遵循单一职责原则，保持组件的纯粹性</span><br><span class="line">属性配置等API对外开放，组件内部状态对外封闭，尽可能的少与业务耦合</span><br><span class="line"></span><br><span class="line">避免暴露组件内部实现</span><br><span class="line"></span><br><span class="line">入口处检查参数的有效性，出口处检查返回的正确性</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>复用与易用，适用SPOT法则 </li>
</ol>
<figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line">UI差异，消化在组件内部（注意并不是写一堆<span class="keyword">if</span>/<span class="keyword">else</span>）</span><br><span class="line">输入输出友好，易用</span><br><span class="line"></span><br><span class="line"><span class="built_in">Single</span> Point <span class="keyword">Of</span> Truth，就是尽量不要重复代码，出自《The Art <span class="keyword">of</span> Unix Programming》</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>避免直接操作DOM，避免使用ref</li>
</ol>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">使用父组件的 <span class="keyword">state</span> 控制子组件的状态而不是直接通过 ref 操作子组件</span><br></pre></td></tr></table></figure>
<ol start="5">
<li><strong>无环依赖原则(ADP)</strong></li>
</ol>
<p>设计不当导致环形依赖示意图<br><img src="http://cdn.anruence.com/1111111111.png" alt="image"></p>
<p><strong>影响</strong></p>
<ul>
<li>组件间耦合度高，集成测试难</li>
<li>一处修改，处处影响，交付周期长</li>
<li>因为组件之间存在循环依赖，变成了“先有鸡还是先有蛋”的问题</li>
</ul>
<p><strong>那倘若我们真的遇到了这种问题，就要考虑如何处理？</strong></p>
<font color="red">消除环形依赖</font>

<blockquote>
<p>我们的追求是沿着逆向的依赖关系即可寻找到所有受影响的组件</p>
</blockquote>
<p>创建一个共同依赖的新组件</p>
<p><img src="http://cdn.anruence.com/xiaochu.png" alt="image"></p>
<ol start="6">
<li>稳定抽象原则(SAP)</li>
</ol>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>组件的抽象程度与其稳定程度成正比，</span><br><span class="line"><span class="bullet">- </span>一个稳定的组件应该是抽象的（逻辑无关的）</span><br><span class="line"><span class="bullet">- </span>一个不稳定的组件应该是具体的（逻辑相关的）</span><br><span class="line"><span class="bullet">- </span>为降低组件之间的耦合度，我们要针对抽象组件编程，而不是针对业务实现编程</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>避免冗余状态</li>
</ol>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">如果一个数据可以由另一个 <span class="keyword">state</span> 变换得到，那么这个数据就不是一个 <span class="keyword">state</span>，只需要写一个变换的处理函数，在 Vue 中可以使用计算属性</span><br><span class="line"></span><br><span class="line">如果一个数据是固定的，不会变化的常量，那么这个数据就如同 HTML 固定的站点标题一样，写死或作为全局配置属性等，不属于 <span class="keyword">state</span></span><br><span class="line"></span><br><span class="line">如果兄弟组件拥有相同的 <span class="keyword">state</span>，那么这个<span class="keyword">state</span> 应该放到更高的层级，使用 props 传递到两个组件中</span><br></pre></td></tr></table></figure>
<ol start="8">
<li>合理的依赖关系</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">父组件不依赖子组件，删除某个子组件不会造成功能异常</span><br></pre></td></tr></table></figure>
<ol start="9">
<li>扁平化参数</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">除了数据，避免复杂的对象，尽量只接收原始类型的值</span><br></pre></td></tr></table></figure>
<ol start="10">
<li>良好的接口设计<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">把组件内部可以完成的工作做到极致，虽然提倡拥抱变化，但接口不是越多越好</span><br><span class="line"></span><br><span class="line">如果常量变为 <span class="built_in">props</span> 能应对更多的场景，那么就可以作为 <span class="built_in">props</span>，原有的常量可作为默认值。</span><br><span class="line"></span><br><span class="line">如果需要为了某一调用者编写大量特定需求的代码，那么可以考虑通过扩展等方式构建一个新的组件。</span><br><span class="line"></span><br><span class="line">保证组件的属性和事件足够的给大多数的组件使用。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="组件的职能划分"><a href="#组件的职能划分" class="headerlink" title="组件的职能划分"></a>组件的职能划分</h1><p>那有了组件设计的“API”，就一定能开发出高质量的组件吗？</p>
<blockquote>
<p>组件最大的不稳定性来自于展现层，一个组件只做一件事，基于功能做好职责划分</p>
</blockquote>
<p>根据以往经验，我将组件分为以下几类</p>
<ul>
<li>基础组件（通常在组件库里就解决了）</li>
<li>容器型组件（Container）</li>
<li>展示型组件（stateless）</li>
<li>业务组件</li>
<li>通用组件<ul>
<li>UI组件</li>
<li>逻辑组件</li>
</ul>
</li>
<li>高阶组件（HOC）</li>
</ul>
<font color="red">除容器组件外，尽量保证组件都是stateless的，这并不冲突！</font>

<h2 id="基础组件"><a href="#基础组件" class="headerlink" title="基础组件"></a>基础组件</h2><p>为了让开发者更关注业务逻辑，涌现出了很多优秀的UI组件库<br>比如<code>antd</code>，<code>element-ui</code>，我们只需要调用API便能满足大部分的业务场景，前端角色后置了，开发变得更简单了</p>
<h2 id="容器型组件"><a href="#容器型组件" class="headerlink" title="容器型组件"></a>容器型组件</h2><p>一个容器性质的组件，一般当作一个业务子模块的入口，比如一个路由指向的组件</p>
<p><img src="http://cdn.anruence.com/RONGQIZUJIAN.png" alt="image"></p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>容器组件内的子组件通常具有业务或数据依赖关系</li>
<li>集中/统一的状态管理，向其他展示型/容器型组件提供数据（充当数据源）和行为逻辑处理（接收回调）</li>
<li>如果使用了全局状态管理，那么容器内部的业务组件可以自行调用全局状态处理业务</li>
<li>业务模块内子组件的通信等统筹处理，充当子级组件通信的状态中转站</li>
<li>模版基本都是子级组件的集合，很少包含<code>DOM</code>标签</li>
<li>辅助代码分离</li>
</ul>
<h3 id="表现形式🌰（vue）"><a href="#表现形式🌰（vue）" class="headerlink" title="表现形式🌰（vue）"></a>表现形式🌰（vue）</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"purchase-box"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 面包屑导航 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bread-crumbs</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"scroll-content"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 搜索区域 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Search</span> <span class="attr">v-show</span>=<span class="string">"toggleFilter"</span> <span class="attr">:form</span>=<span class="string">"form"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--展开收起区域--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Toggle</span> <span class="attr">:toggleFilter</span>=<span class="string">"toggleFilter"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 列表区域--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">List</span> <span class="attr">:data</span>=<span class="string">"listData"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="展示型（stateless）组件"><a href="#展示型（stateless）组件" class="headerlink" title="展示型（stateless）组件"></a>展示型（stateless）组件</h2><p>主要表现为组件是怎样渲染的，就像一个简单的模版渲染过程</p>
<p><img src="http://cdn.anruence.com/zhanshixing.png" alt="image"></p>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul>
<li>只通过props接受数据和回调函数，不充当数据源</li>
<li>可能包含展示和容器组件 并且一般会有Dom标签和css样式</li>
<li>通常用props.children(react) 或者slot(vue)来包含其他组件</li>
<li>对第三方没有依赖（对于一个应用级的组件来说可以有）</li>
<li>可以有状态，在其生命周期内可以操纵并改变其内部状态，职责单一，将不属于自己的行为通过回调传递出去，让父级去处理（搜索组件的搜索事件/表单的添加事件）</li>
</ul>
<h3 id="表现形式🌰（vue）-1"><a href="#表现形式🌰（vue）-1" class="headerlink" title="表现形式🌰（vue）"></a>表现形式🌰（vue）</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"purchase-box"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table</span></span></span><br><span class="line"><span class="tag">      <span class="attr">:data</span>=<span class="string">"data"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">:class</span>=<span class="string">"&#123;'is-empty': !data ||  data.length ==0 &#125;"</span></span></span><br><span class="line"><span class="tag">      &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">el-table-column</span></span></span><br><span class="line"><span class="tag">        <span class="attr">v-for</span> = <span class="string">"(item, index) in listItemConfig"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">:key</span>=<span class="string">"item + index"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">:prop</span>=<span class="string">"item.prop"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">:label</span>=<span class="string">"item.label"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">:width</span>=<span class="string">"item.width ? item.width : ''"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">:min-width</span>=<span class="string">"item.minWidth ? item.minWidth : ''"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">:max-width</span>=<span class="string">"item.maxWidth ? item.maxWidth : ''"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 操作 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">label</span>=<span class="string">"操作"</span> <span class="attr">align</span>=<span class="string">"right"</span> <span class="attr">width</span>=<span class="string">"60"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">"scope"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">slot</span> <span class="attr">:data</span>=<span class="string">"scope.row"</span> <span class="attr">name</span>=<span class="string">"listOption"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 列表为空 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">"empty"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">common-empty</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-table</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    props: &#123;</span><br><span class="line"><span class="actionscript">        listItemConfig:&#123; <span class="comment">//列表项配置</span></span></span><br><span class="line"><span class="javascript">        type:<span class="built_in">Array</span>,</span></span><br><span class="line"><span class="javascript">        <span class="keyword">default</span>: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span> [&#123;</span></span><br><span class="line"><span class="actionscript">                prop:<span class="string">'sku_name'</span>,</span></span><br><span class="line"><span class="actionscript">                label:<span class="string">'商品名称'</span>,</span></span><br><span class="line">                minWidth:200</span><br><span class="line">            &#125;,&#123;</span><br><span class="line"><span class="actionscript">                prop:<span class="string">'sku_code'</span>,</span></span><br><span class="line"><span class="actionscript">                label:<span class="string">'SKU'</span>,</span></span><br><span class="line">                minWidth:120</span><br><span class="line">            &#125;,&#123;</span><br><span class="line"><span class="actionscript">                prop:<span class="string">'product_barcode'</span>,</span></span><br><span class="line"><span class="actionscript">                label:<span class="string">'条形码'</span>,</span></span><br><span class="line">                minWidth:120</span><br><span class="line">            &#125;]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="业务组件"><a href="#业务组件" class="headerlink" title="业务组件"></a>业务组件</h2><p>通常是根据最小业务状态抽象而出，有些业务组件也具有一定的复用性，但大多数是一次性组件</p>
<p><img src="http://cdn.anruence.com/yewu.png" alt="image"></p>
<h2 id="通用组件"><a href="#通用组件" class="headerlink" title="通用组件"></a>通用组件</h2><p>可以在一个或多个APP内通用的组件</p>
<h3 id="UI组件"><a href="#UI组件" class="headerlink" title="UI组件"></a>UI组件</h3><ul>
<li>界面扩展类组件，比如弹窗</li>
</ul>
<p><img src="http://cdn.anruence.com/UI.png" alt="image"></p>
<p>特点：复用性强，只通过 props、events 和 slots 等组件接口与外部通信</p>
<h4 id="表现形式🌰（vue）-2"><a href="#表现形式🌰（vue）-2" class="headerlink" title="表现形式🌰（vue）"></a>表现形式🌰（vue）</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"empty"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/images/empty.png"</span> <span class="attr">alt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>暂无数据<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="逻辑组件"><a href="#逻辑组件" class="headerlink" title="逻辑组件"></a>逻辑组件</h3><ul>
<li>不包含UI层的某个功能的逻辑集合</li>
</ul>
<h2 id="高阶组件（HOC）"><a href="#高阶组件（HOC）" class="headerlink" title="高阶组件（HOC）"></a>高阶组件（HOC）</h2><p>高阶组件可以看做是函数式编程中的组合<br>可以把高阶组件看做是一个函数，他接收一个组件作为参数，并返回一个功能增强的组件</p>
<p>高阶组件可以抽象组件公共功能的方法而不污染你本身的组件<br>比如 <code>debounce</code> 与 <code>throttle</code></p>
<p>用一张图来表示</p>
<p><img src="http://cdn.anruence.com/hoc.png" alt="jsworke"></p>
<p>React中高阶组件是比较常用的组件封装形式，Vue官方内置了一个高阶组件<a href="https://github.com/vuejs/vue/blob/dev/src/core/components/keep-alive.js" target="_blank" rel="noopener">keep-alive</a>，但并未推荐使用HOC :(</p>
<p><strong>猜想原因</strong></p>
<ul>
<li>React：写组件就是在写函数，函数拥有的功能组件都有</li>
<li>Vue：更像是高度封装的函数，能够让你轻松的完成一些事情的同时损失一定的灵活性，你需要按照一定规则才能使系统更好的运行</li>
</ul>
<h3 id="表现形式🌰（react）"><a href="#表现形式🌰（react）" class="headerlink" title="表现形式🌰（react）"></a>表现形式🌰（react）</h3><p>品牌车系滑动的动画</p>
<p><img src="http://cdn.anruence.com/reacthoc.png" alt></p>
<h2 id="各类组件协同组成业务模块"><a href="#各类组件协同组成业务模块" class="headerlink" title="各类组件协同组成业务模块"></a>各类组件协同组成业务模块</h2><p><img src="http://cdn.anruence.com/MOKUAITU.png" alt="image"></p>
<h2 id="容器-展示组件"><a href="#容器-展示组件" class="headerlink" title="容器/展示组件"></a>容器/展示组件</h2><p>对比图</p>
<p><img src="http://cdn.anruence.com/rongqitu.png" alt="image"></p>
<h3 id="引入容器组件的概念只是一种更好的组织方式"><a href="#引入容器组件的概念只是一种更好的组织方式" class="headerlink" title="引入容器组件的概念只是一种更好的组织方式"></a>引入容器组件的概念只是一种更好的组织方式</h3><ul>
<li>各司其职，不易出错，即使出错，也能快速定位问题</li>
<li>容器组件，一个载体的存在</li>
<li>展示型组件不与store耦合，通过props接口来定义所需的数据和方法，<strong>复用性与正确性更能保证</strong></li>
</ul>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">展示型组件直接和<span class="keyword">store</span>通信的话，那么它就会收到限制，因为你在<span class="keyword">store</span>里面的字段已经限制他的使用次数和使用的位置</span><br></pre></td></tr></table></figure>
<font color="red">既然如此，那我什么时候引入容器组件，什么时候引入展示组件</font>

<h3 id="引入容器组件的时机"><a href="#引入容器组件的时机" class="headerlink" title="引入容器组件的时机"></a>引入容器组件的时机</h3><p>优先考虑展示组件，当你意识到有一些中间组件不使用它继承的props而是转而传递给他们的子级，每次子级组件需要更多数据时，都需要“路过”这些中间组件时就要考虑引入容器组件！</p>
<p>两者的区别并没有被严格定义，<font color="red">事实上不在技术上而是目的性上</font></p>
<h4 id="这里有几个供参考的点"><a href="#这里有几个供参考的点" class="headerlink" title="这里有几个供参考的点"></a>这里有几个供参考的点</h4><ul>
<li>容器组件倾向于有状态，展示组件倾向于无状态，这不是硬性规定，它们都是可以有状态的</li>
<li>不要把分离容器组件和展示组件当做教条，如果你不确定该组件是容器组件还是展示组件，就暂时不要分离，写成展示组件，也许是为时尚早，别着急！</li>
<li>这是一个持续的重构过程，不用试图一次就把它做好，习惯这种模式就会培养起一种直觉，知道何时引入容器 就像你知道何时封装一个函数那样！</li>
</ul>
<h2 id="进行组件职能划分的利弊"><a href="#进行组件职能划分的利弊" class="headerlink" title="进行组件职能划分的利弊"></a>进行组件职能划分的利弊</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>更好的关注分离</li>
</ul>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">用这种方式写组件，你可以更好的理解你的<span class="keyword">app</span>和你的ui，甚至会逐渐形成你自己的开发套路</span><br></pre></td></tr></table></figure>
<ul>
<li>复用性高</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一个组件只做一件事，解除了组件的耦合带来更高复用性</span><br></pre></td></tr></table></figure>
<ul>
<li>它是app的调色版，设计师可以随意调整它的ui而不用改变app的逻辑</li>
<li>这会强制你提取“布局组件”，达到更高的易用性</li>
<li>提高健壮性</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">由于展示组件和容器组件是通过prop接口来连接，可以利用props的校验机制来增强代码的可靠性，混合的组件就没有这种好处</span></span><br><span class="line"></span><br><span class="line"><span class="string">举个🌰(Vue)</span></span><br><span class="line"><span class="attr">  props:</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">    editData:</span> <span class="string">Object,</span></span><br><span class="line"><span class="attr">    statusConfig:</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">      type:</span> <span class="string">Object,</span></span><br><span class="line">      <span class="string">default()</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="string">return</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">          isShowOption:</span> <span class="literal">true</span><span class="string">,</span> <span class="string">//是否有操作栏</span></span><br><span class="line"><span class="attr">          isShowSaveBtn:</span> <span class="literal">false</span></span><br><span class="line">        <span class="string">&#125;;</span></span><br><span class="line">      <span class="string">&#125;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">  <span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>可测试性</li>
</ul>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">组件做的事情更少了，测试也会变得容易</span><br><span class="line">容器组件不用关心UI的展示，只关心数据和更新</span><br><span class="line">展示组件只是呈现传入的<span class="built_in">props</span>，写单元测试的时候也非常容易mock数据层</span><br></pre></td></tr></table></figure>
<h3 id="所谓的缺点"><a href="#所谓的缺点" class="headerlink" title="所谓的缺点"></a>所谓的缺点</h3><ul>
<li>设计组件初期会增加一些学习成本</li>
<li>由于需要封装一个容器，包装一些数据和接口给展示组件，<strong>会增加一些工作量</strong></li>
<li>在展示组件内对props的声明会带来少量的工作</li>
</ul>
<font color="red">长远来看，利大于弊，特别是项目初期，一定要有一个好的设计习惯</font>

<h1 id="组件设计的边界"><a href="#组件设计的边界" class="headerlink" title="组件设计的边界"></a>组件设计的边界</h1><p>物极必反，跃跃欲试前，常常思考以下几个问题以引导完善组件的设计</p>
<h2 id="页面层级不宜嵌套超过三层，切勿过度设计"><a href="#页面层级不宜嵌套超过三层，切勿过度设计" class="headerlink" title="页面层级不宜嵌套超过三层，切勿过度设计"></a>页面层级不宜嵌套超过三层，切勿过度设计</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">原则上组件嵌套超过三层，数据传递的过程就会变得相对复杂</span><br></pre></td></tr></table></figure>
<h2 id="这个组件可否（有必要）再分？"><a href="#这个组件可否（有必要）再分？" class="headerlink" title="这个组件可否（有必要）再分？"></a>这个组件可否（有必要）再分？</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">划分粒度的根据实际情况权衡，太小会提升维护成本，太大又不够灵活和高复用性</span><br><span class="line"></span><br><span class="line">是否打破了一个逻辑上有意义的实体，倘若抽离的话，这个代码被复用的概率有多大？</span><br><span class="line"></span><br><span class="line">如果它只是几行代码，那么最终可能会创建更多的代码来分离它，有必要吗？我这么做的好处是否超过了成本？</span><br><span class="line"></span><br><span class="line">如果你当前的逻辑不太可能出现在其他地方，那么将它嵌入其中更好，如果需要，你可以随时抽离，毕竟组件化没有终点</span><br><span class="line"></span><br><span class="line">每一个组件都应该有其独特的划分目的的，有的是为了复用实现，有的是为了封装复杂度清晰业务实现</span><br><span class="line">组件划分的依据通常是业务逻辑、功能，要考虑各组件之间的关系是否明确，及可复用度</span><br></pre></td></tr></table></figure>
<h2 id="性能会受到影响吗？"><a href="#性能会受到影响吗？" class="headerlink" title="性能会受到影响吗？"></a>性能会受到影响吗？</h2><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">如果状态频繁更改，并且当前在一个较大且关系比较紧密的组件里，为了避免性能受到影响最好抽离出来 与<span class="built_in">diff</span>策略相关</span><br></pre></td></tr></table></figure>
<h2 id="这个组件的依赖是否可再缩减？"><a href="#这个组件的依赖是否可再缩减？" class="headerlink" title="这个组件的依赖是否可再缩减？"></a>这个组件的依赖是否可再缩减？</h2><p>缩减组件依赖可以提高组件的可复用度</p>
<h2 id="这个组件是否对其它组件造成侵入？"><a href="#这个组件是否对其它组件造成侵入？" class="headerlink" title="这个组件是否对其它组件造成侵入？"></a>这个组件是否对其它组件造成侵入？</h2><ul>
<li>封装性不足或自身越界操作，就可能对自身之外造成了侵入</li>
<li>一个组件不应对其它兄弟组件造成直接影响</li>
</ul>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">常见的一种情况是：组件运行时对<span class="built_in">window</span>对象添加resize监听事件以实现组件响应视窗尺寸变化事件</span><br><span class="line"></span><br><span class="line">最优的方案：组件提供刷新方法，由父组件实现调用</span><br><span class="line">次优的方案：组件destroy前清理恢复</span><br></pre></td></tr></table></figure>
<h2 id="接口设计是否兼容大部分场景？"><a href="#接口设计是否兼容大部分场景？" class="headerlink" title="接口设计是否兼容大部分场景？"></a>接口设计是否兼容大部分场景？</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">需要考虑需要适用的不同场景，在组件接口设计时进行必要的兼容</span><br></pre></td></tr></table></figure>
<h2 id="当别人使用这个组件时，会怎么想？"><a href="#当别人使用这个组件时，会怎么想？" class="headerlink" title="当别人使用这个组件时，会怎么想？"></a>当别人使用这个组件时，会怎么想？</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">接口设计符合规范和大众习惯，尽量让别人用起来简单易上手，易上手是指更符合直觉</span><br></pre></td></tr></table></figure>
<h2 id="假如业务需要不需要这个功能，是否方便清除？"><a href="#假如业务需要不需要这个功能，是否方便清除？" class="headerlink" title="假如业务需要不需要这个功能，是否方便清除？"></a>假如业务需要不需要这个功能，是否方便清除？</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">各组件之前以组合的关系互相配合，也是对功能需求的模块化抽象，当需求变化时可以将实现以模块粒度进行调整</span><br></pre></td></tr></table></figure>
<p>上文提到的各种准则仅仅描述了一种开发理念，也可以认为是一种开发规范，倘若你认可这规范，对它的分治策略产生了共鸣，那我们就可以继续聊聊它的具体实现了</p>
<p>问自己一个问题</p>
<font color="red">你心中的相对完美的组件是什么样子的？</font>


<h1 id="落实到具体业务中如何做"><a href="#落实到具体业务中如何做" class="headerlink" title="落实到具体业务中如何做"></a>落实到具体业务中如何做</h1><h2 id="划分依据"><a href="#划分依据" class="headerlink" title="划分依据"></a>划分依据</h2><p>明确你的组件划分依据，目前是两种</p>
<ul>
<li>根据业务划分</li>
<li>根据技术划分</li>
</ul>
<ol>
<li>我更多的是根据业务去设计我应用中的组件树，可能会画个草图或xmind，它可以帮我统观全局</li>
<li>明确各个组件的边界，内部state的设计，props的设计以及与其他组件的关系（需要回调出去的事件）</li>
<li>明确各个组件的定位与职能划分，设计好父子组件、兄弟组件的通信机制</li>
<li>搭架子</li>
<li>架子有了，开始填空</li>
</ol>
<h2 id="切割模版（页面结构模块化）"><a href="#切割模版（页面结构模块化）" class="headerlink" title="切割模版（页面结构模块化）"></a>切割模版（页面结构模块化）</h2><p>这是最容易想到的方法，当一个组件渲染了很多元素，就需要尝试分离这些组件的渲染逻辑<br>我们以掘金页面为例</p>
<p><img src="http://cdn.anruence.com/5.png" alt="jsworke"></p>
<p>大体上看，可以分为Part1，Part2，Part3</p>
<h3 id="初步开发"><a href="#初步开发" class="headerlink" title="初步开发"></a>初步开发</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"panel"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"part1 left"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--内容--&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"part1 right"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--内容--&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"part1 right"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--内容--&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>问题：</p>
<ul>
<li>代码量大，难以维护，难以测试</li>
<li>有些许重复量</li>
</ul>
<h3 id="化繁为简"><a href="#化繁为简" class="headerlink" title="化繁为简"></a>化繁为简</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">part1</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">part2</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">part3</span> /&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>好处：</p>
<ul>
<li>同之前的方式相比，这个微妙的改进是革命性的</li>
<li>解决了测试困难，维护困难的问题</li>
</ul>
<p>问题：</p>
<ul>
<li>没有解决代码重复的问题，这种按模块划分，复用性低</li>
</ul>
<p>但我看过很多项目的代码，就是这么干的，认为自己做了组件化，抽象的还不错(@_@)</p>
<h3 id="组件抽象"><a href="#组件抽象" class="headerlink" title="组件抽象"></a>组件抽象</h3><p>它们有相似的外层，part2和part3更有相似的titlebar，除了业务内容，完全就是一模一样</p>
<p>🌰（vue）</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"part"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">header</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><span class="template-variable">&#123;&#123; title &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"content"</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>我们将part内可以抽象的数据都做成了props，利用slot去做模版<br>那么我们在开发相应Part1，Part2时</p>
<p>🌰（vue）<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">part</span> <span class="attr">title</span>=<span class="string">"亦舒"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">slot</span>=<span class="string">"content"</span>&gt;</span>----<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">part</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">part</span> <span class="attr">title</span>=<span class="string">"兴隆臻园户型"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">slot</span>=<span class="string">"content"</span>&gt;</span>-----<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">part</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>更具代表性的示例图</p>
<p><img src="http://cdn.anruence.com/6.png" alt="jsworke"></p>
<ul>
<li>UI差异在哪里定义？</li>
</ul>
<p>在业务逻辑层处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">首先要明确一点，这些差异并不是组件本身造成的，是你自己的业务逻辑造成的，所以容器组件（父组件）应该为此买单</span><br></pre></td></tr></table></figure>
<ul>
<li>数据差异在哪里定义？</li>
</ul>
<p>结合组件本身和业务上下文将差异合理的消除在内部</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">比如part3中，其他的part只有一个类似更多&gt;&gt;的<span class="keyword">link</span>，但是它却有多个(一居，二居<span class="params">...</span>)</span><br><span class="line">这里我推荐将这种差异体现在组件内部，设计方法也很多：</span><br><span class="line">比如可以将<span class="keyword">link</span>数组化为links；</span><br><span class="line">比如可以将更多&gt;&gt;看作是一个default的<span class="keyword">link</span>，而多余的部分则是用户自定义的特殊<span class="keyword">link</span>，这两者合并组成了links。用户自定义的默认是没有的，需要引用组件时进行传入。</span><br></pre></td></tr></table></figure>
<ul>
<li>组件命名规则？</li>
</ul>
<p>组件设计初期，就应该拥有不耦合业务的名字</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">一个通用的或者说未来可能通用的，要有相对合理的命名，比如 <span class="keyword">Search</span>，<span class="keyword">List</span>,尽量不要出现与业务耦合过深的业务名词，通用组件与业务无关，只与自身抽象的组件有关</span><br><span class="line">我们在设计组件初期，就应该有这种思想，等到真正可以抽出公用组件了，再去苦逼的名改名字？</span><br><span class="line">库通常都想让广大开发者用，我们在设计组件时，可以降低标准到先做到你的整个<span class="keyword">APP</span>中通用</span><br></pre></td></tr></table></figure>
<h2 id="组件划分细粒度的考量（抽之有度）"><a href="#组件划分细粒度的考量（抽之有度）" class="headerlink" title="组件划分细粒度的考量（抽之有度）"></a>组件划分细粒度的考量（抽之有度）</h2><p>组件设计规则明明白白写着我们要遵循单一职责原则，这也带来了上文聊过的<font color="red">过度抽象（组件化）</font>的问题，我们结合具体的业务聊一下</p>
<p><img src="http://cdn.anruence.com/7.png" alt="jsworke"></p>
<p>要实现徽章组件，它有两部分组成</p>
<ul>
<li>按钮</li>
<li>右上角提示（小红点/icon）</li>
</ul>
<p>两者都是符合单一职责的，可以将其抽离成一个独立组件，但是通常不要这么做</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">因为同一个<span class="keyword">app</span>的风格必将是统一的，除此之外没别的应用场景了，就像上文所说的，抽离组件之前，多问自己为什么以及投入/产出比，没有绝对的规则</span><br></pre></td></tr></table></figure>
<h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><font color="red">单一职责组件要建立在可复用的基础上，对于不可复用的单⼀职责组件我们仅仅作为独立组件的内部组件即可</font>

<h3 id="某二手车网站体现其细粒度的例子"><a href="#某二手车网站体现其细粒度的例子" class="headerlink" title="某二手车网站体现其细粒度的例子"></a>某二手车网站体现其细粒度的例子</h3><p><img src="http://cdn.anruence.com/1.gif" alt="jsworke"></p>
<p>思考，如果让你实现你会如何设计…<br>我当初是这么设计的</p>
<p><img src="http://cdn.anruence.com/8.png" alt="jsworke"></p>
<p>index.js(react)</p>
<figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"select-brand-box"</span> <span class="attr">onTouchStart</span>=</span></span><span class="template-variable">&#123;touchStartHandler&#125;</span><span class="xml"><span class="tag"> <span class="attr">onTouchMove</span>=</span></span><span class="template-variable">&#123;touchMoveHandler&#125;</span><span class="xml"><span class="tag"> <span class="attr">onTouchEnd</span>=</span></span><span class="template-variable">&#123;touchEndHandler.bind(this, touchEndCallback)&#125;</span><span class="xml"><span class="tag">&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;<span class="name">NavBar</span>&gt;</span><span class="tag">&lt;/<span class="name">NavBar</span>&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;<span class="name">Brand</span> <span class="attr">key</span>=<span class="string">"brands-list"</span> </span></span><span class="template-variable">&#123;...brandsProps&#125;</span><span class="xml"><span class="tag"> /&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;<span class="name">Series</span> <span class="attr">key</span>=<span class="string">"series-list"</span> </span></span><span class="template-variable">&#123;...seriesProps&#125;</span><span class="xml"><span class="tag"> &gt;</span></span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"> export default BrandHoc(index);</span></span><br></pre></td></tr></table></figure>
<p>Brand.js(react)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"brand-box"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"brand-wrap"</span> <span class="attr">ref</span>=<span class="string">"brandWrap"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">"brands-title hot-brands-title"</span>&gt;</span>热门品牌<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">FlexLayout</span> <span class="attr">onClick</span>=<span class="string">&#123;hotBrandClick&#125;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">HotBrands</span> <span class="attr">HotBrands</span>=<span class="string">&#123;hotBrands&#125;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">FlexLayout</span>&gt;</span></span><br><span class="line">        &#123;!isHideStar &amp;&amp; <span class="tag">&lt;<span class="name">UnlimitType</span> &#123;<span class="attr">...unlimitProps</span>&#125; /&gt;</span>&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">AllBrands</span> &#123;<span class="attr">...brandsProps</span>&#125; /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">AsideLetter</span> &#123;<span class="attr">...asideProps</span>&#125; /&gt;</span></span><br><span class="line">    &#123;showPop ? <span class="tag">&lt;<span class="name">PopTips</span> <span class="attr">key</span>=<span class="string">"pop-tips"</span> <span class="attr">tip</span>=<span class="string">&#123;currentLetter&#125;</span> /&gt;</span> : null&#125;</span><br><span class="line">    &#123;showBrandLoading ? <span class="tag">&lt;<span class="name">Loading</span> /&gt;</span> : null&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>FlexLayout.js(react)</p>
<p><img src="http://cdn.anruence.com/9.png" alt="jsworke"></p>
<p>这个示例几乎涵盖了所有的规则</p>
<ul>
<li>首先组件的设计是根据业务划分的，所以右侧字母导航（AsideLetter）才没有在最外层的容器组件，否则通信问题会占用一部分篇幅，事实上这是有解的</li>
<li>入口组件是容器组件，事实上把它当做一个规则就行了，业务逻辑的载体</li>
<li>除了容器组件外，其他的组件都被抽成公用的了，二手车平台类似的场景非常多</li>
</ul>
<p><img src="http://cdn.anruence.com/10.png" alt="jsworke"></p>
<ul>
<li>卖车平台类似的图文混排多且形态各不相同，应用场景广泛，抽！UI差异消化在组件内部，参考FlexLayout.js，给定default props</li>
<li>可提取的组件过多（业务驱动）导致通讯困难如何解决？ 那说明你需要新增可管理状态的容器组件，上例中Brand，Series也是容器组件，负责管理子组件的大小事宜</li>
<li>细粒度的考量，考虑付出产出比</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">"brands-title hot-brands-title"</span>&gt;</span>热门品牌<span class="tag">&lt;/<span class="name">p</span>&gt;</span> 只有一行，直接写就完了</span><br></pre></td></tr></table></figure>
<ul>
<li>组件抽离的过程就是无限向无状态（展示型）组件无限靠近的过程</li>
</ul>
<h2 id="通用性考量"><a href="#通用性考量" class="headerlink" title="通用性考量"></a>通用性考量</h2><p>组件的形态(UI)永远是千变万化的,但是其行为(逻辑)是固定的,因此通用组件的秘诀之⼀就是<font color="red">将DOM 结构的控制权交给开发者,组件只负责⾏为和最基本的DOM结构</font></p>
<p>这是一个显眼的栗子</p>
<p>某一天，你接到这样儿的需求</p>
<p><img src="http://cdn.anruence.com/12.png" alt="jsworke"></p>
<p>开心，简单，三下五除二写完了</p>
<p>突然有一天又有这样儿的需求</p>
<p><img src="http://cdn.anruence.com/13.png" alt="jsworke"></p>
<p>emm..可定制？之前的select没法用了，怎么做？要修改上一个或者再写一个吗？<br>一旦出现了这种情况，证明之前的组件需要重新设计了</p>
<p>实现通用性设计的关键一点是<font color="red">放弃对Dom的掌控</font></p>
<h3 id="那么问题又来了，那么多需要自定义的地方，那组件会不会很难用？"><a href="#那么问题又来了，那么多需要自定义的地方，那组件会不会很难用？" class="headerlink" title="那么问题又来了，那么多需要自定义的地方，那组件会不会很难用？"></a>那么问题又来了，那么多需要自定义的地方，那组件会不会很难用？</h3><p>通用性设计在将Dom结构决定权交给开发者的同时指定默认值</p>
<p>这里是一个新鲜出炉(vue)🌰</p>
<p>List组件</p>
<p><img src="http://cdn.anruence.com/14.png" alt="jsworke"></p>
<p>父组件🌰(vue)及slot</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">模版（伪代码）</span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;List :data=<span class="string">"tableData[item.type]"</span> :loading=<span class="string">"loading"</span> @loadMore=<span class="string">"loadMore"</span> :noMore=<span class="string">"noMore"</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">a</span> v-<span class="keyword">if</span>=<span class="string">"item.type == 0"</span> slot=<span class="string">"listOption"</span> slot-scope=<span class="string">"childScope"</span> class=<span class="string">"edit-btn"</span> @click=<span class="string">"edit(childScope.data)"</span> v-bind:key=<span class="string">"childScope.data.id"</span>&gt;&#123;&#123;Status[childScope<span class="selector-class">.data</span><span class="selector-class">.status</span>][<span class="string">'text'</span>]&#125;&#125;&lt;/a&gt;</span><br><span class="line">&lt;/List&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">config</span><span class="params">(伪代码)</span></span></span><br><span class="line">export const Status = &#123;</span><br><span class="line">  <span class="comment">//....</span></span><br><span class="line">  <span class="number">1</span>: &#123;</span><br><span class="line">    <span class="selector-tag">label</span>: <span class="string">'草稿'</span>,</span><br><span class="line">    type: <span class="string">''</span>,</span><br><span class="line">    text: <span class="string">'编辑'</span>,</span><br><span class="line">    class: <span class="string">'note'</span></span><br><span class="line">  &#125;&#125;</span><br><span class="line">  <span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p>又有一个栗子(vue)</p>
<p><img src="http://cdn.anruence.com/15.png" alt="jsworke"></p>
<ul>
<li>Dialog只负责基础的逻辑，交出控制权给到业务，至于你的业务需要什么，在容器组件（业务逻辑层）去处理</li>
</ul>
<p>忍不住放上磐石业务的反面例子</p>
<p><img src="http://cdn.anruence.com/16.png" alt="jsworke"></p>
<p>难用无非是两方面的问题</p>
<ol>
<li>不肯移交控制权</li>
<li>没有API文档</li>
</ol>
<p>所有的业务逻辑与场景都包含在组件内部，外界只通过变量来控制，初衷是好的，但是随着业务发展，组件越来越庞大，开发者也越来越力不从心了</p>
<p>刚好现阶段UI改版，我们的工作量就由只改样式直接转化为推倒重来了，又没有详细的文档，工作量瞬间翻了N倍😭宝宝心里苦宝宝不说</p>
<h2 id="善用设计模式"><a href="#善用设计模式" class="headerlink" title="善用设计模式"></a>善用设计模式</h2><p>其实一开始，我并没有专门去套用设计模式，完全是业务驱使<br>你一定见到过这样儿的</p>
<p><img src="http://cdn.anruence.com/17.png" alt="jsworke"></p>
<p>一旦这样儿的逻辑多了，那是不是就跟业务耦合了，跟业务耦合多了，那组件自然没有什么通用性了，即使我们不考虑到通用性，那写的累吧？</p>
<p>考虑下这样写会不会好一点</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">config（伪代码）</span><br><span class="line">export const Status = &#123;</span><br><span class="line">  <span class="number">4</span>: &#123;</span><br><span class="line">    <span class="selector-tag">label</span>: <span class="string">'部分入库'</span>,</span><br><span class="line">    type: <span class="string">''</span>,</span><br><span class="line">    text: <span class="string">'查看'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">模版(vue)</span><br><span class="line">&lt;<span class="selector-tag">a</span> v-<span class="keyword">if</span>=<span class="string">"item.type == 0"</span> slot=<span class="string">"listOption"</span> slot-scope=<span class="string">"childScope"</span> class=<span class="string">"edit-btn"</span> @click=<span class="string">"edit(childScope.data)"</span> v-bind:key=<span class="string">"childScope.data.id"</span>&gt;&#123;&#123;Status[childScope<span class="selector-class">.data</span><span class="selector-class">.status</span>][<span class="string">'text'</span>]&#125;&#125;&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p>世界上本没有设计模式，写的人多了，就自成一套脱颖而出进而被历史铭记了！不仅如此,一部分看似复杂的业务如果合理设计配置项，可以会为你省去一大篇js</p>
<h1 id="一些感悟"><a href="#一些感悟" class="headerlink" title="一些感悟"></a>一些感悟</h1><p>像磐石这种底层的业务支持系统，离不开大量的列表，查询，编辑，详情等，我一般会花30秒搭好架子，像但不限于下面这种</p>
<p><img src="http://cdn.anruence.com/18.png" alt="jsworke"></p>
<ul>
<li>index:模块入口（承担容器职责）</li>
<li>api：整块业务的API</li>
<li>components 业务组件集合</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1. </span>Form：表单 一般会被add.vue（编辑） 和edit.vue（详情）引用</span><br><span class="line"><span class="bullet">2. </span>List：列表</span><br><span class="line"><span class="bullet">3. </span>Search: 搜索组件</span><br><span class="line"><span class="bullet">4. </span>其他业务中有但却没看到的基本上都已经抽离到common了 比如面包屑导航，收起展开功能等</span><br></pre></td></tr></table></figure>
<ul>
<li>libs 页面的各种配置</li>
</ul>
<h2 id="具体体现（磐石刚刚重构的模块）"><a href="#具体体现（磐石刚刚重构的模块）" class="headerlink" title="具体体现（磐石刚刚重构的模块）"></a>具体体现（磐石刚刚重构的模块）</h2><p>采购模块结构图</p>
<p><img src="http://cdn.anruence.com/2222323232323.png" alt="image"></p>
<p>Form</p>
<p><img src="http://cdn.anruence.com/edit.png" alt="image"></p>
<p>Edit</p>
<p><img src="http://cdn.anruence.com/form.png" alt="image"></p>
<p>无论有多少种状态，只在edit这层容器维护</p>
<h2 id="要这么做的原因"><a href="#要这么做的原因" class="headerlink" title="要这么做的原因"></a>要这么做的原因</h2><ul>
<li>components中的组件只是暂存，都有可能被升级成通用组件，所以命名要注意，一类的保持了统一，防止业务耦合</li>
<li>bug有迹可循，数据的问题我一定从外向里排查，样式问题从里向外排查，定位问题快</li>
<li>与重复代码做斗争，时刻保持一种强迫症的心态去整理各个模块，形成自己的编码风格，进而团队风格才有可能统一</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>对于组件设计，充分的准备固然，但在现实世界中，切实的结果才是最重要的，组件设计也不要过度设计更不要停滞不前，该做的时候就去做，发现不好就去改</li>
<li>有空闲时间就去思考早期不够理想的代码，它可以作为我们向前发展的基础</li>
<li>技术在变迁，但组件化的核心并没有改变，目标仍然是在API设计尽可能接近原生的情况下完成复用、解耦、封装、抽象的目标，最终服务于开发，提高效率降低错误率</li>
</ul>
<ul>
<li>组件化是对实现的分层，是更有效地代码组合方式</li>
<li>组件化是对资源的重组和优化，从而使项目资源管理更合理，方便拔插、方便集成、方便删除、方便删除后重新加入</li>
<li>这种化繁为简的思想在后端开发中的体现是微服务，而在前端开发中的体现就是组件化</li>
</ul>
<ul>
<li>组件化有利于单元测试与自测效率对重构较友好</li>
<li>新人加入可以直接分配组件进行开发、测试，而非需要熟悉整个项目，可以从一个组件的开发使新进人员比较快速熟悉项目、了解到开发规范</li>
<li>你的直接责任可能是编写代码，但你的终极目标是在创建产品</li>
</ul>
<p>最后说一句</p>
<font color="red">组件化没有终点，day day up</font>

<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a href="https://engineering.carsguide.com.au/front-end-component-design-principles-55c5963998c9?gi=b5b86599de92" target="_blank" rel="noopener">https://engineering.carsguide.com.au/front-end-component-design-principles-55c5963998c9?gi=b5b86599de92</a></li>
<li><a href="https://segmentfault.com/a/1190000009952681" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009952681</a></li>
<li><a href="https://juejin.im/post/5a73d6435188257a6a789d0d" target="_blank" rel="noopener">https://juejin.im/post/5a73d6435188257a6a789d0d</a></li>
<li><a href="https://medium.com/merrickchristensen/function-as-child-components-5f3920a9ace9" target="_blank" rel="noopener">https://medium.com/merrickchristensen/function-as-child-components-5f3920a9ace9</a></li>
<li><a href="http://www.alloyteam.com/2015/11/we-will-be-componentized-web-long-text/" target="_blank" rel="noopener">http://www.alloyteam.com/2015/11/we-will-be-componentized-web-long-text/</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>组件设计</tag>
      </tags>
  </entry>
  <entry>
    <title>一个问题引出的pushState用法</title>
    <url>/2018/11/27/pushState/</url>
    <content><![CDATA[<h3 id="引出问题"><a href="#引出问题" class="headerlink" title="引出问题"></a>引出问题</h3><p>为什么有这篇文章.<br>最近的开发中遇到这么一个问题<br>如下图<br><img src="/images/pushState/pushState1.gif" alt="gifqian"><br>扫码进入网页 点击弹出覆盖整个手机屏幕的层 此时点击浏览器的返回 会直接回退到之前扫码页面<br>其实 这个逻辑很合理 因为它没有历史记录 没有所谓的上一个页面 程序上是合理的<br>但用户体验无疑是差到极致<br>对于用户来讲 可能我只是想把当前的弹层关掉而不是退出网页</p>
<p>那么如何解决呢？</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>没有历史记录 那我们就手动造出来一条“历史记录”，让程序的返回时 能够有迹可循<br>最终效果<br><img src="/images/pushState/pushState2.gif" alt="gifqian"></p>
<p>相关代码</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"> componentDidMount()&#123;</span><br><span class="line">        <span class="comment">//监听popstate事件</span></span><br><span class="line">        <span class="built_in">window</span>.addEventListener(<span class="string">'popstate'</span>,<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.navLeftClick();</span><br><span class="line">        &#125;)    </span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//弹层的返回按钮</span></span><br><span class="line">   navLeftClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">           showBrandContainer: <span class="literal">false</span></span><br><span class="line">       &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">componentWillUnmount() &#123;</span><br><span class="line">    <span class="comment">// 离开页面的时候取消监听popstate</span></span><br><span class="line">   <span class="built_in">window</span>.removeEventListener(<span class="string">'popstate'</span>,<span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="keyword">this</span>.back();</span><br><span class="line">   &#125;) </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    selectBrand = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">window</span>.history.pushState(&#123;page: <span class="number">1</span>&#125;, <span class="string">"title 1"</span>, <span class="string">"?page=1"</span>); <span class="comment">//向history对象push一条state</span></span><br><span class="line"></span><br><span class="line">          &lt;!-- 实现参数透传----</span><br><span class="line">        <span class="keyword">let</span> search = <span class="built_in">window</span>.location.search;</span><br><span class="line">        <span class="built_in">window</span>.history.pushState(&#123; page: <span class="number">1</span> &#125;, <span class="string">""</span>, search);</span><br><span class="line">        实现参数透传---- --&gt;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            showBrandContainer: <span class="literal">true</span> <span class="comment">//开启弹层</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="History"><a href="#History" class="headerlink" title="History"></a>History</h3><p>DOM中的window对象通过window.history方法提供了对浏览器历史记录的读取，让你可以在用户的访问记录中前进和后退<br>从HTML5开始，我们可以开始操作这个历史记录堆栈<br><strong>前进</strong>  <code>window.history.forward();</code><br><strong>后退</strong> <code>window.history.back();</code><br><strong>向前移动N页</strong> <code>window.history.go(-N);</code><br><strong>向后移动N页</strong> <code>window.history.go(N);</code><br>你甚至可以通过检查浏览器历史记录的length属性来找到历史记录堆栈中的页面总数<br><code>window.history.length</code></p>
<h4 id="HTML5-history新特性pushState、replaceState"><a href="#HTML5-history新特性pushState、replaceState" class="headerlink" title="HTML5 history新特性pushState、replaceState"></a>HTML5 history新特性pushState、replaceState</h4><p>HTML5引入了histtory.pushState()和history.replaceState()这两个方法，他们允许添加和修改history实体。同时，这些方法会和window.onpostate事件一起工作，关于window.popstate 可参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/onpopstate" target="_blank" rel="noopener">window.popstate</a><br>pushState：向 history 添加当前页面的记录 使用history.pushState()方法来修改referrer<br>replaceState：和 pushState 的用法完全一样，区别就是它用于修改当前页面在 history 中的记录 </p>
<p>一个🌰</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">假设http://<span class="number">10.70</span>.<span class="number">134.53</span>:<span class="number">3000</span>/opt/financial 控制台执行了JS</span><br><span class="line">var <span class="keyword">state</span>Obj = &#123; foo: <span class="string">"test"</span> &#125;; history.pushState(<span class="keyword">state</span>Obj, <span class="string">"page 2"</span>,<span class="string">"test.html"</span>);</span><br><span class="line">url地址栏变为 http://<span class="number">10.70</span>.<span class="number">134.53</span>:<span class="number">3000</span>/opt/test.html，但浏览器不会加载bar.html页面，即使这个页面存在也不会加载。</span><br><span class="line">此时 如果你点击浏览器的返回 浏览器就貌似有了前一页</span><br><span class="line">如下图：</span><br></pre></td></tr></table></figure>
<p><img src="/images/pushState/pushState3.gif" alt="gifqian"></p>
<p>总结：</p>
<p>关于 popstate 事件 需要注意的几点</p>
<ul>
<li>调用history.pushState()或者history.replaceState()不会触发popstate事件.</li>
<li>popstate事件只会在浏览器某些行为下触发, 比如点击后退、前进按钮(或者在JavaScript中调用history.back()、history.forward()、history.go()方法).</li>
</ul>
<p>也就是说 要触发该事件 你需要两步</p>
<ol>
<li>添加并激活一个历史记录条目(history.pushState)</li>
<li>.改变历史记录条目(用户行为,比如后退,前进)</li>
</ol>
]]></content>
      <categories>
        <category>react</category>
      </categories>
  </entry>
  <entry>
    <title>揭秘setState机制</title>
    <url>/2019/01/27/re_setState/</url>
    <content><![CDATA[<h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>要说<code>React</code>设计体现了响应式编程思想</p>
<blockquote>
<p>UI=f(state) </p>
</blockquote>
<p><a href="https://www.zhihu.com/people/morgancheng/activities" target="_blank" rel="noopener">程墨Morgan</a>的总结真是恰到好处</p>
<p><code>state</code>于<code>React</code>很重要，<code>setState</code>作为管理<code>state</code>的重要方法自然也是头等公民</p>
<p>当然了，如果只是简单用法，API足够了，你知道如何设置，如何更新，或许能解决眼前的需求，但是需求稍微复杂一点，可能会被动陷入<code>setState</code>怪圈</p>
<p>在哪里跌倒就把哪里买下来，被坑了之后，痛定思痛决定研究下<code>setState</code>怪象，最后发现 react真是博大精深</p>
<font color="red">文章太太太长了，不太感兴趣的话，可以拉到最后总结，也能避免入坑</font>

<a id="more"></a>
<h2 id="引出问题"><a href="#引出问题" class="headerlink" title="引出问题"></a>引出问题</h2><p><strong>如果面试官问你</strong></p>
<ol>
<li>setState 是同步的还是异步的？</li>
<li>它可能是同步的吗？如果可能的话如何实现同步更新state？</li>
</ol>
<p>如果是看这篇文章之前 我的答案可能是这样儿</p>
<ol>
<li>它是异步的 不能立马拿到结果</li>
<li>emm….</li>
</ol>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><!--最好的方式就是带着疑问看源码（基于版本<font color="red">16.4.1</font>），相信我 调试大法好-->
<p>可能会有疑问的几个问题.</p>
<h3 id="1-为什么要用setState更新state不能直接修改？"><a href="#1-为什么要用setState更新state不能直接修改？" class="headerlink" title="1. 为什么要用setState更新state不能直接修改？"></a>1. 为什么要用setState更新state不能直接修改？</h3><p>先更正一个观点 是可以通过<code>this.state</code>对象修改state的 也确实能改变状态，但是不能驱动ui更新（不走render）那.. 有什么意义</p>
<h3 id="2-setState是同步的还是异步的？"><a href="#2-setState是同步的还是异步的？" class="headerlink" title="2. setState是同步的还是异步的？"></a>2. setState是同步的还是异步的？</h3><p>setState是同步执行的 但是state并不一定会同步更新（异步更新）,这是结论</p>
<p>针对这个问题 让我们带着问题去源码（基于版本<font color="red">16.4.1</font>）中寻找答案</p>
<hr>
<h4 id="场景一（合成事件中调用setState）"><a href="#场景一（合成事件中调用setState）" class="headerlink" title="场景一（合成事件中调用setState）"></a><font color="green"><strong>场景一（合成事件中调用setState）</strong></font></h4><p>点击按钮实现加一的操作</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">on</span>Click = ()=&gt; &#123;</span><br><span class="line">   this.<span class="built_in">set</span>State(&#123;</span><br><span class="line">       val: this.<span class="keyword">state</span>.val + <span class="number">1</span></span><br><span class="line">   &#125;)</span><br><span class="line">   console.<span class="keyword">log</span>('<span class="keyword">on</span>Click', this.<span class="keyword">state</span>.val);</span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line"> render()&#123;</span><br><span class="line">console.<span class="keyword">log</span>('render', this.<span class="keyword">state</span>.val);</span><br><span class="line"> <span class="variable">&lt;button onClick=&#123;this.onClick&#125;&gt;</span>加<span class="number">1</span>&lt;/button&gt;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>首先 这是<font color="red">合成事件</font>中操作<code>state</code>,</p>
<p><strong>了解什么是合成事件？</strong></p>
<blockquote>
<p>react为了解决跨平台，兼容性问题，自己封装了一套事件机制，代理了原生的事件，像在jsx中常见的onClick、onChange这些都是合成事件</p>
</blockquote>
<p>盯着这张网络盗图，画的完全符合我的预期，先有个概览，下文会跟踪解释</p>
<p><img src="/images/setState/setState__.jpg" alt="setState的更新过程"></p>
<p>当你点击<code>onClick</code>时</p>
<ul>
<li>第一阶段 （对合成事件的前期处理）</li>
</ul>
<p>react会在正式<code>setState</code>前执行一堆pre钩子函数(<font color="red">大部分都不需要关心</font>),你可以在chrome调试台或者<code>console.trace()</code>追踪到<br>像这样儿👇<br><img src="/images/setState/trace.png" alt="trace"><br>这些都是react的前期处理 这个过程你只需要关心👇</p>
<p><img src="/images/setState/pre11.png" alt="pre钩子"></p>
<p>得到的信息<br>isBatchingUpdates默认为false,在这里(某一个pre钩子函数中被置为true了)，划重点，以后要考的 此时程序走的是<font color="red">try分支</font></p>
<p>至此，前期处理结束</p>
<ul>
<li>第二阶段（setState事件的处理）</li>
</ul>
<p>红框部分是<code>setState</code>逻辑的调用栈，执行到<code>requestWork</code>方法时会二次判断 如下图👇<br><img src="/images/setState/sasas.png" alt="sasas"></p>
<p>二阶段完</p>
<ul>
<li>第三阶段（重置post钩子,更新state 渲染ui操作）</li>
</ul>
<p>接上文，那么我想知道它会return到哪里呢<br>通过追踪发现 会走你主进程里的<code>console</code>语句<br><img src="/images/setState/state_delay.png" alt="state延迟更新"><br><strong>这也就是为什么说setState更异步的</strong><br>上文中提到我们现在仍然处在try分支中，而在 finally 中才会更新<code>state</code>并且渲染到UI上，此时我们得到的仍然是<code>更新前的 state</code> 值，这就导致了<code>所谓的&quot;异步&quot;</code>,为什么要用<code>&quot;&quot;</code>号,因为这并不是我们的本意，是<code>react为了性能着想私自做的处理</code></p>
<hr>
<p>接着往下走：<br><img src="/images/setState/sssswww.png" alt="ssssww"><br>最终还会走到这个方法<br>这个方法里面有个 try finally 语法, 到这里 我们知道了原来return到了这个fn<br>继续👇<br><img src="/images/setState/post0.png" alt="post钩子"><br><img src="/images/setState/ui.png" alt="ui"></p>
<p>render之后 合成事件中setState的逻辑就结束了</p>
<hr>
<h4 id="场景二（生命周期中调用setState）"><a href="#场景二（生命周期中调用setState）" class="headerlink" title="场景二（生命周期中调用setState）"></a><font color="green"><strong>场景二（生命周期中调用setState）</strong></font></h4><p>实际上与场景一只在第一阶段不同（没有对合成事件的各种处理）我们可能想在不同的生命周期中聊下state的更新状况</p>
<p>我们照例先来个小demo 再来分析为什么会有这样儿的结果</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">state</span> = &#123;</span><br><span class="line">   val:<span class="number">0</span>,</span><br><span class="line">   name:'yishu',</span><br><span class="line">   age:<span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"> componentWillMount()&#123;</span><br><span class="line">      this.<span class="built_in">set</span>State(&#123;val:this.<span class="keyword">state</span>.val+<span class="number">1</span>&#125;);</span><br><span class="line">      console.<span class="keyword">log</span>('componentWillMount第一次输出',this.<span class="keyword">state</span>.val)</span><br><span class="line">      this.<span class="built_in">set</span>State(&#123;val:this.<span class="keyword">state</span>.val+<span class="number">1</span>&#125;);</span><br><span class="line">      console.<span class="keyword">log</span>('componentWillMount第二次输出',this.<span class="keyword">state</span>.val)</span><br><span class="line">    &#125;</span><br><span class="line">     componentDidMount()&#123;</span><br><span class="line">      this.<span class="built_in">set</span>State(&#123;</span><br><span class="line">            val: this.<span class="keyword">state</span>.val + <span class="number">1</span>,</span><br><span class="line">            name:'🐶'</span><br><span class="line">        &#125;);</span><br><span class="line">        console.<span class="keyword">log</span>('componentDidMount第一次执行', this.<span class="keyword">state</span>.val)</span><br><span class="line">        this.<span class="built_in">set</span>State(&#123;</span><br><span class="line">            val: this.<span class="keyword">state</span>.val + <span class="number">1</span>,</span><br><span class="line">            name:'🐱',</span><br><span class="line">            age:<span class="number">81</span></span><br><span class="line">        &#125;);</span><br><span class="line">        console.<span class="keyword">log</span>('componentDidMount第二次输出', this.<span class="keyword">state</span>.val)</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     componentDidUpdate()&#123;</span><br><span class="line">        console.<span class="keyword">log</span>('componentDidUpdate执行',this.<span class="keyword">state</span>.val)</span><br><span class="line">    &#125;</span><br><span class="line">render()&#123;</span><br><span class="line">      if(this.<span class="keyword">state</span>.val !==<span class="number">0</span>)&#123;</span><br><span class="line">            console.<span class="keyword">log</span>('render执行',this.<span class="keyword">state</span>)</span><br><span class="line">        &#125;</span><br><span class="line">  <span class="variable">&lt;p&gt;</span>当前的值:&#123;this.<span class="keyword">state</span>.val&#125;&lt;/p&gt;</span><br><span class="line">  <span class="variable">&lt;p&gt;</span>你的名字:&#123;this.<span class="keyword">state</span>.name&#125;&lt;/p&gt;</span><br><span class="line">  <span class="variable">&lt;p&gt;</span>芳龄:&#123;this.<span class="keyword">state</span>.age&#125;&lt;/p&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接给出结果</p>
<p><img src="/images/setState/component_state.png" alt="component_state"><br>其实经过各种API的熏陶，不运行也能知道结果,既然摊开来讲，就比较想知道为什么。</p>
<p>按照流程 ，先来一张调用栈鸟瞰图（网图）</p>
<p><img src="/images/setState/gouzihanshu.jpg" alt="钩子函数中setState的调用栈"><br>还是三个阶段</p>
<ul>
<li><p>第一阶段<br><img src="/images/setState/did.png" alt="did"></p>
</li>
<li><p>第二阶段<br><img src="/images/setState/2121233434.png" alt="2121233434"><br>到现在就比较清晰了，与场景一不同的是 走的是<code>requestWork</code>中的第一个<code>if</code>分支,场景一（第二个if分支）不管哪种情况 结果都是一致的 那就是不会走到下面的同步更新分支 并且 两种情况都还只是在<strong>try</strong>模块中执行 再往下的流程参考场景一</p>
</li>
<li><p>第三阶段<br>同场景一</p>
</li>
</ul>
<p>关于这一场景 背着</p>
<font color="red"><code>render</code>之前的生命周期拿到的都是更新之前的值，render之后执行的才能拿到最新的值 比如 <code>componentDidUpdate</code></font>

<hr>
<h3 id="3-setState可以变成同步更新吗？-如果可以的话-怎么做才能获取最新的值？"><a href="#3-setState可以变成同步更新吗？-如果可以的话-怎么做才能获取最新的值？" class="headerlink" title="3. setState可以变成同步更新吗？ 如果可以的话 怎么做才能获取最新的值？"></a>3. setState可以变成同步更新吗？ 如果可以的话 怎么做才能获取最新的值？</h3><p>面试官这么问的话 通常都是可以 😂<br>那我们如何做<br>实践中一般每个人都有一到两种解决方案，这里列举中处理方案 并将在下面的文章中深入研究 为什么 它 可以.</p>
<ul>
<li>在<strong>原生事件</strong>中调用<code>setState</code>函数</li>
<li>利用setState回调函数</li>
<li>setTimeout等异步操作中调用<code>setState</code>函数</li>
<li>最近刚被种草的函数式setstate用法</li>
<li>componentDidUpdate中获取</li>
</ul>
<p>名词释义：<br><strong>原生事件</strong>：指非react合成事件，原生自带的事件监听 <code>addEventListener</code> ，或者也可以用原生<code>js、jq</code>直接 <code>document.querySelector().onclick</code> 这种绑定事件的形式</p>
<hr>
<h4 id="在原生事件中调用setState函数"><a href="#在原生事件中调用setState函数" class="headerlink" title="在原生事件中调用setState函数"></a>在<strong>原生事件</strong>中调用<code>setState</code>函数</h4><p>一个小demo</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">state</span> = &#123;</span><br><span class="line">   val:<span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">componentDidMount = () =&gt;&#123;</span><br><span class="line"> document.querySelector('<span class="comment">#btn-raw').addEventListener('click', this.onClick);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">on</span>Click = ()=&gt; &#123;</span><br><span class="line">   this.<span class="built_in">set</span>State(&#123;</span><br><span class="line">       val: this.<span class="keyword">state</span>.val + <span class="number">1</span></span><br><span class="line">   &#125;);</span><br><span class="line">   console.<span class="keyword">log</span>('<span class="keyword">on</span>Click', this.<span class="keyword">state</span>.val);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">render()&#123;</span><br><span class="line"> if(this.<span class="keyword">state</span>.val !==<span class="number">0</span>)&#123;</span><br><span class="line">            console.<span class="keyword">log</span>('render执行',this.<span class="keyword">state</span>)</span><br><span class="line">        &#125;</span><br><span class="line"> <span class="variable">&lt;button id="btn-raw"&gt;</span>Increment &lt;/button&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果<br><img src="/images/setState/js.png" alt="js"><br>意料之中</p>
<p>按理来说还需要张鸟瞰图 在这里 👇</p>
<p><img src="/images/setState/js0setState.jpg" alt="原生事件的setState"></p>
<p>其实应该已经挺清晰了，我们还是在调试器里走一下</p>
<ul>
<li>第一阶段（setState逻辑之前的处理）</li>
</ul>
<p><img src="/images/setState/js_xzs.png" alt="js_xzs"><br>画风突变，调用栈内不再执行一堆看不懂的pre钩子函数了<br>简单的理解为 用原生事件调用时 不受react控制了 也就没办法针对它执行一堆函数，直接走setState的逻辑了</p>
<ul>
<li>第二阶段（setState执行逻辑）</li>
</ul>
<p><img src="/images/setState/js999.png" alt="js999"></p>
<p>走了第三个<code>if</code>分支 同步更新了（执行了render 再在click函数中打印的 所以拿到了最新值）</p>
<ul>
<li>第三阶段</li>
</ul>
<p>参考场景一</p>
<hr>
<h4 id="利用setState回调函数"><a href="#利用setState回调函数" class="headerlink" title="利用setState回调函数"></a>利用setState回调函数</h4><p>API就不多说了</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line"> this.<span class="built_in">set</span>State(&#123;</span><br><span class="line">       val:this.<span class="keyword">state</span>.val + <span class="number">1</span></span><br><span class="line">        &#125;,()=&gt;&#123;</span><br><span class="line">          console.<span class="keyword">log</span>('cllback',this.<span class="keyword">state</span>.val);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>原理：回调函数被调用的时候，其实render函数已经被调用过了 参考<code>demo</code>的执行结果</p>
<hr>
<h4 id="setTimeout等异步操作中调用setState函数"><a href="#setTimeout等异步操作中调用setState函数" class="headerlink" title="setTimeout等异步操作中调用setState函数"></a>setTimeout等异步操作中调用<code>setState</code>函数</h4><p>实际上 这并不是一个单独的场景，你可以在合成事件中 调用 <code>setTimeout</code> ，可以在生命周期中调用 <code>setTimeout</code> ，也可以在原生事件<code>setTimeout</code>，但是不管是哪个场景下，基于 <code>event loop</code>的模型下， setTimeout 中里去 setState 总能拿到最新的state值</p>
<p>一个demo 👇</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">this.<span class="keyword">state</span> = &#123;</span><br><span class="line">       val:<span class="number">0</span>,</span><br><span class="line">       name:'yishu',</span><br><span class="line">       age:<span class="number">18</span></span><br><span class="line">   &#125;</span><br><span class="line">       componentDidMount()&#123;</span><br><span class="line">        // // debugger;</span><br><span class="line">        // // 生命周期中调用---------------</span><br><span class="line">        this.<span class="built_in">set</span>State(&#123;</span><br><span class="line">            val: this.<span class="keyword">state</span>.val + <span class="number">1</span>,</span><br><span class="line">            name:'🐶'</span><br><span class="line">        &#125;);</span><br><span class="line">        console.<span class="keyword">log</span>('componentDidMount第一次执行', this.<span class="keyword">state</span>.val)</span><br><span class="line">        this.<span class="built_in">set</span>State(&#123;</span><br><span class="line">            val: this.<span class="keyword">state</span>.val + <span class="number">1</span>,</span><br><span class="line">            name:'🐱',</span><br><span class="line">            age:<span class="number">81</span></span><br><span class="line">        &#125;);</span><br><span class="line">        console.<span class="keyword">log</span>('componentDidMount第二次输出', this.<span class="keyword">state</span>.val)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">set</span>Timeout(() =&gt; &#123;</span><br><span class="line">            console.<span class="keyword">log</span>('开始<span class="built_in">set</span>Timeout', this.<span class="keyword">state</span>.val)</span><br><span class="line">            this.<span class="built_in">set</span>State(&#123;</span><br><span class="line">                val: this.<span class="keyword">state</span>.val + <span class="number">1</span></span><br><span class="line">            &#125;);</span><br><span class="line">            console.<span class="keyword">log</span>('<span class="built_in">set</span>Timeout第一次执行', this.<span class="keyword">state</span>.val)</span><br><span class="line">            this.<span class="built_in">set</span>State(&#123;</span><br><span class="line">                val: this.<span class="keyword">state</span>.val + <span class="number">1</span></span><br><span class="line">            &#125;);</span><br><span class="line">            console.<span class="keyword">log</span>('<span class="built_in">set</span>Timeout第二次执行', this.<span class="keyword">state</span>.val)</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        this.<span class="built_in">set</span>State(&#123;</span><br><span class="line">            val: this.<span class="keyword">state</span>.val + <span class="number">1</span></span><br><span class="line">        &#125;);</span><br><span class="line">        console.<span class="keyword">log</span>('componentDidMount第三次输出', this.<span class="keyword">state</span>.val)        </span><br><span class="line">    &#125;</span><br><span class="line">render()&#123;</span><br><span class="line">if(this.<span class="keyword">state</span>.val !==<span class="number">0</span>)&#123;</span><br><span class="line">            console.<span class="keyword">log</span>('render执行',this.<span class="keyword">state</span>)</span><br><span class="line">        &#125;</span><br><span class="line"> <span class="variable">&lt;p&gt;</span>当前的值:&#123;this.<span class="keyword">state</span>.val&#125;&lt;/p&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/setState/setTimeout.png" alt="setTimeout"><br>上述结果，如果你了解<font color="red">js事件循环（ event loop）</font>的机制 就太简单了</p>
<p>默认你已经阅读过全文的上半部分 了解了 <code>setState</code>逻辑都是在<strong>try</strong>模块中执行的,此时当执行到 <code>setTimeout</code> 的时候，把它丢到<strong>定时器触发线程(浏览器提供的线程)</strong>去维护，并没有立即执行，先执行的 <code>finally</code> 代码块，等 finally 执行完了， <code>isBatchingUpdates</code> 又变为了 <code>false</code> ，导致最后去执行队列里的 setState 时候， requestWork 走的是和原生事件一样的 <code>expirationTime === Sync if</code>分支，所以表现就会和原生事件一样，可以同步拿到最新的<code>state</code>值。</p>
<p>关于js事件循环 又是另一个模块儿的东西 值得单开一章去研究，这里就不再细说了 感兴趣的同学 可移步<br><a href="http://maying.ink/2018/11/17/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3js%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/#more">js到底是如何工作的</a> 寻找答案</p>
<hr>
<h3 id="4-函数式setState用法"><a href="#4-函数式setState用法" class="headerlink" title="4. 函数式setState用法"></a>4. 函数式setState用法</h3><p>我在想 怎么才能更好引出这个大彩蛋，那便又涉及到另一个问题<br>以上文章中我们为了说明<code>setState执行的大流程</code> 有一个实际存在却没提及的问题，那就是<code>setState的批量更新</code></p>
<p>类似这样儿的代码</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">//...</span><br><span class="line">this.<span class="built_in">set</span>State(&#123;val: this.<span class="keyword">state</span>.val + <span class="number">1</span>&#125;);</span><br><span class="line">console.<span class="keyword">log</span>('componentDidMount第一次执行', this.<span class="keyword">state</span>.val)</span><br><span class="line">this.<span class="built_in">set</span>State(&#123;val: this.<span class="keyword">state</span>.val + <span class="number">1</span>&#125;);</span><br><span class="line">console.<span class="keyword">log</span>('componentDidMount第二次执行', this.<span class="keyword">state</span>.val)</span><br><span class="line">this.<span class="built_in">set</span>State(&#123;val: this.<span class="keyword">state</span>.val + <span class="number">1</span>&#125;);</span><br><span class="line">console.<span class="keyword">log</span>('componentDidMount第三次执行', this.<span class="keyword">state</span>.val)</span><br><span class="line">//...</span><br></pre></td></tr></table></figure>
<p>得到的执行结果<br><img src="/images/setState/render.png" alt="rende"></p>
<p>API告诉我可以接受，但是有点点懵 发生了什么… emm<br>假如这么写 会不会更清晰👇</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> currentCount = <span class="keyword">this</span>.state.count;</span><br><span class="line"><span class="keyword">this</span>.setState(&#123;count: currentCount + <span class="number">1</span>&#125;);</span><br><span class="line"><span class="keyword">this</span>.setState(&#123;count: currentCount + <span class="number">1</span>&#125;);</span><br><span class="line"><span class="keyword">this</span>.setState(&#123;count: currentCount + <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>对的 你每次设置的都是同一个值<br>setState多次,re-render一次，多次同步执行的<code>setState</code>，会进行合并，类似于<code>Object.assign</code>,相同的<code>key</code>会被覆盖 所以结果为<font color="red">1</font></p>
<p>为了不偏题 实现过程暂时省略,接受这个结论,让我们看函数式setState用法</p>
<font color="red">如果传递给this.setState的参数<code>不是一个对象而是一个函数</code> 那就完全不一样儿了</font>

<p>一个小🌰体验下神奇的效果</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">componentDidMound = () =&gt;&#123;</span><br><span class="line">        console.<span class="keyword">log</span>('参数为函数第一次执行',this.<span class="keyword">state</span>.val)</span><br><span class="line">        this.<span class="built_in">set</span>State(this.increment);</span><br><span class="line">        console.<span class="keyword">log</span>('参数为函数第二次执行',this.<span class="keyword">state</span>.val)</span><br><span class="line">        this.<span class="built_in">set</span>State(this.increment);</span><br><span class="line">        console.<span class="keyword">log</span>('参数为函数第三次执行',this.<span class="keyword">state</span>.val)</span><br><span class="line">        this.<span class="built_in">set</span>State(this.increment);</span><br><span class="line">        console.<span class="keyword">log</span>('参数为函数第四次执行',this.<span class="keyword">state</span>.val)</span><br><span class="line">&#125;</span><br><span class="line">   /**</span><br><span class="line">     * @description increment函数并不去修改组件状态，只是把“希望的状态改变”返回给React，维护状态这些苦力活完全交给React去做。</span><br><span class="line">     * params  <span class="keyword">state</span>：当前的<span class="keyword">state</span></span><br><span class="line">     * params  props：当前的props</span><br><span class="line">     * @return 对象代表之前你想给this.<span class="built_in">set</span>State传递的参数 比如你认为第一次传<span class="number">0</span> 第二次传<span class="number">1</span> </span><br><span class="line">     * @memberof SetState</span><br><span class="line">     */</span><br><span class="line">    increment = (<span class="keyword">state</span>, props) =&gt; &#123;</span><br><span class="line">        // 计算这个对象的方法有些改变，不再依赖于this.<span class="keyword">state</span>，而是依赖于输入参数<span class="keyword">state</span>。</span><br><span class="line">        console.<span class="keyword">log</span>('---state',<span class="keyword">state</span>) </span><br><span class="line">        return &#123;val: <span class="keyword">state</span>.val + <span class="number">1</span>&#125;; //同样是把状态中的count加<span class="number">1</span>，但是状态的来源不是this.<span class="keyword">state</span>，而是输入参数<span class="keyword">state</span>。</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/setState/fn_state.png" alt="fn_state"><br>仔细看下代码中的注释部分<br>结论：<br>对于多次调用函数式setState的情况，React会保证调用每次increment时，state都已经合并了之前的状态修改结果。<br>但是 在<code>increment</code>函数被调用时<code>，this.state</code>并没有被改变，依然要等到<code>render</code>函数被重新执行时才被改变，也没有推翻上文的结论 真好。</p>
<p>API的设计符合函数式编程思想，开发者编写无副作用的函数 increment 并不会去改变组件状态，只是把“希望的状态改变”返回给React，维护状态这些苦力活完全交给React去做。<br>也正是 流程的控制权交给了React，所以React才能协调多个setState调用的关系。</p>
<h3 id="4-手动避免setState的不当调用带来的性能问题"><a href="#4-手动避免setState的不当调用带来的性能问题" class="headerlink" title="4. 手动避免setState的不当调用带来的性能问题"></a>4. 手动避免setState的不当调用带来的性能问题</h3><p>到这里基本上就清楚了setState执行机制，那么 我们应该怎样儿利用自己的知识手动优化页面性能呢</p>
<p>这里列举了几条</p>
<ul>
<li>除了特殊需求 尽量不要在非合成事件中调用<code>setState</code> 这样儿会失控 变成真的同步更新了 每次更新都会走render 走render就不可避免的涉及到 <code>diff对比</code>.. 更新过程很频繁，也就会导致性能问题。</li>
<li>不要在 <code>shouldComponentUpdate</code> 和 <code>componentWillUpdate</code> 中调用 setState 会造成循环<br><img src="/images/setState/xunhuan.jpg" alt="xunhuan"></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>setState不会立刻改变React组件中state的值；</li>
<li>setState通过引发一次组件的更新过程来引发重新绘制；</li>
<li>多次setState函数调用产生的效果会合并。</li>
<li>setState 只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout 中都是同步的，批量更新的策略是基于”异步”之上的，在setTimeout和原生事件中是没有的，因为此时时不受控的</li>
<li>setState 的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形成了所谓的“异步”，但是如果需要，也有解决方案可以直接拿到最新的值</li>
<li>setState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，在更新时会对其进行合并批量更新。</li>
<li>像写受控组件那样儿去操作setState</li>
</ul>
<p>参考文章：<a href="https://zhuanlan.zhihu.com/p/39512941" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/39512941</a><br>        <a href="https://zhuanlan.zhihu.com/p/25990883" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25990883</a></p>
]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>setState</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Node.js逐步建立多路复用的RPC通道</title>
    <url>/2020/03/23/rpc/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>依托Nodejs使用 <code>Buffer</code>  <code>net</code>等模块逐步构建满足应用场景的RPC通道</p>
<h1 id="1-RPC调用"><a href="#1-RPC调用" class="headerlink" title="1. RPC调用"></a>1. RPC调用</h1><p>RPC</p>
<p>全称 <code>Remote Procedure Call</code> 翻译成中文：远程过程调用</p>
<p>emm.. 我只是个小前端..</p>
<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1584877960225&amp;di=1beedaa2bf83dbc8d438dc36164af7d3&amp;imgtype=0&amp;src=http%3A%2F%2Fimg3.cache.netease.com%2Fphoto%2F0005%2F2013-02-20%2F8O5Q4R5K0AI90005.jpg" alt="image"></p>
<h2 id="1-1-如何通俗的解释是RPC？"><a href="#1-1-如何通俗的解释是RPC？" class="headerlink" title="1.1 如何通俗的解释是RPC？"></a>1.1 如何通俗的解释是RPC？</h2><h3 id="1-1-1-本地过程调用"><a href="#1-1-1-本地过程调用" class="headerlink" title="1.1.1 本地过程调用"></a>1.1.1 本地过程调用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我现在在家里，我需要洗衣服，就把衣服扔到洗衣机洗了</span><br></pre></td></tr></table></figure>
<h3 id="1-1-2-远程过程调用-RPC"><a href="#1-1-2-远程过程调用-RPC" class="headerlink" title="1.1.2 远程过程调用(RPC)"></a>1.1.2 远程过程调用(RPC)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我现在在逛街，我需要洗衣服，于是给在家里的男票打个哥电话，他把衣服扔到洗衣机洗了</span><br><span class="line"></span><br><span class="line">那么我就实现了RPC调用！！</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="1-2-从前端的角度上来理解RPC调用？"><a href="#1-2-从前端的角度上来理解RPC调用？" class="headerlink" title="1.2 从前端的角度上来理解RPC调用？"></a>1.2 从前端的角度上来理解RPC调用？</h2><p>从我们熟悉的Ajax入手，它与RPC调用类似，我们来对比一下</p>
<h3 id="1-2-1-相同点"><a href="#1-2-1-相同点" class="headerlink" title="1.2.1 相同点"></a>1.2.1 相同点</h3><h4 id="1-2-1-1-都是两个计算机之间的网络通信"><a href="#1-2-1-1-都是两个计算机之间的网络通信" class="headerlink" title="1.2.1.1 都是两个计算机之间的网络通信"></a>1.2.1.1 都是两个计算机之间的网络通信</h4><ul>
<li>Ajax：客户端和服务端的通信</li>
<li>PRC：服务器和另外一台服务器的通信</li>
</ul>
<p>看图说话</p>
<p><img src="http://cdn.anruence.com/rpc.png" alt="image"></p>
<h4 id="1-2-1-2-需要双方约定一个数据格式"><a href="#1-2-1-2-需要双方约定一个数据格式" class="headerlink" title="1.2.1.2 需要双方约定一个数据格式"></a>1.2.1.2 需要双方约定一个数据格式</h4><h3 id="1-2-2-不同点"><a href="#1-2-2-不同点" class="headerlink" title="1.2.2 不同点"></a>1.2.2 不同点</h3><h4 id="1-2-2-1-不一定使用DNS作为寻址服务"><a href="#1-2-2-1-不一定使用DNS作为寻址服务" class="headerlink" title="1.2.2.1 不一定使用DNS作为寻址服务"></a>1.2.2.1 不一定使用DNS作为寻址服务</h4><ul>
<li>Ajax 是发一个HTTP请求，使用DNS进行寻址服务</li>
</ul>
<p>请求过程<br><img src="http://cdn.anruence.com/dns.png" alt="image"></p>
<ul>
<li>RPC通信一般是在内网进行请求，使用特有的服务（比如id）<br>请求过程<br><img src="http://cdn.anruence.com/rpcxunzhi.png" alt="image"></li>
</ul>
<h4 id="1-2-2-2-应用层协议一般不使用HTTP"><a href="#1-2-2-2-应用层协议一般不使用HTTP" class="headerlink" title="1.2.2.2 应用层协议一般不使用HTTP"></a>1.2.2.2 应用层协议一般不使用HTTP</h4><p>Ajax：使用HTTP文本协议（html,json）<br>RPC:服务端之间的通信，对效率要求更高所以使用一些二进制协议取代HTTP，二进制协议性能上存在优势</p>
<ul>
<li>更小的数据包</li>
<li>更快的编码速率</li>
</ul>
<h4 id="1-2-2-3-基于TCP-UDP协议"><a href="#1-2-2-3-基于TCP-UDP协议" class="headerlink" title="1.2.2.3 基于TCP/UDP协议"></a>1.2.2.3 基于TCP/UDP协议</h4><ul>
<li>浏览器调用（Ajax）使用 TCP是遵循HTTP的规范</li>
<li>RPC调用使用了TCP多种通信方式<ol>
<li>单工通信（独木桥）</li>
</ol>
</li>
</ul>
<p>类比独木桥，两岸同一时间内只能有一方通过<br><img src="http://cdn.anruence.com/dangong.png" alt="image"></p>
<pre><code>1.   半双工通信（轮番单工通信，独木桥）
</code></pre><p><img src="http://cdn.anruence.com/banshuanggongtongxin.png" alt="image"></p>
<pre><code>1.   全双工通信
</code></pre><p><img src="http://cdn.anruence.com/quanshuanggongtongxiin.png" alt="image"></p>
<h2 id="2-使用Buffter编解码二进制数据包"><a href="#2-使用Buffter编解码二进制数据包" class="headerlink" title="2. 使用Buffter编解码二进制数据包"></a>2. 使用Buffter编解码二进制数据包</h2><p>用来处理TCP链接中的流以及文件系统中的数据</p>
<p><a href="http://nodejs.cn/api/buffer.html" target="_blank" rel="noopener">Buffer官方介绍</a></p>
<h3 id="2-1-buffter创建"><a href="#2-1-buffter创建" class="headerlink" title="2.1 buffter创建"></a>2.1 buffter创建</h3><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">const buffter1 = Buffer.from('yishu')</span><br><span class="line">const buffter2 = Buffer.alloc(<span class="number">20</span>)</span><br><span class="line">console.log(buffter1)</span><br><span class="line">console.log(buffter2)</span><br><span class="line"></span><br><span class="line">&lt;Buffer <span class="number">79</span> <span class="number">69</span> <span class="number">73</span> <span class="number">68</span> <span class="number">75</span>&gt;</span><br><span class="line">&lt;Buffer <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-buffter读写"><a href="#2-2-buffter读写" class="headerlink" title="2.2 buffter读写"></a>2.2 buffter读写</h3><p>二进制协议：不同字段塞在二进制流中的不同位置</p>
<p>基本操作</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">buffter<span class="number">2.</span>writeI<span class="symbol">nt8</span><span class="comment">(12,1)</span></span><br></pre></td></tr></table></figure>
<p>图示编码二进制包<br><img src="http://cdn.anruence.com/lll.png" alt="image"></p>
<p><strong>图解：</strong><br>前三位代表一个字段，中间代表一个字段，后面又代表一个字段<br>所以，编码二进制包的时候，我们需要执行三次write写操作</p>
<p>看起来还是稍许麻烦嗷</p>
<p><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=908304341,3029384854&amp;fm=26&amp;gp=0.jpg" alt="image"></p>
<p>有木有像Json格式化方式如此简单的编码方式</p>
<p>答案：有！</p>
<p><a href="https://www.npmjs.com/package/protocol-buffers" target="_blank" rel="noopener">protocol-buffers-npm包</a></p>
<p>使用示例</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">test.proto</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="keyword">required</span> <span class="built_in">int32</span> id  = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">required</span> <span class="built_in">string</span> payload = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>index.js<br><figure class="highlight qml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> protobuf = <span class="built_in">require</span>(<span class="string">'protocol-buffers'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// pass a proto file as a buffer/string or pass a parsed protobuf-schema object</span></span><br><span class="line"><span class="keyword">var</span> messages = protobuf(fs.readFileSync(__dirname + <span class="string">'/test.proto'</span>,<span class="string">'utf-8'</span>))</span><br><span class="line"><span class="keyword">var</span> buf = messages.Test.encode(&#123;</span><br><span class="line">  <span class="attribute">id:</span><span class="string"> 42,</span></span><br><span class="line"><span class="string">  payload</span>: <span class="string">'hello world'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(buf) <span class="comment">// should print a buffer</span></span><br><span class="line">&#123;<span class="comment">/* &lt;Buffer 08 2a 12 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64&gt; */</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(messages.Test.decode(buf))</span><br><span class="line"><span class="comment">// &#123; id: 42, payload: 'hello world' &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>明显发现</p>
<ul>
<li>更直观</li>
<li>更好维护</li>
<li>更便于合作</li>
</ul>
<p>正是所期盼的这样鸭～<br><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1584891026316&amp;di=474986ffbe473f99d8664a54b1f89076&amp;imgtype=0&amp;src=http%3A%2F%2Fp5.pccoo.cn%2Fwinccoo%2F20170317%2F2017031716023399665328.gif" alt="image"></p>
<h2 id="3-建立多路复用的RPC通道"><a href="#3-建立多路复用的RPC通道" class="headerlink" title="3. 建立多路复用的RPC通道"></a>3. 建立多路复用的RPC通道</h2><h3 id="3-1-需求1-实现单工通信通道"><a href="#3-1-需求1-实现单工通信通道" class="headerlink" title="3.1 需求1 实现单工通信通道"></a>3.1 需求1 实现单工通信通道</h3><p>client.js</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> net = require(<span class="string">'net'</span>);</span><br><span class="line"><span class="keyword">const</span> socket  = <span class="keyword">new</span> net.Socket(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">socket.<span class="built_in">connect</span>(&#123;</span><br><span class="line">    host:<span class="string">'127.0.0.1'</span>,</span><br><span class="line">    port:<span class="number">6002</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">socket.<span class="built_in">write</span>(<span class="string">'good!maying'</span>)  <span class="comment">//单工通信</span></span><br></pre></td></tr></table></figure>
<p>server.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"></span><br><span class="line">net.createServer(<span class="function">(<span class="params">socket</span>)=&gt;</span>&#123;</span><br><span class="line">    socket.on(<span class="string">'data'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">buffer</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'buffer'</span>,buffer,buffer.toString())</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">.listen(<span class="number">6002</span>)</span><br></pre></td></tr></table></figure>
<p>得到结果</p>
<p><img src="http://cdn.anruence.com/goodmoring.png" alt="image"></p>
<p>这里实现了TCP通信方式之一 <font color="red">单工通信</font></p>
<h3 id="3-1-需求2-实现半双工通信通道"><a href="#3-1-需求2-实现半双工通信通道" class="headerlink" title="3.1 需求2 实现半双工通信通道"></a>3.1 需求2 实现半双工通信通道</h3><h4 id="3-1-1-客户端和服务器有来有回"><a href="#3-1-1-客户端和服务器有来有回" class="headerlink" title="3.1.1 客户端和服务器有来有回"></a>3.1.1 客户端和服务器有来有回</h4><ul>
<li>客户端请求一个正常数据</li>
<li>服务端返回一个相应的数据</li>
</ul>
<h4 id="3-1-2-重点逻辑"><a href="#3-1-2-重点逻辑" class="headerlink" title="3.1.2 重点逻辑"></a>3.1.2 重点逻辑</h4><p>在单工通信模式下</p>
<ul>
<li>client端：发请求数据，等到服务器端返回结果之后，再次请求</li>
<li>server端：接收到请求后，匹配返回</li>
</ul>
<h4 id="3-1-3-代码"><a href="#3-1-3-代码" class="headerlink" title="3.1.3 代码"></a>3.1.3 代码</h4><p>client.js</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建socket</span></span><br><span class="line"><span class="keyword">const</span> socket = <span class="keyword">new</span> net.Socket(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接服务器</span></span><br><span class="line">socket.connect(&#123;</span><br><span class="line">    host: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">    port: <span class="number">6002</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> lessonids = [</span><br><span class="line">    <span class="string">"136797"</span>,</span><br><span class="line">    <span class="string">"136798"</span>,</span><br><span class="line">    <span class="string">"136799"</span>,</span><br><span class="line">    <span class="string">"136800"</span>,</span><br><span class="line">    <span class="string">"136801"</span>,</span><br><span class="line">    <span class="string">"136803"</span>,</span><br><span class="line">    <span class="string">"136804"</span>,</span><br><span class="line">    <span class="string">"136806"</span>,</span><br><span class="line">    <span class="string">"136807"</span>,</span><br><span class="line">    <span class="string">"136808"</span>,</span><br><span class="line">    <span class="string">"136809"</span>,</span><br><span class="line">    <span class="string">"141994"</span>,</span><br><span class="line">    <span class="string">"143517"</span>,</span><br><span class="line">    <span class="string">"143557"</span>,</span><br><span class="line">    <span class="string">"143564"</span>,</span><br><span class="line">    <span class="string">"143644"</span>,</span><br><span class="line">    <span class="string">"146470"</span>,</span><br><span class="line">    <span class="string">"146569"</span>,</span><br><span class="line">    <span class="string">"146582"</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> id = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * lessonids.length);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 往服务器传数据</span></span><br><span class="line">socket.write(encode(id));</span><br><span class="line"></span><br><span class="line">socket.on(<span class="string">'data'</span>, <span class="function">(<span class="params">buffer</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(buffer.toString())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收到数据之后，按照半双工通信的逻辑，马上开始下一次请求</span></span><br><span class="line">    id = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * lessonids.length);</span><br><span class="line">    socket.write(encode(id));</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把编码请求包的逻辑封装为一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encode</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">    buffer = Buffer.alloc(<span class="number">4</span>);</span><br><span class="line">    buffer.writeInt32BE(</span><br><span class="line">        lessonids[index]</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>server.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建tcp服务器</span></span><br><span class="line"><span class="keyword">const</span> server = net.createServer(<span class="function">(<span class="params">socket</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    socket.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">buffer</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 从传来的buffer里读出一个int32</span></span><br><span class="line">        <span class="keyword">const</span> lessonid = buffer.readInt32BE();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 50毫秒后回写数据</span></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">            socket.write(</span><br><span class="line">                Buffer.from(data[lessonid])</span><br><span class="line">            );</span><br><span class="line">        &#125;, <span class="number">50</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听端口启动服务</span></span><br><span class="line">server.listen(<span class="number">6002</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">    <span class="number">136797</span>: <span class="string">"01 | 课程介绍"</span>,</span><br><span class="line">    <span class="number">136798</span>: <span class="string">"02 | 内容综述"</span>,</span><br><span class="line">    <span class="number">136799</span>: <span class="string">"03 | Node.js是什么？"</span>,</span><br><span class="line">    <span class="number">136800</span>: <span class="string">"04 | Node.js可以用来做什么？"</span>,</span><br><span class="line">    <span class="number">136801</span>: <span class="string">"05 | 课程实战项目介绍"</span>,</span><br><span class="line">    <span class="number">136803</span>: <span class="string">"06 | 什么是技术预研？"</span>,</span><br><span class="line">    <span class="number">136804</span>: <span class="string">"07 | Node.js开发环境安装"</span>,</span><br><span class="line">    <span class="number">136806</span>: <span class="string">"08 | 第一个Node.js程序：石头剪刀布游戏"</span>,</span><br><span class="line">    <span class="number">136807</span>: <span class="string">"09 | 模块：CommonJS规范"</span>,</span><br><span class="line">    <span class="number">136808</span>: <span class="string">"10 | 模块：使用模块规范改造石头剪刀布游戏"</span>,</span><br><span class="line">    <span class="number">136809</span>: <span class="string">"11 | 模块：npm"</span>,</span><br><span class="line">    <span class="number">141994</span>: <span class="string">"12 | 模块：Node.js内置模块"</span>,</span><br><span class="line">    <span class="number">143517</span>: <span class="string">"13 | 异步：非阻塞I/O"</span>,</span><br><span class="line">    <span class="number">143557</span>: <span class="string">"14 | 异步：异步编程之callback"</span>,</span><br><span class="line">    <span class="number">143564</span>: <span class="string">"15 | 异步：事件循环"</span>,</span><br><span class="line">    <span class="number">143644</span>: <span class="string">"16 | 异步：异步编程之Promise"</span>,</span><br><span class="line">    <span class="number">146470</span>: <span class="string">"17 | 异步：异步编程之async/await"</span>,</span><br><span class="line">    <span class="number">146569</span>: <span class="string">"18 | HTTP：什么是HTTP服务器？"</span>,</span><br><span class="line">    <span class="number">146582</span>: <span class="string">"19 | HTTP：简单实现一个HTTP服务器"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://cdn.anruence.com/half.gif" alt="image"></p>
<h3 id="3-2-需求1-实现全双工通信通道"><a href="#3-2-需求1-实现全双工通信通道" class="headerlink" title="3.2 需求1 实现全双工通信通道"></a>3.2 需求1 实现全双工通信通道</h3><p>client端自由发送数据包，无需等待server端返回</p>
<h4 id="3-2-1-解决半双工通信的问题"><a href="#3-2-1-解决半双工通信的问题" class="headerlink" title="3.2.1 解决半双工通信的问题"></a>3.2.1 解决半双工通信的问题</h4><ul>
<li>半双工通信进行并发容易导致请求包和响应包时序错乱</li>
</ul>
<p>看图解释一下</p>
<p><img src="http://cdn.anruence.com/qwwqw.png" alt="image"></p>
<ol>
<li>client同时发送id1，id2的请求</li>
<li>server端处理…</li>
<li>server返回id2的处理结果</li>
<li>server返回id1的处理结果</li>
</ol>
<p>client端如何将两个请求和返回数据对应呢？</p>
<p>如果根据返回的时间来进行匹配，就会造成错乱</p>
<p><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2814248882,3142720346&amp;fm=26&amp;gp=0.jpg" alt="image"></p>
<font color="red">如何解决?</font>


<p>这正是全双工通信模式要解决的问题</p>
<p>将请求包和返回包都加上一个序号</p>
<p>就像下图这样</p>
<p><img src="http://cdn.anruence.com/sasasas.png" alt="image"></p>
<h4 id="3-2-2-重点逻辑"><a href="#3-2-2-重点逻辑" class="headerlink" title="3.2.2 重点逻辑"></a>3.2.2 重点逻辑</h4><p>在半双工通信模式下 </p>
<ul>
<li>client端：增加seq，为数据包绑定特有的id buffer</li>
<li>server端：在返回的数据包里绑定id buffer</li>
</ul>
<h4 id="3-2-3-代码"><a href="#3-2-3-代码" class="headerlink" title="3.2.3 代码"></a>3.2.3 代码</h4><p>client.js</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"><span class="keyword">const</span> socket  = <span class="keyword">new</span> net.Socket(&#123;&#125;);</span><br><span class="line"><span class="keyword">let</span> seq =  <span class="number">0</span>;</span><br><span class="line">socket.connect(&#123;</span><br><span class="line">    host:<span class="string">'127.0.0.1'</span>,</span><br><span class="line">    port:<span class="number">6002</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> LESSON_IDS = [</span><br><span class="line">    <span class="string">"136797"</span>,</span><br><span class="line">    <span class="string">"136798"</span>,</span><br><span class="line">    <span class="string">"136799"</span>,</span><br><span class="line">    <span class="string">"136800"</span>,</span><br><span class="line">    <span class="string">"136801"</span>,</span><br><span class="line">    <span class="string">"136803"</span>,</span><br><span class="line">    <span class="string">"136804"</span>,</span><br><span class="line">    <span class="string">"136806"</span>,</span><br><span class="line">    <span class="string">"136807"</span>,</span><br><span class="line">    <span class="string">"136808"</span>,</span><br><span class="line">    <span class="string">"136809"</span>,</span><br><span class="line">    <span class="string">"141994"</span>,</span><br><span class="line">    <span class="string">"143517"</span>,</span><br><span class="line">    <span class="string">"143557"</span>,</span><br><span class="line">    <span class="string">"143564"</span>,</span><br><span class="line">    <span class="string">"143644"</span>,</span><br><span class="line">    <span class="string">"146470"</span>,</span><br><span class="line">    <span class="string">"146569"</span>,</span><br><span class="line">    <span class="string">"146582"</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> index = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * LESSON_IDS.length);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">socket.on(<span class="string">'data'</span>,<span class="function">(<span class="params">buffer</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> seqBuffer = buffer.slice(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">const</span> titleBuffer = buffer.slice(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(seqBuffer.readInt16BE(),titleBuffer.toString())</span><br><span class="line">    <span class="comment">// 请求回来之后再次发送</span></span><br><span class="line">    index = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * LESSON_IDS.length);</span><br><span class="line">    socket.write(encode(index));</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encode</span>(<span class="params">index</span>)</span>&#123;</span><br><span class="line">    buffer = Buffer.alloc(<span class="number">6</span>);</span><br><span class="line">    buffer.writeInt16BE(seq)</span><br><span class="line">    buffer.writeInt32BE(</span><br><span class="line">        LESSON_IDS[index],<span class="number">2</span></span><br><span class="line">    )</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'发包'</span>,seq,LESSON_IDS[index])</span><br><span class="line">    seq++;</span><br><span class="line">    <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    index = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * LESSON_IDS.length);</span><br><span class="line">    socket.write(encode(index));</span><br><span class="line">&#125;, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// for(let k = 0;k&lt; 100; k++)&#123;</span></span><br><span class="line"><span class="comment">//     index = Math.floor(Math.random() * LESSON_IDS.length);</span></span><br><span class="line"><span class="comment">//     socket.write(encode(index));</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<p>server.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"></span><br><span class="line">net.createServer(<span class="function">(<span class="params">socket</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// socket.write</span></span><br><span class="line">    socket.on(<span class="string">'data'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">buffer</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// console.log('buffer',buffer)</span></span><br><span class="line">        <span class="keyword">const</span> seqBuffer = buffer.slice(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">const</span> lessonId = buffer.readInt32BE(<span class="number">2</span>);</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> buffer = Buffer.concat([</span><br><span class="line">            seqBuffer,</span><br><span class="line">            Buffer.from(LESSON_DATA[lessonId])</span><br><span class="line">        ])</span><br><span class="line">        socket.write(buffer)</span><br><span class="line">    &#125;,<span class="number">10</span>+<span class="built_in">Math</span>.random() * <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">.listen(<span class="number">6002</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假数据</span></span><br><span class="line"><span class="keyword">const</span> LESSON_DATA = &#123;</span><br><span class="line">    <span class="number">136797</span>: <span class="string">"01 | 课程介绍"</span>,</span><br><span class="line">    <span class="number">136798</span>: <span class="string">"02 | 内容综述"</span>,</span><br><span class="line">    <span class="number">136799</span>: <span class="string">"03 | Node.js是什么？"</span>,</span><br><span class="line">    <span class="number">136800</span>: <span class="string">"04 | Node.js可以用来做什么？"</span>,</span><br><span class="line">    <span class="number">136801</span>: <span class="string">"05 | 课程实战项目介绍"</span>,</span><br><span class="line">    <span class="number">136803</span>: <span class="string">"06 | 什么是技术预研？"</span>,</span><br><span class="line">    <span class="number">136804</span>: <span class="string">"07 | Node.js开发环境安装"</span>,</span><br><span class="line">    <span class="number">136806</span>: <span class="string">"08 | 第一个Node.js程序：石头剪刀布游戏"</span>,</span><br><span class="line">    <span class="number">136807</span>: <span class="string">"09 | 模块： CommonJS规范"</span>,</span><br><span class="line">    <span class="number">136808</span>: <span class="string">"10 | 模块：使用模块规范改造石头剪刀布游戏"</span>,</span><br><span class="line">    <span class="number">136809</span>: <span class="string">"11 | 模块：npm"</span>,</span><br><span class="line">    <span class="number">141994</span>: <span class="string">"12 | 模块：Node.js内置模块"</span>,</span><br><span class="line">    <span class="number">143517</span>: <span class="string">"13 | 异步：非阻塞I/O"</span>,</span><br><span class="line">    <span class="number">143557</span>: <span class="string">"14 | 异步：异步编程之callback"</span>,</span><br><span class="line">    <span class="number">143564</span>: <span class="string">"15 | 异步：事件循环"</span>,</span><br><span class="line">    <span class="number">143644</span>: <span class="string">"16 | 异步：异步编程之Promise"</span>,</span><br><span class="line">    <span class="number">146470</span>: <span class="string">"17 | 异步：异步编程之async/await"</span>,</span><br><span class="line">    <span class="number">146569</span>: <span class="string">"18 | HTTP：什么是HTTP服务器？"</span>,</span><br><span class="line">    <span class="number">146582</span>: <span class="string">"19 | HTTP：简单实现一个HTTP服务器"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到结果</p>
<p><img src="http://cdn.anruence.com/gif5%E6%96%B0%E6%96%87%E4%BB%B6.gif" alt="image"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们在大量前置知识的基础上，一步步推导出了全双工通道的搭建，当然了，这是不完整的，还有一些情况需要处理<br>回顾一下全双工通道搭建过程</p>
<ul>
<li>关键在于应用层协议需要有标记包号的字段✅</li>
<li>处理以下情况，需要有标记包长的字段<ul>
<li>出现原因：TCP底层优化机制，把同时发的一些包拼起来</li>
<li>粘包❎</li>
<li>不完整包❎</li>
</ul>
</li>
<li>错误处理<ul>
<li>网络等 </li>
</ul>
</li>
</ul>
<p>希望读完本文，你会对RPC通道有些粗浅的认识</p>
<p>未完待续..</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript下的setTimeout(fn,0)意味着什么？[转]</title>
    <url>/2018/01/16/setTimeout(fn,0)/</url>
    <content><![CDATA[<p>近期在研究异步编程的我对于setTimeout之类的东西异常敏感。在SegmentFault上看到了一个问题《关于SetTimeout时间设为0时》：提问者读了一篇文章，原文解释setTimeout延迟时间为0时会发生的事情，提问者提出了几个文章中的几个疑点。读了那篇文章之后发现原文的作者对于setTimeout的理解和自己的认知有点出入，于是编写了相关测试的代码以求答案。最终编写了这篇文章。</p>
<p>本文内容如下：</p>
<p>起因<br>单线程的JavaScript<br>setTimeout背后意味着什么<br><a id="more"></a><br>起因<br>上午在SegmentFault上看到了这个问题《关于SetTimeout 时间设为0时》（注：SegmentFault正在调整备案，如不能访问，请点击这里），原提问者注明了问题来源：《JS setTimeout延迟时间为0的详解》。这个问题来源也是转载的，我后来找到了出处。<br>在问题来源的那篇的文章中（后者），讲述了JS是单线程引擎：它把任务放到队列中，不会同步去执行，必须在完成一个任务后才开始另外一个任务。<br>而后，转载的那篇文章列出并补充了原文的栗子：</p>
<p>&lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01//EN” “<a href="http://www.w3.org/TR/html4/strict.dtd&quot;&gt;" target="_blank" rel="noopener">http://www.w3.org/TR/html4/strict.dtd&quot;&gt;</a></p>
<p><html></html></p>
<p><head><meta name="generator" content="Hexo 3.9.0"><br>    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><br>    <title>setTimeout</title><br>    <script type="text/javascript"><br>        function get(id) {<br>            return document.getElementById(id);<br>        }<br>        window.onload = function () {<br>            //第一个例子：未使用setTimeout<br>            get(‘makeinput’).onmousedown = function () {<br>                var input = document.createElement(‘input’);<br>                input.setAttribute(‘type’, ‘text’);<br>                input.setAttribute(‘value’, ‘test1’);<br>                get(‘inpwrapper’).appendChild(input);<br>                input.focus();<br>                input.select();<br>            }<br>            //第二个例子：使用setTimeout<br>            get(‘makeinput2’).onmousedown = function () {<br>                var input = document.createElement(‘input’);<br>                input.setAttribute(‘type’, ‘text’);<br>                input.setAttribute(‘value’, ‘test1’);<br>                get(‘inpwrapper2’).appendChild(input);<br>                //setTimeout<br>                setTimeout(function () {<br>                    input.focus();<br>                    input.select();<br>                }, 0);<br>            }<br>            //第三个例子，onkeypress输入的时候少了一个值<br>            get(‘input’).onkeypress = function () {<br>                get(‘preview’).innerHTML = this.value;<br>            }<br>        }<br>    </script><br></head></p>
<p><body><br>    <h1><code>setTimeout</code></h1><br>    <h2>1、未使用 <code>setTimeout</code></h2><br>    <button id="makeinput">生成 input</button><br>    <p id="inpwrapper"></p></body></p>
<pre><code>&lt;h2&gt;2、使用 &lt;code&gt;setTimeout&lt;/code&gt;&lt;/h2&gt;
&lt;button id=&quot;makeinput2&quot;&gt;生成 input&lt;/button&gt;
&lt;p id=&quot;inpwrapper2&quot;&gt;&lt;/p&gt;


&lt;h2&gt;3、另一个例子&lt;/h2&gt;
&lt;p&gt;
    &lt;input type=&quot;text&quot; id=&quot;input&quot; value=&quot;&quot; /&gt;&lt;span id=&quot;preview&quot;&gt;&lt;/span&gt;
&lt;/p&gt;
</code></pre><p><br><br>代码运行实例请戳这里。<br>原文中有这么一段话，描述的有点抽象：</p>
<p>JavaScript引擎在执行onmousedown时，由于没有多线程的同步执行，不可能同时去处理刚创建元素的focus 和select方法，由于这两个方法都不在队列中，在完成onmousedown后，JavaScript 引擎已经丢弃了这两个任务，正如第一种情况。而在第二种情况中，由于setTimeout可以把任务从某个队列中跳脱成为新队列，因而能够得到期望的结果。</p>
<p>我看到这里就觉得非常不对劲了。因为按照这种任务会被丢弃的说法，那么只要在事件触发的函数中再触发其他的事件都会被丢弃，浏览器是绝对不会这么做的，于是我编写了测试代码：</p>
<pre><code>window.onload = function () {
    //第一个例子：未使用setTimeout
    get(&apos;makeinput&apos;).onmousedown = function () {
        var input = document.createElement(&apos;input&apos;);
        input.setAttribute(&apos;type&apos;, &apos;text&apos;);
        input.setAttribute(&apos;value&apos;, &apos;test1&apos;);
        get(&apos;inpwrapper&apos;).appendChild(input);
        //按照文中的理论，这里的click不会被触发，但它却成功触发了
        get(&apos;inpwrapper&apos;).click();//触发了inpwrapper的onclick事件
    }
    get(&apos;inpwrapper&apos;).onclick = function () {
        alert(&apos;linkFly&apos;);
    };
}
</code></pre><p>下面的onclick()最终是执行了：弹出了”linkFly”。</p>
<p>而在转载的文中为了引人深思，又提出了第三个例子：</p>
<p>在此，你可以看看例子 3，它的任务是实时更新输入的文本，现在请试试，你会发现预览区域总是落后一拍，比如你输 a, 预览区并没有出现 a, 在紧接输入b时，a才不慌不忙地出现。</p>
<p>而文中最后留给大家的思考的问题，解决方案就是使用setTimeout再次调整浏览器的代码任务运行队列。</p>
<pre><code>var domInput = get(&apos;input&apos;);
domInput.onkeypress = function () {
    setTimeout(function () {
        //第三个例子的问题就这样就会被解决
        get(&apos;preview&apos;).innerHTML = domInput.value;
    })
}
</code></pre><p>原文和转载的文章中都对setTimeout(fn,0)进行了思考，但原文指出的问题本质漏洞百出，所以才出了这篇文章，我们的正文，现在开始。</p>
<p>单线程的JavaScript<br>首先我们来看浏览器下的JavaScript：</p>
<ul>
<li>javascriipt引擎线程</li>
<li>GUI渲染线程</li>
<li>浏览器事件触发线程</li>
</ul>
<p>javascript引擎是基于事件驱动单线程执行的，JS引擎一直等待着任务队列中任务的到来，然后加以处理，浏览器无论什么时候都只有一个JS线程在运行JS程序。<br>GUI渲染线程负责渲染浏览器界面，当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时,该线程就会执行。但需要注意 GUI渲染线程与JS引擎是互斥的，当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。<br>事件触发线程，当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。这些事件可来自JavaScript引擎当前执行的代码块如setTimeOut、也可来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等，但由于JS的单线程关系所有这些事件都得排队等待JS引擎处理。（当线程中没有执行任何同步代码的前提下才会执行异步代码）<br>js的单线程在这一段面试代码中尤为明显（理解即可，请不要尝试…浏览器会假死的）：</p>
<pre><code>var isEnd = true;
window.setTimeout(function () {
    isEnd = false;//1s后，改变isEnd的值
}, 1000);
//这个while永远的占用了js线程，所以setTimeout里面的函数永远不会执行
while (isEnd);
//alert也永远不会弹出
alert(&apos;end&apos;);
</code></pre><p>在我工作中对js的认识，个人认为js的任务单位是函数。即，一个函数表示着一个任务，这个函数没有执行结束，则在浏览器中当前的任务即没有结束。<br>上面的代码中，当前任务因为while的执行而造成永远无法执行，所以后面的setTimeout也永远不会被执行。它在浏览器的任务队列中如图所示：</p>
<p>Browser Event</p>
<p>setTimeout背后意味着什么<br>这篇文章一直在使用setTimeout为我们展现和理解js单线程的设计，只是它错误的使用了Event来进行演示，并过度解读了Event。<br>这里原文和转载的文章忽略了这些基础的事件触发，而且也偏偏挑了两套本身设计就比较复杂的API：onmouseXXX系和onkeyXXX系。</p>
<p>onKeyXXX系的API触发顺序如图：</p>
<p>onKeyXXX</p>
<p>而我个人所理解它们对应的功能：</p>
<p>onkeydown - 主要获取和处理当前按下按键，例如按下Enter后进行提交。在这一层，并没有更新相关DOM元素的值。<br>onkeypress - 主要获取和处理长按键，因为onkeypress在长按键盘的情况下会反复触发直到释放，这里并没有更新相关DOM元素的值，值得注意的是：keypress之后才会更新值，所以在长按键盘反复触发onkeypress事件的时候，后一个触发的onkeypress能得到上一个onkeypress的值。所以出现了onkeypress每次取值都会是上一次的值而不是最新值。<br>onkeyup - 触发onkeyup的DOM元素的值在这里已经更新，可以拿到最新的值，所以这里主要处理相关DOM元素的值。<br>流程就是上面的图画的那样：</p>
<p>onkeydown =&gt; onkeypress =&gt; onkeyup</p>
<p>使用了setTimeout之后，流程应该是下面这样子的：</p>
<p>onkeydown =&gt; onkeypress =&gt; function =&gt; onkeyup</p>
<p>使用setTimeout(fn,0)之后，在onkeypress后面插入了我们的函数function。上面所说，浏览器在onkeypress之后就会更新相关DOM元素的状态（input[type=text]的value），所以我们的function里面可以拿到最新的值。<br>所以我们在onkeypress里面挂起setTimeout能拿到正确的值，下面的代码可以测试使用setTimeout(fn,0)之后的流程：</p>
<pre><code>window.onload = function () {
    var domInput = get(&apos;input&apos;), view = get(&apos;preview&apos;);
    //onkeypress兼容性和说明：http://www.w3school.com.cn/jsref/jsref_events.asp
    domInput.onkeypress = function () {
        setTimeout(function () {
            //这个函数在keypress之后，keyup之前执行
            console.log(&apos;linkFly&apos;);
        });
    };
    domInput.onkeyup = function () {
        console.log(&apos;up&apos;);
    };
};
</code></pre><p>然后我们再来谈谈原代码中的示例1和示例2，示例1和示例2的区别在这里：</p>
<pre><code>//示例1
input.focus();
input.select();

//示例2
setTimeout(function () {
    input.focus();
    input.select();
}, 0);
</code></pre><p>原文章中说示例1的focus()和select()在onmousedown事件中被丢弃，从而导致了没有选中，但原文的作者忽略了他注册的事件是：onmousedown。<br>我们暂且不讨论onmouseXXX系的其他API，我们仅关注和点击相关的，它们的执行顺序是：</p>
<p>mousedown - 鼠标按钮按下<br>mouseup - 鼠标按钮释放<br>click - 完成单击<br>我们在onmousedown里面新建了input，并且选中input的值（调用了input.focus(),input.select()）。<br>那么为什么没有被选中呢？这样，我们来做一次测试，看看我们的onfocus到底是被丢弃了，还是触发了。我们把原文的代码进行改写：</p>
<pre><code>window.onload = function () {
    var makeBtn = get(&apos;makeinput&apos;);
    //观察onmouseXXX系完成整个单击的顺序
    makeBtn.onmousedown = function (e) {
        console.log(e.type);
        var input = document.createElement(&apos;input&apos;);
        input.setAttribute(&apos;type&apos;, &apos;text&apos;);
        input.setAttribute(&apos;value&apos;, &apos;test1&apos;);
        get(&apos;inpwrapper&apos;).appendChild(input);
        input.onfocus = function () {//观察我们新生成的input什么时候获取焦点的，或者它有没有像原文作者说的那样被丢弃了
            console.info(&apos;input focus&apos;);
        };
        input.focus();
        input.select();
    }
    makeBtn.onclick = function (e) {
        console.log(e.type);
    };
    makeBtn.onmouseup = function (e) {
        console.log(e.type);
    };
    makeBtn.onfocus = function () {//观察我们生成按钮什么时候获取焦点的
        console.log(&apos;makeBtn focus&apos;);
    }
};
</code></pre><p>代码运行的结果是这样的：<br>onmouseXXX &amp; focus</p>
<p>我们的input focus执行了——那么它为什么没有获取到焦点呢？我们再看看后面执行的函数：我们点击的按钮，在mousedown之后，才获得焦点，也就是说：我们的input本来已经得到了focus()，但在onmousedown之后，我们点击的按钮才迟迟触发了自己的onfocus()，导致我们的input被覆盖。<br>我们再加上setTimeout进行测试：</p>
<pre><code>window.onload = function () {
    var makeBtn = get(&apos;makeinput&apos;);
    makeBtn.onmousedown = function (e) {
        console.log(e.type);
        var input = document.createElement(&apos;input&apos;);
        input.setAttribute(&apos;type&apos;, &apos;text&apos;);
        input.setAttribute(&apos;value&apos;, &apos;test1&apos;);
        get(&apos;inpwrapper&apos;).appendChild(input);
        input.onfocus = function () {
            console.info(&apos;input focus&apos;);
        };
        //我们加上setTimeout，看看会发生什么
        setTimeout(function () {
            input.focus();
            input.select();
        });
    }
    makeBtn.onclick = function (e) {
        console.log(e.type);
    };
    makeBtn.onmouseup = function (e) {
        console.log(e.type);
    };
    makeBtn.onfocus = function () {
        console.log(&apos;makeBtn focus&apos;);
    }
};
</code></pre><p>执行结果是这样：<br>onmouseXXX and settimeout</p>
<p>可以看见当我们点击”生成”按钮的时候，按钮的focus正确的执行了，然后才执行了input focus。<br>在示例1中，我们在onmousedown()中执行了input.focus()导致input得到焦点，而onmousedown之后，我们点击的按钮才迟迟得到了自己的焦点，造成了我们input刚拿到手还没焐热的焦点被转移。<br>而示例2中的代码，我们延迟了焦点，当按钮获得焦点之后，我们的input再把焦点抢过来，所以，使用setTimeout(fn,0)之后，我们的input可以得到焦点并选中文本。<br>这里值得思考的focus()的执行时机，根据这次测试观察，发现focus事件好像挂载在mousedown之内的最后面，而不是直接挂在mousedown的后面。它和mousedown仿佛是一体的。<br>我们使用setTimeout之前的任务流程是这样的（-&gt;表示在上一个任务中，=&gt;表示在上一个任务后）：</p>
<p><code>onmousedown -&gt; onmousedown中执行了input.focus() -&gt; button.onfocus =&gt; onmouseup =&gt; onclick</code></p>
<p>onmouseXXX事件流程</p>
<p>而我们使用了setTimeout之后的任务流程是这样的：</p>
<p><code>onmousedown -&gt; button.onfocus =&gt; input.focus =&gt; onmouseup =&gt; onclick</code></p>
<p>onmouseXXX+setTimeout事件流程</p>
<p>而从上面的流程上我们得知了另外的消息，我们还可以把input.focus挂在mouseup和click下，因为在这些事件之前，我们的按钮已经得到过焦点了，不会再抢我们的焦点了。</p>
<pre><code>makeBtn.click = function (e) {
    console.log(e.type);
    var input = document.createElement(&apos;input&apos;);
    input.setAttribute(&apos;type&apos;, &apos;text&apos;);
    input.setAttribute(&apos;value&apos;, &apos;test1&apos;);
    get(&apos;inpwrapper&apos;).appendChild(input);
    input.onfocus = function () {//观察我们新生成的input什么时候获取焦点的
        console.info(&apos;input focus&apos;);
    };
    input.focus();
    input.select();
}
</code></pre><p>我们应该认识到，利用setTimeout(fn,0)的特性，可以帮助我们在某些极端场景下，修正浏览器的下一个任务</p>
<p>总结：<br><strong>意思就是说input的focus有执行， 只是被button的mouseup影响了，所以要要把focus()放到后面执行<br>页面上只有一个元素能获得焦点，就这样而已。。</strong></p>
<p>参考和引用<br>JavaScript异步机制<br>什么是 Event Loop<br>javascript线程解释<br>JavaScript - 前端开发交流群：377786580</p>
<p>作者：linkFly<br>原文：<a href="http://www.cnblogs.com/silin6/p/4333999.html" target="_blank" rel="noopener">http://www.cnblogs.com/silin6/p/4333999.html</a><br>出处：<a href="http://www.cnblogs.com/silin6/" target="_blank" rel="noopener">www.cnblogs.com/silin6/</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>你不知道的JS系列-this指向</title>
    <url>/2019/03/26/this/</url>
    <content><![CDATA[<p>this是js中最复杂的机制之一</p>
<blockquote>
<p>任何足够先进的技术都和魔法无异  - Arthur C.Clarke</p>
</blockquote>
<a id="more"></a>
<p>但其实this机制并没有那么先进，是我们的臆想把它想复杂了，在缺乏认知的情况下，this对你来说就是魔法</p>
<h3 id="为什么要使用this？"><a href="#为什么要使用this？" class="headerlink" title="为什么要使用this？"></a>为什么要使用this？</h3><p>它提供了一种更优雅的方式来隐式传递一个对象引用，因此可以将API设计得更加简洁并且易于使用</p>
<h3 id="对于this的误解"><a href="#对于this的误解" class="headerlink" title="对于this的误解"></a>对于this的误解</h3><ol>
<li>指向函数自身</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">常见需要指向自身的场景是递归</span><br><span class="line">匿名的函数无法指向自身</span><br><span class="line">传统的<span class="selector-tag">arguments</span><span class="selector-class">.callee</span>已经弃用</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>指向函数的词法作用域</li>
</ol>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">this在任何情况下都不指向函数的词法作用域，在<span class="keyword">js</span>内部作用域和对象相似，可见的标识符都是它的属性,但是作用域“对象”无法通过<span class="keyword">js</span>代码访问，它存在于<span class="keyword">JS</span>引擎内部</span><br></pre></td></tr></table></figure>
<h3 id="this到底是什么？"><a href="#this到底是什么？" class="headerlink" title="this到底是什么？"></a>this到底是什么？</h3><p>this是运行时进行绑定的 并不是在编写时绑定的 它的上下文取决于函数调用时的各种条件 this绑定和函数声明的位置没有任何关系 只取决于函数的调用方式</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">当一个函数调用时 会创建一个活动记录（执行上下文）这个记录会包含函数在哪里被调用（调用栈）函数的调用方法 传入的参数等 <span class="keyword">this</span>就是记录的其中一个属性会在函数执行的过程中用到</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>时函数被调用时发生的绑定 指向什么完全取决于函数在哪里被调用</span><br></pre></td></tr></table></figure>
<h4 id="调用位置"><a href="#调用位置" class="headerlink" title="调用位置"></a>调用位置</h4><p>寻找”函数被调用的位置”<br>需要分析调用栈（为了到达当前执行位置所调用的所有函数）</p>
<h4 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h4><p>找到调用位置 然后按照结论中的四条规则判断</p>
<h4 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h4><p>独立函数调用时，如果在严格模式下，就绑定到undefined 否则绑定到全局对象 </p>
<h4 id="隐式绑定-对象上的函数调用"><a href="#隐式绑定-对象上的函数调用" class="headerlink" title="隐式绑定(对象上的函数调用)"></a>隐式绑定(对象上的函数调用)</h4><p>当函数引用有上下文对象时 隐式绑定规则会把函数中的this绑定到这个上下文对象</p>
<p><strong>对象属性引用链中只有最顶层或者说最后一层会影响调用位置</strong></p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">  console.log(this.a)</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">obj2</span> = <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">  a:42,</span></span></span><br><span class="line"><span class="function"><span class="comment">  foo:foo</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = <span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  a:2,</span></span><br><span class="line"><span class="comment">  obj2:obj2</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"></span><br><span class="line">obj1.obj2.foo(); <span class="comment">//42</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">10</span>,</span><br><span class="line">    c: <span class="keyword">this</span>.a + <span class="number">20</span>,</span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.c); <span class="comment">//40</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.fn()); <span class="comment">//10</span></span><br></pre></td></tr></table></figure>
<p>单独的{}是不会形成新的作用域的，因此这里的<code>this.a</code>，由于并没有作用域的限制，所以它仍然处于全局作用域之中。所以这里的<code>this</code>其实是指向的<code>window</code>对象。</p>
<p><strong>被隐式绑定的函数会丢失绑定对象而执行默认绑定规则 下面是两个场景</strong></p>
<p>1.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  a:<span class="number">2</span>,</span><br><span class="line">  foo:foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = obj1.foo; <span class="comment">//函数别名</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"global"</span>; <span class="comment">//全局属性a</span></span><br><span class="line">bar(); <span class="comment">//bar引用的是foo本身 因此此时的bar其实是一个不带任何修饰符的函数调用 因此使用了默认绑定</span></span><br></pre></td></tr></table></figure>
<p><strong>2.当传入回调函数时 使用默认绑定规则</strong></p>
<p>参数传递就是一种隐式赋值，因此我们传入函数时也会被隐式赋值</p>
<p>如果把函数传入语言内置函数 结果也是一样的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dofoo</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">  fn();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  a:<span class="number">2</span>,</span><br><span class="line">  foo:foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"global mama"</span>; <span class="comment">//全局属性a</span></span><br><span class="line"></span><br><span class="line">dofoo(obj1.foo) <span class="comment">//global mama</span></span><br><span class="line"></span><br><span class="line">setTimeout(obj1.foo,<span class="number">100</span>) <span class="comment">//global mama 将函数传入语言内置的函数</span></span><br><span class="line">相当于</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setTimeout</span>(<span class="params">fn,delay</span>)</span>&#123;</span><br><span class="line"><span class="comment">//等待delay之后</span></span><br><span class="line">fn() </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="显式绑定-使用call-apply-bind"><a href="#显式绑定-使用call-apply-bind" class="headerlink" title="显式绑定(使用call apply bind)"></a>显式绑定(使用call apply bind)</h4><p>通过固定this来修复，可以在某个对象上强制调用函数<br><code>使用 call apply 或者bind</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">他们的第一个参数式对象，它们会把这个对象绑定到<span class="keyword">this</span>，接着在调用函数时指定这个<span class="keyword">this</span> 因为你可以直接指定<span class="keyword">this</span>的绑定对象 因此我们称之为显式绑定</span><br></pre></td></tr></table></figure>
<p>如果 foo.call(1) //一个原始值当作对象 这个原始值会转换成它的对象形式(装箱)</p>
<p><strong>可惜，显示绑定无法解决丢失绑定的问题</strong></p>
<p>但是显示绑定的一个变种“硬绑定”可以解决这个问题</p>
<p><strong>硬绑定</strong>：无论何时调用函数bar它总会手动在obj调用foo 这种绑定是一种显式的强制绑定</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  a:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  a:<span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  foo.call(obj1)</span><br><span class="line">&#125;</span><br><span class="line">bar(); <span class="comment">//2</span></span><br><span class="line">setTimeout(bar,<span class="number">100</span>) <span class="comment">//2</span></span><br><span class="line">bar.call(obj2) <span class="comment">// 2 硬绑定的bar不可能再修改它的this</span></span><br></pre></td></tr></table></figure>
<p>由于硬绑定是一种常用的模式，所以ES5提供了内置的方法<br><code>Function.prototype.bind</code></p>
<p>了解了用法 我们来看一个demo</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn.bind().bind(a)() <span class="comment">// ?</span></span><br></pre></td></tr></table></figure>
<p>答案应该是<code>window</code> 你回答对了吗</p>
<p>事实上 我么可以改写一下</p>
<p>它类似于</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="keyword">this</span>)&#125;</span><br><span class="line"><span class="keyword">let</span> fn2 = <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply();</span><br><span class="line">  &#125;.apply(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn2() <span class="comment">//window</span></span><br></pre></td></tr></table></figure>
<p>这样儿结果能猜到了吗</p>
<p>fn中的this永远由<code>第一个bind</code>决定 所以 结果永远是window</p>
<h4 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h4><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">js中的构造函数只是一些使用<span class="keyword">new</span><span class="type"></span>操作符时被调用的函数 他们不并不属于某个类也不会去实例化一个类 他们只是被<span class="keyword">new</span><span class="type"></span>操作符调用的普通函数</span><br><span class="line"></span><br><span class="line">插播<span class="keyword">new</span><span class="type"></span>调用的时候会自动执行下面的操作</span><br><span class="line"><span class="number">1.</span> 创建（构造一个全新的对象）</span><br><span class="line"><span class="number">2.</span> 这个对象会被执行原型链接</span><br><span class="line"><span class="number">3.</span> 这个信贷想回绑定到函数调用的<span class="built_in">this</span></span><br><span class="line"><span class="number">4.</span> 如果函数没有返回其他对象那么<span class="keyword">new</span><span class="type"></span>表达式中的函数调用会自动返回这个新对象</span><br></pre></td></tr></table></figure>
<p>由此可以知道 new操作符调用时，this指向生成的新对象<br>⚠️new 调用时的返回值，如果没有显式返回对象或者函数，才会返回新对象<br>关于这一点</p>
<p><a href>这应该是一篇关于模拟实现JS的new操作符的文章</a></p>
<h4 id="绑定优先级"><a href="#绑定优先级" class="headerlink" title="绑定优先级"></a>绑定优先级</h4><p>new调用 &gt;显示绑定(apply,call,bind) &gt; 隐式绑定（对象上的函数调用） &gt; 默认绑定</p>
<h4 id="绑定例外"><a href="#绑定例外" class="headerlink" title="绑定例外"></a>绑定例外</h4><p>规则总有例外，这里也一样</p>
<p>当你把<code>null</code>或者<code>undefined</code>作为<code>this</code>的绑定对象传入<code>call apply</code>或者<code>bind</code> 这些在调用时候会被忽略应用默认规则<br>应用场景：当你要传入参数时候 如果函数不关心this的话 你可以传入null当作一个占位值 但是这种方式不可取 绑定this可能会引起副作用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line">foo.call(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure>
<p>一种更安全的this</p>
<p><code>Object.create(null)</code>创建的空对象不会创建<code>object.prototype</code> 比<code>{}</code>更空 比<code>null</code>的语义更清楚</p>
<p>代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a,b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> w = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">foo.apply(w,[<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用bind()进行柯里化</span></span><br><span class="line"><span class="keyword">var</span> bar = foo.bind(w,<span class="number">2</span>)</span><br><span class="line">bar(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p><strong>间接引用</strong><br>你会有意无意的创建一个函数的间接引用，在这种情况下，调用这个函数会应用默认规则<br><strong>它最容易在赋值时产生</strong><br>类似这样儿的</p>
<p><code>(p.foo = o.foo)();</code> 它的返回值是目标函数的引用，因此调用的位置是<code>foo()</code>而不是<code>p.foo()</code>或者<code>o.foo()</code>所以使用默认绑定</p>
<h4 id="箭头函数调用模式"><a href="#箭头函数调用模式" class="headerlink" title="箭头函数调用模式"></a>箭头函数调用模式</h4><p>先看箭头函数和普通函数的重要区别：</p>
<ol>
<li>没有自己的this、super、arguments和new.target绑定。</li>
<li>不能使用new来调用。</li>
<li>没有原型对象。</li>
<li>不可以改变this的绑定。</li>
<li>形参名称不能重复。</li>
</ol>
<hr>
<p>箭头函数中没有<code>this</code>绑定，必须通过查找作用域链来决定其值。<br>如果箭头函数被非箭头函数包含，则<code>this</code>绑定的是最近一层非箭头函数的<code>this</code>，否则<code>this</code>的值则被设置为全局对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'window'</span>;</span><br><span class="line"><span class="keyword">var</span> student = &#123;</span><br><span class="line">    name: <span class="string">'ma'</span>,</span><br><span class="line">    doSth: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// var self = this;</span></span><br><span class="line">        <span class="keyword">var</span> arrowDoSth = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// console.log(self.name);</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">        arrowDoSth();</span><br><span class="line">    &#125;,</span><br><span class="line">    arrowDoSth2: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">student.doSth(); <span class="comment">// 'ma'</span></span><br><span class="line">student.arrowDoSth2(); <span class="comment">// 'window'</span></span><br></pre></td></tr></table></figure>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul>
<li>this不指向函数自身</li>
<li>this不指向函数的词法作用域，当你想要把this和词法作用域查找混合使用时，一定要提醒自己 这是无法实现的</li>
<li>this实际上是在函数被调用时发生绑定的，指向什么完全取决于函数在哪里被调用</li>
<li>如果要判断一个运行中函数的this绑定 就需要找到这个函数的直接调用位置 找到之后按照下面这四条规则判断this的绑定对象</li>
</ul>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>由new调用？绑定到新创建的对象</span><br><span class="line"><span class="number">2.</span>由call或apply或bind调用(显示绑定)？绑定到指定的对象</span><br><span class="line"><span class="number">3.</span>由上下文对象调用（隐式绑定）？绑定到上下文对象</span><br><span class="line"><span class="number">4.</span>如果都不是的话 使用默认绑定，如果在严格模式下，就绑定到undefined 否则绑定到全局对象</span><br></pre></td></tr></table></figure>
<ul>
<li>ES6中的箭头函数不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定this,它会继承外层函数调用的this绑定(无论this绑定到什么),这跟ES6之前代码中的<code>self=this</code>机制一样（实际上箭头函数将程序猿们常犯的一个错误：<font color="red">混淆this绑定规则和词法作用域规则 </font>给标准化了,这点容易造成误解）</li>
<li>DOM事件函数：一般指向绑定事件的DOM元素，但有些情况绑定到全局对象（比如IE6~IE8的attachEvent）</li>
</ul>
<p>检验一下学习成果</p>
<p><a href="https://www.cnblogs.com/xxcanghai/p/5189353.html" target="_blank" rel="noopener">小小沧海：一道常被人轻视的前端JS面试题</a><br><a href="https://segmentfault.com/a/1190000010981003" target="_blank" rel="noopener">从这两套题，重新认识JS的this、作用域、闭包、对象</a></p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title>函数节流与防抖</title>
    <url>/2019/02/19/throttleAnddebounce/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>博客中的大部分文章 大部分都有一个引子，要说明的通常是一些零零碎碎或者大多耳熟能详的“知识点”</p>
<p>我认为遇到了问题 解决了问题 然后才会形成一个知识点而不是为了应用某个知识点去搭建场景，否则 真的是过目即忘<br>解决最近一个问题之前 并没有计划写关于防抖和节流的问题，问题引导你说 需要重视这一块儿了</p>
<p>此文系 不要再问我XX系列之 <font color="red">不要再问我函数节流和防抖了</font></p>
<a id="more"></a>
<h3 id="引出问题"><a href="#引出问题" class="headerlink" title="引出问题"></a>引出问题</h3><p>需求：记录用户的浏览深度</p>
<p><img src="/images/throllte/scroll.gif" alt="---"></p>
<p>一旦你使用了类似<code>scroll</code>的浏览器事件，触发频率比较高，若稍处理函数微复杂，需要较多的运算执行时间，响应速度跟不上触发频率，往往会出现延迟，会出现卡顿甚至引发假死</p>
<p>在资源有限的情况下 我们可以想办法只响应部分请求，事实上某些场景下的密集性请求，并不是我们需要的</p>
<p>此时 我并不知道 需要用 “防抖”这个晦涩的结论去解决，只知道目的是只是在<strong>浏览到</strong>这辆车的时候打点</p>
<hr>
<p><strong>那程序中要怎么体现<font color="red">我浏览到</font>这个概念呢？</strong></p>
<p>先要约定一件事<br>假设用户浏览到某一辆车之后停顿了超过你预设的时间值 就认为是浏览了</p>
<p>利用<code>setTimeout</code>实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> timeout = <span class="literal">null</span>;   </span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;        </span><br><span class="line">            clearTimeout(timeout);</span><br><span class="line">            timeout = setTimeout(fn,<span class="number">200</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>通过闭包保存一个定时器的标记<code>timeout</code>，再次执行的时候clear掉之前的，又重新计时 这就保证了 触发非常频繁的<code>scroll</code>事件合并成一次执行。当调用动作过n毫秒后，才会执行该动作，若在这n毫秒内又调用此动作则将重新计算执行时间 所以短时间内的连续动作永远只会触发一次，比如说用手指一直按住一个弹簧，它将不会弹起直到你松手为止</p>
<p>现在的效果</p>
<p><img src="/images/throllte/fangdou111.gif" alt="fangdou111"></p>
<p>好像受控制了 滑动过程中不会执行，一旦我们停下超过n毫秒，会执行一次<br>由此得到一个结论</p>
<font color="red">处理此类问题就是要保证函数在特定的时间内（你设置的延迟时间）不被再调用后执行</font>

<p>我们的问题解决了，上网随便一搜，它是一类<code>知识点</code>，越发感兴趣惹</p>
<hr>
<h3 id="得出结论-引出-防抖-与-节流"><a href="#得出结论-引出-防抖-与-节流" class="headerlink" title="得出结论 引出 防抖 与 节流"></a>得出结论 引出 防抖 与 节流</h3><p>所以说我们直接接触到了 <code>函数防抖</code>，在此之前 我觉得它是晦涩难懂的，现在越发清晰了<br>说到这儿 不得不提另一个兄弟 <code>函数节流</code>，因为应用场景相似而不相同，所以经常会被拿来比较</p>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>网上有很多关于两者的概念<br>简单来讲：<br><strong>函数节流</strong>：指定时间间隔内只会执行一次任务</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">🌰<span class="number">1</span></span><br><span class="line">一个比较形象的例子是如果将水龙头拧紧直到水是以水滴的形式流出，那你会发现每隔一段时间，就会有一滴水流出</span><br><span class="line">🌰<span class="number">2</span></span><br><span class="line">地铁闸机，每个人进入后<span class="number">3</span>秒后门关闭，等待下一个人进入。</span><br></pre></td></tr></table></figure>
<p><strong>函数防抖</strong>：任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行 （当一个动作连续触发，只执行最后一次）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">🌰</span><br><span class="line">用手指一直按住一个弹簧，它将不会弹起直到你松手为止</span><br></pre></td></tr></table></figure>
<p>看下图 感受一下三种环境对于<code>mousemove</code>事件回调的执行情况<br><img src="/images/throllte/fn_dou.png" alt="fn_dou"></p>
<p>竖线的疏密程度代表事件之行的频繁程度<br><strong>可以得到</strong>：</p>
<ul>
<li>正常情况下 函数执行的非常频繁</li>
<li>去抖之后很稀疏 只有当鼠标停止移动时才会执行一次</li>
<li>节流分布的比较均匀 每隔一段时间就会执行一次</li>
</ul>
<hr>
<h4 id="demo示例"><a href="#demo示例" class="headerlink" title="demo示例"></a>demo示例</h4><p>原生scroll</p>
<p><img src="/images/throllte/scrolldemo.gif" alt="scrolldemo"></p>
<p>函数去抖</p>
<p><img src="/images/throllte/debouce.gif" alt="debouce"></p>
<p>函数节流<br><img src="/images/throllte/throllte.gif" alt="throllte"></p>
<p>我们在真实场景中可以感受到无论采取哪种方案都会明显减少了回调的执行，得到了 都是用来控制某个函数在一定时间内执行次数的多少以优化高频率执行js代码的一种技巧，两者相似而又不同的结论</p>
<p>那么 我们 如何选择这两种方案？</p>
<h4 id="优化方案的应用场景"><a href="#优化方案的应用场景" class="headerlink" title="优化方案的应用场景"></a>优化方案的应用场景</h4><p>选择哪个 取决于应用场景</p>
<hr>
<p><strong>函数防抖</strong></p>
<p>如果你的需求是连续的时间只需要触发一次回调</p>
<p>比如：</p>
<ol>
<li>搜索框输入 可能需要等到用户最后一次输入完 再去发送请求</li>
<li>手机号，邮箱等输入检测</li>
<li>浏览器窗口的<code>resize</code> 你肯定要等到窗口调整完成后再进行渲染</li>
<li>scroll事件等</li>
</ol>
<p><strong>函数节流</strong></p>
<p>固定时间间隔执行的</p>
<p>比如：</p>
<ol>
<li>滚动加载 常常需要滚动到底部加载下一页</li>
<li>表单的重复提交</li>
<li>进度条的更新</li>
<li>高频的点击（比如抽奖）</li>
<li>高频的鼠标移动，游戏射击类的</li>
</ol>
<p>哦 理解了如何选择 下一个问题就是如何用</p>
<hr>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>引出问题模块 其实我们已经做到了 <code>防抖</code></p>
<p><strong>函数防抖（debounce）简单实现</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, <span class="keyword">this</span>.debounce(<span class="keyword">this</span>.scrollListener, <span class="number">500</span>), <span class="literal">false</span>);</span><br><span class="line">   </span><br><span class="line">  debounce = <span class="function">(<span class="params">fn, wait</span>) =&gt;</span> &#123;  </span><br><span class="line">        <span class="keyword">var</span> timeout = <span class="literal">null</span>;   </span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;        </span><br><span class="line">            <span class="keyword">if</span>(timeout !== <span class="literal">null</span>)&#123;</span><br><span class="line">                clearTimeout(timeout);</span><br><span class="line">            &#125;; </span><br><span class="line">            timeout = setTimeout(fn, wait);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>函数防抖在第一次执行时，有500ms的延迟。再次执行时，若前一个定时任务未执行完，则 clear 掉定时任务，重新定时</p>
<hr>
<p><strong>函数节流（throttle）</strong></p>
<p>定时器版本实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _.throttle = <span class="function">(<span class="params">func, wait</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> timer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">     <span class="comment">// 判断是否已空闲，如果在执行中，则直接return</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      func();</span><br><span class="line">      timer = <span class="literal">null</span>;</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>函数节流的目的，是为了限制函数一段时间内<strong>只能执行一次</strong> 使用<code>setTimeout</code>执行。在延时的时间内，方法若被触发，则直接退出方法。从而达到函数一段时间内只执行一次的目的</p>
<p>时间戳版简单实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> throttle = <span class="function">(<span class="params">func, wait</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> last = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> current_time = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">if</span> (current_time - last &gt; wait) &#123;</span><br><span class="line">      func.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      last = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其实现原理，通过比对上一次执行时间与本次执行时间的时间差与间隔时间的大小关系，来判断是否执行函数。若时间差大于间隔时间，则立刻执行一次函数。并更新上一次执行时间。</p>
<hr>
<h4 id="函数节流与函数防抖异同"><a href="#函数节流与函数防抖异同" class="headerlink" title="函数节流与函数防抖异同"></a>函数节流与函数防抖异同</h4><p>其实到这里应该比较能清晰的理解甚至选择适合真实场景的优化方案了</p>
<p><strong>相同点</strong></p>
<ul>
<li>都可以通过延时器实现</li>
<li>目的都是 降低回调执行频率 节约计算机资源</li>
</ul>
<p><strong>不同点</strong></p>
<ul>
<li><p>其实从两者的概念也能看出来</p>
</li>
<li><p>函数防抖：关注一定时间连续触发，只在最后执行一次</p>
</li>
<li>函数节流：一段时间内只执行一次。</li>
</ul>
<h3 id="写在最后的话"><a href="#写在最后的话" class="headerlink" title="写在最后的话"></a>写在最后的话</h3><p>很多时候 带着问题来验证结论 更能把自己置身到场景中考虑</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://jinlong.github.io/2016/04/24/Debouncing-and-Throttling-Explained-Through-Examples/" target="_blank" rel="noopener">https://jinlong.github.io/2016/04/24/Debouncing-and-Throttling-Explained-Through-Examples/</a><br><a href="https://github.com/hanzichi/underscore-analysis/issues/20" target="_blank" rel="noopener">https://github.com/hanzichi/underscore-analysis/issues/20</a><br><a href="https://segmentfault.com/a/1190000008768202" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008768202</a></p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>写在入职两周年</title>
    <url>/2019/03/22/twoYears/</url>
    <content><![CDATA[<p>博客计划</p>
]]></content>
  </entry>
  <entry>
    <title>一个页面从输入url到加载完成 这个过程发生了什么</title>
    <url>/2019/03/31/urlrender/</url>
    <content><![CDATA[<h4 id="先来了解以下-五层因特尔协议栈"><a href="#先来了解以下-五层因特尔协议栈" class="headerlink" title="先来了解以下 五层因特尔协议栈"></a>先来了解以下 五层因特尔协议栈</h4><ul>
<li>应用层（dns http） DNS解析成ip并完成http请求发送</li>
<li>传输层（tcp udp）三次握手四次挥手建立tcp链接</li>
<li>网络层 （ip ARP） IP寻址</li>
<li>数字链路层 将请求数据封装成帧</li>
<li>物理层 利用物理介质传输比特流</li>
</ul>
<a id="more"></a>
<h4 id="简介版本"><a href="#简介版本" class="headerlink" title="简介版本"></a>简介版本</h4><ol>
<li>浏览器根据请求的url交给DNS解析 找到这真实IP 向服务器发起请求</li>
<li>服务器交给后台处理完成后返回数据，浏览器接收文件（html,css javascript)等</li>
<li>浏览器对加载到的资源进行语法解析，构建相应的内部数据结构（Dom树 css树 render树等）</li>
<li>载入解析到的资源文件渲染页面完成</li>
</ol>
<h4 id="详细版本"><a href="#详细版本" class="headerlink" title="详细版本"></a>详细版本</h4><ol>
<li>浏览器开启一个线程来处理这个请求，对url进行判断，如果是http协议，则就按照web的方式来处理</li>
<li>浏览器解析url，一般我么输入的都是服务器域名，我们会先查找对应的ip</li>
<li>首先会查看浏览器的DNS缓存,如果存在，则域名解析到此完成</li>
<li>如果浏览器自身的缓存没有找到相应的条目，就会尝试读取操作系统的host文件来看时都存在对应的映射关系</li>
<li>如果host文件没有，继续查找本地的域名服务器</li>
<li>如果本地的域名服务器还没有找到的话 ，它就会向跟服务器发出请求，进行递归查询</li>
<li>查到了IP地址，会将记录存储在本地缓存，此时网络层便会通过ip地址寻得对应服务器的物理地址</li>
<li>寻得服务器的地址 客户端在网络传输层便可以和服务器通过三次握手建立TCPIP链接</li>
</ol>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">TCPIP请求</span><br><span class="line"></span><br><span class="line">http的本质就是TCP/IP请求</span><br><span class="line">需要经历三次握手建立链接 <span class="number">4</span>次挥手断开连接</span><br><span class="line">TCP将http长报文划分为短报文，通过三次握手与服务器建立链接进行可靠传输</span><br><span class="line"></span><br><span class="line">三次握手</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 客户端：你是XX服务器吗</span><br><span class="line"><span class="number">2.</span> 服务端：我是XX服务器，你是客户端吗？</span><br><span class="line"><span class="number">3.</span> 客户端：是的 我是客户端</span><br><span class="line">成功 </span><br><span class="line"></span><br><span class="line">四次挥手</span><br><span class="line">主动方：我已经关闭了向你那边的信息发送通道，只能被动接受信息了</span><br><span class="line">被动方：收到通道关闭信息</span><br><span class="line">被动方：我现在也关闭了</span><br><span class="line">主动方：收到消息 连接断开 之后双方无法通信</span><br><span class="line"></span><br><span class="line">TCPIP请求：浏览器在同一个域名下并发的TCP链接是有限制的（<span class="number">2</span><span class="number">-10</span>个）</span><br></pre></td></tr></table></figure>
<ol start="9">
<li>链接成功后 链路层将请求数据封装成帧</li>
<li>最后物理层通过物理介质进行传输</li>
<li>到了服务器就会通过相反的方式将数据一层一层的还原回去</li>
<li>请求到了后端服务器一般都会有统一的验证 如安全验证，跨域验证等，验证未通过就直接返回相应的http报文</li>
<li>验证通过后就会进入后台代码 此时程序收到请求执行相应的操作（如查询数据库等）</li>
<li>如果浏览器访问过 且缓存上有相应的资源便会与服务器最后的修改时间对比，一致便返回304 告诉浏览器可以使用本地缓存</li>
<li>前端浏览器接收到响应成功的报文便开始下载网页<br>下载完的网页交给浏览器的内核（渲染进程）进行处理</li>
</ol>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>根据顶部定义的DTD类型进行相应的解析方式</span><br><span class="line"><span class="bullet">* </span>渲染进程内部是多线程的 网页的解析会被交给内部的GUI渲染进程处理</span><br><span class="line"><span class="bullet">* </span>首先渲染进程中的html解释器将html网页和资源从字节流解释转化为字符流</span><br><span class="line"><span class="bullet">* </span>再通过词法分析器将字符流解释成词语</span><br><span class="line"><span class="bullet">* </span>之后通过语法分析器根据词语构成节点，最后通过这些节点组建一个DOM树</span><br><span class="line"><span class="bullet">* </span>这个过程中 如果遇到的DOM节点是js代码，就会调用js引擎对js代码进行解释执行。此时由于js引擎和GUI渲染进程的互斥，GUI渲染就会被挂起，渲染过程停止；如果js代码的运行中对dom树进行了修改，那么都没树的构建需要重新开始</span><br><span class="line"><span class="bullet">* </span>如果节点需要依赖其他资源（图片 css）便会调用网络模块的资源去加载它们，但他们是异步的所以不会阻塞当前dom树的构建</span><br><span class="line"><span class="bullet">* </span>如果遇到的是js资源url（没有标记异步）则需要停止当前dom的构建 直到js的资源加载并被js引擎执行后才继续构建dom</span><br><span class="line"><span class="bullet">* </span>对于css css解释器会将css文件解释成内部表示结构（同html解析 子节流-&gt;字符流-&gt;词语-&gt;节点），生成css规则树</span><br><span class="line"><span class="bullet">* </span>然后合并css树和dom树，生成render渲染树</span><br><span class="line"><span class="bullet">* </span>最后对render树进行布局和绘制，并将结果通过IO线程传递给Browser控制进程（浏览器主进程）进行显示</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>viewports剖析一</title>
    <url>/2017/08/03/viewports%E5%89%96%E6%9E%90%E4%B8%80/</url>
    <content><![CDATA[<p>因为工作的原因，很少有机会接触移动web开发，一直都还挺遗憾的，偶尔写几个页面也都是“按照套路”出牌，最近终于有空了解一些概念性的东西，记录一下<br>文中的图片为了说明问题均为<code>盗图</code>，具体出处会在文末注明</p>
<p>本文大概将以下几个概念以做对比</p>
<ul>
<li>PC<ul>
<li><a href="#line1"> <font face="STCAIYUN" size="3" color="blueGreen">设备的pixels和CSS的pixels</font></a></li>
<li><a href="#line2"> <font face="STCAIYUN" size="3" color="blueGreen">所谓的100%缩放</font></a></li>
<li><a href="#line3"> <font face="STCAIYUN" size="3" color="blueGreen">屏幕尺寸和浏览器尺寸</font></a></li>
<li><a href="#line4"> <font face="STCAIYUN" size="3" color="blueGreen">页面的滚动移位</font></a></li>
<li><a href="#line5"> <font face="STCAIYUN" size="3" color="blueGreen">viewport以及度量viewport</font></a></li>
<li><a href="#line6"> <font face="STCAIYUN" size="3" color="blueGreen">html元素以及度量html</font></a></li>
<li><a href="#line7"> <font face="STCAIYUN" size="3" color="blueGreen">关于事件坐标</font></a></li>
<li><a href="#line8"> <font face="STCAIYUN" size="3" color="blueGreen">媒体查询width/height与 device-width/height</font></a></li>
</ul>
</li>
<li>mobile<ul>
<li><a href="#line9"> <font face="STCAIYUN" size="3" color="blueGreen">mobile浏览器</font></a></li>
<li><a href="#line10"> <font face="STCAIYUN" size="3" color="blueGreen">两种viewport</font></a><ul>
<li><font face="STCAIYUN" size="3" color="red">layoutviewport</font></li>
<li><font face="STCAIYUN" size="3" color="red">visualviewport</font></li>
</ul>
</li>
<li><a href="#line11"> <font face="STCAIYUN" size="3" color="blueGreen">缩放 Zooming</font></a></li>
<li><a href="#line12"> <font face="STCAIYUN" size="3" color="blueGreen">屏幕尺寸</font></a></li>
<li><a href="#line13"> <font face="STCAIYUN" size="3" color="blueGreen">页面的滚动移位</font></a></li>
<li><a href="#line14"> <font face="STCAIYUN" size="3" color="blueGreen">html元素以及度量html</font></a></li>
<li><a href="#line15"> <font face="STCAIYUN" size="3" color="blueGreen">关于事件坐标</font></a></li>
<li><a href="#line16"> <font face="STCAIYUN" size="3" color="blueGreen">媒体查询width/height与 device-width/height</font></a></li>
<li><a href="#line17"> <font face="STCAIYUN" size="3" color="blueGreen">viewport的meta标签</font></a></li>
</ul>
</li>
</ul>
<p></p><p id="line1"></p>
<p><font face="STCAIYUN" color="#883958" size="3">设备的pixels和CSS的pixels</font><br></p><br><strong>设备的pixels</strong><br>    设备像素是我们直觉上觉得「靠谱」的像素。这些像素为你所使用的各种设备都提供了正规的分辨率<br>    大多数情况下能从<code>screen.width/height</code> 取出具体值<br>    当然了 设备的pixels对web开发人员几乎毫无用处<br>    这里只需要知道它的概念即可<br><strong>CSS的pixels</strong><br>这些就是那些控制你的样式表如何被渲染的像素<p></p>
<p>现代浏览器上的缩放是基于<code>伸展</code>pixels<br>所以 html元素上的宽度不会因为你缩放了200%而变成了两倍宽，它在形式上还是一倍宽 只不过占用了两倍的设备pixels<br>如下图1-1 有4个1pixels，缩放为100%的html元素 此时css pixels和设备的pixels完全重合<br><img src="/images/viewports/1.jpg" alt><br>此时我们如果缩小浏览器 css的pixels开始收缩，导致1单位的设备pixels 上重叠了多个css的pixels 如下图1-2<br><img src="/images/viewports/2.jpg" alt><br>如果放大浏览器 css的pixels就会放大 导致1单位的css pixels上重叠了多个设备pixels 如图1-3<br><img src="/images/viewports/3.jpg" alt><br>总而言之 你只需要关注CSS的pixels 这些pixels将指定你的样式被如何渲染<br>就像上面所说的 设备的pixels对开发人员无用 但是对用户有用，因为用户回手动缩放页面，这些开发人员不用关注 <font face="STCAIYUN" color="red" size="3">浏览器会自动保证你的css pixels会被伸展还是被收缩</font></p>
<p></p><p id="line2"></p>
<p><font face="STCAIYUN" color="#883958" size="3">所谓的100%缩放</font><br></p><p></p>
<p><font face="STCAIYUN" color="red" size="3">100% 缩放的情况下 1单位的的CSS pixels 严格等于1单位的设备pixels</font></p>
<p></p><p id="line3"></p>
<p><font face="STCAIYUN" color="#883958" size="3">屏幕尺寸和浏览器尺寸</font><br></p><br><strong>屏幕尺寸（Screen size）</strong><br>含义：用户的屏幕的完整大小<br>度量：设备的pixels 不会因为缩放而改变 是显示器的特征<br>对我们来说<font face="STCAIYUN" color="red" size="4">没用</font><br>获取方式<br>如下图1-4<br><img src="/images/viewports/4.jpg" alt><p></p>
<p><strong>浏览器尺寸（Window size）</strong><br>含义：包含<code>滚动条尺寸</code>的浏览器完整尺寸<br>度量：CSS pixels<br>浏览器内部尺寸，它定义了当前用户有多大区域。可供你的css布局占用<br>如下图1-5<br><img src="/images/viewports/5.jpg" alt></p>
<p></p><p id="line4"></p>
<p><font face="STCAIYUN" color="#883958" size="3">页面的滚动移位</font><br></p><br>含义：页面的移位<br>度量：CSS pixels<br>定义了页面（document）的相对于窗口远点的位移，可以利用这个特性获取用户滚动了多少的滚动条距离<br>如下图1-6<br><img src="/images/viewports/6.jpg" alt><p></p>
<p></p><p id="line5"></p>
<p><font face="STCAIYUN" color="#883958" size="3">viewport以及度量viewport</font><br></p><br><strong>viewport</strong><br>啊啊啊 终于提到viewport了 鸡冻<p></p>
<p><font face="STCAIYUN" color="red" size="3">划重点</font> <code>viewport</code>是控制<code>&lt;html&gt;</code>元素的容器  是<code>&lt;html&gt;</code>的爹</p>
<p>你发现了么？<br>百分比布局时 你定义的一个侧边栏宽度为10% 当你改变大小时 它的宽度会自动扩张和收缩  原理是啥<br>当然了 它的宽度是依赖父元素 假如它父元素就是<code>&lt;body&gt;</code> 那么<code>&lt;body&gt;</code>多宽？<br>向上类推 <code>&lt;body&gt;</code>的宽度取决于它的父元素<code>&lt;html&gt;</code><br>呃.. 废话好多 <code>&lt;html&gt;</code>宽度取决于它的父元素<br> <code>&lt;html&gt;</code>恰好等于浏览器的宽度 所以你的10%会占用浏览器宽度的10% 我们都是这么用的  今天深扒发现<br><code>&lt;html&gt;</code>宽度受<code>viewport</code>限制 ，等于<code>viewport</code>宽度的100%<br>也就是说<br><code>viewport</code>严格等于浏览器窗口<br>需要注意的是：<code>viewport</code>不是一个html的概念 所以不能通过CSS修改它</p>
<p><strong>真实页面宽度概念</strong><br>如果你放大页面几倍 如何标识页面宽度（此时已经有横向滚动条了，也就是说页面的内容溢出了<code>&lt;html&gt;</code>元素）<br>使用 document width<br>如图1-7<br><img src="/images/viewports/7.jpg" alt><br>如图1-8<br><img src="/images/viewports/8.jpg" alt><br><strong>度量viewport</strong><br>含义：viewport尺寸<br>度量：CSS pixels<br>如下图1-9<br><img src="/images/viewports/9.jpg" alt><br>document.documentElement 代表<font face="STCAIYUN" color="red" size="3">HTML文档根元素</font><code>&lt;html&gt;</code><br>来 先看张图<br><img src="/images/viewports/10.jpg" alt><br>这张图是在为<code>&lt;html&gt;</code>元素赋值25% 但是<code>document.documentElement.clientWidth</code>值仍然不变<br>说明<font face="STCAIYUN" color="red" size="3">document. documentElement. clientWidth/Height只会给出viewport的尺寸，而不管<html>元素尺寸如何改变</html></font></p>
<p><font face="STCAIYUN" color="#886" size="4">那么问题来了</font><br>我是不是也可以用<code>window.innerWidth</code>来定义<code>viewport</code><br>呃.<br>他与<code>document.documentElement.clientWidth</code>有一点细微的差别<br>前者不包含滚动条</p>
<p></p><p id="line6"></p>
<p><font face="STCAIYUN" color="#883958" size="3">html元素以及度量html</font><br></p><br><strong>html</strong><br>ta爹(<code>viewport</code>)如果<code>document.documentElement.clientWidth</code>表示那么<code>&lt;html&gt;</code>这样获取 <code>document.documentElement.offsetWidth</code><br><img src="/images/viewports/11.jpg" alt><br>如果给<code>&lt;html&gt;</code>元素赋值了宽度 那么<code>offsetWidth</code>就会真实的反映出来<p></p>
<p><img src="/images/viewports/12.jpg" alt></p>
<p></p><p id="line7"></p>
<p><font face="STCAIYUN" color="#883958" size="3">关于事件坐标</font><br></p><br><strong>pageX/Y, clientX/Y, screenX/Y</strong><p></p>
<ul>
<li>pageX/Y：从<html>原点到事件触发点的CSS的 pixels</html></li>
<li>clientX/Y：从viewport原点（浏览器窗口）到事件触发点的CSS的 pixels</li>
<li>screenX/Y：从用户显示器窗口原点到事件触发点的设备 的 pixels。<br>上图<br><img src="/images/viewports/13.jpg" alt><br><img src="/images/viewports/14.jpg" alt><br><img src="/images/viewports/15.jpg" alt></li>
</ul>
<p></p><p id="line8"></p>
<p><font face="STCAIYUN" color="#883958" size="3">媒体查询width/height与 device-width/height</font><br></p><p></p>
<ul>
<li><code>device-width/height</code>使用<code>screen.width/height</code>来做为的判定值。该值以设备的pixels来度量</li>
<li><code>width/height</code>使用<code>documentElement.clientWidth/Height</code>即viewport的值。该值以CSS的pixels来度量<br><img src="/images/viewports/16.jpg" alt><br>桌面浏览器上使用<font face="STCAIYUN" color="red" size="4">width</font><br><p id="line9"><br><font face="STCAIYUN" color="#883958" size="3">mobile浏览器</font><br></p><br>移动设备的屏幕宽度比桌面浏览器小（好多废话.）<br>试想一下 如果我们只是copy桌面的样式到移动设备 该有多丑<br>如下图<br>移动设备浏览器在初始默认打开以最小缩放模式打开网站。（即在手机屏幕上展示完整宽度的页面）</li>
</ul>
<p><img src="/images/viewports/viewport-21.jpg" alt></p>
<p><font face="STCAIYUN" color="#285853" size="3">假设当前设备的宽度是400px 还是之前说过的10%侧边栏，如果移动设备上做同样的处理，会显示40px的宽 太窄了，布局会变得非常可怕</font><br>那么 如何处理?</p>
<p></p><p id="line10"></p>
<p><font face="STCAIYUN" color="#883958" size="3">两种viewport</font></p><br>因为viewport太窄，最显然的解决方式就是将它变宽<br>由此 引出了 虚拟视口  （<code>viewportvisualviewport</code>） 与      布局视口（<code>viewportlayoutviewport</code>）<br>关于它们 有一个很好的解释<p></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  想象一下viewportlayoutviewport是一张大的不能改变大小和角度的图片 现在你有个更小的框来观看这张大图片</span><br><span class="line">这个框被不透明的材料包围 因而你只能看到大图片的一部分 你通过这个框子看到的大图片的那部分就叫做虚拟视口（viewportvisualviewport）</span><br><span class="line"></span><br><span class="line">你拿着这个框拿着站的离大图原点（用户的缩小页面功能）以一次性看到这个大图片</span><br><span class="line">你站的离的近一点（用户的放大页面功能）以看到一部分</span><br><span class="line">你能改变这个框框的远近 但是这张大图片的大小和形状都不会改变</span><br></pre></td></tr></table></figure>
<p>visualviewport是当前显示在屏幕上的部分页面。用户会滚动页面来改变可见部分，或者缩放浏览器来改变visualviewport的尺寸。<br>如下图<br><img src="/images/viewports/20.jpg" alt><br>但是CSS布局 通常是按照<font face="STCAIYUN" color="red" size="3">layoutviewport定义的，这要比visualviewport宽很多</font></p>
<p><html>元素的宽度继承于layoutviewport</html></p>
<p></p><p id="line11"></p>
<p><font face="STCAIYUN" color="#883958" size="3">缩放 Zooming</font><br></p><br>两种viewports都以CSS的 pixels来度量。当你通过缩放改变visualviewport时，layoutviewport保存不变。<p></p>
<p></p><p id="line12"></p>
<p><font face="STCAIYUN" color="#883958" size="3">屏幕尺寸</font><br></p><br><strong>理解layout viewport</strong><br>许多移动设备浏览器在初始默认打开以最小缩放模式打开网站（也就是在手机屏幕上展示完整宽度的页面）<p></p>
<p><img src="/images/viewports/21.jpg" alt><br>此时浏览器已经选择好他们的layoutviewport的尺寸 它完整覆盖了最小缩放模式下的移动浏览器的屏幕，这个时候layoutviewport的宽度高度和最小缩放模式下能在页面上显示的内容的宽度和高度一致。<br><br></p>
<p><font face="STCAIYUN" color="red" size="3">那么移动端如何计算layoutviewport的尺寸？</font><br><code>document. documentElement. clientWidth/Height</code></p>
<p><img src="/images/viewports/25.jpg" alt><br><strong>理解visual viewport</strong></p>
<p><font face="STCAIYUN" color="red" size="3">那么移动端如何计算visualviewport的尺寸？</font><br><code>window.innerWidth/Height</code> 随着用户的缩放浏览器 值会改变 更多 更少的CSS pixels放进了屏幕<br><img src="/images/viewports/27.jpg" alt><br><strong>屏幕尺寸 screen</strong><br>和pc浏览器一样 screen.width/height标示了设置屏幕的尺寸 以设备的pixels 显然 这跟开发人员没有什么关系</p>
<p></p><p id="line13"></p>
<p><font face="STCAIYUN" color="#883958" size="3">页面的滚动移位</font><br></p><br>你同样需要知道当前的虚拟视口相对于布局视口的距离 这叫做<code>滚动位移</code> ，它像在pc端获取一样<br>使用<strong>window.pageX/YOffset</strong><p></p>
<p><img src="/images/viewports/29.jpg" alt></p>
<p></p><p id="line14"></p>
<p><font face="STCAIYUN" color="#883958" size="3">html元素以及度量html</font><br></p><br>html元素的整体尺寸，和pc端一致 使用<code>document.documentElement.offsetWidth/Height</code>，元素以CSS pixels度量<p></p>
<p><img src="/images/viewports/30.jpg" alt></p>
<p></p><p id="line15"></p>
<p><font face="STCAIYUN" color="#883958" size="3">关于事件坐标</font><br></p><br>同pc浏览器 只需要关注 pageX/Y<p></p>
<p><img src="/images/viewports/32.jpg" alt></p>
<p></p><p id="line16"></p>
<p><font face="STCAIYUN" color="#883958" size="3">媒体查询width/height与 device-width/height</font><br></p><br>也如同pc浏览器<br> <code>width/height</code>使用css的pixels度量layoutviewport 即<code>document. documentElement. clientWidth/Height</code><br><code>device-width/height</code>使用设备的pixels 即 <code>screen.width/height.</code><br>所有浏览器都遵循这个原理<p></p>
<p></p><p id="line17"></p>
<p><font face="STCAIYUN" color="#883958" size="3">viewport的meta标签</font><br></p><br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;meta <span class="attribute">name</span>=<span class="string">"viewport"</span> <span class="attribute">content</span>=<span class="string">"width=320"</span>&gt;</span><br></pre></td></tr></table></figure><p></p>
<p>最初这是apple的一个html扩展标签，被很多浏览器复用<br>设置 <code>虚拟视口</code>的宽度</p>
<p>假设你现在创建一个页面  并不为它设置宽度 那么它会伸展开来占据100%的viewlayout的宽度 绝大多数浏览器缩小这个页面在一屏的宽度上显示这个layoutviewport</p>
<p><img src="/images/viewports/33.jpg" alt><br>当用户放大页面  绝大多数会保存元素的宽度（保持元素的定位不变）而导致文字超出屏幕<br><img src="/images/viewports/34.jpg" alt><br>当你设置<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;meta <span class="attribute">name</span>=<span class="string">"viewport"</span> <span class="attribute">content</span>=<span class="string">"width=320"</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>你网站的layoutviewport变成了320px。页面的初始状态就很正确了<br><img src="/images/viewports/36.jpg" alt></p>
<ul>
<li>Part1:<a href="http://www.quirksmode.org/mobile/viewports.html" target="_blank" rel="noopener">http://www.quirksmode.org/mobile/viewports.html</a></li>
<li>Part2:<a href="http://www.quirksmode.org/mobile/viewports2.html" target="_blank" rel="noopener">http://www.quirksmode.org/mobile/viewports2.html</a></li>
</ul>
]]></content>
      <tags>
        <tag>mobile</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue开发中小技巧</title>
    <url>/2019/10/24/vue/</url>
    <content><![CDATA[<p>记录日常开发中不常用的一些小技巧</p>
<h1 id="require-context"><a href="#require-context" class="headerlink" title="require.context()"></a>require.context()</h1><p>1.场景:如页面需要导入多个组件,原始写法:</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> titleCom <span class="keyword">from</span> <span class="string">'@/components/home/titleCom'</span></span><br><span class="line"><span class="keyword">import</span> bannerCom <span class="keyword">from</span> <span class="string">'@/components/home/bannerCom'</span></span><br><span class="line"><span class="keyword">import</span> cellCom <span class="keyword">from</span> <span class="string">'@/components/home/cellCom'</span></span><br><span class="line">components:&#123;titleCom,bannerCom,cellCom&#125;</span><br></pre></td></tr></table></figure>
<p>2.这样就写了大量重复的代码,利用 require.context 可以写成</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">const<span class="built_in"> path</span> = require(<span class="string">'path'</span>)</span><br><span class="line">const files = require.<span class="keyword">context</span>(<span class="string">'@/components/home'</span>,<span class="built_in"> false</span>, /\.vue$/)</span><br><span class="line">const modules = &#123;&#125;</span><br><span class="line">files.keys().forEach<span class="built_in">(key</span> =&gt; &#123;</span><br><span class="line">  const<span class="built_in"> name</span> =<span class="built_in"> path</span>.basename<span class="built_in">(key</span>, <span class="string">'.vue'</span>)</span><br><span class="line">  modules<span class="built_in">[name</span>] = files<span class="built_in">(key</span>).<span class="keyword">default</span> || files<span class="built_in">(key</span>)</span><br><span class="line">&#125;)</span><br><span class="line">components:modules</span><br></pre></td></tr></table></figure>
<p>API方法</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">实际上是 webpack 的方法,vue 工程一般基于 webpack,所以可以使用</span><br><span class="line"><span class="built_in">require</span>.context(<span class="built_in">directory</span>,useSubdirectories,regExp)</span><br><span class="line">接收三个参数:</span><br><span class="line"><span class="built_in">directory</span>：说明需要检索的目录</span><br><span class="line">useSubdirectories：是否检索子目录</span><br><span class="line">regExp: 匹配文件的正则表达式,一般是文件名</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="watch用法"><a href="#watch用法" class="headerlink" title="watch用法"></a>watch用法</h1><h2 id="常用用法"><a href="#常用用法" class="headerlink" title="常用用法"></a>常用用法</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">created()&#123;</span><br><span class="line">  <span class="keyword">this</span>.getList()</span><br><span class="line">&#125;,</span><br><span class="line">watch: &#123;</span><br><span class="line">  inpVal()&#123;</span><br><span class="line">    <span class="keyword">this</span>.getList()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="立即执行"><a href="#立即执行" class="headerlink" title="立即执行"></a>立即执行</h2><p>可以直接利用 watch 的immediate和handler属性简写</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">watch:</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">  inpVal:</span><span class="string">&#123;</span></span><br><span class="line"><span class="attr">    handler:</span> <span class="string">'getList'</span><span class="string">,</span></span><br><span class="line"><span class="attr">      immediate:</span> <span class="literal">true</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="深度监听"><a href="#深度监听" class="headerlink" title="深度监听"></a>深度监听</h2><p>watch 的 deep 属性,深度监听,也就是监听复杂数据类型</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">watch</span>:&#123;</span><br><span class="line">  <span class="attribute">inpValObj</span>:&#123;</span><br><span class="line">    <span class="built_in">handler</span>(newVal,oldVal)&#123;</span><br><span class="line">      console.<span class="built_in">log</span>(newVal)</span><br><span class="line">      console.<span class="built_in">log</span>(oldVal)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="selector-tag">deep</span><span class="selector-pseudo">:true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h1><h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组:不建议使用</span></span><br><span class="line">props:[]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象</span></span><br><span class="line">props:&#123;</span><br><span class="line"> inpVal:&#123;</span><br><span class="line">  type:Number, <span class="comment">//传入值限定类型</span></span><br><span class="line">  <span class="comment">// type 值可为String,Number,Boolean,Array,Object,Date,Function,Symbol</span></span><br><span class="line">  <span class="comment">// type 还可以是一个自定义的构造函数，并且通过 instanceof 来进行检查确认</span></span><br><span class="line">  required: <span class="literal">true</span>, <span class="comment">//是否必传</span></span><br><span class="line">  <span class="keyword">default</span>:<span class="number">200</span>,  <span class="comment">//默认值,对象或数组默认值必须从一个工厂函数获取如 default:()=&gt;[]</span></span><br><span class="line">  validator:(<span class="keyword">value</span>) &#123;</span><br><span class="line">    <span class="comment">// 这个值必须匹配下列字符串中的一个</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="string">'success'</span>, <span class="string">'warning'</span>, <span class="string">'danger'</span>].indexOf(<span class="keyword">value</span>) !== <span class="number">-1</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Attr和listeners"><a href="#Attr和listeners" class="headerlink" title="Attr和listeners"></a>Attr和listeners</h1><h2 id="attrs"><a href="#attrs" class="headerlink" title="attrs"></a>attrs</h2><p>场景:如果父传子有很多值,那么在子组件需要定义多个 props</p>
<p>attrs获取未在 props 定义的值</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;home <span class="built_in">title</span>=<span class="string">"这是标题"</span> <span class="built_in">width</span>=<span class="string">"80"</span> <span class="built_in">height</span>=<span class="string">"80"</span> imgUrl=<span class="string">"imgUrl"</span>/&gt;</span><br><span class="line"></span><br><span class="line">// 子组件</span><br><span class="line">mounted() &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(this.$attrs) //&#123;<span class="built_in">title</span>: <span class="string">"这是标题"</span>, <span class="built_in">width</span>: <span class="string">"80"</span>, <span class="built_in">height</span>: <span class="string">"80"</span>, imgUrl: <span class="string">"imgUrl"</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相对应的如果子组件定义了 props,打印的值就是剔除定义的属性</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">prop<span class="variable">s:</span> &#123;</span><br><span class="line">  width: &#123;</span><br><span class="line">    <span class="built_in">type</span>: String,</span><br><span class="line">    defaul<span class="variable">t:</span> <span class="string">''</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">mounted() &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(this.$attrs) //&#123;title: <span class="string">"这是标题"</span>, heigh<span class="variable">t:</span> <span class="string">"80"</span>, imgUr<span class="variable">l:</span> <span class="string">"imgUrl"</span>&#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h2 id="listeners场景"><a href="#listeners场景" class="headerlink" title="listeners场景"></a>listeners场景</h2><p>子组件内需要调用父组件的方法解决：<br>父组件的方法可以通过v-on=”listeners”传入内部组件</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;home @change=<span class="string">"change"</span>/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="function"><span class="title">mounted</span><span class="params">()</span></span> &#123;</span><br><span class="line">  console.log(this.<span class="variable">$listeners</span>) <span class="comment">//即可拿到 change 事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="root"><a href="#root" class="headerlink" title="$root"></a>$root</h1><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">mounted()&#123;</span><br><span class="line">  console.<span class="built-in">log</span>(this.<span class="symbol">$</span>root) <span class="comment">//获取根实例,最后所有组件都是挂载到根实例上</span></span><br><span class="line">  console.<span class="built-in">log</span>(this.<span class="symbol">$</span>root.<span class="symbol">$</span>children[<span class="number">0</span>]) <span class="comment">//获取根实例的一级子组件</span></span><br><span class="line">  console.<span class="built-in">log</span>(this.<span class="symbol">$</span>root.<span class="symbol">$</span>children[<span class="number">0</span>].<span class="symbol">$</span>children[<span class="number">0</span>]) <span class="comment">//获取根实例的二级子组件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="sync"><a href="#sync" class="headerlink" title=".sync"></a>.sync</h1><p>在 <a href="mailto:vue@1.x" target="_blank" rel="noopener">vue@1.x</a> 的时候曾作为双向绑定功能存在，即子组件可以修改父组件中的值; 在 <a href="mailto:vue@2.0" target="_blank" rel="noopener">vue@2.0</a> 的由于违背单项数据流的设计被干掉了; 在 <a href="mailto:vue@2.3.0" target="_blank" rel="noopener">vue@2.3.0</a>+ 以上版本又重新引入了这个 .sync 修饰符;</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;<span class="string">home :</span>title.sync=<span class="string">"title"</span> /&gt;</span><br><span class="line"><span class="comment">//编译时会被扩展为</span></span><br><span class="line">&lt;<span class="string">home :</span>title=<span class="string">"title"</span>  <span class="meta">@update</span>:title=<span class="string">"val =&gt; title = val"</span>/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="comment">// 所以子组件可以通过$emit 触发 update 方法改变</span></span><br><span class="line">mounted()&#123;</span><br><span class="line">  <span class="keyword">this</span>.$emit(<span class="string">"update:title"</span>, <span class="string">'这是新的title'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="路由传参方案"><a href="#路由传参方案" class="headerlink" title="路由传参方案"></a>路由传参方案</h1><p>方案一</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 路由定义</span></span><br><span class="line">&#123;</span><br><span class="line">  path: '/<span class="keyword">describe</span>/:id',</span><br><span class="line">  name: '<span class="keyword">Describe</span>',</span><br><span class="line">  component: <span class="keyword">Describe</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 页面传参</span></span><br><span class="line">this.<span class="variable">$router</span>.push(&#123;</span><br><span class="line">  path: `/<span class="keyword">describe</span>/<span class="variable">$&#123;id&#125;</span>`,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 页面获取</span></span><br><span class="line">this.<span class="variable">$route</span>.params.id</span><br></pre></td></tr></table></figure>
<p>方案二</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 路由定义</span></span><br><span class="line">&#123;</span><br><span class="line">  path: <span class="string">'/describe'</span>,</span><br><span class="line">  name: <span class="string">'Describe'</span>,</span><br><span class="line">  omponent: Describe</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 页面传参</span></span><br><span class="line">this.<span class="variable">$router</span>.push(&#123;</span><br><span class="line">  name: <span class="string">'Describe'</span>,</span><br><span class="line">  params: &#123;</span><br><span class="line">    id: id</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 页面获取</span></span><br><span class="line">this.<span class="variable">$route</span><span class="selector-class">.params</span><span class="selector-class">.id</span></span><br></pre></td></tr></table></figure>
<p>方案三</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 路由定义</span></span><br><span class="line">&#123;</span><br><span class="line">  path: '/<span class="keyword">describe</span>',</span><br><span class="line">  name: '<span class="keyword">Describe</span>',</span><br><span class="line">  component: <span class="keyword">Describe</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 页面传参</span></span><br><span class="line">this.<span class="variable">$router</span>.push(&#123;</span><br><span class="line">  path: '/<span class="keyword">describe</span>',</span><br><span class="line">    <span class="keyword">query</span>: &#123;</span><br><span class="line">      id: id</span><br><span class="line">  `&#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 页面获取</span></span><br><span class="line">this.<span class="variable">$route</span>.<span class="keyword">query</span>.id</span><br></pre></td></tr></table></figure>
<p>三种方案对比 方案二参数不会拼接在路由后面,页面刷新参数会丢失 方案一和三参数拼接在后面,丑,而且暴露了信息</p>
<h1 id="render函数"><a href="#render函数" class="headerlink" title="render函数"></a>render函数</h1><p>场景:有些代码在 template 里面写会重复很多,所以这个时候 render 函数就有作用啦</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据 props 生成标签</span></span><br><span class="line"><span class="comment">// 初级</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div v-<span class="keyword">if</span>=<span class="string">"level === 1"</span>&gt; <span class="xml"><span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span> <span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &lt;p v-<span class="keyword">else</span>-<span class="keyword">if</span>=<span class="string">"level === 2"</span>&gt; <span class="xml"><span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span> <span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">    &lt;h1 v-<span class="keyword">else</span>-<span class="keyword">if</span>=<span class="string">"level === 3"</span>&gt; <span class="xml"><span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span> <span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    &lt;h2 v-<span class="keyword">else</span>-<span class="keyword">if</span>=<span class="string">"level === 4"</span>&gt; <span class="xml"><span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span> <span class="xml"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">    &lt;strong v-<span class="keyword">else</span>-<span class="keyword">if</span>=<span class="string">"level === 5"</span>&gt; <span class="xml"><span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span> <span class="xml"><span class="tag">&lt;/<span class="name">stong</span>&gt;</span></span></span><br><span class="line">    &lt;textarea v-<span class="keyword">else</span>-<span class="keyword">if</span>=<span class="string">"level === 6"</span>&gt; <span class="xml"><span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span> <span class="xml"><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span></span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化版,利用 render 函数减小了代码重复率</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;child :level=<span class="string">"level"</span>&gt;Hello world!<span class="xml"><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span></span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=<span class="string">'text/javascript'</span>&gt;</span><br><span class="line">  <span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line">  Vue.component(<span class="string">'child'</span>, &#123;</span><br><span class="line">    render(h) &#123;</span><br><span class="line">      <span class="keyword">const</span> tag = [<span class="string">'div'</span>, <span class="string">'p'</span>, <span class="string">'strong'</span>, <span class="string">'h1'</span>, <span class="string">'h2'</span>, <span class="string">'textarea'</span>][<span class="keyword">this</span>.level<span class="number">-1</span>]</span><br><span class="line">      <span class="keyword">return</span> h(tag, <span class="keyword">this</span>.$slots.default)</span><br><span class="line">    &#125;,</span><br><span class="line">    props: &#123;</span><br><span class="line">      level: &#123;  <span class="attr">type</span>: <span class="built_in">Number</span>,  <span class="attr">required</span>: <span class="literal">true</span>  &#125; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)   </span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">'hehe'</span>,</span><br><span class="line">    data() &#123; <span class="keyword">return</span> &#123; <span class="attr">level</span>: <span class="number">3</span> &#125; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>2.render 和 template 的对比 前者适合复杂逻辑,后者适合逻辑简单; 后者属于声明是渲染，前者属于自定Render函数; 前者的性能较高，后者性能较低。</p>
<h1 id="路由的按需加载"><a href="#路由的按需加载" class="headerlink" title="路由的按需加载"></a>路由的按需加载</h1><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">webpack</span>&lt; 2<span class="selector-class">.4</span> 时</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">path</span>:<span class="string">'/'</span>,</span><br><span class="line">  name:<span class="string">'home'</span>,</span><br><span class="line">  components:resolve=&gt;<span class="built_in">require</span>([<span class="string">'@/components/home'</span>],resolve)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">webpack</span>&gt; 2<span class="selector-class">.4</span> 时</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">path</span>:<span class="string">'/'</span>,</span><br><span class="line">  name:<span class="string">'home'</span>,</span><br><span class="line">  components:()=&gt;<span class="built_in">import</span>(<span class="string">'@/components/home'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">import</span>()方法由<span class="selector-tag">es6</span>提出，<span class="selector-tag">import</span>()方法是动态加载，返回一个<span class="selector-tag">Promise</span>对象，<span class="selector-tag">then</span>方法的参数是加载到的模块。类似于<span class="selector-tag">Node</span><span class="selector-class">.js</span>的<span class="selector-tag">require</span>方法，主要<span class="selector-tag">import</span>()方法是异步加载的。</span><br></pre></td></tr></table></figure>
<h1 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h1><figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">component</span> v-bind:<span class="keyword">is</span>=<span class="string">"currentTabComponent"</span>&gt;&lt;/<span class="keyword">component</span>&gt;</span><br></pre></td></tr></table></figure>
<p>但是这样每次组件都会重新加载,会消耗大量性能,所以 就起到了作用</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">"currentTabComponent"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样切换效果没有动画效果,这个也不用着急,可以利用内置的</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">"currentTabComponent"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h1><figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span> <span class="attr">functional</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(item,index) in props.arr"</span>&gt;</span></span><span class="template-variable">&#123;&#123;item&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h1 id="mixins"><a href="#mixins" class="headerlink" title="mixins"></a>mixins</h1><p>场景:有些组件有些重复的 js 逻辑,如校验手机验证码,解析时间等,mixins 就可以实现这种混入 mixins 值是一个数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mixin=&#123;</span><br><span class="line">    created()&#123;</span><br><span class="line">      <span class="keyword">this</span>.dealTime()</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">      dealTime()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'这是mixin的dealTime里面的方法'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">  mixins:[mixin]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Vue-nextTick"><a href="#Vue-nextTick" class="headerlink" title="Vue.nextTick"></a>Vue.nextTick</h1><p>2.1.0 新增 场景:页面加载时需要让文本框获取焦点 用法:在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">mounted</span><span class="params">()</span></span>&#123; <span class="comment">//因为 mounted 阶段 dom 并未渲染完毕,所以需要$nextTick</span></span><br><span class="line">  this.<span class="variable">$nextTick</span>(() =&gt; &#123;</span><br><span class="line">    this.<span class="variable">$refs</span><span class="selector-class">.inputs</span><span class="selector-class">.focus</span>() <span class="comment">//通过 $refs 获取dom 并绑定 focus 方法</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Vue-version"><a href="#Vue-version" class="headerlink" title="Vue.version"></a>Vue.version</h1><p>场景:有些开发插件需要针对不同 vue 版本做兼容,所以就会用到 Vue.version 用法:Vue.version()可以获取 vue 版本</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">version</span> = Number(Vue.<span class="keyword">version</span>.<span class="keyword">split</span>('.')[0])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">version</span> === 2) &#123;</span><br><span class="line">  <span class="comment">// Vue v2.x.x</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">version</span> === 1) &#123;</span><br><span class="line">  <span class="comment">// Vue v1.x.x</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Unsupported versions of Vue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Vue-config-performance"><a href="#Vue-config-performance" class="headerlink" title="Vue.config.performance"></a>Vue.config.performance</h1><p>监听性能</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">Vue.config.performance</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h1 id="Vue-config-warnHandler"><a href="#Vue-config-warnHandler" class="headerlink" title="Vue.config.warnHandler"></a>Vue.config.warnHandler</h1><p>2.4.0 新增 1.场景:为 Vue 的运行时警告赋予一个自定义处理函数,只会在开发者环境下生效 2.用法:</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">Vue.config.warnHandler = <span class="function"><span class="keyword">function</span> <span class="params">(msg, vm, trace)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// `trace` 是组件的继承关系追踪</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="v-pre"><a href="#v-pre" class="headerlink" title="v-pre"></a>v-pre</h1><p>场景:vue 是响应式系统,但是有些静态的标签不需要多次编译,这样可以节省性能</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-pre</span>&gt;</span></span><span class="template-variable">&#123;&#123; this will not be compiled &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span>   显示的是</span><span class="template-variable">&#123;&#123; this will not be compiled &#125;&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-pre</span>&gt;</span></span><span class="template-variable">&#123;&#123;msg&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span>     即使data里面定义了msg这里仍然是显示的</span><span class="template-variable">&#123;&#123;msg&#125;&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure>
<h1 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h1><p>场景:在网速慢的情况下,在使用vue绑定数据的时候，渲染页面时会出现变量闪烁<br>用法:这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 [v-cloak] { display: none } 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// template 中</span></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"#app"</span> v-cloak&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;value.name&#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// css 中</span></span><br><span class="line">[v-cloak] &#123;</span><br><span class="line">    display: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以解决闪烁,但是会出现白屏,这样可以结合骨架屏使用</p>
<h1 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h1><p>场景:有些 template 中的静态 dom 没有改变,这时就只需要渲染一次,可以降低性能开销</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-once</span>&gt;</span> 这时只需要加载一次的标签<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>v-once 和 v-pre 的区别: v-once只渲染一次；v-pre不编译,原样输出</p>
<h1 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h1><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.stop</span>:阻止冒泡</span><br><span class="line"><span class="selector-class">.prevent</span>:阻止默认行为</span><br><span class="line"><span class="selector-class">.self</span>:仅绑定元素自身触发</span><br><span class="line"><span class="selector-class">.once</span>: <span class="number">2.1</span>.<span class="number">4</span> 新增,只触发一次</span><br><span class="line"><span class="selector-class">.passive</span>: <span class="number">2.3</span>.<span class="number">0</span> 新增,滚动事件的默认行为 (即滚动行为) 将会立即触发,不能和<span class="selector-class">.prevent</span> 一起使用</span><br></pre></td></tr></table></figure>
<h1 id="Vue-router"><a href="#Vue-router" class="headerlink" title="Vue.$router"></a>Vue.$router</h1><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$router.push():跳转到不同的url，但这个方法回向history栈添加一个记录，点击后退会返回到上一个页面</span><br><span class="line"><span class="keyword">this</span>.$router.replace():不会有记录</span><br><span class="line"><span class="keyword">this</span>.$router.go(n):n可为正数可为负数。正数返回上一个页面,类似 window.history.go(n)</span><br></pre></td></tr></table></figure>
<h1 id="Vue-route"><a href="#Vue-route" class="headerlink" title="Vue.$route"></a>Vue.$route</h1><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">this.<span class="variable">$route</span><span class="selector-class">.params</span><span class="selector-class">.id</span>:获取通过 params 或/:id传参的参数</span><br><span class="line">this.<span class="variable">$route</span><span class="selector-class">.query</span><span class="selector-class">.id</span>:获取通过 query 传参的参数</span><br></pre></td></tr></table></figure>
<h1 id="调试-template"><a href="#调试-template" class="headerlink" title="调试 template"></a>调试 template</h1><p>场景:在Vue开发过程中, 经常会遇到template模板渲染时JavaScript变量出错的问题, 此时也许你会通过console.log来进行调试 这时可以在开发环境挂载一个 log 函数</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line">Vue.prototype.<span class="symbol">$</span><span class="built-in">log</span> = window.console.<span class="built-in">log</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件内部</span></span><br><span class="line">&lt;<span class="built-in">div</span>&gt;&#123;&#123;<span class="symbol">$</span><span class="built-in">log</span>(info)&#125;&#125;&lt;/<span class="built-in">div</span>&gt;</span><br></pre></td></tr></table></figure>
<h1 id="vue-loader-小技巧"><a href="#vue-loader-小技巧" class="headerlink" title="vue-loader 小技巧"></a>vue-loader 小技巧</h1><h2 id="preserveWhitespace"><a href="#preserveWhitespace" class="headerlink" title="preserveWhitespace"></a>preserveWhitespace</h2><p>场景:开发 vue 代码一般会有空格,这个时候打包压缩如果不去掉空格会加大包的体积 配置preserveWhitespace可以减小包的体积</p>
<p>{<br>  vue: {<br>    preserveWhitespace: false<br>  }<br>}</p>
<h2 id="transformToRequire"><a href="#transformToRequire" class="headerlink" title="transformToRequire"></a>transformToRequire</h2><p>场景:以前在写 Vue 的时候经常会写到这样的代码：把图片提前 require 传给一个变量再传给组件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// page 代码</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">avatar</span> <span class="attr">:img-src</span>=<span class="string">"imgSrc"</span>&gt;</span><span class="tag">&lt;/<span class="name">avatar</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    created () &#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.imgSrc = <span class="built_in">require</span>(<span class="string">'./assets/default-avatar.png'</span>)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>现在:通过配置 transformToRequire 后，就可以直接配置，这样vue-loader会把对应的属性自动 require 之后传给组件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue-cli 2.x在vue-loader.conf.js 默认配置是</span></span><br><span class="line">transformToRequire: &#123;</span><br><span class="line">    video: [<span class="string">'src'</span>, <span class="string">'poster'</span>],</span><br><span class="line">    source: <span class="string">'src'</span>,</span><br><span class="line">    img: <span class="string">'src'</span>,</span><br><span class="line">    image: <span class="string">'xlink:href'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置文件,如果是vue-cli2.x 在vue-loader.conf.js里面修改</span></span><br><span class="line">  avatar: [<span class="string">'default-src'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// vue-cli 3.x 在vue.config.js</span></span><br><span class="line"><span class="comment">// vue-cli 3.x 将transformToRequire属性换为了transformAssetUrls</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  pages,</span><br><span class="line">  chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    config</span><br><span class="line">      .module</span><br><span class="line">        .rule(<span class="string">'vue'</span>)</span><br><span class="line">        .use(<span class="string">'vue-loader'</span>)</span><br><span class="line">        .loader(<span class="string">'vue-loader'</span>)</span><br><span class="line">        .tap(<span class="function"><span class="params">options</span> =&gt;</span> &#123;</span><br><span class="line">      options.transformAssetUrls = &#123;</span><br><span class="line">        avatar: <span class="string">'img-src'</span>,</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> options;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// page 代码可以简化为</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;avatar img-src=<span class="string">"./assets/default-avatar.png"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">avatar</span>&gt;</span></span></span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br></pre></td></tr></table></figure>
<h1 id="为路径设置别名"><a href="#为路径设置别名" class="headerlink" title="为路径设置别名"></a>为路径设置别名</h1><p>1.场景:在开发过程中，我们经常需要引入各种文件，如图片、CSS、JS等，为了避免写很长的相对路径（../），我们可以为不同的目录配置一个别名</p>
<p>2.vue-cli 2.x 配置</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">// 在 webpack.base.config.js中的 <span class="built_in">resolve</span> 配置项，在其 alias 中增加别名</span><br><span class="line"><span class="built_in">resolve</span>: &#123;</span><br><span class="line">    extension<span class="variable">s:</span> [<span class="string">'.js'</span>, <span class="string">'.vue'</span>, <span class="string">'.json'</span>],</span><br><span class="line">    alia<span class="variable">s:</span> &#123;</span><br><span class="line">      <span class="string">'vue$'</span>: <span class="string">'vue/dist/vue.esm.js'</span>,</span><br><span class="line">      <span class="string">'@'</span>: <span class="built_in">resolve</span>(<span class="string">'src'</span>),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>3.vue-cli 3.x 配置</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">// 在根目录下创建vue.<span class="built_in">config</span>.js</span><br><span class="line">var <span class="built_in">path</span> = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span> <span class="params">(dir)</span></span> &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(__dirname)</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">path</span>.join(__dirname, dir)</span><br><span class="line">&#125;</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  chainWebpack: <span class="built_in">config</span> =&gt; &#123;</span><br><span class="line">    <span class="built_in">config</span>.resolve.alias</span><br><span class="line">      .set(key, value) // key,value自行定义，比如.set(<span class="string">'@@'</span>, resolve(<span class="string">'src/components'</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="img-加载失败"><a href="#img-加载失败" class="headerlink" title="img 加载失败"></a>img 加载失败</h1><p>场景:有些时候后台返回图片地址不一定能打开,所以这个时候应该加一张默认图片</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// page 代码</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">"imgUrl"</span> @<span class="attr">error</span>=<span class="string">"handleError"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span></span><br><span class="line">  data()&#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span>&#123;</span></span><br><span class="line"><span class="actionscript">      imgUrl:<span class="string">''</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    handleError(e)&#123;</span><br><span class="line"><span class="actionscript">      e.target.src=reqiure(<span class="string">'图片路径'</span>) <span class="comment">//当然如果项目配置了transformToRequire,参考上面 27.2</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="局部样式"><a href="#局部样式" class="headerlink" title="局部样式"></a>局部样式</h2><p>1.Vue中style标签的scoped属性表示它的样式只作用于当前模块，是样式私有化.</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原始代码</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;<span class="selector-tag">div</span> class=<span class="string">"demo"</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">span</span> class=<span class="string">"content"</span>&gt;</span><br><span class="line">      Vue<span class="selector-class">.js</span> scoped</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=<span class="string">"less"</span> scoped&gt;</span><br><span class="line">  .demo&#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">    .<span class="attribute">content</span>&#123;</span><br><span class="line">      <span class="attribute">color</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 浏览器渲染效果</span></span><br><span class="line">&lt;<span class="selector-tag">div</span> data-v-fed36922&gt;</span><br><span class="line">  Vue<span class="selector-class">.js</span> scoped</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;style type=<span class="string">"text/css"</span>&gt;</span><br><span class="line"><span class="selector-class">.demo</span>[data-v-<span class="number">039</span>c5b43] &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.demo</span> <span class="selector-class">.content</span>[data-v-<span class="number">039</span>c5b43] &#123; <span class="comment">//.demo 上并没有加 data 属性</span></span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<h2 id="deep-属性"><a href="#deep-属性" class="headerlink" title="deep 属性"></a>deep 属性</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// 上面样式加一个 /deep/</span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">"less"</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.demo</span>&#123;</span></span><br><span class="line">    font-size: 14px;</span><br><span class="line">  &#125;</span><br><span class="line">  .demo /deep/ .content&#123;</span><br><span class="line">    color: blue;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 浏览器编译后</span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.demo</span><span class="selector-attr">[data-v-039c5b43]</span> &#123;</span></span><br><span class="line">  font-size: 14px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.demo</span><span class="selector-attr">[data-v-039c5b43]</span> <span class="selector-class">.content</span> &#123;</span></span><br><span class="line">  color: blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>从不规范生产套路看效率</title>
    <url>/2017/07/22/%E4%BB%8E%E4%B8%8D%E8%A7%84%E8%8C%83%E5%9B%A2%E9%98%9F%E7%9C%8B%E6%95%88%E7%8E%87/</url>
    <content><![CDATA[<p>标题好像是句废话，”不规范” 何谈 <font face="STCAIYUN" color="red" size="5">效率</font> 呢？</p>
<p><img src="http://oucjferwh.bkt.clouddn.com/wunai.jpg" alt></p>
<ol>
<li><font face="STCAIYUN" color="#83933b" size="4">何为效率</font></li>
<li><font face="STCAIYUN" color="#83933b" size="4">从产品看效率</font></li>
<li><font face="STCAIYUN" color="#83933b" size="4">从UI看效率</font></li>
<li><font face="STCAIYUN" color="#83933b" size="4">从开发看效率</font></li>
<li><font face="STCAIYUN" color="#83933b" size="4">从测试看效率 </font>



</li>
</ol>
<p><strong>何为效率？</strong></p>
<p><a href="https://baike.baidu.com/item/%E6%95%88%E7%8E%87/868847?fr=aladdin" target="_blank" rel="noopener">百度百科</a>上大概是这么定义的:是指在给定投入和技术等条件下，<font face="STCAIYUN" color="red" size="4">最有效地</font>使用资源以满足设定的愿望和需要的评价方式</p>
<p>对我来说最直观的判断方式就是  <font face="STCAIYUN" color="red" size="4">项目是否有延期 线上是否有bug</font></p>
<ul>
<li><font face="STCAIYUN" color="darkorange" size="4">效率有多重要？</font>

<p>大部分的电子厂工资都是按件计费的，多劳多得，单位时间产出与收入能正比，所以工人们都非常努力 这是自发性行为 所以也是最任怨的。</p>
<p>对我而言 效率能带来好心情 好状态以及好的生活态 废话 大家都一样 –  </p>
</li>
</ul>
<p><strong>从产品看效率</strong><br>一款产品的成功与否 有多方便的决定因素 产品最终都是面向用户的 一个不能为用户创造价值的产品应该是没有使用价值的，产品本就是提升效率的一种方式</p>
<p>那么 接下来  我要开始吐槽了</p>
<font face="STCAIYUN" color="darkorange" size="4">如果产品需求不明确或者需求不完整  项目要不要开始做？</font><br>一般来说 不要 绝对不要 除非是两个完全不相干的模块 昂 基本也不太可能<br>但是尼 为了所谓的工期 产品大大一般会这么说  做呗  先做着  我这么单（wu）纯（nai）的 每次都被套路住🤡 然后后来计算工时的时候 ： 哦 你不是从那个什么什么时候就开始了吗？👐🏽<br>这还不是最主要的，毕竟 时间就像海绵里的水 挤一挤总会有的😂<br><br>最主要的当然是<font face="STCAIYUN" color="red" size="4">改需求</font>啦 这大概是所有产品最擅长的<br><br>这两者本质上是没有矛盾的，只不过产品更多的以目标为导向，需求只是手段，而对开发来说 技术是手段 需求是目标 只不过产品更容易主观，比如需求，比如说功能，比如说交互，这些都受到个人经验，眼界，学识很大影响。朝三暮四，朝令夕改，是常有的事情。<br><br><strong>说真的</strong><br>产品的功能、质量、发布时间和需要投入的资源这四者不能都是封闭条件，否则可能无解<br><br>而且现在的产品很是聪明啊 需求给了，开始做了,做到最后发现这种情况下不是很合理，简单啊 改呗 反正做到这里我逻辑也捋清楚了，也知道该咋办了<font face="STCAIYUN" color="#83933b" size="3">产品默想到</font>

<p>呃.. 这两天刚遇到个类似的情况 哦 不好意思，是<font face="STCAIYUN" color="red" size="5">经常遇到</font>，提测一周也测了<font face="STCAIYUN" color="red" size="5">一周</font>了，代码上体验版（预上线）了</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">产品：咦？这块不是那样儿的吗？怎么是这样的？</span><br><span class="line"></span><br><span class="line">开发：？ 前两天不是专门讨论过这个问题吗，这个就是这样儿的！</span><br><span class="line"></span><br><span class="line">产品：哦？是吗？ 但是这样儿看起来好诡异啊！就应该是那样儿的 改一下吧</span><br><span class="line"></span><br><span class="line">开发：<span class="string">...</span>当初接口设计的就是这样儿的，怎么不早说？这都要上线啦！😩</span><br><span class="line"></span><br><span class="line">产品：<span class="string">"之前流程没走通 不太清楚这块儿的逻辑，现在改一下吧"</span> 然后就走了</span><br><span class="line"></span><br><span class="line">开发：<span class="string">...</span></span><br></pre></td></tr></table></figure>
<p>还有就是<strong>排期</strong></p>
<p>产品经常这么一句话：因为我们的上线时间是XX号 测试需要 XX天 所以 开发排下期吧 ？</p>
<p>…..</p>
<p>排完期之后..</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">产品：昂昂，你这儿不行啊 时间太长了 能不能缩短点</span><br><span class="line"></span><br><span class="line">开发：我按工时算的 每一项 都列出来了 不会差太多</span><br><span class="line"></span><br><span class="line">产品：这不行啊 因为我们要XX提审 测试需要XX天 所以你必须 XX天提测</span><br><span class="line"></span><br><span class="line">开发：这等于 XX 天的工期 你给我压到 XX／<span class="number">2</span> 天</span><br><span class="line"></span><br><span class="line">产品：嘿嘿😉</span><br><span class="line"></span><br><span class="line">开发：...</span><br><span class="line"></span><br><span class="line">开发OS：<span class="string">"赶紧开发 为了给测试腾时间😂😭🙈，尼萌给开发时间充足了 问题自然就会少很多好吗 测试好像是最重要的噻"</span></span><br></pre></td></tr></table></figure>
<p>百度过类似的问题 最好的办法<font face="STCAIYUN" color="red" size="3">是让产品也学会基础的编程，了解每一个实现都是需要耗费资源的，这样才能基于对有限资源的理解，做出更谨慎的规划。</font></p>
<font face="STCAIYUN" color="#83933b" size="3">然而，这基本不可能，所以..</font>

<p>实际上 那些<font face="STCAIYUN" color="#83933b" size="4">非常紧急</font>的需求，这么一搞成了拖延的第一个关键点<br><br></p>
<p><img src="http://oucjferwh.bkt.clouddn.com/tuxie.jpeg" alt="tuxie"></p>
<p><strong>从UI看效率</strong></p>
<p>呃 . 对于用户来说 一个产品能不能吸引到你，最浅显也最重要的是<font face="STCAIYUN" color="red" size="5">眼缘</font>，说俗气点就是颜值<br>而且 UI链接 产品与开发 自然也是马虎不得的 深刻理解原型的精髓 然后利用智慧的小脑瓜设计成用户想要的样子，上面说了 他们最重要的工作是 <font face="STCAIYUN" color="red" size="5">深刻理解原型的精髓</font>，因为 对于<font face="STCAIYUN" color="#83933b" size="4">美</font>，设计师总是有不一样的定义，就比如 <font face="STCAIYUN" color="gold" size="4">情人眼里出西施</font></p>
<p>非常不幸 我们UI也是必须要吐槽的对象</p>
<p>直接上日常</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">开发：设计小哥，对比原型 是不是缺了一张图</span><br><span class="line"></span><br><span class="line">设计：？</span><br><span class="line"></span><br><span class="line">开发：搜索中状态</span><br><span class="line"></span><br><span class="line">设计：沉默</span><br><span class="line"></span><br><span class="line">产品：哦 那个不就是在未搜索的状态基础上把导航去掉吗？还用出图吗？</span><br><span class="line"></span><br><span class="line">一分钟后～～</span><br><span class="line"></span><br><span class="line">设计：突然扔出来一张图  <span class="meta">@开发:好了</span></span><br><span class="line"></span><br><span class="line">开发：瞅了一眼 <span class="meta">@设计：嗯</span> ？不是这样儿的吧</span><br><span class="line"></span><br><span class="line">设计：？</span><br><span class="line"></span><br><span class="line">开发：把产品的话 <span class="meta">@设计：“哦</span> 那个不就是在未搜索的状态基础上把导航去掉吗？还用出图吗？”</span><br><span class="line"></span><br><span class="line">设计：沉默</span><br><span class="line"></span><br><span class="line">两分钟后～～</span><br><span class="line"></span><br><span class="line">设计：扔出来一张图 呐 上传了</span><br><span class="line"></span><br><span class="line">开发：嗯 现在才是对的</span><br><span class="line"></span><br><span class="line">设计：嗯</span><br></pre></td></tr></table></figure>
<p>类似的事情简直日常</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">上午～</span><br><span class="line"></span><br><span class="line">产品：今天周五 需要把UI提的问题都改完</span><br><span class="line"></span><br><span class="line">开发：ok</span><br><span class="line"></span><br><span class="line">设计：ok</span><br><span class="line"></span><br><span class="line">下午～</span><br><span class="line"></span><br><span class="line">开发：什么时候有空，当面改</span><br><span class="line"></span><br><span class="line">设计：嗯</span><br><span class="line"></span><br><span class="line">下午四点～</span><br><span class="line"></span><br><span class="line">开发：什么时候有空</span><br><span class="line"></span><br><span class="line">设计：现在过去</span><br><span class="line"></span><br><span class="line">开发：嗯</span><br><span class="line"></span><br><span class="line">改了大概有两个之后 设计被叫走</span><br><span class="line"></span><br><span class="line">又过了一个小时～</span><br><span class="line"></span><br><span class="line">开发：快下班了 啥时候改尼</span><br><span class="line"></span><br><span class="line">设计：今天比较忙 现在可以开始了</span><br><span class="line"></span><br><span class="line">开发： 嗯？我看了一下 你拿到的不是最新版吧 好些问题现在不能复现了</span><br><span class="line"></span><br><span class="line">设计：哦</span><br><span class="line"></span><br><span class="line">一个小时之后</span><br><span class="line"></span><br><span class="line">开发：改完了 我下班了啊 今天有点事儿</span><br><span class="line"></span><br><span class="line">设计：嗯 好的 下班吧</span><br><span class="line"></span><br><span class="line">开发 走了</span><br><span class="line"></span><br><span class="line">两个小时后 忙完 开发都到家了～～</span><br><span class="line"></span><br><span class="line">产品：<span class="meta">@开发：在哪里呢</span> 啥时候回来</span><br><span class="line"></span><br><span class="line">开发：？我到家了啊</span><br><span class="line"></span><br><span class="line">产品：你咋走了？设计小哥还在等你呢</span><br><span class="line"></span><br><span class="line">开发：？我走的时候跟他说了啊 他知道啊</span><br><span class="line"></span><br><span class="line">产品：我不是说了今天要改完吗 设计review了 还有一点问题</span><br><span class="line"></span><br><span class="line">开发：... 那我明天去加班吧</span><br><span class="line"></span><br><span class="line">第二天，到公司之后</span><br><span class="line"></span><br><span class="line">开发：在群里<span class="meta">@设计</span><span class="meta">@产品</span> ：这个只有截图看不出来哪有问题噻</span><br><span class="line"></span><br><span class="line">设计：沉默</span><br><span class="line"></span><br><span class="line">产品：沉默</span><br><span class="line"></span><br><span class="line">开发：...</span><br></pre></td></tr></table></figure>
<p><strong>从开发看效率</strong></p>
<p>开发效率无疑存在于两方面</p>
<p>强健的框架支撑与准确的拆分估期</p>
<p>一般情况下是不会延期的 也算是这几个环节当中最可控的</p>
<p><strong>从测试看效率</strong></p>
<p>你理解一个开发只用了一天的功能测试测了四天的心情吗</p>
<p>你理解一个开发用了一周 测试用了9个工作日的心痛吗</p>
<p>🙊</p>
<p>结语：💊</p>
]]></content>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>前端防刷实现</title>
    <url>/2018/12/26/%E5%89%8D%E7%AB%AF%E9%98%B2%E5%88%B7/</url>
    <content><![CDATA[<p>前段时间写了前端防刷逻辑 作此记录<br>当时的需求</p>
<hr>
<blockquote>
<p>防刷逻辑1 24小时内 一个手机号只能提交三次 第四次提交的时候 提示 已提交成功 请耐心等待 400<br>防刷逻辑2 24小时内 提交三个手机号 提交第四个时 提示 401</p>
</blockquote>
<a id="more"></a>
<p><strong>步骤一 页面加载 获取cookie中当前的信息</strong></p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line"> componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// 获取cookie里存的用户信息</span></span><br><span class="line">    let cookieSaveInfo = getCookie(COOKIE_CONFIG.FINANCIAL_SAVE_INFO) <span class="string">|| "</span>&#123;&#125;<span class="string">";</span></span><br><span class="line">    <span class="comment">//todo...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>点击保存按钮 防刷逻辑</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">saveInfo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">const</span> &#123; userInfoFromCookie, setModal &#125; = <span class="keyword">this</span>;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 获取手机号列表</span></span><br><span class="line">   <span class="keyword">let</span> phoneList = <span class="built_in">Object</span>.keys(userInfoFromCookie); <span class="comment">// ['12','21212','212']</span></span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 获取当前存的手机号的个数</span></span><br><span class="line">   <span class="keyword">let</span> phoneListLength = phoneList.length;</span><br><span class="line">   <span class="comment">// 当前输入的存在手机号列表中</span></span><br><span class="line">   <span class="keyword">if</span> (phone <span class="keyword">in</span> userInfoFromCookie) &#123;</span><br><span class="line">       <span class="keyword">if</span> (userInfoFromCookie[phone] &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">           <span class="comment">// 当前的手机号存在手机列表中 看当前是第几次 大于三次提示</span></span><br><span class="line">         </span><br><span class="line">          setModal(<span class="number">400</span>);</span><br><span class="line">          <span class="comment">//todo...</span></span><br><span class="line">           <span class="keyword">return</span>; <span class="comment">//防御式编程</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (phoneListLength &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">       <span class="comment">// 如果当前列表中已经有三个不同的手机号 则提示401</span></span><br><span class="line">       setModal(<span class="number">401</span>);</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//可以发起请求</span></span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>请求成功的回调</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> saveFunc = <span class="function">(<span class="params">resData</span>) =&gt;</span> &#123;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">let</span> thePhoneCount = userInfoFromCookie[phone] || <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">if</span> (resData.error_code === <span class="number">200</span>) &#123;</span><br><span class="line">   </span><br><span class="line">       <span class="comment">// 存cookie 规则 看下当前手机号在不在列表里 在的话 就更新次数 不在的数就设置这个key</span></span><br><span class="line">       <span class="keyword">if</span> (phone <span class="keyword">in</span> userInfoFromCookie) &#123;</span><br><span class="line">           userInfoFromCookie[phone] = thePhoneCount + <span class="number">1</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           userInfoFromCookie[phone] = thePhoneCount;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// cookie存储</span></span><br><span class="line">       setCookie(COOKIE_CONFIG.FINANCIAL_SAVE_INFO, <span class="built_in">JSON</span>.stringify(userInfoFromCookie), <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>不要再问关于缓存的问题了</title>
    <url>/2019/01/21/%E4%B8%8D%E8%A6%81%E5%86%8D%E9%97%AE%E5%85%B3%E4%BA%8E%E7%BC%93%E5%AD%98%E7%9A%84%E9%97%AE%E9%A2%98%E4%BA%86/</url>
    <content><![CDATA[<p>背景：<br>前端er需要关注的点，<code>缓存</code><br>它在移动端上尤其严重，因为手机随时随地会缓存你的资源，要想清缓存，不像PC使用强制刷新，还要手动找到浏览器的缓存，有时候还要重启等<br>所以 用实践理解缓存机制 写下此文记录</p>
<p>为了对比理解本文会涉及到</p>
<ul>
<li>DNS缓存</li>
<li>CDN缓存</li>
<li>浏览器缓存(HTTP缓存)</li>
</ul>
<hr>
<a id="more"></a>
<h2 id="先梳理以下web缓存的优缺点"><a href="#先梳理以下web缓存的优缺点" class="headerlink" title="先梳理以下web缓存的优缺点"></a>先梳理以下web缓存的优缺点</h2><h3 id="缓存的优势"><a href="#缓存的优势" class="headerlink" title="缓存的优势"></a>缓存的优势</h3><ul>
<li>减少网络延迟 加快页面打开速度</li>
<li>降低服务器压力</li>
</ul>
<h3 id="缓存的缺点"><a href="#缓存的缺点" class="headerlink" title="缓存的缺点"></a>缓存的缺点</h3><ul>
<li>缓存没有清理机制（时间一长 当你不需要浏览之前的这些网页，他们就变成了无用文件）</li>
<li>给开发带来困扰</li>
</ul>
<h2 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h2><h3 id="什么是DNS？"><a href="#什么是DNS？" class="headerlink" title="什么是DNS？"></a>什么是DNS？</h3><p>全称 <code>Domain Name System</code> 域名解析系统</p>
<hr>
<p>万维网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。DNS协议运行在UDP协议之上，使用端口号53。</p>
<hr>
<h3 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h3><p>简单的说,通过域名,最终得到该域名对应的IP地址的过程叫做域名解析（或主机名解析）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">www</span><span class="selector-class">.dnscache</span><span class="selector-class">.com</span> (域名)  <span class="selector-tag">-</span> <span class="selector-tag">DNS</span>解析 <span class="selector-tag">-</span>&gt; 11<span class="selector-class">.222</span><span class="selector-class">.33</span><span class="selector-class">.444</span> (<span class="selector-tag">IP</span>地址)</span><br></pre></td></tr></table></figure>
<h3 id="DNS缓存-1"><a href="#DNS缓存-1" class="headerlink" title="DNS缓存"></a>DNS缓存</h3><p>有DNS的地方,就有缓存。浏览器、操作系统、Local DNS、根域名服务器，它们都会对DNS结果做一定程度的缓存。</p>
<hr>
<h3 id="DNS查询过程"><a href="#DNS查询过程" class="headerlink" title="DNS查询过程"></a>DNS查询过程</h3><hr>
<ol>
<li>首先搜索浏览器自身的DNS缓存,如果存在，则域名解析到此完成。</li>
<li>如果浏览器自身的缓存里面没有找到对应的条目，那么会尝试读取操作系统的hosts文件看是否存在对应的映射关系,如果存在，则域名解析到此完成。</li>
<li>如果本地hosts文件不存在映射关系，则查找本地DNS服务器(ISP服务器,或者自己手动设置的DNS服务器),如果存在,域名到此解析完成。</li>
<li>如果本地DNS服务器还没找到的话,它就会向根服务器发出请求,进行递归查询。</li>
</ol>
<h2 id="CDN缓存"><a href="#CDN缓存" class="headerlink" title="CDN缓存"></a>CDN缓存</h2><h3 id="什么是CDN？"><a href="#什么是CDN？" class="headerlink" title="什么是CDN？"></a>什么是CDN？</h3><p>全称 Content Delivery Network,即内容分发网络。<br>类似于火车站代售点 这样儿 乘客不用再去售票大厅去排队买票 减轻了售票大厅的压力（起到分流作用,减轻服务器负载压力）</p>
<hr>
<p>用户在浏览网站的时候，<code>CDN</code>会选择一个离用户最近的CDN边缘节点来响应用户的请求，这样海南移动用户的请求就不会千里迢迢跑到北京电信机房的服务器（假设源站部署在北京电信机房）上了。</p>
<h3 id="CDN缓存-1"><a href="#CDN缓存-1" class="headerlink" title="CDN缓存"></a>CDN缓存</h3><p><code>CDN缓存</code>,在浏览器本地缓存失效后,浏览器会向CDN边缘节点发起请求。类似浏览器缓存,CDN边缘节点也存在着一套缓存机制。CDN边缘节点缓存策略因服务商不同而不同，但一般都会遵循<code>http</code>标准协议，通过http响应头中的<br><code>Cache-control: max-age   //后面会提到</code>的字段来设置CDN边缘节点数据缓存时间。</p>
<hr>
<p><strong>CDN边缘节点数据缓存机制</strong></p>
<ul>
<li>当浏览器向CDN节点请求数据时，CDN节点会判断缓存数据是否过期，</li>
<li>未过期：直接将缓存数据返回给客户端；</li>
<li>过期：CDN节点向服务器发出回源请求，拉取最新数据同时更新本地缓存，并将最新数据返回给客户端。 </li>
</ul>
<p>CDN服务商一般会提供基于<font color="red">文件后缀、目录多个维度来指定CDN缓存时间</font>，为用户提供更精细化的缓存管理。</p>
<hr>
<h3 id="CDN-优势"><a href="#CDN-优势" class="headerlink" title="CDN 优势"></a>CDN 优势</h3><ol>
<li>CDN节点解决了跨运营商和跨地域访问的问题，访问延时大大降低。</li>
<li>大部分请求在CDN边缘节点完成，CDN起到了分流作用，减轻了源服务器的负载。</li>
</ol>
<hr>
<h2 id="浏览器缓存（HTTP缓存）"><a href="#浏览器缓存（HTTP缓存）" class="headerlink" title="浏览器缓存（HTTP缓存）"></a>浏览器缓存（HTTP缓存）</h2><p>对于一个数据请求来说，可以分为发起网络请求 后端处理  浏览器响应三个步骤<br>浏览器缓存可以 i帮助我们在第一步和第三步中优化性能<br>比如我们可以直接使用缓存而不发起请求</p>
<p>盯着这张图<br><img src="/images/cache/cache_detail.png" alt="cache_detai"></p>
<h3 id="什么是浏览器缓存？"><a href="#什么是浏览器缓存？" class="headerlink" title="什么是浏览器缓存？"></a>什么是浏览器缓存？</h3><p><img src="/images/cache/cachehttp.png" alt="cachehttp"><br>浏览器缓存其实就是浏览器保存通过HTTP获取的所有资源,是浏览器将网络资源存储在本地的一种行为。</p>
<p>我们从两个方面来看浏览器缓存</p>
<ul>
<li>缓存位置</li>
<li>缓存策略</li>
</ul>
<h3 id="缓存的资源去哪里了（缓存位置）"><a href="#缓存的资源去哪里了（缓存位置）" class="headerlink" title="缓存的资源去哪里了（缓存位置）?"></a>缓存的资源去哪里了（缓存位置）?</h3><p>你可能会有疑问,浏览器存储了资源,那它把资源存储在哪里呢？</p>
<ul>
<li>memory cache(存在内存)</li>
</ul>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">MemoryCache顾名思义，就是将资源缓存到内存中，等待下次访问时不需要重新下载资源，而直接从内存中获取。Webkit早已支持memoryCache。</span><br><span class="line">目前Webkit资源分成两类，一类是主资源，比如HTML页面，或者下载项，一类是派生资源，比如HTML页面中内嵌的图片或者脚本链接，分别对应代码中两个类：MainResourceLoader和SubresourceLoader。虽然Webkit支持memoryCache，但是也只是针对派生资源，它对应的类为CachedResource，用于保存原始数据（比如CSS，<span class="keyword">JS</span>等），以及解码过的图片数据。</span><br></pre></td></tr></table></figure>
<ul>
<li>disk cache（存在磁盘）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DiskCache顾名思义，就是将资源缓存到磁盘中，等待下次访问时不需要重新下载资源，而直接从磁盘中获取，它的直接操作对象为CurlCacheManager。</span><br></pre></td></tr></table></figure>
<p><img src="/images/cache/huancunduibi.png" alt="huancunduibi"></p>
<h3 id="访问缓存优先级"><a href="#访问缓存优先级" class="headerlink" title="访问缓存优先级"></a>访问缓存优先级</h3><ol>
<li>先在内存中查找,如果有,直接加载。</li>
<li>如果内存中不存在,则在硬盘中查找,如果有直接加载。</li>
<li>如果硬盘中也没有,那么就进行网络请求。</li>
<li>请求获取的资源缓存到硬盘和内存。</li>
</ol>
<h3 id="浏览器缓存的分类（缓存策略）"><a href="#浏览器缓存的分类（缓存策略）" class="headerlink" title="浏览器缓存的分类（缓存策略）"></a>浏览器缓存的分类（缓存策略）</h3><h4 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h4><h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>需要说明的是 浏览器会先判断是否命中强缓存</p>
<h3 id="浏览器缓存的优点"><a href="#浏览器缓存的优点" class="headerlink" title="浏览器缓存的优点"></a>浏览器缓存的优点</h3><ol>
<li>减少了冗余的数据传输 节省了网费</li>
<li>减少了服务器的负担，大大提升了网站的性能</li>
<li>加快了客户端加载网页的速度</li>
</ol>
<p><strong>浏览器在第一次请求发生后，再次请求时：</strong></p>
<ol>
<li>验证是否命中强缓存，如果命中，就直接使用缓存了。</li>
<li>如果没有命中强缓存，就发请求到服务器检查是否命中协商缓存。</li>
<li>如果命中协商缓存，服务器会返回 304 告诉浏览器使用本地缓存。</li>
<li>否则，返回最新的资源。</li>
</ol>
<h4 id="强缓存-1"><a href="#强缓存-1" class="headerlink" title="强缓存"></a>强缓存</h4><p>强缓存是利用http的返回头中的<code>Expires</code>或者<code>Cache-Control</code>两个字段来控制的，用来表示资源的缓存时间。</p>
<font color="red">Expires</font>:<br>该字段是http1.0时的规范，它的值为一个绝对时间的GMT格式的时间字符串，比如Expires:Mon,18 Oct 2066 23:59:59 GMT。这个时间代表着这个资源的失效时间，在此时间之前，即命中缓存。这种方式有一个明显的缺点，由于失效时间是一个绝对时间，所以当服务器与客户端时间偏差较大时，就会导致缓存混乱。<br><br>——-<br><font color="red">Cache-Control</font>:<br>Cache-Control是http1.1时出现的header信息，主要是利用该字段的max-age值来进行判断，它是一个相对时间，例如Cache-Control:max-age=3600，代表着资源的有效期是3600秒。cache-control除了该字段外，还有下面几个比较常用的设置值：<br><br><em> no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。
</em> no-store：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。<br><em> public：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。
</em> private：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。<br><br><br><font color="red">Cache-Control与Expires可以在服务端配置同时启用，同时启用的时候Cache-Control优先级高。</font>

<h2 id="协商缓存-1"><a href="#协商缓存-1" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>当强缓存没有命中的时候，浏览器会发送一个请求到服务器，服务器根据 <code>header</code> 中的部分信息来判断是否命中缓存。如果命中，则返回<code>304</code> ，告诉浏览器资源未更新，可使用本地的缓存。</p>
<hr>
<p>header： <code>Last-Modify/If-Modify-Since</code>和 <code>ETag/If-None-Match</code>.</p>
<p><strong>Last-Modify/If-Modify-Since</strong><br>浏览器第一次请求一个资源的时候，服务器返回的 header 中会加上 Last-Modify，Last-modify 是一个时间标识该资源的最后修改时间。<br>当浏览器再次请求该资源时，request 的请求头中会包含 If-Modify-Since，该值为缓存之前返回的 Last-Modify。服务器收到 If-Modify-Since 后，根据资源的最后修改时间判断是否命中缓存。<br>如果命中缓存，则返回 304，并且不会返回资源内容，并且不会返回 Last-Modify。</p>
<font color="red">缺点:</font><br>1. <strong>短时间内资源发生了改变</strong>,<code>Last-Modified</code>并不会发生变化。<br>2. <strong>周期性变化</strong>,如果这个资源在一个周期内修改回原来的样子了，我们认为是可以使用缓存的，但是 <code>Last-Modified</code> 可不这样认为,因此便有了 <code>ETag</code><br><br><strong>ETag/If-None-Match</strong><br>与 <code>Last-Modify/If-Modify-Since</code> 不同的是，<code>Etag/If-None-Match</code>返回的是一个校验码。<code>ETag</code> 可以保证每一个资源是唯一的，资源变化都会导致 <code>ETag</code>变化。服务器根据浏览器上送的 <code>If-None-Match</code> 值来判断是否命中缓存。<br>与 <code>Last-Modified</code> 不一样的是，当服务器返回 <code>304 Not Modified</code>的响应时，由于 <code>ETag</code>重新生成过，<code>response header</code>中还会把这个 <code>ETag</code> 返回，即使这个 <code>ETag</code> 跟之前的没有变化。<br><br><font color="red">Last-Modified 与 ETag 是可以一起使用的，服务器会优先验证 ETag，一致的情况下，才会继续比对 Last-Modified，最后才决定是否返回 304。</font>


<hr>
<h3 id="实践检验"><a href="#实践检验" class="headerlink" title="实践检验"></a>实践检验</h3><p>我讨厌文字记忆，所以毫不犹豫选了理工科～～<br><code>talk is cheap , show me your code</code></p>
<p>⚠️ 实践过程控制台不要禁用缓存</p>
<p>利用<code>koa</code>启动<code>server</code>服务 <code>port：8000</code></p>
<p>引入静态资源 加载前端模版 去内蒙的航拍 哈哈哈 有我</p>
<p><img src="/images/cache/cache_one.png" alt="cache_one"></p>
<p>如图可见 初次访问 正常加载模版页面<code>cache</code>与图片资源<code>1.jpeg</code></p>
<p><strong>实现强缓存</strong></p>
<hr>
<ol>
<li><strong>服务端</strong>设置响应头Cache-Control 资源有效期为300秒</li>
</ol>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line"> </span><br><span class="line">  ctx.<span class="keyword">set</span>(&#123;</span><br><span class="line">    <span class="string">'Cache-Control'</span>: <span class="string">'max-age=300'</span>  </span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>刷新页面</li>
</ol>
<p><img src="/images/cache/cache1.png" alt="cache1"><br>响应头的<code>Cache-Control</code>变成了 max-age=300</p>
<p><font color="red">验证访问缓存的优先级:</font><br>第一次的网络请求,浏览器把图片资源缓存到了磁盘和内存里，根据约定 应该会先从内存中找资源</p>
<ol>
<li>再次刷新页面</li>
</ol>
<p> <img src="/images/cache/cache-----.png" alt="cache-----"></p>
<p>确实是从内存获取的</p>
<p>4.关掉页面再重新打开 （内存是存在进程中的,所以关闭该页面,内存中的资源也被释放掉了,磁盘中的资源是永久性的,所以还存在）<br><img src="/images/cache/cache_disk.png" alt="cache_disk"></p>
<p>from disk cache 从磁盘中获取资源</p>
<p>5.接下来 有效期 300秒 后.<br><img src="/images/cache/cachehuancunshixiao.png" alt="cachehuancunshixiao"><br>缓存失效 重新向服务器载入资源</p>
<hr>
<p><strong>实现协商缓存</strong><br>协商缓存本地测试直接拦截url给定code</p>
<p>Cache-Control 取默认值 no-cache</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">app.use( async(ctx, <span class="keyword">next</span>) =&gt; &#123;</span><br><span class="line"><span class="regexp">//</span> <span class="regexp">//</span> 强制缓存</span><br><span class="line"><span class="regexp">//</span>  ctx.set(&#123;</span><br><span class="line"><span class="regexp">//</span>    <span class="string">'Cache-Control'</span>: <span class="string">'max-age=300'</span>  </span><br><span class="line"><span class="regexp">//</span>  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> 协商缓存测试</span><br><span class="line"><span class="keyword">if</span>(ctx.url === <span class="string">'/imgs/1.jpeg'</span>)&#123;</span><br><span class="line">  ctx.status = <span class="number">304</span>;</span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br><span class="line">await <span class="keyword">next</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><img src="/images/cache/xieshang.png" alt="xieshang"></p>
<p>服务器返回<code>304</code> 同时<code>size</code>变小了很多 因为只返回了必要信息</p>
<p>也可利用 现成的插件帮我们计算文件的ETag<br><code>npm install koa-tag -D
npm install koa-conditional-get -D</code><br>就不演示了</p>
<p>加载资源发生变化（比如换了张图片）<code>ETag</code>改变 会导致协商缓存策略失效</p>
<p>然后  就行了. 😊</p>
<p>如果你想亲自体验</p>
<p><a href>源码在这里</a></p>
<p>day day up</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>2018 写在年终的话</title>
    <url>/2019/01/21/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>2018年终总结</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title>微信小程序开发常见问题</title>
    <url>/2017/07/19/%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="场景一：首页增加下拉刷新功能无效？"><a href="#场景一：首页增加下拉刷新功能无效？" class="headerlink" title="场景一：首页增加下拉刷新功能无效？"></a>场景一：首页增加下拉刷新功能无效？</h2><p>经过各种尝试 问题定位到了是因为 在<code>scroll-view</code>中使用了<code>onPullDownRefresh</code>，最后通过改首页的代码结构达到了预期结果</p>
<p>结论：<font face="STCAIYUN" color="#83933b" size="3"><br>在滚动 scroll-view 时会阻止页面回弹，所以在 scroll-view 中滚动，是无法触发 onPullDownRefresh</font></p>
<p>如果非要在<code>scroll-view</code>使用下拉刷新，<font face="STCAIYUN" color="#83933b" size="3">官方给出的解决方案</font>是监听页面的滚动事件 <code>bindscroll</code>  厄.. 也是一种方法 只不过我的更粗鲁一些</p>
<p><strong>其他需要注意的：</strong></p>
<ul>
<li>不要在<code>scroll-view</code>中使用 <code>textarea</code>、<code>map</code>、<code>canvas</code>、<code>video</code> 组件</li>
<li>目前只验证过 <code>textarea</code> 暂且放到场景二吧</li>
<li><code>scroll-into-view</code> 的优先级高于 <code>scroll-top</code></li>
</ul>
<h2 id="场景二：无法在-scroll-view中使用textarea？"><a href="#场景二：无法在-scroll-view中使用textarea？" class="headerlink" title="场景二：无法在 scroll-view中使用textarea？"></a>场景二：无法在 scroll-view中使用textarea？</h2><font face="STCAIYUN" color="red" size="3">这是个只有在真机上才会出现的bug</font>

<p>刚开始以为是不能在某些特定的组件内使用<code>textarea</code> 几番尝试 发现是因为 <code>textarea</code>组件与其他组件的层级关系 后来发现 <font face="STCAIYUN" color="#83933b" size="3">文档在最下方用最小号的字体给标注出来了已经！</font><font face="STCAIYUN" color="red" size="3">吐血</font></p>
<p>结论：<font face="STCAIYUN" color="#83933b" size="3"><br><code>textarea</code>组件是由客户端创建的原生组件，他的层级是最高的，在实际项目中 要保证本页面中 无 </font><font face="STCAIYUN" color="red" size="3">弹层</font>之类一切可能会覆盖到页面的鬼。<br></p>
<p><strong>其他需要注意的：</strong></p>
<ul>
<li>不要在 <code>scroll-view</code> 中使用 <code>textarea</code> 组件。</li>
<li>css 动画对 textarea 组件无效</li>
<li>textarea 的 <code>blur</code> 事件会晚于页面上的 tap 事件，如果需要在 button 的点击事件获取 textarea，可以使用 <code>form</code> 的 bindsubmit。</li>
<li>官方遗留bug: <code>textarea</code> 在列表渲染时，新增加的 textarea 在自动聚焦时的位置计算错误。<h2 id="场景三：textarea的placeholder不固定的问题"><a href="#场景三：textarea的placeholder不固定的问题" class="headerlink" title="场景三：textarea的placeholder不固定的问题"></a>场景三：textarea的placeholder不固定的问题</h2></li>
</ul>
<p>当把<code>textarea</code>放到一个<code>position：fixed</code>中的元素中时，会发现这个<code>textarea</code>也会跟着固定位置，但是<code>textarea</code>的placeholder内容不会固定，当滚动页面时，placeholder的内容会跟着滚动</p>
<p>解决方式：<font face="STCAIYUN" color="red" size="3">给<code>textarea</code>组件增加属性fixed<br></font></p>
<p>结论：<font face="STCAIYUN" color="#83933b" size="3">踩坑大法好</font></p>
<h2 id="场景四：微信小程序的兼容问题"><a href="#场景四：微信小程序的兼容问题" class="headerlink" title="场景四：微信小程序的兼容问题"></a>场景四：微信小程序的兼容问题</h2><p><code>wx.request()</code>返回的状态码<code>res.statusCode</code>的值 在IOS下是<font face="STCAIYUN" color="red" size="3">init</font>型的数据 但是在 Android 6.0.1 上却是 <font face="STCAIYUN" color="red" size="3">String</font> 型数据<br>要特别注意判断状态码的方式</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">X</span><br><span class="line">wx.request(&#123;</span><br><span class="line">    url: <span class="string">'http://api.example.com'</span>,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span> <span class="params">(res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (res.statusCode === <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="comment">// success</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// server failure</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">像这样使用 === 就错了 不要判断类型</span><br><span class="line">使用 ==即可</span><br></pre></td></tr></table></figure>
<p>小程序的WXML没有HTML的宽容度​那么高，单标签必需是 /&gt; 结尾的 不然会报错。</p>
<h2 id="场景五：小程序版本的兼容问题"><a href="#场景五：小程序版本的兼容问题" class="headerlink" title="场景五：小程序版本的兼容问题"></a>场景五：小程序版本的兼容问题</h2><p>无论用哪个组件 必须时刻注意当前兼容的版本 做低版本兼容</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"> <span class="selector-tag">wx</span><span class="selector-class">.openBluetoothAdapter</span>()</span><br><span class="line">&#125; <span class="selector-tag">else</span> &#123;</span><br><span class="line">  <span class="comment">// 如果希望用户在最新版本的客户端上体验您的小程序，可以这样子提示</span></span><br><span class="line">  <span class="selector-tag">wx</span><span class="selector-class">.showModal</span>(&#123;</span><br><span class="line">    <span class="attribute">title</span>: <span class="string">'提示'</span>,</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">'当前微信版本过低，无法使用该功能，请升级到最新微信版本后重试。'</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Fundebug</code>能够实时监测小程序，捕获小程序Bug，然后反馈给开发者<br><a href="https://fundebug.com/" target="_blank" rel="noopener">Fundebug</a></p>
<h2 id="场景六：小程序版本的兼容问题"><a href="#场景六：小程序版本的兼容问题" class="headerlink" title="场景六：小程序版本的兼容问题"></a>场景六：小程序版本的兼容问题</h2><p>绑定事件的时候，当两个方法重名时,后面的方法会覆盖前面的方法，并且IDE不报错</p>
<h2 id="场景七：image"><a href="#场景七：image" class="headerlink" title="场景七：image"></a>场景七：image</h2><p>小程序的image与HTML5的img最大的区别在于：<br>小程序的image是按照<code>background-image</code>来实现的。<br>默认image的高宽是320*240。必须通过样式定义去覆盖这个默认高宽，auto在这里不生效。</p>
<font face="STCAIYUN" color="red" size="3">开发者说这样设置的原因是：如果设置 auto ，页面布局会因为图片加载的过程有一个闪的现象（例如高度从 0 到 height ），所以要求一定要设置一个宽度和高度。</font>

<p>图片包括三种缩放模式scaleToFill、aspectFit、aspectFill和9种裁剪模式，三种缩放模式的实现原理对应如下：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">scaleToFill&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">background</span>-<span class="built_in">size</span>:<span class="number">100</span>% <span class="number">100</span>%;<span class="comment">//不保持纵横比缩放图片，使图片的宽高完全拉伸至填满 image 元素</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">aspectFit&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">background</span>-<span class="built_in">size</span>:contain;<span class="comment">//保持纵横比缩放图片，使图片的长边能完全显示出来。也就是说，可以完整地将图片显示出来。</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">aspectFill&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">background</span>-<span class="built_in">size</span>:cover;<span class="comment">//保持纵横比缩放图片，只保证图片的短边能完全显示出来。也就是说，图片通常只在水平或垂直方向是完整的，另一个方向将会发生截取。</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="场景八：navigator"><a href="#场景八：navigator" class="headerlink" title="场景八：navigator"></a>场景八：navigator</h2><p>navigator支持相对路径和绝对路径的跳转，默认是打开新页面，当前页面打开需要加redirect；<br>navigator仅支持<font face="STCAIYUN" color="red" size="3">5级</font>页面的跳转；<br>navigator不可跳转到小程序外的链接地址；</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">navigator</span> <span class="attr">class</span>=<span class="string">"navigator"</span> <span class="attr">redirect</span>  <span class="attr">url</span>=<span class="string">"../login/index"</span> &gt;</span>登录页<span class="tag">&lt;/<span class="name">navigator</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在小程序开发工具里，默认打开新页面，工具左上角有返回按钮。加上redirect，当前页打开，不出现返回按钮。</p>
<h2 id="场景八：大胆使用flex布局"><a href="#场景八：大胆使用flex布局" class="headerlink" title="场景八：大胆使用flex布局"></a>场景八：大胆使用flex布局</h2><p>在做传统H5的时候，为了兼容各种低端设备的机型，通常不太敢轻易尝试flex，但在小程序里就可以大胆的使用了。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.media</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="attribute">display</span>: flex;</span><br><span class="line"></span><br><span class="line"><span class="attribute">justify-content</span>:center;</span><br><span class="line"><span class="attribute">align-items</span>:center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.media</span> <span class="selector-class">.content</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="场景八：大胆使用flex布局-1"><a href="#场景八：大胆使用flex布局-1" class="headerlink" title="场景八：大胆使用flex布局"></a>场景八：大胆使用flex布局</h2><p>在做传统H5的时候，为了兼容各种低端设备的机型，通常不太敢轻易尝试flex，但在小程序里就可以大胆的使用了。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.media</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="attribute">display</span>: flex;</span><br><span class="line"></span><br><span class="line"><span class="attribute">justify-content</span>:center;</span><br><span class="line"><span class="attribute">align-items</span>:center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.media</span> <span class="selector-class">.content</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="场景八：页面最后一个-view-组件-设置margin-bottom属性-IOS-机型-失效的问题"><a href="#场景八：页面最后一个-view-组件-设置margin-bottom属性-IOS-机型-失效的问题" class="headerlink" title="场景八：页面最后一个 view 组件 设置margin-bottom属性 IOS 机型 失效的问题"></a>场景八：页面最后一个 view 组件 设置margin-bottom属性 IOS 机型 失效的问题</h2><p>解决方式：<font face="STCAIYUN" color="red" size="3">当前view 当前组件下加一个同级view<br></font></p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">wxml</span><br><span class="line">    &lt;<span class="built_in">view</span>&gt;这是个按钮&lt;/<span class="built_in">view</span>&gt;</span><br><span class="line">    &lt;<span class="built_in">view</span> class=<span class="string">"marginB"</span>&gt;&lt;/<span class="built_in">view</span>&gt;</span><br><span class="line"></span><br><span class="line">    css</span><br><span class="line"></span><br><span class="line">    .marginB&#123;</span><br><span class="line">        	<span class="built_in">height</span>: <span class="number">0rpx</span>;</span><br><span class="line">        	<span class="built_in">font</span>-size: <span class="number">0rpx</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h2 id="场景九：实现长按保存图片-短按图片隐藏"><a href="#场景九：实现长按保存图片-短按图片隐藏" class="headerlink" title="场景九：实现长按保存图片 短按图片隐藏"></a>场景九：实现长按保存图片 短按图片隐藏</h2><p>现有问题  用户体验不佳 长按需要抬起才能弹出 <code>sheetAction</code>菜单</p>
<p>理想状态下是长按开始计时 350秒之后自动弹操作菜单</p>
<p>利用 <code>bindtouchstart</code> 与 <code>bindtouchend</code>事件结合 <code>bindtap</code>实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">问题代码一</span><br><span class="line"></span><br><span class="line">WXML</span><br><span class="line"></span><br><span class="line">&lt;view  bindtouchstart=<span class="string">"mytouchstart"</span> bindtouchend=<span class="string">"mytouchend"</span> bindtap=<span class="string">"editAddress"</span> &gt;</span><br><span class="line"></span><br><span class="line">JS</span><br><span class="line"></span><br><span class="line">editAddress: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;  </span><br><span class="line">   <span class="keyword">let</span> that = <span class="keyword">this</span>;  </span><br><span class="line">   <span class="comment">//触摸时间距离页面打开的毫秒数  </span></span><br><span class="line">   <span class="keyword">var</span> touchTime = that.data.touch_end - that.data.touch_start;  </span><br><span class="line">   <span class="built_in">console</span>.log(touchTime);  </span><br><span class="line">   <span class="comment">//如果按下时间大于350为长按  </span></span><br><span class="line">   <span class="keyword">if</span> (touchTime &gt; <span class="number">350</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//TODO..</span></span><br><span class="line"></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//TODO..</span></span><br><span class="line"></span><br><span class="line">   &#125;  </span><br><span class="line"> &#125;,  </span><br><span class="line"> <span class="comment">//按下事件开始  </span></span><br><span class="line"> mytouchstart: <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;  </span><br><span class="line">   <span class="keyword">let</span> that = <span class="keyword">this</span>;  </span><br><span class="line">   that.setData(&#123;  </span><br><span class="line">     touch_start: e.timeStamp  </span><br><span class="line">   &#125;)  </span><br><span class="line">   <span class="built_in">console</span>.log(e.timeStamp + <span class="string">'- touch-start'</span>)  </span><br><span class="line"> &#125;,  </span><br><span class="line"> <span class="comment">//按下事件结束  </span></span><br><span class="line"> mytouchend: <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;  </span><br><span class="line">   <span class="keyword">let</span> that = <span class="keyword">this</span>;  </span><br><span class="line">   that.setData(&#123;  </span><br><span class="line">     touch_end: e.timeStamp  </span><br><span class="line">   &#125;)  </span><br><span class="line">   <span class="built_in">console</span>.log(e.timeStamp + <span class="string">'- touch-end'</span>)  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>改进</p>
<p>小程序的事件触发顺序</p>
<p>单击 touchstart → touchend → tap<br>双击 touchstart → touchend → tap → touchstart → touchend → tap<br>长按 touchstart → longtap → touchend → tap</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">问题代码二</span><br><span class="line"></span><br><span class="line">wxml</span><br><span class="line"></span><br><span class="line">&lt;view  bindlongtap=<span class="string">"longPress"</span>   bindtap=<span class="string">"tapFun"</span> style=<span class="string">"width: 100%;height:100%"</span> mode=<span class="string">"scaleToFill"</span> src=<span class="string">"&#123;&#123;img_url&#125;&#125;"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">js</span><br><span class="line"></span><br><span class="line">longPress(e)&#123;</span><br><span class="line">  <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'你点击了长按时间'</span>,e)</span><br><span class="line">  <span class="comment">// 可以通过 wx.getSetting 先查询一下用户是否授权了 "scope.record" 这个 scope</span></span><br><span class="line">  wx.getSetting(&#123;</span><br><span class="line">      success(res) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'222222222222222222'</span>)</span><br><span class="line">          <span class="keyword">if</span> (!res[<span class="string">'scope.writePhotosAlbum'</span>]) &#123;</span><br><span class="line">              wx.authorize(&#123;</span><br><span class="line">                  scope: <span class="string">'scope.writePhotosAlbum'</span>,</span><br><span class="line">                  success() &#123;</span><br><span class="line">                   <span class="comment">//  调起操作菜单</span></span><br><span class="line">                   <span class="built_in">console</span>.log(<span class="string">'33333333333333333333'</span>)</span><br><span class="line">                   <span class="built_in">console</span>.log(<span class="string">'wx.showActionSheet()'</span>,wx.showActionSheet)</span><br><span class="line">                    wx.showActionSheet(&#123;</span><br><span class="line">                         itemList: [<span class="string">'保存到本地'</span>],</span><br><span class="line">                         success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">                           <span class="built_in">console</span>.log(<span class="string">'操作菜单弹出成功'</span>,<span class="string">'第'</span>+res.tapIndex+<span class="string">'个操作菜单弹出成功'</span>)</span><br><span class="line">                           <span class="comment">// 下载文件资源到本地。客户端直接发起一个 HTTP GET 请求，返回文件的本地临时路径。</span></span><br><span class="line">                         <span class="keyword">if</span>(res.tapIndex ==<span class="number">0</span>)&#123;</span><br><span class="line">                          <span class="built_in">console</span>.log(<span class="string">'wx.downloadFile'</span>,wx.downloadFile)</span><br><span class="line">                           wx.downloadFile(&#123;</span><br><span class="line">                           url: that.data.img_url, <span class="comment">//仅为示例，并非真实的资源</span></span><br><span class="line">                           success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">                             wx.playVoice(&#123;</span><br><span class="line">                               filePath: res.tempFilePath</span><br><span class="line">                             &#125;);</span><br><span class="line">                             <span class="built_in">console</span>.log(<span class="string">'wx.playVoice()'</span>,wx.playVoice)</span><br><span class="line">                             <span class="built_in">console</span>.log(<span class="string">'将图片先保存到本地--res.tempFilePath'</span>,res.tempFilePath);</span><br><span class="line">                                     <span class="comment">// 用户已经同意小程序使用功能，后续调用 wx.startRecord 接口不会弹窗询问</span></span><br><span class="line">                                     <span class="built_in">console</span>.log(<span class="string">'wx.saveImageToPhotosAlbum()'</span>,wx.saveImageToPhotosAlbum)</span><br><span class="line">                                     wx.saveImageToPhotosAlbum(&#123;</span><br><span class="line">                                       filePath:res.tempFilePath,</span><br><span class="line">                                       success(res) &#123;</span><br><span class="line">                                         wx.showToast(&#123;</span><br><span class="line">                                         title: <span class="string">'保存成功'</span>,</span><br><span class="line">                                         icon: <span class="string">'success'</span></span><br><span class="line">                                       &#125;);</span><br><span class="line">                                       setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                                         wx.hideToast();</span><br><span class="line">                                       &#125;,<span class="number">3000</span>)</span><br><span class="line">                                       &#125;,</span><br><span class="line">                                       fail(res)&#123;</span><br><span class="line">                                         wx.showToast(&#123;</span><br><span class="line">                                         title: <span class="string">'保存失败'</span>,</span><br><span class="line">                                         icon: <span class="string">'success'</span></span><br><span class="line">                                       &#125;);</span><br><span class="line">                                       setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                                         wx.hideToast();</span><br><span class="line">                                       &#125;,<span class="number">3000</span>)</span><br><span class="line">                                       &#125;</span><br><span class="line">                                   &#125;)</span><br><span class="line"></span><br><span class="line">                           &#125;</span><br><span class="line">                         &#125;)</span><br><span class="line">                         &#125;</span><br><span class="line">                         &#125;,</span><br><span class="line">                         fail: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">                           <span class="built_in">console</span>.log(<span class="string">'操作菜单弹出失败'</span>,res.tapIndex)</span><br><span class="line">                         &#125;</span><br><span class="line">               &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tapFun: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        that.setData(&#123;</span><br><span class="line">        qrShow:<span class="literal">false</span></span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">很显然 这也是有问题的</span><br><span class="line"></span><br><span class="line">因为事件机制。总会触发 tap事件 表现形式比 问题一还难以接受</span><br></pre></td></tr></table></figure>
<p>好了，结合前两种 解决办法如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">WXml</span><br><span class="line"></span><br><span class="line"> &lt;image  wx:<span class="keyword">if</span>=<span class="string">"&#123;&#123;img_url !=''&#125;&#125;"</span>  bindlongtap=<span class="string">"editAddress1"</span>   bindtouchstart=<span class="string">"mytouchstart"</span> bindtouchend=<span class="string">"mytouchend"</span>  style=<span class="string">"width: 100%;height:100%"</span> mode=<span class="string">"scaleToFill"</span> src=<span class="string">"&#123;&#123;img_url&#125;&#125;"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">js</span><br><span class="line"></span><br><span class="line"><span class="comment">//按下事件开始</span></span><br><span class="line">mytouchstart:<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> that = <span class="keyword">this</span>;</span><br><span class="line">  that.setData(&#123;</span><br><span class="line">    touch_start: e.timeStamp</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(e.timeStamp + <span class="string">'- touch-start'</span>)</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">//按下事件结束</span></span><br><span class="line">mytouchend:<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> that = <span class="keyword">this</span>;</span><br><span class="line">  that.setData(&#123;</span><br><span class="line">    touch_end: e.timeStamp</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(e.timeStamp + <span class="string">'- touch-end'</span>)</span><br><span class="line">  that.editAddress(e);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是长按操作还是短按操作</span></span><br><span class="line">editAddress: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">      <span class="keyword">if</span>(that.data.touch_end - that.data.touch_start &lt; <span class="number">350</span>)&#123;</span><br><span class="line">        that.setData(&#123;</span><br><span class="line">        qrShow:<span class="literal">false</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">editAddress1(e)&#123;&#125;   <span class="comment">// 同问题二  longPress（）</span></span><br></pre></td></tr></table></figure>
<h2 id="场景十：第二次扫码进入小程序的缓存问题"><a href="#场景十：第二次扫码进入小程序的缓存问题" class="headerlink" title="场景十：第二次扫码进入小程序的缓存问题"></a>场景十：第二次扫码进入小程序的缓存问题</h2>]]></content>
      <tags>
        <tag>issue</tag>
        <tag>wechat</tag>
      </tags>
  </entry>
  <entry>
    <title>彻底理解js是如何工作的</title>
    <url>/2018/11/17/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3js%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/</url>
    <content><![CDATA[<p>曾经 你一定遇到过类似这样儿的题目</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(<span class="string">'script start'</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span></span> &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">'timer over'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">Promise.resolve().<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span></span> &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">'promise1'</span>)</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span></span> &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">'promise2'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">'script end'</span>)</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">script start</span><br><span class="line">script <span class="keyword">end</span></span><br><span class="line">promise1</span><br><span class="line">promise2</span><br></pre></td></tr></table></figure>
<p>如果你很轻松的答对并且能说出原理 那么恭喜你，倘若有些疑问，那么读完这篇文章，你一定会彻底搞懂它的运行原理。</p>
<a id="more"></a>
<h3 id="首先-先了解几个概念"><a href="#首先-先了解几个概念" class="headerlink" title="首先  先了解几个概念"></a>首先  先了解几个概念</h3><blockquote>
<p>JavaScript引擎</p>
</blockquote>
<p>js引擎是执行js的程序或者解释器 我们常说的V8引擎就是一种js引擎的实现，其他的还有基于<code>java</code>开发的<code>Rhin</code> <code>Nashorn</code>等</p>
<p>V8引擎 使用在chrome 和node中，它由两部分组成</p>
<ul>
<li>内存堆 ：这是内存分配发生的地方</li>
<li>调用栈： 这是你的代码执行时的地方</li>
</ul>
<hr>
<blockquote>
<p>JS的特性</p>
</blockquote>
<font color="red">单线程 异步 非阻塞</font>

<p><strong>js的单线程</strong><br>由于js的单线程</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">console.<span class="built_in">log</span>('script start')</span><br><span class="line">console.<span class="built_in">log</span>('do something...')</span><br><span class="line">console.<span class="built_in">log</span>('script end')</span><br><span class="line"></span><br><span class="line"><span class="comment">// script start</span></span><br><span class="line"><span class="comment">// do something...</span></span><br><span class="line"><span class="comment">// script end</span></span><br></pre></td></tr></table></figure>
<p>很好理解</p>
<p>那再来看</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'2'</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'3'</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> 点击页面</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'4'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'5'</span>)</span><br></pre></td></tr></table></figure>
<p>那么它的输出是什么呢？ 应该是<code>1，2，4，5，3</code>？ 而不是<code>1，2，3，4，5</code>，js不是一行一行从上到下执行的吗 为啥会出现这种情况？</p>
<p><strong>这就是我们接下来要说的问题</strong></p>
<p>为什么不能同步执行？</p>
<p>如果一个任务的处理耗时（或者是等待）很久的话，如：网络请求、定时器、等待鼠标点击等，后面的任务也就会被阻塞,可能会出现白屏的情况 用户体验极其不友好</p>
<p>所幸的是 浏览器给我们提供了很多有用的<code>webapi</code></p>
<p>如何优化？</p>
<p>js的单线程指的是浏览器中负责解释和执行js代码的只有一个线程 -js引擎线程 但是浏览器的渲染进程是提供多个线程的，遇到定时器 Dom事件或者是网络请求的任务的时候 js引擎会将他们交给webapi 也就是浏览器提供的相应线程去处理 而js引擎线程继续去处理后面的任务 这样儿实现了<strong>异步非阻塞</strong><br>以下是日常线程：</p>
<ul>
<li>js引擎线程</li>
<li>事件触发线程</li>
<li>定时器触发线程</li>
<li>异步HTTP请求线程</li>
<li>GUI渲染线程</li>
</ul>
<p>图示的话 大概长下面这样儿<br><img src="/images/jsWorker/jsworker.jpg" alt="jsworke"><br>所以 这里的 图例中的<code>setTimeout</code>会被分配到定时器触发线程去维护 去定时，时间一到 还是会把它的回调塞到<code>消息队列</code>等待</p>
<p>那么 到这里 又引出了两个问题<br>1.什么叫消息队列？<br>2.js引擎什么时候处理这个定时器 怎么处理？</p>
<p>JavaScript 通过事件循环（ event loop）的机制来解决这些问题<br>猜对了吗？<br>事件循环 机制和 消息队列 的维护是由<strong>事件触发线程</strong>（浏览器渲染引擎webapi之一）控制的</p>
<p>JS引擎线程 会维护一个 执行栈</p>
<ol>
<li>同步和异步任务进入不同的执行场所 同步的进入<strong>主线程</strong> 异步的进入Event Table并注册函数</li>
<li>当指定的事情完成时 Event Table会将这个函数移入<strong>Event Queue</strong></li>
<li>主线程内的任务执行完毕为空，会去<strong>Event Queue</strong>读取对应的函数，进入主线程执行</li>
<li>上述过程会不断重复，也就是常说的<strong>Event Loop</strong>(事件循环)。</li>
</ol>
<p>言语太过苍白 举个🌰～</p>
<p><img src="/images/jsWorker/jswork2.jpg" alt="jswork2"></p>
<p>所以 这个时候来看<br>setTimeout异步函数对应的回调函数( () =&gt; {} )会在执行栈为空，主代码块执行完了后才会执行</p>
<p>结果就不意外了吧</p>
<p>那么 像这样</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timer'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>0延时的情况是啥意思呢<br>只是 timer的回调函数会立即加入消息队列而已，回调的执行还是得等执行栈为空（JS引擎线程空闲）时执行。</p>
<p>还没完～～</p>
<p>ES5中以上标准就够用了 但是ES6中新出了一些API 引出了一些新概念</p>
<blockquote>
<p>宏任务与微任务</p>
</blockquote>
<p>先来看一段代码 你能立刻说出它的执行结果吗</p>
<figure class="highlight scilab"><table><tr><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(<span class="string">'script start'</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span> &#123;</span></span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">'timer over'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">Promise.resolve().<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span> &#123;</span></span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">'promise1'</span>)</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span> &#123;</span></span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">'promise2'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">'script end'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// script start</span></span><br><span class="line"><span class="comment">// script end</span></span><br><span class="line"><span class="comment">// promise1</span></span><br><span class="line"><span class="comment">// promise2</span></span><br><span class="line"><span class="comment">// timer over</span></span><br></pre></td></tr></table></figure>
<p>What？ timer over 会在 promise1 promise2 之后执行？</p>
<p>好的 不要着急 往下看👇<br>所有任务分为 <code>宏任务</code> 和 <code>微任务</code></p>
<ul>
<li>宏任务（macrotask）：主代码块、setTimeout、setInterval等（可以看到，事件队列中的每一个事件都是一个 macrotask，现在称之为宏任务队列</li>
<li>微任务（microtask）：Promise、process.nextTick等 在microtask中 process.nextTick 优先级高于 Promise，它用来调度应在当前执行的脚本执行结束后立即执行的任务</li>
</ul>
<p>事件（任务）队列和宏任务和微任务的联系：</p>
<ul>
<li>一个事件循环有一个或者多个任务队列；</li>
<li>每个事件循环都有一个microtask队列</li>
<li>macrotask队列就是我们常说的任务队列，microtask队列不是任务队列</li>
<li>一个任务可以被放入到macrotask队列，也可以放入microtask队列</li>
<li>当一个任务被放入microtask或者macrotask队列后，准备工作就已经结束，这时候可以开始执行任务了</li>
</ul>
<p>js的执行规则：</p>
<ol>
<li>执行一个宏任务（栈中没有就从事件队列中获取）</li>
<li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</li>
<li>宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）</li>
<li>当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染</li>
<li>渲染完毕后，JS引擎线程继续，开始下一个宏任务（从宏任务队列中获取）</li>
</ol>
<p>所以 promise1 与 promise1属于微任务 会在第一个宏任务结束之后立即执行 而setTimeout即使延时为0 也是要等到下个事件循环去执行的😊</p>
<p>再简单点的话 那就</p>
<p>macro-task队列包含任务: a1, a2 , a3<br>micro-task队列包含任务: b1, b2 , b3</p>
<p>执行顺序为，首先执行marco-task队列开头的任务，也就是 a1 任务，执行完毕后，在执行micro-task队列里的所有任务，也就是依次执行b1, b2 , b3，执行完后清空micro-task中的任务，接着执行marco-task中的第二个任务，依次循环。</p>
<p>再简单点的话 那就.. 上图吧😄</p>
<p><img src="/images/jsWorker/jsworker3.jpg" alt="jsworke">s</p>
<p>好的 理解的话 再来一个栗子 你可能继续懵逼</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;console.<span class="built_in">log</span>(<span class="number">1</span>)&#125;,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">new Promise(<span class="function"><span class="keyword">function</span><span class="params">(resolve,reject)</span></span>&#123;</span><br><span class="line">   console.<span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line">   resolve();</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;console.<span class="built_in">log</span>(<span class="number">3</span>)</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;console.<span class="built_in">log</span>(<span class="number">4</span>)&#125;);</span><br><span class="line"></span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;console.<span class="built_in">log</span>(<span class="number">5</span>)&#125;);</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(<span class="number">6</span>);</span><br><span class="line">输出 <span class="number">2</span>，<span class="number">6</span>，<span class="number">5</span> ，<span class="number">3</span>，<span class="number">4</span>，<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>定义promise的构造部分是同步的<br>如下<br>script(主程序代码)——&gt;process.nextTick——&gt;promise——&gt;setTimeout</p>
<p>关于 process.nextTick()<br>插入到事件队列尾部，但在下次事件队列之前会执行。也就是说，它指定的任务总是发生在所有异步任务之前，当前主线程的末尾。<br>大致流程：当前”执行栈”的尾部–&gt;下一次Event Loop（主线程读取”任务队列”）之前–&gt;触发process指定的回调函数。<br>服务器端node提供的办法。用此方法可以用于处于异步延迟的问题。<br>可以理解为：此次不行，预约下次优先执行。</p>
<p>好的 再再来一个😂</p>
<figure class="highlight scilab"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;<span class="title">console</span>.<span class="title">log</span><span class="params">(1)</span>&#125;,0); （<span class="title">setTimeout1</span>）</span></span><br><span class="line"></span><br><span class="line">new Promise(<span class="function"><span class="keyword">function</span><span class="params">(resolve,reject)</span>&#123;</span></span><br><span class="line">   console.<span class="built_in">log</span>(<span class="number">2</span>);  （promise1）</span><br><span class="line">   setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;<span class="title">resolve</span><span class="params">()</span>&#125;,0) （<span class="title">setTimeout2</span>）</span></span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;<span class="title">console</span>.<span class="title">log</span><span class="params">(3)</span>  （<span class="title">then1</span>）</span></span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;<span class="title">console</span>.<span class="title">log</span><span class="params">(4)</span>&#125;); （<span class="title">then2</span>）</span></span><br><span class="line"></span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;<span class="title">console</span>.<span class="title">log</span><span class="params">(5)</span>&#125;); （<span class="title">nextTick</span>）</span></span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(<span class="number">6</span>); （<span class="built_in">log</span>）</span><br><span class="line">输出： <span class="number">2</span> <span class="number">6</span> <span class="number">5</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>区别在于promise的构造中，没有同步的resolve，因此promise.then在当前的执行队列中是不存在的，只有promise从pending转移到resolve，才会有then方法，而这个resolve是在一个setTimout时间中完成的，因此3,4最后输出。</p>
<p>写到这里 想到一个某位大师的很形象的例子</p>
<p>事件循环队列就类似于游乐园游戏，玩过了一个游戏之后 你需要到队尾去排队才能再玩一次 而任务队列类似w玩过了这个游戏之后 插队接着玩<br>看到这里 文章开头的题目应该不成问题了 甚至还觉得so easy</p>
<p>好的 到这里 就完了 下面是两个js运行时的概念 你可以傲娇的略过</p>
<hr>
<blockquote>
<p>js执行时</p>
</blockquote>
<p>js调用栈</p>
<p>拥有 LIFO（后进先出）数据结构的栈，被用来存储代码运行时创建的所有<strong>执行上下文</strong>，记录了我们在程序中的位置  如果我们运行到一个函数 它就会将其放到栈顶 当从这个函数返回的时候，就会将这个函数从栈顶弹出，这就是调用栈做的事情</p>
<p>当 <code>JavaScript</code> 引擎第一次遇到你的脚本时，它会创建一个全局的执行上下文并且压入当前执行栈。每当引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部。</p>
<p>引擎会执行那些执行上下文位于栈顶的函数。当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文</p>
<hr>
<blockquote>
<p>js执行上下文</p>
</blockquote>
<p>执行上下文是评估和执行js代码的环境的抽象概念<br>js代码在执行的时候 它都是在执行上下文中运行</p>
<p>它分为三种类型</p>
<ol>
<li>全局执行上下文</li>
</ol>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">它会执行两件事： 创建一个全局<span class="built_in">window</span>对象 并且设置<span class="keyword">this</span>的值等于这个全局对象 一个程序中只会有一个全局执行上下文</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>函数执行上下文</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">函数被调用时候 会创建上下文，函数上下文可以有任意多个  每当一个新的执行上下文被创建 它会按定义的顺序 执行一系列步骤</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>eval函数执行上下文</li>
</ol>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">执行在<span class="built_in">eval</span>函数内部的代码会有他自己的执行上下文</span><br></pre></td></tr></table></figure>
<p><strong>js如何创建执行上下文</strong></p>
<p>两个阶段</p>
<ul>
<li>创建阶段</li>
<li>执行阶段</li>
</ul>
<p>代码执行栈 执行上下文经历创建阶段 会发生</p>
<ol>
<li>this值的制定</li>
<li>创建词法环境组件</li>
<li>创建变量环境组件</li>
</ol>
<hr>
<p>最后的最后</p>
<p>JavaScript 是单线程语言，决定于它的设计最初是用来处理浏览器网页的交互。浏览器负责解释和执行 JavaScript 的线程只有一个（所以说是单线程），即JS引擎线程，但是浏览器同样提供其他线程，如：事件触发线程、定时器触发线程等</p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>微信小程序 初见篇</title>
    <url>/2017/07/19/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%20%E5%88%9D%E8%A7%81%E7%AF%87/</url>
    <content><![CDATA[<ul>
<li><p><strong>题外话</strong></p>
<ul>
<li><a href="#line6"> <font face="STCAIYUN" size="3">关于微信小程序</font></a></li>
<li><a href="#line5"> <font face="STCAIYUN" size="3">小程序与传统HTML5的区别</font></a></li>
</ul>
</li>
<li><p><strong>框架</strong></p>
<ul>
<li><a href="#line1"> <font face="STCAIYUN" size="3">目录结构与配置</font></a></li>
<li><a href="#line2"> <font face="STCAIYUN" size="3">逻辑层</font></a></li>
<li><a href="#line3"> <font face="STCAIYUN" size="3">视图层</font></a></li>
<li><a href="#line4"> <font face="STCAIYUN" size="3">运行机制</font></a></li>
</ul>
</li>
</ul>
<p><br></p>
<a id="more"></a>
<p id="line6"><br><font face="STCAIYUN" color="#883958" size="4">关于微信小程序</font><br></p>

<p><strong>小程序是什么？它有着什么样的功能？</strong></p>
<p>A：小程序是一种不需要下载安装即可使用的应用，用户扫一扫或者搜一下即可打开应用。也体现了“用完即走”的理念，通过公众号关联，用户可以实现公众号与小程序之间相互跳转。</p>
<p><strong>小程序可以和现有的App 打通吗？</strong></p>
<p>A：小程序可以借助微信联合登录，和开发者已有的App 后台的用户数据进行打通，但不会支持小程序和App 直接的跳转，<font face="STCAIYUN" color="red" size="4">现在最新版已经支持小程序跳转到另一个小程序了</font></p>
<p id="line5"><br><font face="STCAIYUN" color="#883958" size="4">小程序与传统HTML5的区别</font><br></p>

<ul>
<li><p><strong>开发工具不同</strong><br>区别于H5的开发工具+浏览器Device Mode预览的模式，小程序的开发基于自己的开发者工具，可以实现同步本地文件+开发调试+编译+预览+上传+发布等一整套流程。</p>
</li>
<li><p><strong>开发语言不同</strong><br>小程序自己开发了一套WXML标签语言和WXSS样式语言，并非直接使用标准的HTML5+css3。</p>
</li>
<li><strong>组件封装不同</strong><br>小程序独立出来了很多原生APP的组件，在HTML5需要模拟才能实现的功能，小程序里可以直接调用组件。</li>
</ul>
<p>传统HTML5在加载的时候受限于网络环境，需要顺序加载HTML、CSS、JS，然后返回数据，最后渲染页面显示在浏览器中</p>
<p>小程序的两个线程：逻辑层和视图层会同时进行、并行加载，甚至视图层会更早执行，当视图线程加载完，通知逻辑层，逻辑层会把准备好的数据用setData的方法返回给视图线程</p>
<p id="line1"><br><font face="STCAIYUN" color="#883958" size="4">目录结构与配置</font><br></p>

<p><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html" target="_blank" rel="noopener">官方框架配置</a></p>
<p>小程序包含一个描述整体程序的app和多个描述各个页面的page<br>小程序的主体部分由三个文件组成 必须放在<font face="STCAIYUN" color="#883958" size="3">项目的根目录</font>下</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">app<span class="selector-class">.js</span> 小程序入口逻辑</span><br><span class="line">app<span class="selector-class">.json</span> 小程序的公共设置</span><br><span class="line">对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等</span><br><span class="line">app<span class="selector-class">.wxss</span> 小程序的公共样式表</span><br></pre></td></tr></table></figure>
<p>一个程序页面由四个页面组成</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">wxml 页面结构</span><br><span class="line">wxss 页面的样式表 （不必填）</span><br><span class="line"><span class="keyword">json </span>页面的配置 （不必填）</span><br><span class="line"><span class="keyword">js </span>  页面逻辑</span><br></pre></td></tr></table></figure>
<font face="STCAIYUN" color="#83933b" size="3"><br>为了方便开发者减少配置项，我们规定描述页面的这四个文件必须具有相同的路径与文件名。</font>

<p id="line2"><br><font face="STCAIYUN" color="#883958" size="4">逻辑层</font><br></p>

<p>小程序开发框架的逻辑层是由<font face="STCAIYUN" color="#83933b" size="3">Javascript</font>编写的<br>逻辑层将数据进行处理后发送给视图层，同时接收视图层的反馈，为了方便开发 小程序做了以下更改</p>
<ol>
<li><font face="STCAIYUN" color="#83933b" size="3">增加APP和Page方法，进行程序和页面的注册</font>

<p>APP()函数用来注册一个小程序 接受一个object参数 也就是小程序的生命周期函数</p>
</li>
</ol>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">onLaunch</span>	监听小程序初始化 当小程序初始化完成时，会触发 <span class="literal">on</span>Launch（全局只触发一次）</span><br><span class="line"><span class="literal">on</span>Show		生命周期函数--监听小程序显示	当小程序启动，或从后台进入前台显示，会触发 <span class="literal">on</span>Show</span><br><span class="line"><span class="literal">on</span>Hide		生命周期函数--监听小程序隐藏	当小程序从前台进入后台，会触发 <span class="literal">on</span>Hide</span><br><span class="line"></span><br><span class="line">前台、后台定义： 当用户点击左上角关闭，或者按了设备 Home 键离开微信，小程序并没有直接销毁，而是进入了后台；当再次进入微信或再次打开小程序，又会从后台进入前台。需要注意的是：只有当小程序进入后台一定时间，或者系统资源占用过高，才会被真正的销毁。</span><br><span class="line"></span><br><span class="line"><span class="literal">on</span>Error		错误监听函数	当小程序发生脚本错误，或者 api 调用失败时，会触发 <span class="literal">on</span>Error 并带上错误信息</span><br><span class="line">当然了 开发者也可以添加任意的函数或数据到 Object 参数中，用 this 可以访问比如点击 长按 事件等</span><br></pre></td></tr></table></figure>
<p>  Page()函数用来注册一个页面 接受一个object参数 其指定页面的初始数据、生命周期函数、事件处理函数等。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">data</span>		            页面的初始数据</span><br><span class="line"><span class="literal">on</span>Load(query)		   生命周期函数--监听页面加载</span><br><span class="line"><span class="literal">on</span>Ready		         生命周期函数--监听页面初次渲染完</span><br><span class="line"><span class="literal">on</span>Show		         生命周期函数--监听页面显示</span><br><span class="line"><span class="literal">on</span>Hide		         生命周期函数--监听页面隐藏</span><br><span class="line"><span class="literal">on</span>Unload		         生命周期函数--监听页面卸载</span><br><span class="line"><span class="literal">on</span>PullDownRefresh		页面相关事件处理函数--监听用户下拉</span><br><span class="line"><span class="literal">on</span>ReachBottom		   页面上拉触底事件的处理函数</span><br><span class="line"><span class="literal">on</span>ShareAppMessage		用户点击右上角转发</span><br><span class="line"><span class="literal">on</span>PageScroll(scrollTop)		   页面滚动触发事件的处理函数 参数代表页面垂直方向已经滚动的距离</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">route 字段可以获取到当前页面的路径。</span><br><span class="line">注册函数里 console.log(<span class="string">'this.route'</span>,<span class="keyword">this</span>.route)</span><br><span class="line"></span><br><span class="line">setData 函数以key value 的形式接收一个对象 用于将数据从逻辑层发送到视图层，改变对应的 <span class="keyword">this</span>.<span class="keyword">data</span>中相应key的值。</span><br><span class="line"><span class="keyword">set</span>的值不需要在<span class="keyword">this</span>.<span class="keyword">data</span>中预先定义</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">      name:<span class="string">'马莹'</span></span><br><span class="line">    &#125;)</span><br><span class="line">    console.log(<span class="string">'this.data'</span>,<span class="keyword">this</span>.<span class="keyword">data</span>)</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line"></span><br><span class="line">    直接修改 <span class="keyword">this</span>.<span class="keyword">data</span> 而不调用 <span class="keyword">this</span>.setData 是无法改变页面的状态的，还会造成数据不一致</span><br><span class="line">    单次设置的数据不能超过<span class="number">1024</span>kB，请尽量避免一次设置过多的数据。</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><font face="STCAIYUN" color="#83933b" size="3">增加getAPP和getCurrentPages方法，分别用来获取App实例和当前技术栈</font>

<p>可以根据全局函数获取到小程序的实例</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> appInstance = getApp()</span><br><span class="line"><span class="built_in">console</span>.log(appInstance.globalData)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'getCurrentPages()'</span>,getCurrentPages())</span><br></pre></td></tr></table></figure>
<font face="STCAIYUN" color="#b36666" size="3">小tips：</font>

<ul>
<li><code>App()</code> 必须在app.js中注册，只能注册一次</li>
<li>在定义在<code>APP()</code>的函数中想获取app实例，不要用<code>getApp()</code> 的方式 直接用<font face="STCAIYUN" color="#b36666" size="3">this</font>就行</li>
<li><p>不要在onLaunch的时候调用<code>getCurrentPages()</code>，此时page还没有生成<br><br><br>3 . <font face="STCAIYUN" color="#83933b" size="3">每个页面有独立的作用域，并提供模块化的能力</font></p>
<p>  在javascript文件中声明的变量和函数只是在该文件中有效</p>
<p>   我们可以将一些公共的代码抽离成为一个单独的 js 文件，作为一个模块。模块只有通过 module.exports 或者 exports 才能对外暴露接口。</p>
<pre><code>需要注意的是：

exports 是 module.exports 的一个引用，因此在模块里边随意更改 exports 的指向会造成未知的错误。所以我们更推荐开发者采用 module.exports 来暴露模块接口，除非你已经清晰知道这两者的关系。
小程序目前不支持直接引入 node_modules , 开发者需要使用到 node_modules 时候需要拷贝出相关的代码到小程序的目录中。
</code></pre></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Hello <span class="subst">$&#123;name&#125;</span> !`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayGoodbye</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Goodbye <span class="subst">$&#123;name&#125;</span> !`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports.sayHello = sayHello</span><br><span class="line">exports.sayGoodbye = sayGoodbye</span><br><span class="line"></span><br><span class="line">引用</span><br><span class="line"><span class="keyword">var</span> common = <span class="built_in">require</span>(<span class="string">'common.js'</span>)  <span class="built_in">require</span> 暂时不支持绝对路径</span><br><span class="line">Page(&#123;</span><br><span class="line">  helloMINA: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    common.sayHello(<span class="string">'MINA'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  goodbyeMINA: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    common.sayGoodbye(<span class="string">'MINA'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>4 .  <font face="STCAIYUN" color="#83933b" size="3">由于框架并非运行在浏览器中，所以 JavaScript 在 web 中一些能力都无法使用，如 document，window 等。 </font></p>
<p>5 . <font face="STCAIYUN" color="#83933b" size="3">开发者写的所有代码最终将会打包成一份 JavaScript，并在小程序启动的时候运行，直到小程序销毁， </font></p>
<p><strong>页面路由</strong><br>在小程序中所有页面的路由全部由框架进行管理。<br>框架以栈的形式维护了当前的所有页面。 当发生路由切换的时候，页面栈的表现如下：</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">初始化-&gt; 新页面入栈</span><br><span class="line">打开新页面-&gt; 新页面入栈</span><br><span class="line">页面重定向-&gt; 当前页面出栈 新页面入栈</span><br><span class="line">页面返回-&gt; 页面不断出栈，直到目标返回页，新页面入栈</span><br><span class="line">Tab切换-&gt;  页面全部出栈 只留下新的Tab页面</span><br><span class="line">重加载-&gt;  页面全部出栈 只留下新的页面</span><br></pre></td></tr></table></figure>
 <font face="STCAIYUN" color="#b36666" size="3">小tips：</font><br><em>  <code>navigateTo</code>, <code>redirectTo</code> 只能打开非 tabBar 页面。
</em>  switchTab 只能打开 tabBar 页面<br><em>  reLaunch 可以打开任意页面
</em> 页面底部的 tabBar 由页面决定，即只要是定义为 tabBar 的页面，底部都有 tabBar。<br><p id="line3"><br><font face="STCAIYUN" color="#883958" size="4">视图层</font><br></p><br><br><strong>WXml </strong><br>WXML（WeiXin Markup Language）是框架设计的一套标签语言，结合基础组件、事件系统，可以构建出页面的结构。<br>WXML在语法上更接近XML语言，遵循SGML规范，区别于HTML语言随意的标签闭合方式，<font face="STCAIYUN" color="#883958" size="4">WXML语言必须包括开始标签和结束标签</font>

<p><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/" target="_blank" rel="noopener">基本语法</a><br>WXML 中的动态数据均来自对应 Page 的 data。不同于 Vue 它是<code>单向绑定</code> 必须通过调用事件来<code>setData</code>新的数据</p>
<figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">view</span>&gt;</span> </span><span class="template-variable">&#123;&#123; message &#125;</span><span class="xml">&#125; <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line"><span class="xml">Page(</span><span class="template-variable">&#123;</span></span><br><span class="line"><span class="template-variable">  data: &#123;</span></span><br><span class="line"><span class="template-variable">    message: 'Hello MINA!'</span></span><br><span class="line"><span class="template-variable">  &#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">&#125;)</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">花括号和引号之间不能留空，否则将最终被解析成为字符串</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:for</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123;[1,2,3]&#125;</span><span class="xml"><span class="tag"><span class="string">&#125; "</span>&gt;</span></span></span><br><span class="line"><span class="xml">  </span><span class="template-variable">&#123;&#123;item&#125;</span><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line"><span class="xml">等同于</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:for</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123;[1,2,3] + ' '&#125;</span><span class="xml"><span class="tag"><span class="string">&#125;"</span> &gt;</span></span></span><br><span class="line"><span class="xml">  </span><span class="template-variable">&#123;&#123;item&#125;</span><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">当 wx:for 的值为字符串时，会将字符串解析成字符串数组</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:for</span>=<span class="string">"yishu"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  </span><span class="template-variable">&#123;&#123;item&#125;</span><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line"><span class="xml">===</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:for</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123;['y','i','s','h','u']&#125;</span><span class="xml"><span class="tag"><span class="string">&#125;"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  </span><span class="template-variable">&#123;&#123;item&#125;</span><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:if</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123;condition&#125;</span><span class="xml"><span class="tag"><span class="string">&#125;"</span>&gt;</span> <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:if</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123;length &gt; 5&#125;</span><span class="xml"><span class="tag"><span class="string">&#125;"</span>&gt;</span> <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">关键字 需要在双引号之内 checked="false"，其计算结果是一个字符串，转成 boolean 类型后代表真值。</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">checkbox</span> <span class="attr">checked</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123;false&#125;</span><span class="xml"><span class="tag"><span class="string">&#125;"</span>&gt;</span> <span class="tag">&lt;/<span class="name">checkbox</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">view</span> <span class="attr">hidden</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123;flag ? true : false&#125;</span><span class="xml"><span class="tag"><span class="string">&#125;"</span>&gt;</span> Hidden <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">条件渲染</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:if</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123;length &gt; 5&#125;</span><span class="xml"><span class="tag"><span class="string">&#125;"</span>&gt;</span> 1 <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:elif</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123;length &gt; 2&#125;</span><span class="xml"><span class="tag"><span class="string">&#125;"</span>&gt;</span> 2 <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:else</span>&gt;</span> 3 <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">如果想一次性判断多个组件标签  可以这么写</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:if</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123;true&#125;</span><span class="xml"><span class="tag"><span class="string">&#125;"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">view</span>&gt;</span> view1 <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">view</span>&gt;</span> view2 <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">block</span>&gt;</span></span></span><br><span class="line"><span class="xml"> 是一个包装元素，不会在页面中做任何渲染，只接受控制属性。当然了 我是经常用View标签包裹的</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"> 关于 wx:if 与 hidden</span></span><br><span class="line"><span class="xml"> 简单来说 hidden为true的组件始终被渲染 只是切换 display与none状态</span></span><br><span class="line"><span class="xml"> 而 wx:if只有在条件成立的情况下才会被真的渲染</span></span><br></pre></td></tr></table></figure>
<p>使用模版 模板拥有自己的作用域，只能使用data传入的数据。</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span> <span class="attr">name</span>=<span class="string">"msgItem"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">view</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">text</span>&gt;</span> </span><span class="template-variable">&#123;&#123;index&#125;&#125;</span><span class="xml">: </span><span class="template-variable">&#123;&#123;msg&#125;&#125;</span><span class="xml"> <span class="tag">&lt;/<span class="name">text</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">text</span>&gt;</span> Time: </span><span class="template-variable">&#123;&#123;time&#125;&#125;</span><span class="xml"> <span class="tag">&lt;/<span class="name">text</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">引用</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span> <span class="attr">is</span>=<span class="string">"msgItem"</span> <span class="attr">data</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123;...item&#125;&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>/&gt;</span></span></span><br></pre></td></tr></table></figure>
<p><strong>事件 （冒泡 非冒泡）</strong><br><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/event.html" target="_blank" rel="noopener">事件API</a><br>事件是视图层到逻辑层的通讯方式，当组件触发事件时，逻辑层绑定该事件的处理函数会收到一个事件对象。<br>冒泡事件<br>touchstart    手指触摸动作开始<br>touchmove    手指触摸后移动<br>touchcancel    手指触摸动作被打断，如来电提醒，弹窗<br>touchend    手指触摸动作结束<br>tap    手指触摸后马上离开<br>longtap 手指触摸后，超过350ms再离开</p>
<font face="STCAIYUN" color="#83933b" size="3">bind事件绑定不会阻止冒泡事件向上冒泡，<br>catch事件绑定可以阻止冒泡事件向上冒泡。</font><br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">视图层</span><br><span class="line">&lt;<span class="keyword">view</span> id=<span class="string">"tapTest"</span> data-<span class="keyword">hi</span>=<span class="string">"WeChat"</span> bindtap=<span class="string">"tapName"</span>&gt; Click me! &lt;/<span class="keyword">view</span>&gt;</span><br><span class="line">逻辑层</span><br><span class="line">Page(&#123;</span><br><span class="line">  tapName: <span class="function"><span class="keyword">function</span><span class="params">(event)</span> &#123;</span></span><br><span class="line">    console.<span class="built_in">log</span>(event)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br><br><strong>文件引入</strong><br>WXML 提供两种文件引用方式import和include。<br><br>import可以在该文件中使用目标文件定义的 template<br><br><br><figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!-- item.wxml --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span> <span class="attr">name</span>=<span class="string">"item"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">text</span>&gt;</span></span><span class="template-variable">&#123;&#123;text&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">text</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">引入模版</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">import</span> <span class="attr">src</span>=<span class="string">"item.wxml"</span>/&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span> <span class="attr">is</span>=<span class="string">"item"</span> <span class="attr">data</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123;text: 'forbar'&#125;&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>/&gt;</span></span></span><br></pre></td></tr></table></figure><br><br><code>import</code> 有作用域的概念，即只会<br><font face="STCAIYUN" color="#83933b" size="3">import 目标文件中定义的 template，而不会 import 目标文件 import 的 template。</font>

<p><code>include</code>可以将目标文件除了<code>&lt;template/&gt;</code>的整个代码引入 也就是说 copy到了当前引入的位置</p>
<p><strong>WXSS</strong><br>WXSS(WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式。</p>
<p>WXSS支持的单位有<code>px、rem和rpx</code>，其中rem和rpx可以针对屏幕容器进行适配，px则为固定尺寸。<br>其中<code>1rpx=0.5px</code>，在WXSS和WXML中定义的rpx单位最终会转换为在手机端可以识别的<code>rem</code>单位。</p>
<p><strong>建议</strong>：<font face="STCAIYUN" color="red" size="3">开发微信小程序时设计师可以用 iPhone6 作为视觉稿的标准。<br>我们拿到750的设计稿，在PS中量取的容器大小，可以直接定义为rpx，不需要进行2倍尺寸的换算，rpx的单位不光在样式中会自适应，写在WXML的style里也会根据屏幕自适应。</font></p>
<p>像CSS一样 可以使用<code>@import</code>语句可以导入外联样式表，@import后跟需要导入的外联样式表的<font face="STCAIYUN" color="#83933b" size="3"> 相对路径</font></p>
<p><code>import &quot;../../wxss/common.wxss&quot;;</code></p>
<p>为了提高渲染速度尽量避免静态样式存在于style中，除非需要接收动态样式才应该写在行内<font face="STCAIYUN" color="#83933b" size="3">（貌似说了一句废话）</font></p>
<p><code>&lt;view style=&quot;color:;&quot; /&gt;</code></p>
<p>全局样式与局部样式<br>全局样式都在<code>app.wxss</code>中定义 page里的wxss文件定义的是局部样式 局部样式可以覆盖同名的全局样式</p>
<p id="line4"><br><font face="STCAIYUN" color="#883958" size="4">运行机制</font><br></p>

<ul>
<li>小程序没有重启的概念</li>
<li>当小程序进入后台，客户端会维持一段时间的运行状态，超过一定的时间后会自动销毁（目前是五分钟）</li>
<li>置顶的小程序不会被微信主动销毁</li>
<li>当收到内存警号时小程序会销毁</li>
</ul>
]]></content>
      <tags>
        <tag>wechat</tag>
      </tags>
  </entry>
  <entry>
    <title>揭秘setState机制</title>
    <url>/2018/11/23/%E6%8F%AD%E7%A7%98setState%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>前言：state是react中重要的概念， react是通过管理状态来实现对组件的管理，那么 react是如何控制组件的状态 又是如何利用状态来管理组件的呢？</p>
<p>我们所知道的版本 大概是 通过<code>this.state</code>来访问<code>state</code>，通过<code>setState()</code>方法来更新<code>state</code>，当<code>this.state()</code>被调用的时候 <code>React</code>会重新调用<code>render</code>方法来重新渲染<code>UI</code></p>
<p>那好的 先来看一道题吧</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">export <span class="keyword">default</span> class SetState extends React.Component &#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        super();</span><br><span class="line">        this.<span class="keyword">state</span> = &#123;</span><br><span class="line">            val:<span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentWillMount()&#123;</span><br><span class="line">        this.<span class="built_in">set</span>State(&#123;val:this.<span class="keyword">state</span>.val+<span class="number">1</span>&#125;);</span><br><span class="line">        console.<span class="keyword">log</span>('componentWillMount第一次输出',this.<span class="keyword">state</span>.val)</span><br><span class="line">        this.<span class="built_in">set</span>State(&#123;val:this.<span class="keyword">state</span>.val+<span class="number">1</span>&#125;);</span><br><span class="line">        console.<span class="keyword">log</span>('componentWillMount第二次输出',this.<span class="keyword">state</span>.val)</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount()&#123;</span><br><span class="line">        // debugger;</span><br><span class="line">        this.<span class="built_in">set</span>State(&#123;val:this.<span class="keyword">state</span>.val+<span class="number">1</span>&#125;);</span><br><span class="line">        console.<span class="keyword">log</span>('componentDidMount第一次输出',this.<span class="keyword">state</span>.val)</span><br><span class="line">        this.<span class="built_in">set</span>State(&#123;val:this.<span class="keyword">state</span>.val+<span class="number">1</span>&#125;);</span><br><span class="line">        console.<span class="keyword">log</span>('componentDidMount第二次输出',this.<span class="keyword">state</span>.val)</span><br><span class="line">        <span class="built_in">set</span>Timeout(()=&gt;&#123;</span><br><span class="line">            // debugger;</span><br><span class="line">            console.<span class="keyword">log</span>('开始<span class="built_in">set</span>Timeout',this.<span class="keyword">state</span>.val)</span><br><span class="line">            this.<span class="built_in">set</span>State(&#123;val:this.<span class="keyword">state</span>.val+<span class="number">1</span>&#125;);</span><br><span class="line">            console.<span class="keyword">log</span>('第三次输出',this.<span class="keyword">state</span>.val) </span><br><span class="line"></span><br><span class="line">            this.<span class="built_in">set</span>State(&#123;val:this.<span class="keyword">state</span>.val+<span class="number">1</span>&#125;);</span><br><span class="line">            console.<span class="keyword">log</span>('第四次输出',this.<span class="keyword">state</span>.val) </span><br><span class="line">        &#125;,<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    render()&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这道题的答案是 <code>0 0 1 1 2 3 4</code></p>
<p>假如结果与你心中的答案并不完全相同，那么你应该感兴趣这背后究竟发生了什么.</p>
<a id="more"></a>
<h2 id="了解setState"><a href="#了解setState" class="headerlink" title="了解setState"></a>了解setState</h2><ol>
<li>setState是同步执行的 但是state并不一定会同步更新（异步更新）</li>
</ol>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">实际上react的异步更新通过一个队列机制来实现，当执行<span class="keyword">state</span>时 需要将更新的<span class="keyword">state</span>合并后放入状态队列而不会立刻更新 队列机制可以高效的批量更新<span class="keyword">state</span> 如果在非构造方法里更改值  类似 this.<span class="keyword">state</span>.name='yishu' 是不会被放到状态队列中 当下次调用<span class="built_in">set</span>State并对状态队列进行合并时 将会忽略它而造成无法预知的错误</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>setState在React生命周期和合成事件中批量覆盖执行</li>
</ol>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">在React的生命周期钩子和合成事件中，多次执行<span class="keyword">set</span>State，会批量执行，多次同步执行的<span class="keyword">set</span>State，会进行合并，类似于Object.assign</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>setState在原生事件，setTimeout，setInterval，Promise等异步操作中，state会同步更新</li>
</ol>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">当执行到 <span class="built_in">set</span>Timeout 的时候，把它丢到列队里，并没有去执行，而是先执行的 finally 主进程代码块，等 finally 执行完了， isBatchingUpdates 又变为了 false ，导致最后去执行队列里的 <span class="built_in">set</span>State 时候， requestWork 走的是和原生事件一样的 expirationTime === Sync if分支，所以表现就会和原生事件一样，可以同步拿到最新的<span class="keyword">state</span>的值。</span><br></pre></td></tr></table></figure>
<p>关于setState这个方法 源码记载</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ReactComponent.prototype.setState = <span class="function"><span class="keyword">function</span><span class="params">(partialState, callback)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">this</span>.updater.enqueueSetState(<span class="keyword">this</span>, partialState);</span><br><span class="line">  <span class="keyword">if</span> (callback) &#123;</span><br><span class="line">    <span class="keyword">this</span>.updater.enqueueCallback(<span class="keyword">this</span>, callback, <span class="string">'setState'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">  enqueueSetState: <span class="function"><span class="keyword">function</span><span class="params">(publicInstance, partialState)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">var</span> queue =internalInstance._pendingStateQueue ||</span><br><span class="line">      (internalInstance._pendingStateQueue = []);</span><br><span class="line">    queue.push(partialState);</span><br><span class="line"></span><br><span class="line">    enqueueUpdate(internalInstance);</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>setState方法实际上会执行 <code>enqueueSetState</code>方法 通过<code>_pendingStateQueue</code>更新队列进行合并操作 最终通过<code>enqueueUpdate</code>执行state更新</p>
<h2 id="setState调用栈"><a href="#setState调用栈" class="headerlink" title="setState调用栈"></a>setState调用栈</h2><p><img src="/images/setState/setState1.png" alt></p>
<p>如图：通过变量isBatchingUpdate 来决定当前是应该走批量更新 还是立即更新 为true时 说明当前在批量更新模式 为false的话 会立即更新</p>
<p>为了更好的理解 涉及到部分源码</p>
<p>enqueueUpdate 代码如下：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueueUpdate</span><span class="params">(component)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果不处于批量更新模式 更新</span></span><br><span class="line">  <span class="keyword">if</span> (!batchingStrategy.isBatchingUpdates) &#123;</span><br><span class="line">batchingStrategy.batchedUpdates(enqueueUpdate, component);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果处于批量更新模式 则将该组件保存在 dirtyComponents 中</span></span><br><span class="line">  dirtyComponents.push(component);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>那么这个<code>batchingStrategy</code>究竟是做什么的？ 其实它只是一个简单的对象，定义了 isBatchingUpdates 和 batchedUpdates 方法 其中transaction.perform 的调用 涉及到了<font color="red">事务</font>的概念</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// batchedUpdates 方法</span></span><br><span class="line"><span class="keyword">var</span> ReactDefaultBatchingStrategy = &#123;</span><br><span class="line">  isBatchingUpdates: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">   batchedUpdates: <span class="function"><span class="keyword">function</span><span class="params">(callback, a, b, c, d, e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;</span><br><span class="line"></span><br><span class="line">    ReactDefaultBatchingStrategy.isBatchingUpdates = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (alreadyBatchingUpdates) &#123;</span><br><span class="line">      callback(a, b, c, d, e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      transaction.perform(callback, <span class="literal">null</span>, a, b, c, d, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="事务机制"><a href="#事务机制" class="headerlink" title="事务机制"></a>事务机制</h2><p>事务就是将需要执行的方法使用wrapper封装起来 再通过事务提供的perform方法执行<br><img src="/images/setState/setState2.png" alt><br>执行 perform 之前 先执行  wrapper 中的init方法 执行完 perform之后 再执行 所有的close方法<br>假如有一个事务 test 执行顺序表现为 </p>
<p><code>init-&gt;test-&gt;close</code></p>
<h2 id="揭秘setState机制"><a href="#揭秘setState机制" class="headerlink" title="揭秘setState机制"></a>揭秘setState机制</h2><p>那么 说了这么多，事务是怎么导致前面所述的setState的各种不同表现呢.</p>
<p>在整个React组件渲染到Dom中的过程就处于一个大的事务中 ，在生命周期和合成事件执行前后都会执行init 和 close，init会调用batchedUpdate方法将isBatchingUpdates变量置为true，开启批量更新，而close会将isBatchingUpdates置为false，setState的更新会被存入队列中，待同步代码执行完后，再执行队列中的state更新。</p>
<p>而在原生事件和异步操作中，不会执行pre钩子，或者生命周期的中的异步操作之前执行了pre钩子，但是pos钩子也在异步操作之前执行完了，isBatchingUpdates必定为false，也就不会进行批量更新</p>
<h2 id="获取正确的state值"><a href="#获取正确的state值" class="headerlink" title="获取正确的state值"></a>获取正确的state值</h2><p>以下：</p>
<ol>
<li>setState函数式</li>
<li>放到setTimeout，Promise等异步中执行</li>
<li>放到componentDidUpdate中</li>
</ol>
<h2 id="说在最后的话"><a href="#说在最后的话" class="headerlink" title="说在最后的话"></a>说在最后的话</h2><p>所以 开篇的结果应该可以理解了吧</p>
<p>我们把didMount中四次调用归类，前两次一类 因为它们在同一个调用栈中执行 setTimeout中的两次属于另一类，我们重点看第一类，早在setState调用之前  ReactDefaultBatchingStrategy.isBatchingUpdates已经被设置为true，所以两次的setSate并没有生效 而是被放进了队列中<br>再看setTimeout中的两次state 此时的isBatchingUpdates为false，这也就导致了心的state马上生效 没有走到队列的分支（可参考调用栈图）也就是说 第一次执行setState时 值就为1 加1之后变为2 第二次打印同理</p>
<p>参考：深入react技术栈一书 希望通过setState 深入源码 知其然也知其所以然</p>
]]></content>
      <categories>
        <category>react</category>
      </categories>
  </entry>
  <entry>
    <title>深入理解Javascript 系列一：编写高质量代码的基本要点</title>
    <url>/2018/03/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3js%E7%B3%BB%E5%88%97%E4%B8%80/</url>
    <content><![CDATA[<p><a href="http://www.cnblogs.com/TomXu/archive/2011/12/28/2286877.html" target="_blank" rel="noopener">汤姆大叔的原文链接</a></p>
<a id="more"></a>
<h2 id="书写可维护的代码"><a href="#书写可维护的代码" class="headerlink" title="书写可维护的代码"></a>书写可维护的代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">目标：可读的 一致的 可预测的 看上去就像是同一个人写的</span><br></pre></td></tr></table></figure>
<h2 id="js的变量问题"><a href="#js的变量问题" class="headerlink" title="js的变量问题"></a>js的变量问题</h2><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">js通过函数管理作用域</span><br><span class="line">在任何函数外面上声明的变量 或者 不声明就直接使用的（隐含的全局概念） 均为全局变量</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> uu; <span class="comment">// 显式全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span><span class="params">(x, y)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 不推荐写法: 隐式全局变量</span></span><br><span class="line">   result = x + y;</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建隐式全局变量 反例，勿使用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> a = b = <span class="number">0</span>;发生的原因是 这个从右往左赋值 b = <span class="number">0</span>  此时 b是未声明的</span><br><span class="line">   相当于</span><br><span class="line">   <span class="keyword">var</span> a = (b = <span class="number">0</span>);</span><br><span class="line">   你可以这个定义局部变量（正确写法）</span><br><span class="line">   <span class="keyword">var</span> a, b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="隐式全局变量-与显式全局变量的差异"><a href="#隐式全局变量-与显式全局变量的差异" class="headerlink" title="隐式全局变量 与显式全局变量的差异"></a><font color="green">隐式全局变量 与显式全局变量的差异</font></h4><ul>
<li>通过var创建的全局变量是不能被删除的</li>
<li>无var创建的隐式全局变量 是能被删除的</li>
</ul>
<h6 id="关于隐式全局变量的解释"><a href="#关于隐式全局变量的解释" class="headerlink" title="关于隐式全局变量的解释"></a>关于隐式全局变量的解释</h6><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">不管一个变量有没有用过，JavaScript解释器反向遍历作用域链来查找整个变量的<span class="keyword">var</span>声明，如果没有找到<span class="keyword">var</span>，解释器则假定该变量是全局变量，如果该变量用于了赋值操作的话，之前如果不存在的话，解释器则会自动创建它，这就是说在匿名闭包里使用或创建全局变量非常容易 避免创建式全局变量 方式</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="params">($, YAHOO)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里，我们的代码就可以使用全局的jQuery对象了，YAHOO也是一样</span></span><br><span class="line">&#125; (jQuery, YAHOO))</span><br><span class="line">将全局变量当做一个参数传入匿名函数内使用 jquery源码就用这种方式</span><br></pre></td></tr></table></figure>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">在技术上 隐式全局变量 并不是真正的全局变量 但他们是全局对象的属性</span><br><span class="line">属性是可以通过<span class="keyword">delete</span> 操作符删除的</span><br></pre></td></tr></table></figure>
<h4 id="如何访问全局变量"><a href="#如何访问全局变量" class="headerlink" title="如何访问全局变量"></a><font color="green">如何访问全局变量</font></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">一般情况下 全局对象可以通过<span class="built_in">window</span>属性在任何位置访问</span><br><span class="line">也可以</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gobal =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">这种方法可以随时获取全局变量 <span class="keyword">this</span>总是指向全局对象</span><br></pre></td></tr></table></figure>
<h4 id="变量与函数的预解析（变量提升）"><a href="#变量与函数的预解析（变量提升）" class="headerlink" title="变量与函数的预解析（变量提升）"></a><font color="green">变量与函数的预解析（变量提升）</font></h4><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> a = <span class="number">1</span>,</span><br><span class="line">       b = <span class="number">2</span>,</span><br><span class="line">       sum = a + b,</span><br><span class="line">       myobject = &#123;&#125;,</span><br><span class="line">       i, <span class="comment">// undefined</span></span><br><span class="line">       j; <span class="comment">//undefined</span></span><br><span class="line">   <span class="comment">// function body...</span></span><br><span class="line">&#125;</span><br><span class="line">变量初始化可以防止逻辑错误 也解决了<span class="keyword">var</span>散布的问题</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反例</span></span><br><span class="line">myname = <span class="string">"global"</span>; <span class="comment">// 全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    alert(myname); <span class="comment">// "undefined"</span></span><br><span class="line">    <span class="keyword">var</span> myname = <span class="string">"local"</span>; <span class="comment">// 声明myname的变量被当做局部变量预解析了</span></span><br><span class="line">    alert(myname); <span class="comment">// "local"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">相当于</span><br><span class="line">myname = <span class="string">"global"</span>; <span class="comment">// 全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> myname； <span class="comment">// === var myname == undefined</span></span><br><span class="line">     alert(myname); <span class="comment">// "undefined"</span></span><br><span class="line">     myname = <span class="string">"local"</span>;</span><br><span class="line">     alert(myname); <span class="comment">// "local"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="【延伸】js-是如何执行的"><a href="#【延伸】js-是如何执行的" class="headerlink" title="【延伸】js 是如何执行的"></a><font color="green">【延伸】js 是如何执行的</font></h4><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">代码处理 分为两个阶段</span><br><span class="line"><span class="number">1.</span>变量 函数声明 以及 正常格式的参数创建 这是一个解析和进入上下文的阶段</span><br><span class="line"><span class="number">2.</span>代码执行 函数表达式和 声明的变量被创建</span><br></pre></td></tr></table></figure>
<h2 id="js的循环问题"><a href="#js的循环问题" class="headerlink" title="js的循环问题"></a>js的循环问题</h2><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">缓存 数组 以及 HTMLCollection 的长度</span><br><span class="line">当要循环的是一个集合对象时候 如果不缓存长度 你要实时查询Dom 而Dom操作一般来讲比较昂贵</span><br><span class="line"></span><br><span class="line">像这样</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (var i = <span class="number">0</span>, <span class="built_in">max</span> = myarray.<span class="built_in">length</span>; i &lt; <span class="built_in">max</span>; i++) &#123;</span><br><span class="line">   <span class="comment">// 使用myarray[i]做点什么</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">尽量不要使用i++</span><br><span class="line">像这样儿</span><br><span class="line"></span><br><span class="line">i = i + <span class="number">1</span></span><br><span class="line">i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">还有两种改进形式（参考）</span><br><span class="line">少了一个变量(无<span class="built_in">max</span>)</span><br><span class="line">向下数到<span class="number">0</span>，通常更快，因为和<span class="number">0</span>做比较要比和数组长度或是其他不是<span class="number">0</span>的东西作比较更有效率</span><br><span class="line"></span><br><span class="line">像这样</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种变化的形式：</span></span><br><span class="line"></span><br><span class="line">var i, myarray = [];</span><br><span class="line"><span class="keyword">for</span> (i = myarray.<span class="built_in">length</span>; i–-;) &#123;</span><br><span class="line">  <span class="comment">//....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种使用while循环：</span></span><br><span class="line"></span><br><span class="line">var myarray = [],</span><br><span class="line">    i = myarray.<span class="built_in">length</span>;</span><br><span class="line"><span class="keyword">while</span> (i–-) &#123;</span><br><span class="line">   <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="for-in循环"><a href="#for-in循环" class="headerlink" title="for-in循环"></a>for-in循环</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">也称 ‘枚举’ 应该用在非数组对象的遍历上 不推荐用来循环数组（数组也是对象 但是 <span class="keyword">for</span>-<span class="keyword">in</span>中 属性列表的顺序是不能保证的）</span><br><span class="line"></span><br><span class="line">值得说明的是 我们平常老是忽略一个很重要的方法</span><br><span class="line">hasOwnProperty() 遍历对象属性的时候可以过滤掉从原型链上下来的属性</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> man = &#123;</span><br><span class="line">	    hands:<span class="number">2</span>,</span><br><span class="line">		legs:<span class="number">2</span>,</span><br><span class="line">		heads:<span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Object</span>.prototype.clone === <span class="string">'undefined'</span>)&#123;</span><br><span class="line">	    <span class="built_in">Object</span>.prototype.clone = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	        <span class="comment">//。。。。</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	为了避免枚举 出现clone方法</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> man) &#123;</span><br><span class="line"><span class="comment">//	    方式一 过滤原型属性</span></span><br><span class="line">	    <span class="keyword">if</span> (man.hasOwnProperty(i)) &#123;</span><br><span class="line"><span class="comment">//            console.log(i, "1:", man[i]);</span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//		方式二 取消Object。prototype上的方法</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(man,i))&#123;</span><br><span class="line"><span class="comment">//            console.log(i, "1:", man[i]);</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//或者 避免长属性查找</span></span><br><span class="line">		<span class="keyword">var</span> hasOwn = <span class="built_in">Object</span>.prototype.hasOwnProperty;</span><br><span class="line">        <span class="keyword">if</span> (hasOwn.call(man,i))&#123;</span><br><span class="line"><span class="comment">//            console.log(i, "1:", man[i]);</span></span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="给原型自定义添加方法"><a href="#给原型自定义添加方法" class="headerlink" title="给原型自定义添加方法"></a>给原型自定义添加方法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Object</span>.prototype.myMethod ！==<span class="string">"function"</span>)&#123;</span><br><span class="line">    <span class="built_in">Object</span>.prototype.myMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="避免隐式类型转换"><a href="#避免隐式类型转换" class="headerlink" title="避免隐式类型转换"></a>避免隐式类型转换</h2><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">js变量在比较时会隐式类型转换</span><br><span class="line">为了避免引起混乱的隐式类型转换 比较值和表达式类型的时候始终使用</span><br><span class="line"><span class="section">=== 和 !== 操作符</span></span><br></pre></td></tr></table></figure>
<h2 id="避免-eval-不给-给setInterval-setTimeout-和Function-构造函数传递字符串"><a href="#避免-eval-不给-给setInterval-setTimeout-和Function-构造函数传递字符串" class="headerlink" title="避免 eval() 不给 给setInterval(), setTimeout()和Function()构造函数传递字符串"></a>避免 eval() 不给 给setInterval(), setTimeout()和Function()构造函数传递字符串</h2><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 反面示例</span></span><br><span class="line">setTimeout(<span class="string">"myFunc()"</span>, <span class="number">1000</span>);</span><br><span class="line">setTimeout(<span class="string">"myFunc(1, 2, 3)"</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更好的</span></span><br><span class="line">setTimeout(myFunc, <span class="number">1000</span>);</span><br><span class="line">setTimeout(function () &#123;</span><br><span class="line">   myFunc(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<h2 id="parseInt-数值转换不应该忽略第二个参数"><a href="#parseInt-数值转换不应该忽略第二个参数" class="headerlink" title="parseInt()数值转换不应该忽略第二个参数"></a>parseInt()数值转换不应该忽略第二个参数</h2><figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">在ECMAScript <span class="number">3</span>中，开头为”<span class="number">0</span>″的字符串被当做<span class="number">8</span>进制处理了，但这已在ECMAScript <span class="number">5</span>中改变了。为了避免矛盾和意外的结果，总是指定基数参数</span><br><span class="line"></span><br><span class="line"><span class="built_in">var</span> <span class="built_in">month</span> = <span class="string">"06"</span>,</span><br><span class="line">    <span class="built_in">year</span> = <span class="string">"09"</span>;</span><br><span class="line"><span class="built_in">month</span> = parseInt(<span class="built_in">month</span>, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">year</span> = parseInt(<span class="built_in">year</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<h2 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h2><ul>
<li>编码规范</li>
<li>代码缩进</li>
<li>技术上可以省略的花括号( 只有一条语句的for循环{}) 也不要省略</li>
<li>不要省略分号;</li>
<li>左花括号的位置</li>
<li>适当的地方使用空格 – 列表模样表达式（相当于逗号）和结束语句（相对于完成了“想法”）后面添加间隔</li>
<li>命名规范</li>
<li>注释</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">if (true) &#123;</span><br><span class="line">   alert("It's TRUE!");</span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line">if (true)</span><br><span class="line">&#123;</span><br><span class="line">   alert("It's TRUE!");</span><br><span class="line">&#125;</span><br><span class="line">但是如果要返回一个对象自变量的话</span><br><span class="line">function func() &#123;</span><br><span class="line">   return  // === return undefined;</span><br><span class="line">  // 下面代码不执行</span><br><span class="line">   &#123;</span><br><span class="line">      name : "Batman"</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结论</span><br><span class="line">总之，总是使用花括号，并始终把在与之前的语句放在同一行：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">使用空格</span><br><span class="line"></span><br><span class="line">for循环分号分开后的的部分：如for (var i = 0; i &lt; 10; i += 1) &#123;...&#125;</span><br><span class="line">for循环中初始化的多变量(i和max)：for (var i = 0, max = 10; i &lt; max; i += 1) &#123;...&#125;</span><br><span class="line">分隔数组项的逗号的后面：var a = [1, 2, 3];</span><br><span class="line">对象属性逗号的后面以及分隔属性名和属性值的冒号的后面：var o = &#123;a: 1, b: 2&#125;;</span><br><span class="line">限定函数参数：myFunc(a, b, c)</span><br><span class="line">函数声明的花括号的前面：function myFunc() &#123;&#125;</span><br><span class="line">匿名函数表达式function的后面：var myFunc = function () &#123;&#125;;</span><br><span class="line">花括号的间距  最好使用空格</span><br><span class="line">有一个经常被忽略的代码可读性方面是垂直空格的使用。你可以使用空行来分隔代码单元，就像是文学作品中使用段落分隔一样。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">命名规范</span><br><span class="line"></span><br><span class="line">以大写字母写构造函数(Capitalizing Constructors)</span><br><span class="line"></span><br><span class="line">getName() 公共方法</span><br><span class="line">_getFirst() 私有方法</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Javascript 系列二：揭秘命名函数表达式</title>
    <url>/2018/03/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3js%E7%B3%BB%E5%88%97%E4%BA%8C/</url>
    <content><![CDATA[<p><a href="http://www.cnblogs.com/TomXu/archive/2011/12/29/2290308.html" target="_blank" rel="noopener">汤姆大叔的原文链接</a></p>
<a id="more"></a>
<h2 id="函数表达式-和函数声明"><a href="#函数表达式-和函数声明" class="headerlink" title="函数表达式 和函数声明"></a>函数表达式 和函数声明</h2><h4 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h4><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">函数名称（可选）（参数：可选）&#123;函数体&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">函数名称（参数：可选）&#123;函数体&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="如何区分两者"><a href="#如何区分两者" class="headerlink" title="如何区分两者"></a>如何区分两者</h4><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">函数表达式：不声明函数名称和声明了函数名称的其他情况</span><br><span class="line">          如果 <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span>&#123;&#125; 是作为赋值表达式的一部分的话</span><br><span class="line">          像这样：</span><br><span class="line">           <span class="number">1.</span><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span>&#123;&#125;; <span class="comment">// 表达式，因为它是赋值表达式的一部分</span></span><br><span class="line">           <span class="number">2.</span><span class="keyword">new</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span><span class="params">()</span></span>&#123;&#125;; <span class="comment">// 表达式，因为它是new表达式</span></span><br><span class="line">           <span class="number">3.</span>被括号括住的(<span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span>&#123;&#125;)他是表达式的原因是因为括号 ()是一个分组操作符，它的内部只能包含表达式</span><br><span class="line">            (<span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span>&#123;&#125;); <span class="comment">// 函数表达式：包含在分组操作符内</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">函数声明：声明了函数名称且<span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span>&#123;&#125; 被包含在一个函数体内（规则：只能出现在程序或函数体内）</span><br><span class="line">            像这样</span><br><span class="line">            (<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="function"><span class="keyword">function</span> <span class="title">bar</span><span class="params">()</span></span>&#123;&#125; <span class="comment">// 声明，因为它是函数体的一部分</span></span><br><span class="line">            &#125;)();</span><br><span class="line">        或者位于程序最顶部的话</span><br><span class="line">        像这样</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span>&#123;&#125; <span class="comment">// 声明，因为它是程序的一部分</span></span><br></pre></td></tr></table></figure>
<h4 id="一些特性"><a href="#一些特性" class="headerlink" title="一些特性"></a>一些特性</h4><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">函数声明:会在任何表达式被解析和求值之前先被解析和求值 即使你的声明在最后一行 它也会在同作用域内的第一个表达式之前被解析/求值</span></span><br></pre></td></tr></table></figure>
<h4 id="函数语句"><a href="#函数语句" class="headerlink" title="函数语句"></a>函数语句</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">函数语句不是在变量初始化期间声明的，而是在运行时声明的——与函数表达式一样。不过，函数语句的标识符一旦声明能在函数的整个作用域生效了。标识符有效性正是导致函数语句与函数表达式不同的关键所在</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此刻，foo还没用声明</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'typeof foo1'</span>,<span class="keyword">typeof</span> foo)<span class="comment">// "undefined"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 进入这里以后，foo就被声明在整个作用域内了</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="string">'11111'</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 从来不会走到这里，所以这里的foo也不会被声明</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="string">'222'</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">typeof</span> foo; <span class="comment">// "function"</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'typeof foo2'</span>,<span class="keyword">typeof</span> foo)</span><br></pre></td></tr></table></figure>
<h4 id="命名函数表达式"><a href="#命名函数表达式" class="headerlink" title="命名函数表达式"></a>命名函数表达式</h4><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">命名函数表达式，理所当然，就是它得有名字，前面的例子<span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span>&#123;&#125;;就是一个有效的命名函数表达式，但有一点需要记住：这个名字只在新定义的函数作用域内有效， 这就是 与函数语句的区别</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> foo; <span class="comment">// foo是在内部作用域内有效</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// foo在外部用于是不可见的</span></span><br><span class="line">  <span class="keyword">typeof</span> foo; <span class="comment">// "undefined"</span></span><br><span class="line">  f(); <span class="comment">// "function"</span></span><br><span class="line"></span><br><span class="line">  命名函数表达式出现的意义：便于调试 调试器在调试的时候会将它的名字显示在调用的栈上</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>网易与淘宝移动端适配工作流思考一</title>
    <url>/2017/08/09/%E7%BD%91%E6%98%93%E4%B8%8E%E6%B7%98%E5%AE%9D%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E5%B7%A5%E4%BD%9C%E6%B5%81/</url>
    <content><![CDATA[<p>最近尝试了解了一些移动端的概念<br>得空总结了网易与淘宝的一些适配方案，为后续工作记录一下<br><a id="more"></a></p>
<p>##网易移动端适配方案<br>要点：<br><figure class="highlight qml"><table><tr><td class="code"><pre><span class="line">* 网易页面上html的<span class="built_in">font</span>-<span class="built_in">size</span>不是预先通过媒介查询在css里定义好的，而是通过js计算出来的</span><br><span class="line">* 为了方便，取一个<span class="number">100</span>px的<span class="built_in">font</span>-<span class="built_in">size</span>为参照</span><br></pre></td></tr></table></figure></p>
<p>步骤：<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>拿设计稿竖着的横向分辨率除以<span class="number">100</span>得到body的宽度</span><br><span class="line">  eg：  iphone6，横向分辨率为<span class="number">750</span>，<span class="built_in">width</span> =<span class="number">750</span> / <span class="number">100</span> = <span class="number">7.5</span>rem</span><br><span class="line">        iphone4/<span class="number">5</span>，横向分辨率为<span class="number">640</span>，<span class="built_in">width</span>为<span class="number">640</span> / <span class="number">100</span> = <span class="number">6.4</span>rem</span><br><span class="line"> <span class="number">2.</span>布局时  css尺寸 = 设计稿标注尺寸／<span class="number">100</span></span><br><span class="line">   eg：<span class="number">210</span>px = <span class="number">210</span>/<span class="number">100</span> = <span class="number">2.1</span>rem       </span><br><span class="line">  <span class="number">3.</span>   Dom <span class="built_in">ready</span>以后获取html的font-<span class="built_in">size</span></span><br><span class="line">    ⚠️ 当设备宽度（deviceWidth大于设计稿的横向分辨率时 html的font-<span class="built_in">size</span>始终等于横向分辨率/body元素宽）</span><br><span class="line"> 代码体现</span><br><span class="line">   var deviceWidth = document.documentElement.clientWidth;</span><br><span class="line">        <span class="built_in">if</span>(deviceWidth &gt; <span class="number">640</span>) deviceWidth = <span class="number">640</span>;</span><br><span class="line">        document.documentElement.style.fontSize = deviceWidth / <span class="number">7.5</span> + <span class="string">'px'</span>;</span><br><span class="line"><span class="number">4.</span>font-<span class="built_in">size</span> 可能需要额外的媒体查询 而且不要用rem</span><br><span class="line"></span><br><span class="line">   @media screen <span class="keyword">and</span> (<span class="built_in">max</span>-<span class="built_in">width</span>:<span class="number">321</span>px)&#123;</span><br><span class="line">           .m-navlist&#123;font-<span class="built_in">size</span>:<span class="number">15</span>px&#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          @media screen <span class="keyword">and</span> (<span class="built_in">min</span>-<span class="built_in">width</span>:<span class="number">321</span>px) <span class="keyword">and</span> (<span class="built_in">max</span>-<span class="built_in">width</span>:<span class="number">400</span>px)&#123;</span><br><span class="line">              .m-navlist&#123;font-<span class="built_in">size</span>:<span class="number">16</span>px&#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          @media screen <span class="keyword">and</span> (<span class="built_in">min</span>-<span class="built_in">width</span>:<span class="number">400</span>px)&#123;</span><br><span class="line">              .m-navlist&#123;font-<span class="built_in">size</span>:<span class="number">18</span>px&#125;</span><br><span class="line">          &#125;</span><br><span class="line"><span class="number">5.</span>关于视口的设置</span><br><span class="line">      &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"initial-scale=1,maximum-scale=1, minimum-scale=1"</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>#淘宝移动端适配方案<br>要点：<br><figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.设置视口标签</span><br><span class="line"> &lt;meta <span class="attr">name="viewport"</span>   <span class="attr">content="width=device-width,</span> <span class="attr">initial-scale=1,</span> <span class="attr">maximum-scale=1,</span> <span class="attr">user-scalable=no"&gt;</span></span><br><span class="line">使得整个网页在设备内显示时页面的宽度始终等于设备宽度（device-width）</span><br><span class="line"></span><br><span class="line"><span class="attr">scale</span>  =<span class="number">1</span> 时 <span class="attr">device-width</span> = 设备的物理分辨率／devicePixelRatio（设备像素比）</span><br></pre></td></tr></table></figure></p>
 <font face="STCAIYUN" color="#83933b" size="4">手淘的布局前提是  动态设置 viewport的scale  目的就是为了保证页面大小与设计稿大小一致</font><br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">比如设计稿是<span class="number">750</span>的横向分辨率 那么实际页面的device-width 以iphone6来说 也等于<span class="number">750</span></span><br><span class="line">这样的话设计稿上标注的尺寸只要除以某一个值就能够转换成rem了</span><br></pre></td></tr></table></figure><br><br>2.<font face="STCAIYUN" color="red" size="3">那么 如何动态设置？</font>

<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">var</span> <span class="built_in">scale</span> = <span class="number">1</span> / devicePixelRatio;</span><br><span class="line">document.querySelector('meta[name=<span class="string">"viewport"</span>]').setAttribute('<span class="built_in">content</span>','initial-<span class="built_in">scale</span>=' + <span class="built_in">scale</span> + ', maximum-<span class="built_in">scale</span>=' + <span class="built_in">scale</span> + ', minimum-<span class="built_in">scale</span>=' + <span class="built_in">scale</span> + ', user-scalable=no');</span><br></pre></td></tr></table></figure>
<p>3.<font face="STCAIYUN" color="red" size="3">手淘布局的第二个要点就是关于html元素的font-size计算公式</font></p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">font-size</span> = deviceWidth/<span class="number">10</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>可能会需要额外的媒体查询 同网易 不使用rem<br>但是呢 淘宝的rem不太好计算  如果借助less 就好算多了<br>类似：<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个变量和一个mixin</span></span><br><span class="line"><span class="variable">@baseFontSize:</span> <span class="number">75</span>;<span class="comment">//基于视觉稿横屏尺寸/100得出的基准font-size</span></span><br><span class="line"><span class="selector-class">.px2rem</span>(<span class="variable">@name</span>, <span class="variable">@px</span>)&#123;</span><br><span class="line">    <span class="attribute">@&#123;name&#125;</span>: <span class="variable">@px</span> / <span class="variable">@baseFontSize</span> * <span class="number">1rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用示例：</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="selector-class">.px2rem</span>(height, <span class="number">240</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//less翻译结果：</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">3.2rem</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4.<font face="STCAIYUN" color="red" size="3">元素的css尺寸如何计算？</font><br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">比如一个设计稿上某一个元素的高是 <span class="number">150</span>px</span><br><span class="line">css尺寸 =  设计稿标记尺寸/该设计稿对应的html的font-size</span><br><span class="line">也就是说  设计稿是<span class="number">750</span>  所以 font-size = <span class="number">750</span>/<span class="number">10</span> =<span class="number">75</span>px</span><br><span class="line"> <span class="number">150</span>/<span class="number">75</span> = <span class="number">2</span>rem</span><br></pre></td></tr></table></figure></p>
<p>关于这种做法的具体实现，淘宝已经给我们提供了一个开源的解决方案</p>
<font face="STCAIYUN" color="bluegreen" size="5"><a href="https://github.com/amfe/lib-flexible" target="_blank" rel="noopener">淘宝移动端布局方案</a></font>

<p><font face="STCAIYUN" color="red" size="3">比较网易与淘宝的做法</font></p>
<p><font face="STCAIYUN" color="bluegreen" size="3">共同点：</font><br>都能适配所有的手机设备，对于pad，网易与淘宝都会跳转到pc页面，不再使用触屏版的页面<br>都需要动态设置html的font-size<br>布局时各元素的尺寸值都是根据设计稿标注的尺寸计算出来，由于html的font-size是动态调整的，所以能够做到不同分辨率下页面布局呈现等比变化<br>容器元素的font-size都不用rem，需要额外地对font-size做媒介查询<br>都能应用于尺寸不同的设计稿，只要按以上总结的方法去用就可以了</p>
<p><font face="STCAIYUN" color="bluegreen" size="3">不同点：</font><br>淘宝的设计稿是基于750的横向分辨率，网易的设计稿是基于640的横向分辨率，还要强调的是，虽然设计稿不同，但是最终的结果是一致的，设计稿的尺寸一个公司设计人员的工作标准，每个公司不一样而已<br>淘宝还需要动态设置viewport的scale，网易不用<br>最重要的区别就是：网易的做法，rem值很好计算，淘宝的做法肯定得用计算器才能用好了 。不过要是你使用了less和sass这样的css处理器，就好办多了</p>
]]></content>
      <tags>
        <tag>mobile</tag>
      </tags>
  </entry>
  <entry>
    <title>记梦一</title>
    <url>/2017/07/31/%E8%AE%B0%E6%A2%A6/</url>
    <content><![CDATA[<p>此时此刻 ，反复思索着昨晚的梦，<font face="STCAIYUN" color="red" size="4">人生充满无奈，珍惜眼前人</font></p>
<p>具体的故事背景记不清了 大概是朋友的奶奶蹊跷去世了，我去她家安慰她并试图查事故原因，结果等我回去找他们的时候发现自己已经变成了<font face="STCAIYUN" color="red" size="4">隐形人</font> 其实就是已经死掉了，显然我自己也不知道自己发生了什么事情，事实就是我还在人间，就是我能看世人，世人再也看不到我了</p>
<p>第一反应是：  <font face="STCAIYUN" color="red" size="4">我要回家</font><br>我不知道他们是怎么处理世间的我，我只知道我的灵魂回家了<br>我也记不清爸妈是否知不知道我已经不在了，我用力的跟他们讲话 只可惜他们大大小小全都对我视而不见，我来不及思考 依然用力呼唤他们，追着拉着，全都没有用， <font face="STCAIYUN" color="yellow" size="3">我好无力…</font></p>
<p>想到多年前看过一部日本的温情电影，讲的也是主人公意外身故 化身隐形人回家，发现自己没办法让家人注意到也是很痛苦 不过电影就是电影 有一个巫婆是阴阳眼 成了 家人跟 “隐形人”沟通的桥梁，必要的时候还会帮助家人度过难关  影片最后是巫婆帮助隐形人附身于自己身上，与妻子做最后的告别，最后安稳投胎<br>印象中这才是鬼魂的正确打开方式 国产剧中的鬼魂仿佛都很厉害的样子，有仇报仇，有冤报冤，一言不合就施法 也是～</p>
<p>我当时想起来银行账户还有钱 就想给他们转过去，但是负责管我的警察，暂且叫他 <font face="STCAIYUN" color="red" size="4">灵魂摆渡人</font> （404号便利店),对耶 我为什么没去404号便利店找夏冬青帮我实现愿望，大概我遇见的是赵吏 笑cry 他说 我可以往人间账户汇款，就是有损耗 1W只能到账1k 这尼玛是跨行手续费吗😢</p>
<p>不记得最后是咋解决的， 反正世界就再也没有我了，就算再挣扎<br>我开始回忆一生，那些活过的平淡日子，能记起来的只有桩桩件件的遗憾</p>
<p>我还没有孝顺父母</p>
<p>上次电话里没有喊一嗓子 爸妈我爱你</p>
<p>我应该再回一次家的</p>
<p>想在老家给爹妈买房子的钱还没存够</p>
<p>家庭旅行的计划家门口还没出</p>
<p>想起来这些碎碎念</p>
<p>突然我就开始怀念了</p>
<p>我想，如果我在世的时候能有这些危机感 现在也不会有这么多遗憾了</p>
<p>私人一点的是</p>
<p>恋爱记有这么多点滴 另一半还没添加<br>这世上 除了爸妈亲人 连个记挂我的人都没有</p>
<p>好悲哀</p>
<p>早上被闹钟叫醒 发现自己还活着</p>
<p>感谢上帝 有些事只有失去过才知道 我拥有的还很多</p>
<p>致每一个空虚的你</p>
]]></content>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>react基本概念解析</title>
    <url>/2018/06/24/%E8%AF%BBreact%E5%AE%98%E7%BD%91/</url>
    <content><![CDATA[<p><a href="http://www.css88.com/react/docs/hello-world.html" target="_blank" rel="noopener">读react官网</a></p>
<p>关于react 你必须要知道的事情～</p>
<a id="more"></a>
<h2 id="react阻止默认事件"><a href="#react阻止默认事件" class="headerlink" title="react阻止默认事件"></a>react阻止默认事件</h2><p>在react阻止默认行为 必须使用<br>  e.preventDefault();</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'The link was clicked.'</span>);</span><br><span class="line">&#125;</span><br><span class="line">这里， e 是一个合成的事件。 React 根据 W3C 规范 定义了这个合成事件，所以你不需要担心跨浏览器的兼容性问题。查看 SyntheticEvent 参考指南了解更多。</span><br></pre></td></tr></table></figure>
<p>在JSX回调中你必须注意 this 的指向。 在 JavaScript 中，类方法默认没有 绑定 的。如果你忘记绑定 this.handleClick 并将其传递给onClick，那么在直接调用该函数时，this 会是 undefined 。</p>
<p>这不是 React 特有的行为；这是 JavaScript 中的函数如何工作的一部分。 一般情况下，如果你引用一个后面没跟 () 的方法，例如 onClick={this.handleClick} ，那你就应该 绑定(bind) 该方法。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Toggle</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;isToggleOn: <span class="literal">true</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个绑定是必要的，使`this`在回调中起作用</span></span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(prevState =&gt; (&#123;</span><br><span class="line">      isToggleOn: !prevState.isToggleOn</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.isToggleOn ? <span class="symbol">'O</span>N' : <span class="symbol">'OF</span>F'&#125;</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ReactDOM</span>.render(</span><br><span class="line">  &lt;<span class="type">Toggle</span> /&gt;,</span><br><span class="line">  document.getElementById(<span class="symbol">'roo</span>t')</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>解决方式</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这个语法确保 `this` 绑定在 handleClick 中。</span></span><br><span class="line">  <span class="comment">// 警告：这是 *实验性的* 语法。</span></span><br><span class="line">  handleClick = () =&gt; &#123;</span><br><span class="line">    console.log(<span class="symbol">'this</span> is:', <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line">        <span class="type">Click</span> me</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    console.log(<span class="symbol">'this</span> is:', <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// 这个语法确保 `this` 被绑定在 handleClick 中</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;(e) =&gt; <span class="keyword">this</span>.handleClick(e)&#125;&gt;</span><br><span class="line">        <span class="type">Click</span> me</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">这样不好  问题是</span><br><span class="line">这个语法的问题是，每次 <span class="type">LoggingButton</span> 渲染时都创建一个不同的回调。在多数情况下，没什么问题。然而，如果这个回调被作为 prop(属性) 传递给下级组件，这些组件可能需要额外的重复渲染。我们通常建议在构造函数中进行绑定，以避免这类性能问题。</span><br></pre></td></tr></table></figure>
<p>如果需要参数传递给事件处理程序</p>
<figure class="highlight hsp"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">button</span> <span class="keyword">onClick</span>=&#123;(e) =&gt; this.deleteRow(id, e)&#125;&gt;<span class="keyword">Delete</span> Row&lt;/<span class="keyword">button</span>&gt;</span><br><span class="line">&lt;<span class="keyword">button</span> <span class="keyword">onClick</span>=&#123;this.deleteRow.bind(this, id)&#125;&gt;<span class="keyword">Delete</span> Row&lt;/<span class="keyword">button</span>&gt;</span><br></pre></td></tr></table></figure>
<p>使用逻辑 &amp;&amp; 操作符的内联 if 用法 来进行条件渲染</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> Mailbox(props) &#123;</span><br><span class="line">  const unreadMessages = props.unreadMessages;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      </span><span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml">      </span><span class="xquery">&#123;unreadMessages.length &gt; <span class="number">8</span> ?</span></span><br><span class="line"><span class="xquery">        <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="xquery">          You have &#123;unreadMessages.length&#125;</span><span class="xml"> unread messages.</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">       : <span class="string">''</span></span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const messages = [<span class="string">'React'</span>, <span class="string">'Re: React'</span>, <span class="string">'Re:Re: React'</span>];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Mailbox unreadMessages=&#123;messages&#125; /&gt;,</span><br><span class="line"> <span class="built_in"> document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">==</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> Mailbox(props) &#123;</span><br><span class="line">  const unreadMessages = props.unreadMessages;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      </span><span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml">      </span><span class="xquery">&#123;unreadMessages.length &gt; <span class="number">8</span> &amp;&amp;</span></span><br><span class="line"><span class="xquery">        <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="xquery">          You have &#123;unreadMessages.length&#125;</span><span class="xml"> unread messages.</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">       </span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const messages = [<span class="string">'React'</span>, <span class="string">'Re: React'</span>, <span class="string">'Re:Re: React'</span>];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Mailbox unreadMessages=&#123;messages&#125; /&gt;,</span><br><span class="line"> <span class="built_in"> document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">条件渲染的一种简便写法（类似于三目运算符）</span><br><span class="line"></span><br><span class="line">它可以正常运行，因为在 JavaScript 中，<span class="built_in"> true</span> &amp;&amp; expression 总是会评估为 expression ，而<span class="built_in"> false</span> &amp;&amp; expression 总是执行为<span class="built_in"> false</span> 。</span><br><span class="line"></span><br><span class="line">因此，如果条件为<span class="built_in"> true</span> ，则 &amp;&amp; 后面的元素将显示在输出中。 如果是<span class="built_in"> false</span>，React 将会忽略并跳过它。</span><br><span class="line"></span><br><span class="line">最low的一种方式也是借助于元素变量</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> button = null;</span><br><span class="line">    <span class="keyword">if</span> (isLoggedIn) &#123;</span><br><span class="line">      button = &lt;LogoutButton onClick=&#123;this.handleLogoutClick&#125; /&gt;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      button = &lt;LoginButton onClick=&#123;this.handleLoginClick&#125; /&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">    这可以帮助您有条件地渲染组件的一部分，而输出的其余部分不会更改。</span><br></pre></td></tr></table></figure>
<p>使用条件操作符的内联if-else<br>另一个用于条件渲染元素的内联方法是使用 JavaScript 的条件操作符 condition ? true : false 。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">const</span> isLoggedIn = <span class="keyword">this</span>.state.isLoggedIn;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      The user <span class="keyword">is</span> &lt;b&gt;&#123;isLoggedIn ? <span class="string">'currently'</span> : <span class="string">'not'</span>&#125;&lt;/b&gt; logged <span class="keyword">in</span>.</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="防止组件渲染-返回null"><a href="#防止组件渲染-返回null" class="headerlink" title="防止组件渲染 返回null"></a>防止组件渲染 返回null</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">WarningBanner</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!props.warn) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"warning"</span>&gt;</span><br><span class="line">      Warning!</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"> render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;WarningBanner warn=&#123;this.state.showWarning&#125; /</span>&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleToggleClick&#125;&gt;</span><br><span class="line">          &#123;<span class="keyword">this</span>.state.showWarning ? <span class="string">'Hide'</span> : <span class="string">'Show'</span>&#125;</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="react和key"><a href="#react和key" class="headerlink" title="react和key"></a>react和key</h2><p>键（key）<br>键(Keys) 帮助 React 标识哪个项被修改、添加或者移除了。数组中的每一个元素都应该有一个唯一不变的键(Keys)来标识：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> listItems = numbers.map(<span class="function">(<span class="params">number</span>) =&gt;</span></span><br><span class="line">  &lt;li key=&#123;number.toString()&#125;&gt;</span><br><span class="line">    &#123;number&#125;</span><br><span class="line">  &lt;<span class="regexp">/li&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="如何指定key？"><a href="#如何指定key？" class="headerlink" title="如何指定key？"></a>如何指定key？</h3><p>如果你提取 一个 ListItem 组件，应该把 key 放置在数组处理的 <listitem> 元素中，不能放在 ListItem 组件自身中的 <li> 根元素上。</li></listitem></p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> ListItem(props) &#123;</span><br><span class="line">  // 正确！这里不需要指定<span class="built_in"> key</span> ：</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span><span class="xquery">&#123;props.<span class="keyword">value</span>&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> NumberList(props) &#123;</span><br><span class="line">  const numbers = props.numbers;</span><br><span class="line">  const listItems = numbers.<span class="keyword">map</span>(<span class="built_in">(number</span>) =&gt;</span><br><span class="line">    // 正确<span class="built_in">！key</span> 应该在这里被指定</span><br><span class="line">    &lt;ListItem<span class="built_in"> key</span>=<span class="built_in">&#123;number</span>.toString()&#125;</span><br><span class="line">              <span class="keyword">value</span>=<span class="built_in">&#123;number</span>&#125; /&gt;</span><br><span class="line"></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">      </span><span class="xquery">&#123;listItems&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;NumberList numbers=&#123;numbers&#125; /&gt;,</span><br><span class="line"> <span class="built_in"> document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">一个好的经验准则是元素中调用 <span class="keyword">map</span>() 需要 keys 。</span><br></pre></td></tr></table></figure>
<h2 id="组合-继承"><a href="#组合-继承" class="headerlink" title="组合 继承"></a>组合 继承</h2><p>react拥有一个强大的组合模型 建议使用组合而不是继承以实现代码的重用</p>
<p>包含  如果你不确定要使用什么组件 在 弹层等通用的容器中比较常见<br>建议这种组件使用特别的 children props 来直接传递</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyBorder</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=&#123;<span class="string">'FancyBorder FancyBorder-'</span> + props.color&#125;&gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function WelcomeDialog() &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;FancyBorder color="blue"&gt;</span></span><br><span class="line"><span class="regexp">      &lt;h1 className="Dialog-title"&gt;</span></span><br><span class="line"><span class="regexp">        Welcome</span></span><br><span class="line"><span class="regexp">      &lt;/</span>h1&gt;</span><br><span class="line">      &lt;p className=<span class="string">"Dialog-message"</span>&gt;</span><br><span class="line">        Thank you <span class="keyword">for</span> visiting our spacecraft!</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>FancyBorder&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dialog</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;FancyBorder color=<span class="string">"blue"</span>&gt;</span><br><span class="line">      &lt;h1 className=<span class="string">"Dialog-title"</span>&gt;</span><br><span class="line">        &#123;props.title&#125;</span><br><span class="line">      &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p className="Dialog-message"&gt;</span></span><br><span class="line"><span class="regexp">        &#123;props.message&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>p&gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;<span class="regexp">/FancyBorder&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class SignUpDialog extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  constructor(props) &#123;</span></span><br><span class="line"><span class="regexp">    super(props);</span></span><br><span class="line"><span class="regexp">    this.handleChange = this.handleChange.bind(this);</span></span><br><span class="line"><span class="regexp">    this.handleSignUp = this.handleSignUp.bind(this);</span></span><br><span class="line"><span class="regexp">    this.state = &#123;login: ''&#125;;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;Dialog title="Mars Exploration Program"</span></span><br><span class="line"><span class="regexp">              message="How should we refer to you?"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input value=&#123;this.state.login&#125;</span></span><br><span class="line"><span class="regexp">               onChange=&#123;this.handleChange&#125; /</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleSignUp&#125;&gt;</span><br><span class="line">          Sign Me Up!</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>Dialog&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(e) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">login</span>: e.target.value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSignUp() &#123;</span><br><span class="line">    alert(<span class="string">`Welcome aboard, <span class="subst">$&#123;<span class="keyword">this</span>.state.login&#125;</span>!`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义组件写法"><a href="#自定义组件写法" class="headerlink" title="自定义组件写法"></a>自定义组件写法</h2><p>用户自定义的组件必须以大写字母开头</p>
<p>但一个元素类型以小写字母开头 他表示引用一个类似于<div>或者<span>的内置组件<br>以大写字母开头的类型，类似于 <foo>，会被编译成 React.createElement(Foo) ，对应于自定义组件 或者在 JavaScript 文件中导入的组件。</foo></span></div></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误！这是一个组件，首字母应该大写：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 正确！这种使用 &lt;div&gt; 是合法的，因为 div 是一个有效的HTML标记：</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello &#123;props.toWhat&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HelloWorld</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 错误！React 认为 &lt;hello /&gt; 是一个 HTML 标签，因为它首字母应不是大写的：</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">hello</span> <span class="attr">toWhat</span>=<span class="string">"World"</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<p>字符串字面量</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">&lt;MyComponent message="hello world" /&gt;</span><br><span class="line">====</span><br><span class="line">&lt;MyComponent message=&#123;<span class="emphasis">'hello world'</span>&#125; /&gt;</span><br></pre></td></tr></table></figure>
<p>props(属性)默认为true</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">&lt;MyTextBox autocomplete /&gt;</span><br><span class="line">===</span><br><span class="line">&lt;MyTextBox autocomplete=&#123;true&#125; /&gt;</span><br></pre></td></tr></table></figure>
<p>jsx中的children</p>
<p>字符串变量</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="params">&lt;MyComponent&gt;</span>Hello world!<span class="params">&lt;/MyComponent&gt;</span></span><br><span class="line">这是有效的 JSX ，MyComponent 组件中的 props.children 值为字符串 <span class="string">"Hello world!"</span> 。</span><br></pre></td></tr></table></figure>
<p>JSX会删除每行开头和结尾的空格，并且也会删除空行。邻接标签的空行也会被移除，字符串之间的空格会被压缩成一个空格，因此下面的渲染效果都是相同的</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span>&gt;Hello World&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;<span class="keyword">div</span>&gt;</span><br><span class="line">  Hello World</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;<span class="keyword">div</span>&gt;</span><br><span class="line">  Hello</span><br><span class="line">  World</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;<span class="keyword">div</span>&gt;</span><br><span class="line"></span><br><span class="line">  Hello World</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>
<p>Booleans, Null, 和 Undefined 被忽略<br>false，null，undefined，和 true 都是有效的的 children(子元素) 。但是并不会被渲染，下面的JSX表达式渲染效果是相同的：</p>
<figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> /&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><span class="template-variable">&#123;false&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><span class="template-variable">&#123;null&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><span class="template-variable">&#123;undefined&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><span class="template-variable">&#123;true&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>在有条件渲染的时候非常有用 如果 showheader为true的时候 <header>会被渲染（必须保证&amp;&amp;表达式之前总是布尔值）</header></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  &#123;showHeader &amp;&amp; <span class="tag">&lt;<span class="name">Header</span> /&gt;</span>&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">Content</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果在输出中想要渲染false true null或者undefined 必须先将其转化为字符串</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">&lt;<span class="built-in">div</span>&gt;</span><br><span class="line">  My JavaScript <span class="keyword">variable</span> is <span class="comment">&#123;String(myVariable)&#125;.</span></span><br><span class="line">&lt;/<span class="built-in">div</span>&gt;</span><br></pre></td></tr></table></figure>
<p>使用propType进行类型检查<br>可以通过赋值特定的default属性为pros定义默认值</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeting</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;h1&gt;<span class="type">Hello</span>, &#123;<span class="keyword">this</span>.props.name&#125;&lt;/h1&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定 props 的默认值：</span></span><br><span class="line"><span class="type">Greeting</span>.defaultProps = &#123;</span><br><span class="line">  name: <span class="symbol">'Strange</span>r'</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染为 "Hello, Stranger":</span></span><br><span class="line"><span class="type">ReactDOM</span>.render(</span><br><span class="line">  &lt;<span class="type">Greeting</span> /&gt;,</span><br><span class="line">  document.getElementById(<span class="symbol">'exampl</span>e')</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Greeting</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  static defaultProps = &#123;</span><br><span class="line">    name: <span class="symbol">'strange</span>r'</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;<span class="type">Hello</span>, &#123;<span class="keyword">this</span>.props.name&#125;&lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">propTypes 的类型检测是在defaultProps 解析之后发生的，因此也会对默认属性 defaultProps 进行类型检测。</span><br></pre></td></tr></table></figure>
<h2 id="ES6-声明class组件"><a href="#ES6-声明class组件" class="headerlink" title="ES6 声明class组件"></a>ES6 声明class组件</h2><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeting</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Greeting</span>.defaultProps = &#123;</span><br><span class="line">  name: <span class="symbol">'Mar</span>y'</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="设置初始化组件"><a href="#设置初始化组件" class="headerlink" title="设置初始化组件"></a>设置初始化组件</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;count: props.initialCount&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="一致性比较（diff算法的实现）"><a href="#一致性比较（diff算法的实现）" class="headerlink" title="一致性比较（diff算法的实现）"></a>一致性比较（diff算法的实现）</h2><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">使用react的时候 任何一个单点时刻可以认为 render（）函数的作用是创建react元素树</span><br><span class="line">在下一个<span class="keyword">state</span>或者props更新的时候 render（）函数将会返回一个不同的react元素树</span><br><span class="line">接下来 react将会找出如何高效的更新ui来匹配最近时刻的react元素树</span><br></pre></td></tr></table></figure>
<p>react基于以下两个假设实现了时间复杂度为o（n）的算法</p>
<ul>
<li>不同类型的两个元素将会产生不同的树。</li>
<li>开发人员可以使用一个key prop来指示在不同的渲染中那个那些元素可以保持稳定</li>
</ul>
<h3 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h3><p>当比较不同的树 react会首先比较两个根元素 根据根的类型不同 它有不同的行为</p>
<h4 id="元素类型不相同时"><a href="#元素类型不相同时" class="headerlink" title="元素类型不相同时"></a>元素类型不相同时</h4><p>无论什么时候 当根元素类型不同时，react将会销毁原先的树并重写构建新的树<br>当销毁原先的树时 之前的dom节点将销毁，实例组件执行 componentWillUnmount() 。当构建一个新的树 新的dom节点将会插入dom中 组件将会执行componentWillMount() 以及 componentDidMount() 。与之前旧的树相关的 state 都会丢失。</p>
<h4 id="dom元素类型相同时"><a href="#dom元素类型相同时" class="headerlink" title="dom元素类型相同时"></a>dom元素类型相同时</h4><p>当元素类型相同 react会比较检查它们的属性（attributes）保留相同的底层dom节点 只更新发生改变的属性</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="attribute">className</span>=<span class="string">"before"</span> <span class="attribute">title</span>=<span class="string">"stuff"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;div <span class="attribute">className</span>=<span class="string">"after"</span> <span class="attribute">title</span>=<span class="string">"stuff"</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>通过比较两个元素，React 会仅修改底层 DOM 节点的 className 属性。<br>在处理完当前 DOM 节点后，React 会递归处理子节点。</p>
<h4 id="相同类型的组件"><a href="#相同类型的组件" class="headerlink" title="相同类型的组件"></a>相同类型的组件</h4><p>当一个组件更新的时候 组件实例保持不变 以便在渲染中保持state react会更新组件实例的属性来匹配新的元素 并在组件实例中调用componentWillReceiveProps() 和 componentWillUpdate()。接下来， render() 方法会被调用并且diff算法对上一次的结果和新的结果进行递归。</p>
<h4 id="子元素递归"><a href="#子元素递归" class="headerlink" title="子元素递归"></a>子元素递归</h4><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;<span class="built_in">li</span>&gt;<span class="built_in">first</span>&lt;/<span class="built_in">li</span>&gt;</span><br><span class="line">  &lt;<span class="built_in">li</span>&gt;<span class="built_in">second</span>&lt;/<span class="built_in">li</span>&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;<span class="built_in">li</span>&gt;<span class="built_in">first</span>&lt;/<span class="built_in">li</span>&gt;</span><br><span class="line">  &lt;<span class="built_in">li</span>&gt;<span class="built_in">second</span>&lt;/<span class="built_in">li</span>&gt;</span><br><span class="line">  &lt;<span class="built_in">li</span>&gt;<span class="built_in">third</span>&lt;/<span class="built_in">li</span>&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">React 会比较两个 &lt;<span class="built_in">li</span>&gt;<span class="built_in">first</span>&lt;/<span class="built_in">li</span>&gt; 树与两个 &lt;<span class="built_in">li</span>&gt;<span class="built_in">second</span>&lt;/<span class="built_in">li</span>&gt; 树，然后插入 &lt;<span class="built_in">li</span>&gt;<span class="built_in">third</span>&lt;/<span class="built_in">li</span>&gt; 树。</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Duke<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Villanova<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Connecticut<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Duke<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Villanova<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">React 将会改变每一个子节点而没有意识到需要保留 <span class="tag">&lt;<span class="name">li</span>&gt;</span>Duke<span class="tag">&lt;/<span class="name">li</span>&gt;</span> 和 <span class="tag">&lt;<span class="name">li</span>&gt;</span>Villanova<span class="tag">&lt;/<span class="name">li</span>&gt;</span> 两个子树。这种低效是一个问题。</span><br></pre></td></tr></table></figure>
<p>怎么解决类似的问题<br>为了解决这个问题 react支持一个key属性 当子节点有了key react使用这个key去比较原来的树的子节点和之后的子节点 </p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;<span class="built_in">li</span> <span class="built_in">key</span>=<span class="string">"2015"</span>&gt;Duke&lt;/<span class="built_in">li</span>&gt;</span><br><span class="line">  &lt;<span class="built_in">li</span> <span class="built_in">key</span>=<span class="string">"2016"</span>&gt;Villanova&lt;/<span class="built_in">li</span>&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;<span class="built_in">li</span> <span class="built_in">key</span>=<span class="string">"2014"</span>&gt;Connecticut&lt;/<span class="built_in">li</span>&gt;</span><br><span class="line">  &lt;<span class="built_in">li</span> <span class="built_in">key</span>=<span class="string">"2015"</span>&gt;Duke&lt;/<span class="built_in">li</span>&gt;</span><br><span class="line">  &lt;<span class="built_in">li</span> <span class="built_in">key</span>=<span class="string">"2016"</span>&gt;Villanova&lt;/<span class="built_in">li</span>&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">现在 react知道<span class="number">2014</span>的<span class="built_in">key</span>元素是新的 <span class="built_in">key</span>为<span class="number">2015</span>和<span class="number">2016</span>的两个元素仅仅只是被移动而已</span><br></pre></td></tr></table></figure>
<h2 id="片段"><a href="#片段" class="headerlink" title="片段"></a>片段</h2><p>解决痛点</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Table</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;table&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">          &lt;Columns /&gt;</span><br><span class="line">        &lt;<span class="regexp">/tr&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>table&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">为了渲染有效的 HTML ， &lt;Columns /&gt; 需要返回多个 &lt;td&gt; 元素。如果 &lt;Columns /&gt; 的 render() 函数里面使用一个父级 div ，那么最终生成的 HTML 将是无效的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Columns</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;td&gt;Hello&lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">        &lt;td&gt;World&lt;/</span>td&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">最后会渲染成</span></span><br><span class="line"><span class="regexp">&lt;table&gt;</span></span><br><span class="line"><span class="regexp">  &lt;tr&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;td&gt;Hello&lt;/</span>td&gt;</span><br><span class="line">      &lt;td&gt;World&lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  &lt;<span class="regexp">/tr&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>table&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">使用方式</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Columns</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;React.Fragment&gt;</span><br><span class="line">        &lt;td&gt;Hello&lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">        &lt;td&gt;World&lt;/</span>td&gt;</span><br><span class="line">      &lt;<span class="regexp">/React.Fragment&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">新的声明方式（看起来像空标签）</span></span><br><span class="line"><span class="regexp">class Columns extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;&gt;</span></span><br><span class="line"><span class="regexp">        &lt;td&gt;Hello&lt;/</span>td&gt;</span><br><span class="line">        &lt;td&gt;World&lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">带key的片段</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Glossary</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;dl&gt;</span><br><span class="line">      &#123;props.items.map(<span class="function"><span class="params">item</span> =&gt;</span> (</span><br><span class="line">        <span class="comment">// 没有`key`，将会触发一个key警告</span></span><br><span class="line">        &lt;React.Fragment key=&#123;item.id&#125;&gt;</span><br><span class="line">          &lt;dt&gt;&#123;item.term&#125;&lt;<span class="regexp">/dt&gt;</span></span><br><span class="line"><span class="regexp">          &lt;dd&gt;&#123;item.description&#125;&lt;/</span>dd&gt;</span><br><span class="line">        &lt;<span class="regexp">/React.Fragment&gt;</span></span><br><span class="line"><span class="regexp">      ))&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>dl&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">key 是唯一可以传递给 Fragment 的属性。在将来，我们可能增加额外的属性支持，比如事件处理。</span><br></pre></td></tr></table></figure>
<h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><p>Portals 提供了一种很好的方法，将子节点渲染到父组件 DOM 层次结构之外的 DOM 节点。</p>
<p><code>ReactDOM.createPortal(child, container)</code></p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line">第一个参数（child）是任何可渲染的 React 子元素，例如一个元素，字符串或 片段(fragment)。</span><br><span class="line">第二个参数（<span class="keyword">container</span>）则是一个 DOM 元素。</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="comment">// React 装载一个新的 div，并将 children 渲染到这个 div 中</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;<span class="keyword">this</span>.props.children&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">然而，有时候将子元素插入到 DOM 节点的其他位置会有用的：</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line">  <span class="comment">// React *不* 会创建一个新的 div。 它把 children 渲染到 `domNode` 中。</span></span><br><span class="line">  <span class="comment">// `domNode` 可以是任何有效的 DOM 节点，不管它在 DOM 中的位置。</span></span><br><span class="line">  <span class="keyword">return</span> ReactDOM.createPortal(</span><br><span class="line">    <span class="keyword">this</span>.props.children,</span><br><span class="line">    domNode,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="错误边界"><a href="#错误边界" class="headerlink" title="错误边界"></a>错误边界</h3><p>部分 UI 中的 JavaScript 错误不应该破坏整个应用程序，错误边界是 React 组件，它可以在子组件树的任何位置捕获 JavaScript 错误，记录这些错误，并显示一个备用 UI ** ，而不是使整个组件树崩溃。错误边界(Error Boundaries) 在渲染，生命周期方法以及整个组件树下的构造函数中捕获错误。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; hasError: <span class="literal">false</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"> 有这个生命周期方法 证明是错误边界方式</span><br><span class="line">  componentDidCatch(error, info) &#123;</span><br><span class="line">    <span class="comment">// Display fallback UI</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; hasError: <span class="literal">true</span> &#125;);</span><br><span class="line">    <span class="comment">// You can also log the error to an error reporting service</span></span><br><span class="line">    logErrorToMyService(error, info);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state.hasError) &#123;</span><br><span class="line">      <span class="comment">// You can render any custom fallback UI</span></span><br><span class="line">      <span class="keyword">return</span> &lt;h1&gt;<span class="type">Something</span> went wrong.&lt;/h1&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.children;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">调用</span><br><span class="line">&lt;<span class="type">ErrorBoundary</span>&gt;</span><br><span class="line">  &lt;<span class="type">MyWidget</span> /&gt;</span><br><span class="line">&lt;/<span class="type">ErrorBoundary</span>&gt;</span><br></pre></td></tr></table></figure>
<p>注意错误边界(Error Boundaries) 仅可以捕获其子组件的错误。错误边界无法捕获其自身的错误。如果一个错误边界无法渲染错误信息，则错误会向上冒泡至最接近的错误边界。这也类似于 JavaScript 中 catch {} 的工作机制</p>
<p><a href="https://codepen.io/anon/pen/VdyBrE?editors=0010" target="_blank" rel="noopener">https://codepen.io/anon/pen/VdyBrE?editors=0010</a></p>
<h3 id="未捕获错误的新行为"><a href="#未捕获错误的新行为" class="headerlink" title="未捕获错误的新行为"></a>未捕获错误的新行为</h3><p>这一改变有非常重要的意义。自 React 16 开始，任何未被错误边界捕获的错误将会卸载整个 React 组件树。</p>
<p>时间处理器如何处理<br>错误边界无法捕获事件处理器内部的错误。</p>
<p>因为时间处理器不会在渲染周期内触发<br>因此若他们抛出异常 react仍然能够知道需要在屏幕中显示什么<br>如果你需要在事件处理器内部捕获错误，使用普通的 JavaScript try / catch 语句：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; error: <span class="literal">null</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  handleClick = () =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Do something that could throw</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; error &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state.error) &#123;</span><br><span class="line">      <span class="keyword">return</span> &lt;h1&gt;<span class="type">Caught</span> an error.&lt;/h1&gt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &lt;div onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;<span class="type">Click</span> <span class="type">Me</span>&lt;/div&gt;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>代码拆分</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">import &#123; <span class="keyword">add</span><span class="bash"> &#125; from <span class="string">'./math'</span>;</span></span><br><span class="line"></span><br><span class="line">console.log(<span class="keyword">add</span><span class="bash">(16, 26));</span></span><br></pre></td></tr></table></figure>
<p>以后</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">"./math"</span>).then(<span class="function"><span class="params">math</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(math.add(<span class="number">16</span>, <span class="number">26</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当 Webpack 遇到这个语法时，它会自动启动 代码拆分 来拆分你的应用程序。</p>
<p>react component</p>
<h3 id="Mounting-装载"><a href="#Mounting-装载" class="headerlink" title="Mounting(装载)"></a>Mounting(装载)</h3><p> 当组件实例被创建并且将其插入dom时 z和谐方法将会被调用</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constructor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">componentWillMount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">render</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">componentDidMount</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<h3 id="Updating-更新"><a href="#Updating-更新" class="headerlink" title="Updating(更新)"></a>Updating(更新)</h3><p>改变props或者state可以触发更新事件，在重新渲染组件时将会调用</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">componentWillReceiveProps</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">shouldComponentUpdate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">componentWillUpdate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">render</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">componentDidUpdate</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<h3 id="Unmounting-卸载"><a href="#Unmounting-卸载" class="headerlink" title="Unmounting(卸载)"></a>Unmounting(卸载)</h3><p>当一个组件从Dom中删除时 将会调用</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">componentWillUnmount</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<h3 id="render-方法"><a href="#render-方法" class="headerlink" title="render() 方法"></a>render() 方法</h3><p>render() 函数应该是纯函数，这意味着它不会修改组件状态，每次调用它时返回相同的结果 如果 shouldComponentUpdate() 方法返回 false ，render() 不会被调用。</p>
<p>当被调用时，它会检查this.props 和 this.state并返回其中一个类型</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">react元素</span><br><span class="line">字符串和数字</span><br><span class="line">Portals  ReactDOM.createPortal 创建。</span><br><span class="line">null:不渲染任何东西</span><br><span class="line">布尔值:不渲染任何东西 （通常存在于 <span class="built_in">return</span> <span class="built_in">test</span> &amp;&amp; &lt;Child /&gt;写法，其中 <span class="built_in">test</span> 是布尔值。）</span><br></pre></td></tr></table></figure>
<p>你可以返回 null 或 false 来表示你不想要渲染任何东西 当返回 null 或 false 时，ReactDOM.findDOMNode(this) 将返回 null<br>当你想返回多个元素时 用数组操作</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="built_in">return</span> [</span><br><span class="line">    &lt;<span class="built_in">li</span> <span class="built_in">key</span>=<span class="string">"A"</span>&gt;First item&lt;/<span class="built_in">li</span>&gt;,</span><br><span class="line">    &lt;<span class="built_in">li</span> <span class="built_in">key</span>=<span class="string">"B"</span>&gt;Second item&lt;/<span class="built_in">li</span>&gt;,</span><br><span class="line">    &lt;<span class="built_in">li</span> <span class="built_in">key</span>=<span class="string">"C"</span>&gt;Third item&lt;/<span class="built_in">li</span>&gt;,</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="constructor-方法"><a href="#constructor-方法" class="headerlink" title="constructor()方法"></a>constructor()方法</h3><p>组件被装载前调用，当实现<code>react.component</code>时子类的constructor(构造函数)时 应该最先调用<code>super(props)</code> 否则将找不到this 报错</p>
<p>可以在构造函数中初始化state 采用<br>this.state={} 的方式而不是使用setState()  构造函数也经常用于将事件处理程序绑定到类实例(目前可以用箭头函数解决此类问题)<br>如果state需要根据props的值来初始化，就是你需要考虑变量提升的时候</p>
<p>如果你没有初始化 状态(state) ，并且没有绑定方法，不用实现一个构造函数</p>
<h3 id="componentWillMount"><a href="#componentWillMount" class="headerlink" title="componentWillMount()"></a>componentWillMount()</h3><p>在组件装载之前立即被调用的方法 在render之前渲染 所以 不会触发render<br>也是服务端渲染调用的唯一的生命周期的<br>钩子</p>
<h3 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount()"></a>componentDidMount()</h3><p>组件装载之后立即被调用<br>初始化需要的dom节点或从远程加载数据的地方<br>在这里调用<code>setState()</code>会触render()<br>但会在浏览器更新屏幕之前发生。在这种情况下，即使 render() 会被调用两次， 也可以保证用户不会看到中间状态</p>
<h3 id="componentWillReceiveProps"><a href="#componentWillReceiveProps" class="headerlink" title="componentWillReceiveProps()"></a>componentWillReceiveProps()</h3><p> 在已装载组件接收新 props 之前被调用,<br> 可以在此方法中比较this.props 和 nextProps 并使用 this.setState() 执行状态转换。</p>
<h3 id="shouldComponentUpdate-nextProps-nextState"><a href="#shouldComponentUpdate-nextProps-nextState" class="headerlink" title="shouldComponentUpdate(nextProps, nextState)"></a>shouldComponentUpdate(nextProps, nextState)</h3><p>让 React 知道组件的输出是否不受 state 或 props 当前变化的影响，默认行为是在每次 state 更改时重新渲染，并且在绝大多数情况下，你应该依赖于默认行为。<br>当接收到新的 props 或 state 时，shouldComponentUpdate() 在渲染之前被调用。 默认返回 true ，对于初始(第一次)渲染，不调用此方法，返回 false 不会阻止子组件在 state 更改时重新渲染 但是<br><code>componentWillUpdate()</code> ，<code>render()</code>和<code>componentDidUpdate()</code>将不会被调用</p>
<h3 id="componentWillUpdate"><a href="#componentWillUpdate" class="headerlink" title="componentWillUpdate()"></a>componentWillUpdate()</h3><p>当接收到state或者props，它会在渲染之前被调用</p>
<h3 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate()"></a>componentDidUpdate()</h3><p>在更新发生之立即被调用，当组件已经更新时，也可以在这里操作dom 也可以做网络请求</p>
<h3 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount()"></a>componentWillUnmount()</h3><p>当组件被卸载和销毁之前 被调用 可以在此执行必要的清理 计时器 网络请求 或者在didmount创建的元素</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">componentDidMount</span><span class="params">()</span></span> &#123;</span><br><span class="line">  this<span class="selector-class">.serverRequest</span> = axios.get(<span class="string">'/api'</span>)</span><br><span class="line">    .then(posts =&gt; &#123;</span><br><span class="line">      this.setState(&#123;</span><br><span class="line">        posts</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">componentWillUnmount</span><span class="params">()</span></span> &#123;</span><br><span class="line">  this<span class="selector-class">.serverRequest</span><span class="selector-class">.abort</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="componentDidCatch"><a href="#componentDidCatch" class="headerlink" title="componentDidCatch()"></a>componentDidCatch()</h3><p>错误边界 可以在其_子组件树 _中的任何位置捕获js错误 显示备用ui<br>错误边界在渲染过程中，在生命周期方法中，以及整个树下的构造函数中捕获错误。</p>
<h3 id="setState"><a href="#setState" class="headerlink" title="setState()"></a>setState()</h3><p>setState() 总是会导致重新渲染，除非 shouldComponentUpdate() 返回 false</p>
<p>setState是作为一个请求而不是立即命令来更新组件 为了性能考虑 react可能会批量 或 延迟到后面更新它 然后合并多个setState()更新多个组件<br>React不保证 state 更新就立即应用(重新渲染)。所以更新之后立即读取可能会有问题<br>你可以使用 componentDidUpdate或者setState回调 <code>（setState(updater, callback)）</code></p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">例如，假设我们想通过 props.step 在 <span class="keyword">state</span> 中增加一个值：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">this.<span class="built_in">set</span>State((prevState, props) =&gt; &#123;</span><br><span class="line">  return &#123;counter: prevState.counter + props.step&#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>State(<span class="keyword">state</span>Change, [callback])</span><br><span class="line">这将执行 <span class="keyword">state</span>Change 的浅合并到新的 <span class="keyword">state</span> </span><br><span class="line"></span><br><span class="line">这种也是异步的会进行批处理 如果同一时间段需要多次操作 可能会被覆盖</span><br><span class="line">Object.assign(</span><br><span class="line">  previousState,</span><br><span class="line">  &#123;quantity: <span class="keyword">state</span>.quantity + <span class="number">1</span>&#125;,</span><br><span class="line">  &#123;quantity: <span class="keyword">state</span>.quantity + <span class="number">1</span>&#125;,</span><br><span class="line">  ...</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">可以这么使用</span><br><span class="line">this.<span class="built_in">set</span>State((prevState) =&gt; &#123;</span><br><span class="line">  return &#123;counter: prevState.quantity + <span class="number">1</span>&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>传递一个更新函数允许你在更新中访问当前的状态值。由于 setState 调用是批处理的,这允许你链式更新并确保它们建立在彼此之上，而不是产生冲突：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">incrementCount() &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState((prevState) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;count: prevState.count + <span class="number">1</span>&#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handleSomething() &#123;</span><br><span class="line">  <span class="comment">// this.state.count 是 1，然后我们这样做：</span></span><br><span class="line">  <span class="keyword">this</span>.incrementCount();</span><br><span class="line">  <span class="keyword">this</span>.incrementCount(); <span class="comment">// count 现在是 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="ReactDOMServer"><a href="#ReactDOMServer" class="headerlink" title="ReactDOMServer"></a>ReactDOMServer</h2><p>ReactDOMServer 对象允许您在服务器上渲染组件。</p>
<p>renderToString()<br>renderToStaticMarkup()</p>
<p>渲染流<br>renderToNodeStream()<br>renderToStaticNodeStream()</p>
<p>渲染流可以减小第一个字节(TTFB)渲染时间，在文档的下一个部分生成之前，将文档的开头向下发送到浏览器。所有主流浏览器都会在服务器以这种方式流出内容时开始解析和呈现文档。</p>
<h4 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h4><p>是阻止函数在给定时间内被多次调用</p>
<h4 id="Debounce（防抖）"><a href="#Debounce（防抖）" class="headerlink" title="Debounce（防抖）"></a>Debounce（防抖）</h4><p>防抖确保函数上次执行后的一段时间内，不会再次执行。</p>
<h4 id="操作css"><a href="#操作css" class="headerlink" title="操作css"></a>操作css</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">let</span> className = <span class="string">'menu'</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.props.isActive) &#123;</span><br><span class="line">    className += <span class="string">' menu-active'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&#123;className&#125;</span>&gt;</span>Menu<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Virtual-DOM-and-Internals"><a href="#Virtual-DOM-and-Internals" class="headerlink" title="Virtual DOM and Internals"></a>Virtual DOM and Internals</h3><h4 id="什么是虚拟dom"><a href="#什么是虚拟dom" class="headerlink" title="什么是虚拟dom"></a>什么是虚拟dom</h4><p>虚拟dom是一种编程概念，是指虚拟的视图被保留在内存中 通过如reactDom这样的库与“真实”的dom 保持同步<br>虚拟DOM是由JavaScript库在浏览器API之上实现的一种概念</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文为react概况，意在对react有个整理认知，其中的任意一条都值得深入研究，日后可能会针对某一个知识点单开文章～ </p>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>重构前端体系系列 - 构建前端知识架构</title>
    <url>/2020/03/12/relearning_front-end/</url>
    <content><![CDATA[<h2 id="重新理解前端"><a href="#重新理解前端" class="headerlink" title="重新理解前端"></a>重新理解前端</h2><p>前端工程师已经成为研发体系中重要的岗位，但与此相对是大部分前端工程师的知识其实都是来自于实践和工作中零散的学习，这个现状就引发了一系列的问题</p>
<ul>
<li>前端的基础知识薄弱：散点自学 + 基础不牢 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">基础知识的欠缺会让你束手束脚，更限制你解决问题的思路</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>技术上存在短板，就会导致前端开发者的上升通道不甚顺畅 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">小公司的程序员，只能靠自己摸索，这样就很容易陷入重复性劳动的陷阱，最终耽误自己的职业发展</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>前端工程师也会面临技术发展问题带来的挑战 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">前端社区高度活跃，前端标准也在快速更新，这样蓬勃发展对技术来说无疑是好事，但是副作用也显而易见，它使得前端工程师的学习压力变得很大。</span><br></pre></td></tr></tbody></table></figure>

<p>大部分人学前端的方式是 “土法学前端”，他们对于知识的理解基本都停留在点上，从来没有大范围把这些点串成线，形成自己的知识体系，因此才会出现遗漏和盲点</p>
<a id="more"></a>
<h3 id="前端工程师的成长视角"><a href="#前端工程师的成长视角" class="headerlink" title="前端工程师的成长视角"></a>前端工程师的成长视角</h3><ul>
<li>是立足标准，系统性总结和整理前端知识，建立自己的认知和方法论</li>
<li>是放眼团队，从业务和工程角度思考前端团队的价值和发展需要。只有这样做，才能够持续发展，在高速发展的技术和工程浪潮中稳稳立足</li>
<li>以完备、体系化的方式理解和思考前端的基础知识和工程实践</li>
</ul>
<p>事实上，前端的能力可以带来更多的业务场景，这些有待于我们去发掘<br>建立自己的知识体系和方法论，才能够保持领先优势</p>
<h2 id="明确前端的学习路线和方法"><a href="#明确前端的学习路线和方法" class="headerlink" title="明确前端的学习路线和方法"></a>明确前端的学习路线和方法</h2><h3 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h3><ul>
<li>摸索出适合你自己的前端学习方法</li>
<li>帮助建立前端技术的知识架构</li>
<li>理解前端技术背后的核心思想</li>
</ul>
<h3 id="前端学习方法"><a href="#前端学习方法" class="headerlink" title="前端学习方法"></a>前端学习方法</h3><h4 id="建立知识架构"><a href="#建立知识架构" class="headerlink" title="建立知识架构"></a>建立知识架构</h4><ul>
<li>学习的过程实际上就是知识架构不断进化的过程</li>
<li>通过知识架构的自然延伸，我们可以更轻松地记忆一些原本难以记住的点，还可以发现被忽视的知识盲点</li>
<li>建立知识架构同样利于面试</li>
</ul>
<h4 id="追本溯源"><a href="#追本溯源" class="headerlink" title="追本溯源"></a>追本溯源</h4><ul>
<li>有一些知识，背后有一个很大的体系</li>
<li>关注技术提出来的背景，找到知识的源头</li>
<li>关注原始的论文或者文章，关注作者说的话</li>
</ul>
<p>比如 关注 scheme，Java 与 JS 语言的异同</p>
<h2 id="前端知识图谱"><a href="#前端知识图谱" class="headerlink" title="前端知识图谱"></a>前端知识图谱</h2><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>用一定的词法和语法，表达一定语义，从而操作运行时</p>
<p>所以分为以下三个部分</p>
<ul>
<li>运行时</li>
<li>文法</li>
<li>语义</li>
</ul>
<p><img src="http://cdn.anruence.com/js%E5%9B%BE.png" alt="image"></p>
<h3 id="HTML-和-CSS"><a href="#HTML-和-CSS" class="headerlink" title="HTML 和 CSS"></a>HTML 和 CSS</h3><p>HTML 的功能主要由标签来承担，所以我们首先会把标签做一些分类</p>
<ul>
<li>文档元信息：通常是出现在 head 标签中的元素，包含了描述文档自身的一些信息；</li>
<li>语义相关：扩展了纯文本，表达文章结构、不同语言要素的标签；</li>
<li>链接：提供到文档内和文档外的链接；</li>
<li>替换型标签：引入声音、图片、视频等外部元素替换自身的一类标签；</li>
<li>表单：用于填写和提交信息的一类标签</li>
<li>表格：表头、表尾、单元格等表格的结构</li>
</ul>
<p><img src="http://cdn.anruence.com/html%E5%9B%BE.png" alt="image"></p>
<h3 id="浏览器的实现原理和-API"><a href="#浏览器的实现原理和-API" class="headerlink" title="浏览器的实现原理和 API"></a>浏览器的实现原理和 API</h3><p><img src="http://cdn.anruence.com/liulanqi.png" alt="image"></p>
<h3 id="前端工程实践"><a href="#前端工程实践" class="headerlink" title="前端工程实践"></a>前端工程实践</h3><p><img src="http://cdn.anruence.com/qianduangongcheng.jpg" alt="image"></p>
<h3 id="前端知识架构"><a href="#前端知识架构" class="headerlink" title="前端知识架构"></a>前端知识架构</h3><p><img src="http://cdn.anruence.com/qiandaunzhishikuangjia.png" alt="image"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>建立一个理解前端的全景图<br>这样，任何时候都能够体系地思考问题，分析问题，解决问题！</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端体系</tag>
      </tags>
  </entry>
</search>
