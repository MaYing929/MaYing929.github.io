<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"maying.ink","root":"/","scheme":"Muse","version":"8.0.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>

  <meta name="description" content="知识带来自由，我等风也等你 🍂">
<meta property="og:type" content="website">
<meta property="og:title" content="亦舒的海角">
<meta property="og:url" content="http://maying.ink/page/5/index.html">
<meta property="og:site_name" content="亦舒的海角">
<meta property="og:description" content="知识带来自由，我等风也等你 🍂">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="亦舒">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://maying.ink/page/5/">


<script data-pjax class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>亦舒的海角</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">亦舒的海角</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">26</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">6</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">53</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="亦舒"
      src="/uploads/avatar.jpeg">
  <p class="site-author-name" itemprop="name">亦舒</p>
  <div class="site-description" itemprop="description">知识带来自由，我等风也等你 🍂</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">53</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/maying2020" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;maying2020" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:maxiaoying929@gmail.com" title="E-Mail → mailto:maxiaoying929@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://weibo.com/3640193250/profile?topnav=1&wvr=6" title="Weibo → http:&#x2F;&#x2F;weibo.com&#x2F;3640193250&#x2F;profile?topnav&#x3D;1&amp;wvr&#x3D;6" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/maying2020" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://maying.ink/2017/08/03/viewports%E5%89%96%E6%9E%90%E4%B8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
      <meta itemprop="name" content="亦舒">
      <meta itemprop="description" content="知识带来自由，我等风也等你 🍂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亦舒的海角">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/08/03/viewports%E5%89%96%E6%9E%90%E4%B8%80/" class="post-title-link" itemprop="url">viewports 剖析一</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-08-03 00:00:00" itemprop="dateCreated datePublished" datetime="2017-08-03T00:00:00+08:00">2017-08-03</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-10-23 02:41:42" itemprop="dateModified" datetime="2020-10-23T02:41:42+08:00">2020-10-23</time>
      </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>因为工作的原因，很少有机会接触移动 web 开发，一直都还挺遗憾的，偶尔写几个页面也都是 “按照套路” 出牌，最近终于有空了解一些概念性的东西，记录一下<br>文中的图片为了说明问题均为<code>盗图</code>，具体出处会在文末注明</p>
<p>本文大概将以下几个概念以做对比</p>
<ul>
<li>PC<ul>
<li><a href="#line1"> <font face="STCAIYUN" size="3" color="blueGreen"> 设备的 pixels 和 CSS 的 pixels</font></a></li>
<li><a href="#line2"> <font face="STCAIYUN" size="3" color="blueGreen"> 所谓的 100% 缩放</font></a></li>
<li><a href="#line3"> <font face="STCAIYUN" size="3" color="blueGreen">屏幕尺寸和浏览器尺寸</font></a></li>
<li><a href="#line4"> <font face="STCAIYUN" size="3" color="blueGreen">页面的滚动移位</font></a></li>
<li><a href="#line5"> <font face="STCAIYUN" size="3" color="blueGreen"> viewport 以及度量 viewport</font></a></li>
<li><a href="#line6"> <font face="STCAIYUN" size="3" color="blueGreen">html 元素以及度量 html</font></a></li>
<li><a href="#line7"> <font face="STCAIYUN" size="3" color="blueGreen"> 关于事件坐标</font></a></li>
<li><a href="#line8"> <font face="STCAIYUN" size="3" color="blueGreen">媒体查询 width/height 与 device-width/height</font></a></li>
</ul>
</li>
<li>mobile<ul>
<li><a href="#line9"> <font face="STCAIYUN" size="3" color="blueGreen">mobile 浏览器</font></a></li>
<li><a href="#line10"> <font face="STCAIYUN" size="3" color="blueGreen">两种 viewport</font></a><ul>
<li><font face="STCAIYUN" size="3" color="red">layoutviewport</font></li>
<li><font face="STCAIYUN" size="3" color="red">visualviewport</font></li>
</ul>
</li>
<li><a href="#line11"> <font face="STCAIYUN" size="3" color="blueGreen"> 缩放 Zooming</font></a></li>
<li><a href="#line12"> <font face="STCAIYUN" size="3" color="blueGreen"> 屏幕尺寸</font></a></li>
<li><a href="#line13"> <font face="STCAIYUN" size="3" color="blueGreen">页面的滚动移位</font></a></li>
<li><a href="#line14"> <font face="STCAIYUN" size="3" color="blueGreen"> html 元素以及度量 html</font></a></li>
<li> <a href="#line15"> <font face="STCAIYUN" size="3" color="blueGreen"> 关于事件坐标</font></a></li>
<li><a href="#line16"> <font face="STCAIYUN" size="3" color="blueGreen">媒体查询 width/height 与 device-width/height</font></a></li>
<li><a href="#line17"> <font face="STCAIYUN" size="3" color="blueGreen">viewport 的 meta 标签</font></a></li>
</ul>
</li>
</ul>
<p id="line1">
<font face="STCAIYUN" color="#883958" size="3">设备的 pixels 和 CSS 的 pixels</font>
</p>
**设备的pixels**
    设备像素是我们直觉上觉得「靠谱」的像素。这些像素为你所使用的各种设备都提供了正规的分辨率
    大多数情况下能从`screen.width/height` 取出具体值
    当然了 设备的pixels对web开发人员几乎毫无用处
    这里只需要知道它的概念即可
**CSS的pixels**
这些就是那些控制你的样式表如何被渲染的像素

<p>现代浏览器上的缩放是基于<code>伸展</code> pixels<br>所以 html 元素上的宽度不会因为你缩放了 200% 而变成了两倍宽，它在形式上还是一倍宽 只不过占用了两倍的设备 pixels<br>如下图 1-1 有 4 个 1pixels，缩放为 100% 的 html 元素 此时 css pixels 和设备的 pixels 完全重合<br><img src="/images/viewports/1.jpg"><br>此时我们如果缩小浏览器 css 的 pixels 开始收缩，导致 1 单位的设备 pixels 上重叠了多个 css 的 pixels 如下图 1-2<br><img src="/images/viewports/2.jpg"><br>如果放大浏览器 css 的 pixels 就会放大 导致 1 单位的 css pixels 上重叠了多个设备 pixels 如图 1-3<br><img src="/images/viewports/3.jpg"><br>总而言之 你只需要关注 CSS 的 pixels 这些 pixels 将指定你的样式被如何渲染<br>就像上面所说的 设备的 pixels 对开发人员无用 但是对用户有用，因为用户回手动缩放页面，这些开发人员不用关注 <font face="STCAIYUN" color="red" size="3">浏览器会自动保证你的 css pixels 会被伸展还是被收缩</font></p>
<p id="line2">
<font face="STCAIYUN" color="#883958" size="3">所谓的 100% 缩放</font>
</p>
<font face="STCAIYUN" color="red" size="3"> 100% 缩放的情况下 1 单位的的 CSS pixels 严格等于 1 单位的设备 pixels</font>
<p id="line3">
<font face="STCAIYUN" color="#883958" size="3"> 屏幕尺寸和浏览器尺寸</font>
</p>
**屏幕尺寸（Screen size）**
含义：用户的屏幕的完整大小
度量：设备的pixels 不会因为缩放而改变 是显示器的特征
对我们来说<font face="STCAIYUN" color="red" size="4">没用</font>
获取方式
如下图1-4
![](/images/viewports/4.jpg)

<p><strong>浏览器尺寸（Window size）</strong><br>含义：包含<code>滚动条尺寸</code>的浏览器完整尺寸<br>度量：CSS pixels<br>浏览器内部尺寸，它定义了当前用户有多大区域。可供你的 css 布局占用<br>如下图 1-5<br><img src="/images/viewports/5.jpg"></p>
<p id="line4">
<font face="STCAIYUN" color="#883958" size="3">页面的滚动移位</font>
</p>
含义：页面的移位
度量：CSS pixels
定义了页面（document）的相对于窗口远点的位移，可以利用这个特性获取用户滚动了多少的滚动条距离
如下图1-6
![](/images/viewports/6.jpg)

<p id="line5">
<font face="STCAIYUN" color="#883958" size="3"> viewport 以及度量 viewport</font>
</p>
**viewport**
啊啊啊 终于提到viewport了 鸡冻
<font face="STCAIYUN" color="red" size="3"> 划重点</font> `viewport`是控制``元素的容器  是``的爹

<p>你发现了么？<br>百分比布局时 你定义的一个侧边栏宽度为 10% 当你改变大小时 它的宽度会自动扩张和收缩  原理是啥<br>当然了 它的宽度是依赖父元素 假如它父元素就是 <code>&lt;body&gt;</code> 那么 <code>&lt;body&gt;</code> 多宽？<br>向上类推 <code>&lt;body&gt;</code> 的宽度取决于它的父元素 <code>&lt;html&gt;</code><br>呃.. 废话好多 <code>&lt;html&gt;</code> 宽度取决于它的父元素<br> <code>&lt;html&gt;</code> 恰好等于浏览器的宽度 所以你的 10% 会占用浏览器宽度的 10% 我们都是这么用的  今天深扒发现<br><code>&lt;html&gt;</code> 宽度受 <code>viewport</code> 限制 ，等于 <code>viewport</code> 宽度的 100%<br>也就是说<br><code>viewport</code> 严格等于浏览器窗口<br>需要注意的是：<code>viewport</code> 不是一个 html 的概念 所以不能通过 CSS 修改它</p>
<p><strong>真实页面宽度概念</strong><br>如果你放大页面几倍 如何标识页面宽度（此时已经有横向滚动条了，也就是说页面的内容溢出了 <code>&lt;html&gt;</code> 元素）<br>使用 document width<br>如图 1-7<br><img src="/images/viewports/7.jpg"><br>如图 1-8<br><img src="/images/viewports/8.jpg"><br><strong>度量 viewport</strong><br>含义：viewport 尺寸<br>度量：CSS pixels<br>如下图 1-9<br><img src="/images/viewports/9.jpg"><br>document.documentElement 代表<font face="STCAIYUN" color="red" size="3"> HTML 文档根元素</font><code>&lt;html&gt;</code><br>来 先看张图<br><img src="/images/viewports/10.jpg"><br>这张图是在为 <code>&lt;html&gt;</code> 元素赋值 25% 但是 <code>document.documentElement.clientWidth</code> 值仍然不变<br>说明<font face="STCAIYUN" color="red" size="3"> document. documentElement. clientWidth/Height 只会给出 viewport 的尺寸，而不管元素尺寸如何改变</font><br><font face="STCAIYUN" color="#886" size="4">那么问题来了</font><br>我是不是也可以用 <code>window.innerWidth</code> 来定义 <code>viewport</code><br>呃.<br>他与 <code>document.documentElement.clientWidth</code> 有一点细微的差别<br>前者不包含滚动条</p>
<p id="line6">
<font face="STCAIYUN" color="#883958" size="3">html 元素以及度量 html</font>
</p>
**html**
ta爹(`viewport`)如果`document.documentElement.clientWidth`表示那么``这样获取 `document.documentElement.offsetWidth`
![](/images/viewports/11.jpg)
如果给``元素赋值了宽度 那么`offsetWidth`就会真实的反映出来


<p><img src="/images/viewports/12.jpg"></p>
<p id="line7">
<font face="STCAIYUN" color="#883958" size="3"> 关于事件坐标</font>
</p>
**pageX/Y, clientX/Y, screenX/Y**

<ul>
<li> pageX/Y：从原点到事件触发点的 CSS 的 pixels</li>
<li>clientX/Y：从 viewport 原点（浏览器窗口）到事件触发点的 CSS 的 pixels</li>
<li>screenX/Y：从用户显示器窗口原点到事件触发点的设备 的 pixels。<br>上图<br><img src="/images/viewports/13.jpg"><br><img src="/images/viewports/14.jpg"><br><img src="/images/viewports/15.jpg"></li>
</ul>
<p id="line8">
<font face="STCAIYUN" color="#883958" size="3">媒体查询 width/height 与 device-width/height</font>
</p>
* `device-width/height`使用`screen.width/height`来做为的判定值。该值以设备的pixels来度量
* `width/height`使用`documentElement.clientWidth/Height`即viewport的值。该值以CSS的pixels来度量
![](/images/viewports/16.jpg)
桌面浏览器上使用<font face="STCAIYUN" color="red" size="4">width</font>
<p id="line9">
<font face="STCAIYUN" color="#883958" size="3">mobile 浏览器</font>
</p>
移动设备的屏幕宽度比桌面浏览器小（好多废话.）
试想一下 如果我们只是copy桌面的样式到移动设备 该有多丑
如下图
移动设备浏览器在初始默认打开以最小缩放模式打开网站。（即在手机屏幕上展示完整宽度的页面）

<p><img src="/images/viewports/viewport-21.jpg"></p>
<p><font face="STCAIYUN" color="#285853" size="3">假设当前设备的宽度是 400px 还是之前说过的 10% 侧边栏，如果移动设备上做同样的处理，会显示 40px 的宽 太窄了，布局会变得非常可怕</font><br>那么 如何处理？</p>
<p id="line10">
<font face="STCAIYUN" color="#883958" size="3">两种 viewport</font></p>
因为viewport太窄，最显然的解决方式就是将它变宽
由此 引出了 虚拟视口  （`viewportvisualviewport`） 与      布局视口（`viewportlayoutviewport`）
关于它们 有一个很好的解释

<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  想象一下viewportlayoutviewport是一张大的不能改变大小和角度的图片 现在你有个更小的框来观看这张大图片</span><br><span class="line">这个框被不透明的材料包围 因而你只能看到大图片的一部分 你通过这个框子看到的大图片的那部分就叫做虚拟视口（viewportvisualviewport）</span><br><span class="line"></span><br><span class="line">你拿着这个框拿着站的离大图原点（用户的缩小页面功能）以一次性看到这个大图片</span><br><span class="line">你站的离的近一点（用户的放大页面功能）以看到一部分</span><br><span class="line">你能改变这个框框的远近 但是这张大图片的大小和形状都不会改变</span><br></pre></td></tr></tbody></table></figure>
<p>visualviewport 是当前显示在屏幕上的部分页面。用户会滚动页面来改变可见部分，或者缩放浏览器来改变 visualviewport 的尺寸。<br>如下图<br><img src="/images/viewports/20.jpg"><br>但是 CSS 布局 通常是按照<font face="STCAIYUN" color="red" size="3"> layoutviewport 定义的，这要比 visualviewport 宽很多</font></p>
元素的宽度继承于layoutviewport
<p id="line11">
<font face="STCAIYUN" color="#883958" size="3">缩放 Zooming</font>
</p>
两种viewports都以CSS的 pixels来度量。当你通过缩放改变visualviewport时，layoutviewport保存不变。
<p id="line12">
<font face="STCAIYUN" color="#883958" size="3"> 屏幕尺寸</font>
</p>
**理解layout viewport**
许多移动设备浏览器在初始默认打开以最小缩放模式打开网站（也就是在手机屏幕上展示完整宽度的页面）

<p><img src="/images/viewports/21.jpg"><br>此时浏览器已经选择好他们的 layoutviewport 的尺寸 它完整覆盖了最小缩放模式下的移动浏览器的屏幕，这个时候 layoutviewport 的宽度高度和最小缩放模式下能在页面上显示的内容的宽度和高度一致。<br><br><br><font face="STCAIYUN" color="red" size="3">那么移动端如何计算 layoutviewport 的尺寸？</font><br><code>document. documentElement. clientWidth/Height</code></p>
<p><img src="/images/viewports/25.jpg"><br><strong>理解 visual viewport</strong><br><font face="STCAIYUN" color="red" size="3">那么移动端如何计算 visualviewport 的尺寸？</font><br><code>window.innerWidth/Height</code> 随着用户的缩放浏览器 值会改变 更多 更少的 CSS pixels 放进了屏幕<br><img src="/images/viewports/27.jpg"><br><strong>屏幕尺寸 screen</strong><br>和 pc 浏览器一样 screen.width/height 标示了设置屏幕的尺寸 以设备的 pixels 显然 这跟开发人员没有什么关系</p>
<p id="line13">
<font face="STCAIYUN" color="#883958" size="3">页面的滚动移位</font>
</p>
你同样需要知道当前的虚拟视口相对于布局视口的距离 这叫做`滚动位移` ，它像在pc端获取一样
使用**window.pageX/YOffset**

<p><img src="/images/viewports/29.jpg"></p>
<p id="line14">
<font face="STCAIYUN" color="#883958" size="3"> html 元素以及度量 html</font>
</p>
html元素的整体尺寸，和pc端一致 使用`document.documentElement.offsetWidth/Height`，元素以CSS pixels度量

<p><img src="/images/viewports/30.jpg"></p>
<p id="line15">
<font face="STCAIYUN" color="#883958" size="3"> 关于事件坐标</font>
</p>
同pc浏览器 只需要关注 pageX/Y

<p><img src="/images/viewports/32.jpg"></p>
<p id="line16">
<font face="STCAIYUN" color="#883958" size="3">媒体查询 width/height 与 device-width/height</font>
</p>
也如同pc浏览器
 `width/height `使用css的pixels度量layoutviewport 即`document. documentElement. clientWidth/Height `
`device-width/height  `使用设备的pixels 即 `screen.width/height. `
所有浏览器都遵循这个原理
<p id="line17">
<font face="STCAIYUN" color="#883958" size="3">viewport 的 meta 标签 </font>
</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name="viewport" content="width=320"&gt;</span><br></pre></td></tr></tbody></table></figure>
最初这是apple的一个html扩展标签，被很多浏览器复用
设置 `虚拟视口`的宽度

<p>假设你现在创建一个页面  并不为它设置宽度 那么它会伸展开来占据 100% 的 viewlayout 的宽度 绝大多数浏览器缩小这个页面在一屏的宽度上显示这个 layoutviewport</p>
<p><img src="/images/viewports/33.jpg"><br>当用户放大页面  绝大多数会保存元素的宽度（保持元素的定位不变）而导致文字超出屏幕<br><img src="/images/viewports/34.jpg"><br>当你设置</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name="viewport" content="width=320"&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>你网站的 layoutviewport 变成了 320px。页面的初始状态就很正确了<br><img src="/images/viewports/36.jpg"></p>
<ul>
<li>Part1:<a target="_blank" rel="noopener" href="http://www.quirksmode.org/mobile/viewports.html">http://www.quirksmode.org/mobile/viewports.html</a></li>
<li>Part2:<a target="_blank" rel="noopener" href="http://www.quirksmode.org/mobile/viewports2.html">http://www.quirksmode.org/mobile/viewports2.html</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://maying.ink/2017/07/31/%E8%AE%B0%E6%A2%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
      <meta itemprop="name" content="亦舒">
      <meta itemprop="description" content="知识带来自由，我等风也等你 🍂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亦舒的海角">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/07/31/%E8%AE%B0%E6%A2%A6/" class="post-title-link" itemprop="url">记梦一</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-07-31 00:00:00" itemprop="dateCreated datePublished" datetime="2017-07-31T00:00:00+08:00">2017-07-31</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-10-23 02:41:42" itemprop="dateModified" datetime="2020-10-23T02:41:42+08:00">2020-10-23</time>
      </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>838</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>此时此刻 ，反复思索着昨晚的梦，<font face="STCAIYUN" color="red" size="4">人生充满无奈，珍惜眼前人</font></p>
<p>具体的故事背景记不清了 大概是朋友的奶奶蹊跷去世了，我去她家安慰她并试图查事故原因，结果等我回去找他们的时候发现自己已经变成了<font face="STCAIYUN" color="red" size="4">隐形人</font> 其实就是已经死掉了，显然我自己也不知道自己发生了什么事情，事实就是我还在人间，就是我能看世人，世人再也看不到我了</p>
<p>第一反应是：  <font face="STCAIYUN" color="red" size="4">我要回家</font><br>我不知道他们是怎么处理世间的我，我只知道我的灵魂回家了<br>我也记不清爸妈是否知不知道我已经不在了，我用力的跟他们讲话 只可惜他们大大小小全都对我视而不见，我来不及思考 依然用力呼唤他们，追着拉着，全都没有用， <font face="STCAIYUN" color="yellow" size="3">我好无力…</font></p>
<p>想到多年前看过一部日本的温情电影，讲的也是主人公意外身故 化身隐形人回家，发现自己没办法让家人注意到也是很痛苦 不过电影就是电影 有一个巫婆是阴阳眼 成了 家人跟 “隐形人” 沟通的桥梁，必要的时候还会帮助家人度过难关  影片最后是巫婆帮助隐形人附身于自己身上，与妻子做最后的告别，最后安稳投胎<br>印象中这才是鬼魂的正确打开方式 国产剧中的鬼魂仿佛都很厉害的样子，有仇报仇，有冤报冤，一言不合就施法 也是～</p>
<p>我当时想起来银行账户还有钱 就想给他们转过去，但是负责管我的警察，暂且叫他 <font face="STCAIYUN" color="red" size="4">灵魂摆渡人</font> （404 号便利店), 对耶 我为什么没去 404 号便利店找夏冬青帮我实现愿望，大概我遇见的是赵吏 笑 cry 他说 我可以往人间账户汇款，就是有损耗 1W 只能到账 1k 这尼玛是跨行手续费吗😢</p>
<p>不记得最后是咋解决的， 反正世界就再也没有我了，就算再挣扎<br>我开始回忆一生，那些活过的平淡日子，能记起来的只有桩桩件件的遗憾</p>
<p>我还没有孝顺父母</p>
<p>上次电话里没有喊一嗓子 爸妈我爱你</p>
<p>我应该再回一次家的</p>
<p>想在老家给爹妈买房子的钱还没存够</p>
<p>家庭旅行的计划家门口还没出</p>
<p>想起来这些碎碎念</p>
<p>突然我就开始怀念了</p>
<p>我想，如果我在世的时候能有这些危机感 现在也不会有这么多遗憾了</p>
<p>私人一点的是</p>
<p>恋爱记有这么多点滴 另一半还没添加<br>这世上 除了爸妈亲人 连个记挂我的人都没有</p>
<p>好悲哀</p>
<p>早上被闹钟叫醒 发现自己还活着</p>
<p>感谢上帝 有些事只有失去过才知道 我拥有的还很多</p>
<p>致每一个空虚的你</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://maying.ink/2017/07/22/%E4%BB%8E%E4%B8%8D%E8%A7%84%E8%8C%83%E5%9B%A2%E9%98%9F%E7%9C%8B%E6%95%88%E7%8E%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
      <meta itemprop="name" content="亦舒">
      <meta itemprop="description" content="知识带来自由，我等风也等你 🍂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亦舒的海角">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/07/22/%E4%BB%8E%E4%B8%8D%E8%A7%84%E8%8C%83%E5%9B%A2%E9%98%9F%E7%9C%8B%E6%95%88%E7%8E%87/" class="post-title-link" itemprop="url">从不规范生产套路看效率</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-07-22 00:00:00" itemprop="dateCreated datePublished" datetime="2017-07-22T00:00:00+08:00">2017-07-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-10-23 02:41:42" itemprop="dateModified" datetime="2020-10-23T02:41:42+08:00">2020-10-23</time>
      </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>标题好像是句废话，” 不规范” 何谈 <font face="STCAIYUN" color="red" size="5">效率</font> 呢？</p>
<p><img src="http://oucjferwh.bkt.clouddn.com/wunai.jpg"></p>
<ol>
<li> <font face="STCAIYUN" color="#83933b" size="4">何为效率</font></li>
<li> <font face="STCAIYUN" color="#83933b" size="4">从产品看效率</font></li>
<li> <font face="STCAIYUN" color="#83933b" size="4">从 UI 看效率</font></li>
<li> <font face="STCAIYUN" color="#83933b" size="4">从开发看效率</font></li>
<li> <font face="STCAIYUN" color="#83933b" size="4">从测试看效率 </font></li>
</ol>
<p><strong>何为效率？</strong></p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%88%E7%8E%87/868847?fr=aladdin">百度百科</a>上大概是这么定义的：是指在给定投入和技术等条件下，<font face="STCAIYUN" color="red" size="4">最有效地</font>使用资源以满足设定的愿望和需要的评价方式</p>
<p>对我来说最直观的判断方式就是  <font face="STCAIYUN" color="red" size="4">项目是否有延期 线上是否有 bug</font></p>
<ul>
<li><p><font face="STCAIYUN" color="darkorange" size="4">效率有多重要？</font></p>
<p>大部分的电子厂工资都是按件计费的，多劳多得，单位时间产出与收入能正比，所以工人们都非常努力 这是自发性行为 所以也是最任怨的。</p>
<p>对我而言 效率能带来好心情 好状态以及好的生活态 废话 大家都一样 –  </p>
</li>
</ul>
<p><strong>从产品看效率</strong><br>一款产品的成功与否 有多方便的决定因素 产品最终都是面向用户的 一个不能为用户创造价值的产品应该是没有使用价值的，产品本就是提升效率的一种方式</p>
<p>那么 接下来  我要开始吐槽了</p>
<p><font face="STCAIYUN" color="darkorange" size="4">如果产品需求不明确或者需求不完整  项目要不要开始做？</font><br>一般来说 不要 绝对不要 除非是两个完全不相干的模块 昂 基本也不太可能<br>但是尼 为了所谓的工期 产品大大一般会这么说  做呗  先做着  我这么单（wu）纯（nai）的 每次都被套路住🤡 然后后来计算工时的时候 ： 哦 你不是从那个什么什么时候就开始了吗？👐🏽<br>这还不是最主要的，毕竟 时间就像海绵里的水 挤一挤总会有的😂</p>
<p>最主要的当然是<font face="STCAIYUN" color="red" size="4">改需求</font>啦 这大概是所有产品最擅长的</p>
<p>这两者本质上是没有矛盾的，只不过产品更多的以目标为导向，需求只是手段，而对开发来说 技术是手段 需求是目标 只不过产品更容易主观，比如需求，比如说功能，比如说交互，这些都受到个人经验，眼界，学识很大影响。朝三暮四，朝令夕改，是常有的事情。</p>
<p><strong>说真的</strong><br>产品的功能、质量、发布时间和需要投入的资源这四者不能都是封闭条件，否则可能无解</p>
<p>而且现在的产品很是聪明啊 需求给了，开始做了，做到最后发现这种情况下不是很合理，简单啊 改呗 反正做到这里我逻辑也捋清楚了，也知道该咋办了<font face="STCAIYUN" color="#83933b" size="3">产品默想到</font></p>
<p>呃.. 这两天刚遇到个类似的情况 哦 不好意思，是<font face="STCAIYUN" color="red" size="5">经常遇到</font>，提测一周也测了<font face="STCAIYUN" color="red" size="5">一周</font>了，代码上体验版（预上线）了</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">产品：咦？这块不是那样儿的吗？怎么是这样的？</span><br><span class="line"></span><br><span class="line">开发：？ 前两天不是专门讨论过这个问题吗，这个就是这样儿的！</span><br><span class="line"></span><br><span class="line">产品：哦？是吗？ 但是这样儿看起来好诡异啊！就应该是那样儿的 改一下吧</span><br><span class="line"></span><br><span class="line">开发：...当初接口设计的就是这样儿的，怎么不早说？这都要上线啦！😩</span><br><span class="line"></span><br><span class="line">产品："之前流程没走通 不太清楚这块儿的逻辑，现在改一下吧" 然后就走了</span><br><span class="line"></span><br><span class="line">开发：...</span><br></pre></td></tr></tbody></table></figure>

<p>还有就是<strong>排期</strong></p>
<p>产品经常这么一句话：因为我们的上线时间是 XX 号 测试需要 XX 天 所以 开发排下期吧 ？</p>
<p>…..</p>
<p>排完期之后..</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">产品：昂昂，你这儿不行啊 时间太长了 能不能缩短点</span><br><span class="line"></span><br><span class="line">开发：我按工时算的 每一项 都列出来了 不会差太多</span><br><span class="line"></span><br><span class="line">产品：这不行啊 因为我们要XX提审 测试需要XX天 所以你必须 XX天提测</span><br><span class="line"></span><br><span class="line">开发：这等于 XX 天的工期 你给我压到 XX／2 天</span><br><span class="line"></span><br><span class="line">产品：嘿嘿😉</span><br><span class="line"></span><br><span class="line">开发：...</span><br><span class="line"></span><br><span class="line">开发OS："赶紧开发 为了给测试腾时间😂😭🙈，尼萌给开发时间充足了 问题自然就会少很多好吗 测试好像是最重要的噻"</span><br></pre></td></tr></tbody></table></figure>


<p>百度过类似的问题 最好的办法<font face="STCAIYUN" color="red" size="3">是让产品也学会基础的编程，了解每一个实现都是需要耗费资源的，这样才能基于对有限资源的理解，做出更谨慎的规划。</font><br><font face="STCAIYUN" color="#83933b" size="3">然而，这基本不可能，所以..</font></p>
<p>实际上 那些<font face="STCAIYUN" color="#83933b" size="4">非常紧急</font>的需求，这么一搞成了拖延的第一个关键点<br><br></p>
<p><img src="http://oucjferwh.bkt.clouddn.com/tuxie.jpeg" alt="tuxie"></p>
<p><strong>从 UI 看效率</strong></p>
<p>呃。对于用户来说 一个产品能不能吸引到你，最浅显也最重要的是<font face="STCAIYUN" color="red" size="5">眼缘</font>，说俗气点就是颜值<br>而且 UI 链接 产品与开发 自然也是马虎不得的 深刻理解原型的精髓 然后利用智慧的小脑瓜设计成用户想要的样子，上面说了 他们最重要的工作是 <font face="STCAIYUN" color="red" size="5">深刻理解原型的精髓</font>，因为 对于<font face="STCAIYUN" color="#83933b" size="4">美</font>，设计师总是有不一样的定义，就比如 <font face="STCAIYUN" color="gold" size="4">情人眼里出西施</font></p>
<p>非常不幸 我们 UI 也是必须要吐槽的对象</p>
<p>直接上日常</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">开发：设计小哥，对比原型 是不是缺了一张图</span><br><span class="line"></span><br><span class="line">设计：？</span><br><span class="line"></span><br><span class="line">开发：搜索中状态</span><br><span class="line"></span><br><span class="line">设计：沉默</span><br><span class="line"></span><br><span class="line">产品：哦 那个不就是在未搜索的状态基础上把导航去掉吗？还用出图吗？</span><br><span class="line"></span><br><span class="line">一分钟后～～</span><br><span class="line"></span><br><span class="line">设计：突然扔出来一张图  @开发:好了</span><br><span class="line"></span><br><span class="line">开发：瞅了一眼 @设计：嗯 ？不是这样儿的吧</span><br><span class="line"></span><br><span class="line">设计：？</span><br><span class="line"></span><br><span class="line">开发：把产品的话 @设计：“哦 那个不就是在未搜索的状态基础上把导航去掉吗？还用出图吗？”</span><br><span class="line"></span><br><span class="line">设计：沉默</span><br><span class="line"></span><br><span class="line">两分钟后～～</span><br><span class="line"></span><br><span class="line">设计：扔出来一张图 呐 上传了</span><br><span class="line"></span><br><span class="line">开发：嗯 现在才是对的</span><br><span class="line"></span><br><span class="line">设计：嗯</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>类似的事情简直日常</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">上午～</span><br><span class="line"></span><br><span class="line">产品：今天周五 需要把UI提的问题都改完</span><br><span class="line"></span><br><span class="line">开发：ok</span><br><span class="line"></span><br><span class="line">设计：ok</span><br><span class="line"></span><br><span class="line">下午～</span><br><span class="line"></span><br><span class="line">开发：什么时候有空，当面改</span><br><span class="line"></span><br><span class="line">设计：嗯</span><br><span class="line"></span><br><span class="line">下午四点～</span><br><span class="line"></span><br><span class="line">开发：什么时候有空</span><br><span class="line"></span><br><span class="line">设计：现在过去</span><br><span class="line"></span><br><span class="line">开发：嗯</span><br><span class="line"></span><br><span class="line">改了大概有两个之后 设计被叫走</span><br><span class="line"></span><br><span class="line">又过了一个小时～</span><br><span class="line"></span><br><span class="line">开发：快下班了 啥时候改尼</span><br><span class="line"></span><br><span class="line">设计：今天比较忙 现在可以开始了</span><br><span class="line"></span><br><span class="line">开发： 嗯？我看了一下 你拿到的不是最新版吧 好些问题现在不能复现了</span><br><span class="line"></span><br><span class="line">设计：哦</span><br><span class="line"></span><br><span class="line">一个小时之后</span><br><span class="line"></span><br><span class="line">开发：改完了 我下班了啊 今天有点事儿</span><br><span class="line"></span><br><span class="line">设计：嗯 好的 下班吧</span><br><span class="line"></span><br><span class="line">开发 走了</span><br><span class="line"></span><br><span class="line">两个小时后 忙完 开发都到家了～～</span><br><span class="line"></span><br><span class="line">产品：@开发：在哪里呢 啥时候回来</span><br><span class="line"></span><br><span class="line">开发：？我到家了啊</span><br><span class="line"></span><br><span class="line">产品：你咋走了？设计小哥还在等你呢</span><br><span class="line"></span><br><span class="line">开发：？我走的时候跟他说了啊 他知道啊</span><br><span class="line"></span><br><span class="line">产品：我不是说了今天要改完吗 设计review了 还有一点问题</span><br><span class="line"></span><br><span class="line">开发：... 那我明天去加班吧</span><br><span class="line"></span><br><span class="line">第二天，到公司之后</span><br><span class="line"></span><br><span class="line">开发：在群里@设计@产品 ：这个只有截图看不出来哪有问题噻</span><br><span class="line"></span><br><span class="line">设计：沉默</span><br><span class="line"></span><br><span class="line">产品：沉默</span><br><span class="line"></span><br><span class="line">开发：...</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>




<p><strong>从开发看效率</strong></p>
<p>开发效率无疑存在于两方面</p>
<p>强健的框架支撑与准确的拆分估期</p>
<p>一般情况下是不会延期的 也算是这几个环节当中最可控的</p>
<p><strong>从测试看效率</strong></p>
<p>你理解一个开发只用了一天的功能测试测了四天的心情吗</p>
<p>你理解一个开发用了一周 测试用了 9 个工作日的心痛吗</p>
<p>🙊</p>
<p>结语：💊</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://maying.ink/2017/07/19/%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
      <meta itemprop="name" content="亦舒">
      <meta itemprop="description" content="知识带来自由，我等风也等你 🍂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亦舒的海角">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/07/19/%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">微信小程序开发常见问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-07-19 00:00:00" itemprop="dateCreated datePublished" datetime="2017-07-19T00:00:00+08:00">2017-07-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-10-23 02:41:42" itemprop="dateModified" datetime="2020-10-23T02:41:42+08:00">2020-10-23</time>
      </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="场景一：首页增加下拉刷新功能无效？"><a href="#场景一：首页增加下拉刷新功能无效？" class="headerlink" title="场景一：首页增加下拉刷新功能无效？"></a>场景一：首页增加下拉刷新功能无效？</h2><p>经过各种尝试 问题定位到了是因为 在 <code>scroll-view</code> 中使用了 <code>onPullDownRefresh</code>，最后通过改首页的代码结构达到了预期结果</p>
<p>结论：<font face="STCAIYUN" color="#83933b" size="3"><br>在滚动 scroll-view 时会阻止页面回弹，所以在 scroll-view 中滚动，是无法触发 onPullDownRefresh</font></p>
<p>如果非要在 <code>scroll-view</code> 使用下拉刷新，<font face="STCAIYUN" color="#83933b" size="3">官方给出的解决方案</font>是监听页面的滚动事件 <code>bindscroll</code>  厄.. 也是一种方法 只不过我的更粗鲁一些</p>
<p><strong>其他需要注意的：</strong></p>
<ul>
<li>不要在 <code>scroll-view</code> 中使用 <code>textarea</code>、<code>map</code>、<code>canvas</code>、<code>video</code> 组件</li>
<li>目前只验证过 <code>textarea</code> 暂且放到场景二吧</li>
<li><code>scroll-into-view</code> 的优先级高于 <code>scroll-top</code></li>
</ul>
<h2 id="场景二：无法在-scroll-view中使用textarea？"><a href="#场景二：无法在-scroll-view中使用textarea？" class="headerlink" title="场景二：无法在 scroll-view中使用textarea？"></a>场景二：无法在 scroll-view 中使用 textarea？</h2><p><font face="STCAIYUN" color="red" size="3">这是个只有在真机上才会出现的 bug</font></p>
<p>刚开始以为是不能在某些特定的组件内使用<code>textarea</code> 几番尝试 发现是因为 <code>textarea</code>组件与其他组件的层级关系 后来发现 <font face="STCAIYUN" color="#83933b" size="3">文档在最下方用最小号的字体给标注出来了已经！</font><font face="STCAIYUN" color="red" size="3">吐血</font></p>
<p>结论：<font face="STCAIYUN" color="#83933b" size="3"><br><code>textarea</code>组件是由客户端创建的原生组件，他的层级是最高的，在实际项目中 要保证本页面中 无 </font><font face="STCAIYUN" color="red" size="3">弹层</font>之类一切可能会覆盖到页面的鬼。<br></p>
<p><strong>其他需要注意的：</strong></p>
<ul>
<li>不要在 <code>scroll-view</code> 中使用 <code>textarea</code> 组件。</li>
<li>css 动画对 textarea 组件无效</li>
<li> textarea 的 <code>blur</code> 事件会晚于页面上的 tap 事件，如果需要在 button 的点击事件获取 textarea，可以使用 <code>form</code> 的 bindsubmit。</li>
<li>官方遗留 bug: <code>textarea</code> 在列表渲染时，新增加的 textarea 在自动聚焦时的位置计算错误。<h2 id="场景三：textarea的placeholder不固定的问题"><a href="#场景三：textarea的placeholder不固定的问题" class="headerlink" title="场景三：textarea的placeholder不固定的问题"></a>场景三：textarea 的 placeholder 不固定的问题</h2></li>
</ul>
<p>当把<code>textarea</code>放到一个<code> position：fixed</code> 中的元素中时，会发现这个<code>textarea</code>也会跟着固定位置，但是<code>textarea</code>的 placeholder 内容不会固定，当滚动页面时，placeholder 的内容会跟着滚动</p>
<p>解决方式：<font face="STCAIYUN" color="red" size="3">给<code>textarea</code>组件增加属性 fixed<br></font></p>
<p>结论：<font face="STCAIYUN" color="#83933b" size="3">踩坑大法好</font></p>
<h2 id="场景四：微信小程序的兼容问题"><a href="#场景四：微信小程序的兼容问题" class="headerlink" title="场景四：微信小程序的兼容问题"></a>场景四：微信小程序的兼容问题</h2><p><code>wx.request()</code> 返回的状态码 <code>res.statusCode</code> 的值 在 IOS 下是<font face="STCAIYUN" color="red" size="3"> init</font> 型的数据 但是在 Android 6.0.1 上却是 <font face="STCAIYUN" color="red" size="3">String</font> 型数据<br>要特别注意判断状态码的方式</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">X</span><br><span class="line">wx.request({</span><br><span class="line">    url: 'http://api.example.com',</span><br><span class="line">    success: function (res) {</span><br><span class="line">        if (res.statusCode === 200) {</span><br><span class="line">            // success</span><br><span class="line">        } else {</span><br><span class="line">            // server failure</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">})</span><br><span class="line">像这样使用 === 就错了 不要判断类型</span><br><span class="line">使用 ==即可</span><br></pre></td></tr></tbody></table></figure>

<p>小程序的 WXML 没有 HTML 的宽容度​那么高，单标签必需是 /&gt; 结尾的 不然会报错。</p>
<h2 id="场景五：小程序版本的兼容问题"><a href="#场景五：小程序版本的兼容问题" class="headerlink" title="场景五：小程序版本的兼容问题"></a>场景五：小程序版本的兼容问题</h2><p>无论用哪个组件 必须时刻注意当前兼容的版本 做低版本兼容</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> wx.openBluetoothAdapter()</span><br><span class="line">} else {</span><br><span class="line">  // 如果希望用户在最新版本的客户端上体验您的小程序，可以这样子提示</span><br><span class="line">  wx.showModal({</span><br><span class="line">    title: '提示',</span><br><span class="line">    content: '当前微信版本过低，无法使用该功能，请升级到最新微信版本后重试。'</span><br><span class="line">  })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>Fundebug</code> 能够实时监测小程序，捕获小程序 Bug，然后反馈给开发者<br><a target="_blank" rel="noopener" href="https://fundebug.com/">Fundebug</a></p>
<h2 id="场景六：小程序版本的兼容问题"><a href="#场景六：小程序版本的兼容问题" class="headerlink" title="场景六：小程序版本的兼容问题"></a>场景六：小程序版本的兼容问题</h2><p>绑定事件的时候，当两个方法重名时，后面的方法会覆盖前面的方法，并且 IDE 不报错</p>
<h2 id="场景七：image"><a href="#场景七：image" class="headerlink" title="场景七：image"></a>场景七：image</h2><p>小程序的 image 与 HTML5 的 img 最大的区别在于：<br>小程序的 image 是按照 <code>background-image</code> 来实现的。<br>默认 image 的高宽是 320*240。必须通过样式定义去覆盖这个默认高宽，auto 在这里不生效。<br><font face="STCAIYUN" color="red" size="3">开发者说这样设置的原因是：如果设置 auto ，页面布局会因为图片加载的过程有一个闪的现象（例如高度从 0 到 height ），所以要求一定要设置一个宽度和高度。</font></p>
<p>图片包括三种缩放模式 scaleToFill、aspectFit、aspectFill 和 9 种裁剪模式，三种缩放模式的实现原理对应如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">scaleToFill{</span><br><span class="line"></span><br><span class="line">background-size:100% 100%;//不保持纵横比缩放图片，使图片的宽高完全拉伸至填满 image 元素</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">aspectFit{</span><br><span class="line"></span><br><span class="line">background-size:contain;//保持纵横比缩放图片，使图片的长边能完全显示出来。也就是说，可以完整地将图片显示出来。</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">aspectFill{</span><br><span class="line"></span><br><span class="line">background-size:cover;//保持纵横比缩放图片，只保证图片的短边能完全显示出来。也就是说，图片通常只在水平或垂直方向是完整的，另一个方向将会发生截取。</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>


<h2 id="场景八：navigator"><a href="#场景八：navigator" class="headerlink" title="场景八：navigator"></a>场景八：navigator</h2><p>navigator 支持相对路径和绝对路径的跳转，默认是打开新页面，当前页面打开需要加 redirect；<br>navigator 仅支持<font face="STCAIYUN" color="red" size="3"> 5 级</font>页面的跳转；<br>navigator 不可跳转到小程序外的链接地址；</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;navigator class="navigator" redirect  url="../login/index" &gt;登录页&lt;/navigator&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>在小程序开发工具里，默认打开新页面，工具左上角有返回按钮。加上 redirect，当前页打开，不出现返回按钮。</p>
<h2 id="场景八：大胆使用flex布局"><a href="#场景八：大胆使用flex布局" class="headerlink" title="场景八：大胆使用flex布局"></a>场景八：大胆使用 flex 布局</h2><p>在做传统 H5 的时候，为了兼容各种低端设备的机型，通常不太敢轻易尝试 flex，但在小程序里就可以大胆的使用了。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.media {</span><br><span class="line"></span><br><span class="line">display: flex;</span><br><span class="line"></span><br><span class="line">justify-content:center;</span><br><span class="line">align-items:center;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">.media .content {</span><br><span class="line"></span><br><span class="line">flex: 1;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="场景八：大胆使用flex布局-1"><a href="#场景八：大胆使用flex布局-1" class="headerlink" title="场景八：大胆使用flex布局"></a>场景八：大胆使用 flex 布局</h2><p>在做传统 H5 的时候，为了兼容各种低端设备的机型，通常不太敢轻易尝试 flex，但在小程序里就可以大胆的使用了。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.media {</span><br><span class="line"></span><br><span class="line">display: flex;</span><br><span class="line"></span><br><span class="line">justify-content:center;</span><br><span class="line">align-items:center;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">.media .content {</span><br><span class="line"></span><br><span class="line">flex: 1;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="场景八：页面最后一个-view-组件-设置margin-bottom属性-IOS-机型-失效的问题"><a href="#场景八：页面最后一个-view-组件-设置margin-bottom属性-IOS-机型-失效的问题" class="headerlink" title="场景八：页面最后一个 view 组件 设置margin-bottom属性 IOS 机型 失效的问题"></a>场景八：页面最后一个 view 组件 设置 margin-bottom 属性 IOS 机型 失效的问题</h2><p>解决方式：<font face="STCAIYUN" color="red" size="3">当前 view 当前组件下加一个同级 view<br></font></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">wxml</span><br><span class="line">    &lt;view&gt;这是个按钮&lt;/view&gt;</span><br><span class="line">    &lt;view class="marginB"&gt;&lt;/view&gt;</span><br><span class="line"></span><br><span class="line">    css</span><br><span class="line"></span><br><span class="line">    .marginB{</span><br><span class="line">        	height: 0rpx;</span><br><span class="line">        	font-size: 0rpx;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>


<h2 id="场景九：实现长按保存图片-短按图片隐藏"><a href="#场景九：实现长按保存图片-短按图片隐藏" class="headerlink" title="场景九：实现长按保存图片 短按图片隐藏"></a>场景九：实现长按保存图片 短按图片隐藏</h2><p>现有问题  用户体验不佳 长按需要抬起才能弹出 <code>sheetAction</code> 菜单</p>
<p>理想状态下是长按开始计时 350 秒之后自动弹操作菜单</p>
<p>利用 <code>bindtouchstart</code> 与 <code>bindtouchend</code> 事件结合 <code>bindtap</code> 实现</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">问题代码一</span><br><span class="line"></span><br><span class="line">WXML</span><br><span class="line"></span><br><span class="line">&lt;view  bindtouchstart="mytouchstart" bindtouchend="mytouchend" bindtap="editAddress" &gt;</span><br><span class="line"></span><br><span class="line">JS</span><br><span class="line"></span><br><span class="line">editAddress: function (event) {  </span><br><span class="line">   let that = this;  </span><br><span class="line">   //触摸时间距离页面打开的毫秒数  </span><br><span class="line">   var touchTime = that.data.touch_end - that.data.touch_start;  </span><br><span class="line">   console.log(touchTime);  </span><br><span class="line">   //如果按下时间大于350为长按  </span><br><span class="line">   if (touchTime &gt; 350) {</span><br><span class="line"></span><br><span class="line">    //TODO..</span><br><span class="line"></span><br><span class="line">   } else {  </span><br><span class="line"></span><br><span class="line">    //TODO..</span><br><span class="line"></span><br><span class="line">   }  </span><br><span class="line"> },  </span><br><span class="line"> //按下事件开始  </span><br><span class="line"> mytouchstart: function (e) {  </span><br><span class="line">   let that = this;  </span><br><span class="line">   that.setData({  </span><br><span class="line">     touch_start: e.timeStamp  </span><br><span class="line">   })  </span><br><span class="line">   console.log(e.timeStamp + '- touch-start')  </span><br><span class="line"> },  </span><br><span class="line"> //按下事件结束  </span><br><span class="line"> mytouchend: function (e) {  </span><br><span class="line">   let that = this;  </span><br><span class="line">   that.setData({  </span><br><span class="line">     touch_end: e.timeStamp  </span><br><span class="line">   })  </span><br><span class="line">   console.log(e.timeStamp + '- touch-end')  </span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>改进</p>
<p>小程序的事件触发顺序</p>
<p>单击 touchstart → touchend → tap<br>双击 touchstart → touchend → tap → touchstart → touchend → tap<br>长按 touchstart → longtap → touchend → tap</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">问题代码二</span><br><span class="line"></span><br><span class="line">wxml</span><br><span class="line"></span><br><span class="line">&lt;view  bindlongtap="longPress"   bindtap="tapFun" style="width: 100%;height:100%" mode="scaleToFill" src="{{img_url}}"&gt;&lt;/view&gt;</span><br><span class="line"></span><br><span class="line">js</span><br><span class="line"></span><br><span class="line">longPress(e){</span><br><span class="line">  var that = this;</span><br><span class="line">  console.log('你点击了长按时间',e)</span><br><span class="line">  // 可以通过 wx.getSetting 先查询一下用户是否授权了 "scope.record" 这个 scope</span><br><span class="line">  wx.getSetting({</span><br><span class="line">      success(res) {</span><br><span class="line">        console.log('222222222222222222')</span><br><span class="line">          if (!res['scope.writePhotosAlbum']) {</span><br><span class="line">              wx.authorize({</span><br><span class="line">                  scope: 'scope.writePhotosAlbum',</span><br><span class="line">                  success() {</span><br><span class="line">                   //  调起操作菜单</span><br><span class="line">                   console.log('33333333333333333333')</span><br><span class="line">                   console.log('wx.showActionSheet()',wx.showActionSheet)</span><br><span class="line">                    wx.showActionSheet({</span><br><span class="line">                         itemList: ['保存到本地'],</span><br><span class="line">                         success: function(res) {</span><br><span class="line">                           console.log('操作菜单弹出成功','第'+res.tapIndex+'个操作菜单弹出成功')</span><br><span class="line">                           // 下载文件资源到本地。客户端直接发起一个 HTTP GET 请求，返回文件的本地临时路径。</span><br><span class="line">                         if(res.tapIndex ==0){</span><br><span class="line">                          console.log('wx.downloadFile',wx.downloadFile)</span><br><span class="line">                           wx.downloadFile({</span><br><span class="line">                           url: that.data.img_url, //仅为示例，并非真实的资源</span><br><span class="line">                           success: function(res) {</span><br><span class="line">                             wx.playVoice({</span><br><span class="line">                               filePath: res.tempFilePath</span><br><span class="line">                             });</span><br><span class="line">                             console.log('wx.playVoice()',wx.playVoice)</span><br><span class="line">                             console.log('将图片先保存到本地--res.tempFilePath',res.tempFilePath);</span><br><span class="line">                                     // 用户已经同意小程序使用功能，后续调用 wx.startRecord 接口不会弹窗询问</span><br><span class="line">                                     console.log('wx.saveImageToPhotosAlbum()',wx.saveImageToPhotosAlbum)</span><br><span class="line">                                     wx.saveImageToPhotosAlbum({</span><br><span class="line">                                       filePath:res.tempFilePath,</span><br><span class="line">                                       success(res) {</span><br><span class="line">                                         wx.showToast({</span><br><span class="line">                                         title: '保存成功',</span><br><span class="line">                                         icon: 'success'</span><br><span class="line">                                       });</span><br><span class="line">                                       setTimeout(function(){</span><br><span class="line">                                         wx.hideToast();</span><br><span class="line">                                       },3000)</span><br><span class="line">                                       },</span><br><span class="line">                                       fail(res){</span><br><span class="line">                                         wx.showToast({</span><br><span class="line">                                         title: '保存失败',</span><br><span class="line">                                         icon: 'success'</span><br><span class="line">                                       });</span><br><span class="line">                                       setTimeout(function(){</span><br><span class="line">                                         wx.hideToast();</span><br><span class="line">                                       },3000)</span><br><span class="line">                                       }</span><br><span class="line">                                   })</span><br><span class="line"></span><br><span class="line">                           }</span><br><span class="line">                         })</span><br><span class="line">                         }</span><br><span class="line">                         },</span><br><span class="line">                         fail: function(res) {</span><br><span class="line">                           console.log('操作菜单弹出失败',res.tapIndex)</span><br><span class="line">                         }</span><br><span class="line">               })</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                  }</span><br><span class="line">              })</span><br><span class="line">          }</span><br><span class="line">      }</span><br><span class="line">  })</span><br><span class="line">},</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tapFun: function(event) {</span><br><span class="line">        that.setData({</span><br><span class="line">        qrShow:false</span><br><span class="line">        })</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">很显然 这也是有问题的</span><br><span class="line"></span><br><span class="line">因为事件机制。总会触发 tap事件 表现形式比 问题一还难以接受</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>好了，结合前两种 解决办法如下</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">WXml</span><br><span class="line"></span><br><span class="line"> &lt;image  wx:if="{{img_url !=''}}"  bindlongtap="editAddress1"   bindtouchstart="mytouchstart" bindtouchend="mytouchend"  style="width: 100%;height:100%" mode="scaleToFill" src="{{img_url}}"&gt;&lt;/image&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">js</span><br><span class="line"></span><br><span class="line">//按下事件开始</span><br><span class="line">mytouchstart:function(e){</span><br><span class="line">  let that = this;</span><br><span class="line">  that.setData({</span><br><span class="line">    touch_start: e.timeStamp</span><br><span class="line">  })</span><br><span class="line">  console.log(e.timeStamp + '- touch-start')</span><br><span class="line">},</span><br><span class="line"></span><br><span class="line">//按下事件结束</span><br><span class="line">mytouchend:function(e){</span><br><span class="line">  let that = this;</span><br><span class="line">  that.setData({</span><br><span class="line">    touch_end: e.timeStamp</span><br><span class="line">  })</span><br><span class="line">  console.log(e.timeStamp + '- touch-end')</span><br><span class="line">  that.editAddress(e);</span><br><span class="line">},</span><br><span class="line"></span><br><span class="line">// 判断是长按操作还是短按操作</span><br><span class="line">editAddress: function(event) {</span><br><span class="line">      var that = this;</span><br><span class="line">      if(that.data.touch_end - that.data.touch_start &lt; 350){</span><br><span class="line">        that.setData({</span><br><span class="line">        qrShow:false</span><br><span class="line">        })</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">},</span><br><span class="line"></span><br><span class="line">editAddress1(e){}   // 同问题二  longPress（）</span><br></pre></td></tr></tbody></table></figure>
<h2 id="场景十：第二次扫码进入小程序的缓存问题"><a href="#场景十：第二次扫码进入小程序的缓存问题" class="headerlink" title="场景十：第二次扫码进入小程序的缓存问题"></a>场景十：第二次扫码进入小程序的缓存问题</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://maying.ink/2017/07/19/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%20%E5%88%9D%E8%A7%81%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
      <meta itemprop="name" content="亦舒">
      <meta itemprop="description" content="知识带来自由，我等风也等你 🍂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亦舒的海角">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/07/19/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%20%E5%88%9D%E8%A7%81%E7%AF%87/" class="post-title-link" itemprop="url">微信小程序 初见篇</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-07-19 00:00:00" itemprop="dateCreated datePublished" datetime="2017-07-19T00:00:00+08:00">2017-07-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-10-23 02:41:42" itemprop="dateModified" datetime="2020-10-23T02:41:42+08:00">2020-10-23</time>
      </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li><p><strong>题外话</strong></p>
<ul>
<li><a href="#line6"> <font face="STCAIYUN" size="3">关于微信小程序</font></a></li>
<li><a href="#line5"> <font face="STCAIYUN" size="3">小程序与传统 HTML5 的区别</font></a></li>
</ul>
</li>
<li><p><strong>框架</strong></p>
<ul>
<li><a href="#line1"> <font face="STCAIYUN" size="3">目录结构与配置</font></a></li>
<li><a href="#line2"> <font face="STCAIYUN" size="3">逻辑层</font></a></li>
<li><a href="#line3"> <font face="STCAIYUN" size="3">视图层</font></a></li>
<li><a href="#line4"> <font face="STCAIYUN" size="3">运行机制</font></a></li>
</ul>
</li>
</ul>
<br>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2017/07/19/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%20%E5%88%9D%E8%A7%81%E7%AF%87/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://maying.ink/2017/07/02/React%E9%99%B7%E9%98%B1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
      <meta itemprop="name" content="亦舒">
      <meta itemprop="description" content="知识带来自由，我等风也等你 🍂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亦舒的海角">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/07/02/React%E9%99%B7%E9%98%B1/" class="post-title-link" itemprop="url">React 陷阱</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-07-02 00:00:00" itemprop="dateCreated datePublished" datetime="2017-07-02T00:00:00+08:00">2017-07-02</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-10-23 02:41:42" itemprop="dateModified" datetime="2020-10-23T02:41:42+08:00">2020-10-23</time>
      </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>不要改变 props</li>
</ul>
<p>错误例子：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var component = &lt;Component /&gt;;</span><br><span class="line">component.props.foo = x; // bad</span><br><span class="line">component.props.bar = y; // also bad</span><br></pre></td></tr></tbody></table></figure>

<p>这样写是错误的，因为我们手动直接添加的属性 React 后续没办法检查到属性类型错误，也就是说，当我们手动添加的属性发生类型错误时，在控制台是看不到错误信息的</p>
<p>在 React 的设定中，初始化完 props 后，props 是不可变的。改变 props 会引起无法想象的后果</p>
<p>正确写法：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var props = {};</span><br><span class="line">props.foo = x;</span><br><span class="line">props.bar = y;</span><br><span class="line">var component = &lt;Component {...props} /&gt;;</span><br></pre></td></tr></tbody></table></figure>

<p>当需要拓展我们的属性的时候，定义个一个属性对象，并通过 {…props} 的方式引入，React 会帮我们拷贝到组件的 props 属性中。<br>重要的是 — 这个过程是由 React 操控的，不是手动添赋值的属性</p>
<p>需要覆盖的时候可以这么写</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var props = { foo: 'default' };</span><br><span class="line">var component = &lt;Component {...props} foo={'override'} /&gt;;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>


<ul>
<li>React 默认会进行 HTML 的转义如下</li>
</ul>
<p>输入：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var content='&lt;strong&gt;content&lt;/strong&gt;';</span><br><span class="line"></span><br><span class="line">React.render(</span><br><span class="line">    &lt;div&gt;{content}&lt;/div&gt;,</span><br><span class="line">    document.body</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;stonrg&gt;content&lt;/strong&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>避免转义：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var content='&lt;strong&gt;content&lt;/strong&gt;';    </span><br><span class="line"></span><br><span class="line">React.render(</span><br><span class="line">    &lt;div dangerouslySetInnerHTML={{__html: content}}&gt;&lt;/div&gt;,</span><br><span class="line">    document.body</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>如果在编写时使用了 react 自定义属性  react 是不会渲染的</li>
</ul>
<p>错误做法：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">React.render(</span><br><span class="line">    &lt;div dd='xxx'&gt;content&lt;/div&gt;,</span><br><span class="line">    document.body</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>

<p>正确做法：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">React.render(</span><br><span class="line">    &lt;div data-dd='xxx' aria-dd='xxx'&gt;content&lt;/div&gt;,</span><br><span class="line">    document.body</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://maying.ink/2017/04/24/js%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89require.js/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
      <meta itemprop="name" content="亦舒">
      <meta itemprop="description" content="知识带来自由，我等风也等你 🍂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亦舒的海角">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/04/24/js%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89require.js/" class="post-title-link" itemprop="url">js 模块化编程系列（二）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-04-24 00:00:00" itemprop="dateCreated datePublished" datetime="2017-04-24T00:00:00+08:00">2017-04-24</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-10-23 02:41:42" itemprop="dateModified" datetime="2020-10-23T02:41:42+08:00">2020-10-23</time>
      </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>require.js</strong></p>
<p>出现背景：所有的 javascript 代码都在一个文件中，代码越来越多时必须分成多个文件，依次加载，问题：加载 js 的时候浏览器停止渲染，加载文件越多，网页的响应时间就越长，由于 js 之间有依赖关系，因此必须严格保证加载顺序，当依赖关系变的复杂时，代码的编写和维护都会变的异常困难</p>
<ol>
<li> 加载 require.js</li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src="js/require.js" defer async='true'&gt;&lt;/script&gt;</span><br><span class="line">async   表明这个文件需要异步加载</span><br><span class="line">在require.js的基础上加载自己的 main.js</span><br><span class="line">&lt;script src="require.js" data-main="js/main"&gt;&lt;/script&gt;</span><br><span class="line">ata-main:指定程序的主模块，这个人间会第一个被require.js加载，由于require.js默认的文件后缀名是js，所以可以把main.js 简写成main</span><br><span class="line"></span><br><span class="line">//main.js</span><br><span class="line"></span><br><span class="line">require(['moduleA', 'moduleB', 'moduleC'],   function (moduleA, moduleB, moduleC){</span><br><span class="line">　　　　// some code here</span><br><span class="line">　　})``</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li>模块的加载<br>当加载不同路径下的模块可以使用 require.config () 可以对模块的加载进行自定义， require.config () 就写在主模块 (main.js) 的头部，参数就是一个对象，这个对象的 path 属性指定各个模块的加载路径 </li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">　　require.config({</span><br><span class="line">　　　　paths: {</span><br><span class="line">　　　　　　"jquery": "lib/jquery.min",</span><br><span class="line">　　　　　　"underscore": "lib/underscore.min",</span><br><span class="line">　　　　　　"backbone": "lib/backbone.min"</span><br><span class="line">　　　　}</span><br><span class="line">　　});</span><br><span class="line">　　</span><br><span class="line">　　另一种形式</span><br><span class="line">　　</span><br><span class="line">　　　require.config({</span><br><span class="line">　　　　baseUrl: "js/lib",</span><br><span class="line">　　　　paths: {</span><br><span class="line">　　　　　　"jquery": "jquery.min",</span><br><span class="line">　　　　　　"underscore": "underscore.min",</span><br><span class="line">　　　　　　"backbone": "backbone.min"</span><br><span class="line">　　　　}</span><br><span class="line">　　});</span><br><span class="line">　　</span><br><span class="line">　　再或者</span><br><span class="line">　　　require.config({</span><br><span class="line">　　　　paths: {</span><br><span class="line">　　　　　　"jquery": "https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min"</span><br><span class="line">　　　　}</span><br><span class="line">　　});</span><br></pre></td></tr></tbody></table></figure>

<ol start="3">
<li>AMD 模块的写法<br>require.js 加载的模块采用 AMD 规范<br>具体来说，就是模块必须采用特定的 define () 函数来定义，如果一个模块不依赖其他模块，那么可以直接定义在 define 函数中 </li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//math.js 定义了一个math模块</span><br><span class="line">define(function(){</span><br><span class="line">var add = function(){</span><br><span class="line">   return x+y;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">return {</span><br><span class="line"> add:add</span><br><span class="line">}</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">加载方法：</span><br><span class="line"></span><br><span class="line">// main.js</span><br><span class="line">　　require(['math'], function (math){</span><br><span class="line">　　　　alert(math.add(1,1));</span><br><span class="line">　　});</span><br><span class="line">　　</span><br><span class="line">　　如果这个模块还依赖其他模块，那么那么define()函数的第一个参数，必须是一个数组，指明该模块的依赖性。</span><br><span class="line">　　　define(['myLib'], function(myLib){</span><br><span class="line">　　　　function foo(){</span><br><span class="line">　　　　　　myLib.doSomething();</span><br><span class="line">　　　　}</span><br><span class="line">　　　　return {</span><br><span class="line">　　　　　　foo : foo</span><br><span class="line">　　　　};</span><br><span class="line">　　});</span><br><span class="line">　　当require()函数加载上面这个模块的时候，就会先加载myLib.js文件。</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<ol start="3">
<li>AMD 模块的写法<br>加载非规范的模块<br>理论上 require.js 加载的模块，必须是按照 AMD 规范、用 define () 函数定义的模块<br>加载非规范模块，必须先用 require.config () 方法定义它们的一些特征 </li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">eg：加载非AMD规范模块 underscore，backbone</span><br><span class="line">　　require.config({</span><br><span class="line">　　　　shim: {</span><br><span class="line"></span><br><span class="line">　　　　　　'underscore':{</span><br><span class="line">　　　　　　　　exports: '_'</span><br><span class="line">　　　　　　},</span><br><span class="line">　　　　　　'backbone': {</span><br><span class="line">　　　　　　　　deps: ['underscore', 'jquery'],</span><br><span class="line">　　　　　　　　exports: 'Backbone'</span><br><span class="line">　　　　　　}</span><br><span class="line">　　　　}</span><br><span class="line">　　});</span><br><span class="line">　　</span><br><span class="line">　　shim属性：专门用来配置不兼容的模块。具体来说，每个模块要定义</span><br><span class="line">　　（1）exports值（输出的变量名），表明这个模块外部调用时的名称；</span><br><span class="line">　　（2）deps数组，表明该模块的依赖性。</span><br><span class="line">　　</span><br><span class="line">　　eg：</span><br><span class="line">　　   jQuery的插件可以这样定义：</span><br><span class="line">　　　　shim: {</span><br><span class="line">　　　　'jquery.scroll': {</span><br><span class="line">　　　　　　deps: ['jquery'],</span><br><span class="line">　　　　　　exports: 'jQuery.fn.scroll'</span><br><span class="line">　　　　}</span><br><span class="line">　　}</span><br></pre></td></tr></tbody></table></figure>

<ol start="4">
<li><p>require 插件<br>domready 插件，可以让回调函数在页面 DOM 结构加载完成后再运行。</p>
<p>　</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">require(['domready!'], function (doc){</span><br><span class="line">　　　　// called once the DOM is ready</span><br><span class="line">　　});</span><br><span class="line">　　</span><br></pre></td></tr></tbody></table></figure>


</li>
</ol>
<p>text 和 image 插件，则是允许 require.js 加载文本和图片文件。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">define([</span><br><span class="line">　　　　'text!review.txt',</span><br><span class="line">　　　　'image!cat.jpg'</span><br><span class="line">　　　　],</span><br><span class="line"></span><br><span class="line">　　　　function(review,cat){</span><br><span class="line">　　　　　　console.log(review);</span><br><span class="line">　　　　　　document.body.appendChild(cat);</span><br><span class="line">　　　　}</span><br><span class="line">　　);</span><br></pre></td></tr></tbody></table></figure>


<p>类似的插件还有 json 和 mdown，用于加载 json 文件和 markdown 文件</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://maying.ink/2017/04/23/js%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
      <meta itemprop="name" content="亦舒">
      <meta itemprop="description" content="知识带来自由，我等风也等你 🍂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亦舒的海角">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/04/23/js%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">js 模块化编程系列（一）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-04-23 00:00:00" itemprop="dateCreated datePublished" datetime="2017-04-23T00:00:00+08:00">2017-04-23</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-10-23 02:41:42" itemprop="dateModified" datetime="2020-10-23T02:41:42+08:00">2020-10-23</time>
      </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ol>
<li>原始写法 </li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function m1(){}</span><br><span class="line">function m2(){}</span><br></pre></td></tr></tbody></table></figure>
<p> 缺点：污染了全局变量，容易与其它模块发生命名冲突，而且模块之间看不出直接关系</p>
<ol start="2">
<li>对象写法 </li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var moudle = new Object({</span><br><span class="line"> _count = 0;</span><br><span class="line"> m1:function(){},</span><br><span class="line"> m2:function(){}</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>
<p>缺点：会暴露所有模块成员，内部状态可以被外部改写</p>
<ol start="3">
<li>立即执行函数的写法 (达到不暴露私有成员的目的)</li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var moudle1 = (function(){</span><br><span class="line">var count = 0;</span><br><span class="line">var m1 = function(){</span><br><span class="line">//...</span><br><span class="line">};</span><br><span class="line">var m2 = function(){</span><br><span class="line">//...</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">return {</span><br><span class="line">         m1:m1,</span><br><span class="line">         m2:m2</span><br><span class="line">       }</span><br><span class="line">})();</span><br></pre></td></tr></tbody></table></figure>

<p> moudle1 就是 javascript 模块的基本写法</p>
<ol start="4">
<li>放大模式<br>背景：如果一个模块很大必须分为几个部分，或者一个模块需要继承另外一个模块时 </li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var moudle1 = (function(mod){</span><br><span class="line">   mod.m3 = function(){</span><br><span class="line">   //...</span><br><span class="line">   }</span><br><span class="line">   return mod;</span><br><span class="line">  })(moudle1);</span><br></pre></td></tr></tbody></table></figure>

<p>  上面的代码为 moudle1 添加了一个新方法 m3，然后返回新的 moudle1 模块</p>
<ol start="5">
<li>宽放大模式<br>背景：在浏览器环境中，模块的各个部分都是从网上获取的，有时候无法知道哪个部分会先加载，如果单纯采用放大模式，第一个执行的 部分有可能加载一个不存在的空对象 </li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var moudle1 = (function(mod){</span><br><span class="line">  mod.m3 = function(){</span><br><span class="line">  //...</span><br><span class="line">  }</span><br><span class="line">  return mod;</span><br><span class="line"> })(window.moudle1 || {});</span><br></pre></td></tr></tbody></table></figure>

<ol start="6">
<li>输入全局变量<br>背景：保持模块独立性，内部最好不要与程序的其他部分直接交互 </li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var moudle1 = (function($,YAHOO){</span><br><span class="line">      //...</span><br><span class="line">  })(jQuery, YAHOO);</span><br></pre></td></tr></tbody></table></figure>
<p>  保持独立的同时，模块的依赖关系变的更明显</p>
<ol start="7">
<li>模块的规范<br>CommonJS 和 AMD<br>CommonJS：nodejs 的模块系统，是参照 CommonJS 规范实现的，在 CommonJS 中，有一个全局方法 require ()，用于加载模块 </li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line">var math = require('math');</span><br><span class="line">  调用math模块提供的方法：</span><br><span class="line">  math.add(2,3); // 5</span><br></pre></td></tr></tbody></table></figure>

<ol start="8">
<li>浏览器环境<br>局限使 CommonJS 规范不适用于浏览器环境 </li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var math = require('math');</span><br><span class="line">math.add(2,3); // 5</span><br></pre></td></tr></tbody></table></figure>
<p>  在浏览器中运行，第二行在第一行之后运行，也就是说必须得等到 math 模块加载完成，如果加载时间很长，整个应用都会停在那里等，对于服务器端来说，所有模块都放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间，但是对于浏览器，这就是致命的问题，取决于网速，<br>  所以，浏览器端的模块不能采用同步加载，要采用<strong>异步加载</strong></p>
<ol start="9">
<li>AMD<br>‘异步模块定义’，采用异步方式加载模块，所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，回调函数才执行<br>AMD 也采用 require () 语句加载模块，不同于 CommonJS，它要求两个参数
　</li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">require([module], callback)</span><br><span class="line">require(['math'], function (math) {</span><br><span class="line">　　　　math.add(2, 3);</span><br><span class="line">　　});</span><br></pre></td></tr></tbody></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://maying.ink/2017/04/21/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
      <meta itemprop="name" content="亦舒">
      <meta itemprop="description" content="知识带来自由，我等风也等你 🍂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亦舒的海角">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/04/21/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" class="post-title-link" itemprop="url">js 面向对象</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-04-21 00:00:00" itemprop="dateCreated datePublished" datetime="2017-04-21T00:00:00+08:00">2017-04-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-10-23 02:41:42" itemprop="dateModified" datetime="2020-10-23T02:41:42+08:00">2020-10-23</time>
      </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>工厂模式</strong><br>解决了重复实例化的问题</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function createObject(name,age){</span><br><span class="line">var obj = new Object();</span><br><span class="line">obj.name= name;</span><br><span class="line">obj.age = age;</span><br><span class="line">obj.run = function(){</span><br><span class="line"> return this.name + this.age + '运行中'</span><br><span class="line">}</span><br><span class="line">return obj;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var box1 = createObject（‘lee’,100）</span><br><span class="line">var box2 = createObject（‘jack’,200）</span><br></pre></td></tr></tbody></table></figure>

<p>工厂模式的缺点：<br>无法区分实例是哪个对象的实例</p>
<p><strong>构造函数模式</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Box(name,age){</span><br><span class="line"> this.name= name;</span><br><span class="line"> this.age = age;</span><br><span class="line"> this.run = function(){</span><br><span class="line">  return this.name + this.age + '运行中'</span><br><span class="line"> }</span><br><span class="line">}</span><br><span class="line">var box3 = new Box（‘lee’,100）</span><br><span class="line">var box4 = new Box（‘jack’,200）</span><br></pre></td></tr></tbody></table></figure>
<p>如何识别了对象？<br>构造函数没有 new Object，但是它后台回自动 var obj = new Object ();<br>this 指的就是 obj<br>没有返回值</p>
<p>console.log(box4 instanceof Box)</p>
<p><strong>对象冒充</strong><br>把 o 冒充成 box 对象</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var  o = new Object();</span><br><span class="line">Box.call(o,'Lee',100)</span><br></pre></td></tr></tbody></table></figure>


<p><strong>原型</strong></p>
<p>prototype 原型属性是一个对象</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function Box(){}</span><br></pre></td></tr></tbody></table></figure>
<p> 这里如果有属性或者方法 叫做实例属性和实例方法</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Box.prototypr.name 原型属性</span><br><span class="line">Box.prototypr.run=function(){} 原型方法</span><br></pre></td></tr></tbody></table></figure>

<p><strong>_proto_：</strong> 实际上是一个指向原型对象的一个指针，它的作用就是指向构造函数的原型属性 constructor</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var box1 = new Box()</span><br><span class="line">box1.constructor 指向构造函数</span><br><span class="line">box1._proto_指向原型对象</span><br></pre></td></tr></tbody></table></figure>

<p>判断一个对象实例是不是指向了对象的原型对象，实例化之后是自动指向的</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Box.prototype.isPrototypeOf(box1)</span><br></pre></td></tr></tbody></table></figure>

<p><strong>什么叫闭包？ 有什么用</strong></p>
<p>闭包是指有权访问另一个作用域中的变量和函数，常见的形式是在<font face="STCAIYUN" color="red" size="4">某个作用域中定义的函数</font></p>
<p>闭包的作用域链包括三部分：</p>
<ol>
<li>函数本身作用域</li>
<li>闭包定义的作用域</li>
<li>全局作用域</li>
</ol>
<p><font face="STCAIYUN" color="green" size="4">闭包的常见用途？</font></p>
<ol>
<li>读取函数内部的变量</li>
<li>将变量始终保持在内存中</li>
<li>模拟面向对象的代码风格</li>
</ol>
<p><strong>匿名执行函数</strong></p>
<p>不加 <strong>var</strong> 关键字 默认回呗添加到全局对象的属性中去，类似的临时变量的属性加入全局对象有很多坏处<br>比如：<br>别的函数可能误用这些变量 造成全局变量过于庞大，影响访问速度（因为变量的取值是需要从圆形链上遍历的）</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var datamodel = {    </span><br><span class="line">    table : [],    </span><br><span class="line">    tree : {}    </span><br><span class="line">};    </span><br><span class="line"></span><br><span class="line">(function(dm){    </span><br><span class="line">    for(var i = 0; i &lt; dm.table.rows; i++){    </span><br><span class="line">       var row = dm.table.rows[i];    </span><br><span class="line">       for(var j = 0; j &lt; row.cells; i++){    </span><br><span class="line">           drawCell(i, j);    </span><br><span class="line">       }    </span><br><span class="line">    }    </span><br><span class="line"></span><br><span class="line">    //build dm.tree      </span><br><span class="line">})(datamodel);  </span><br><span class="line"></span><br><span class="line">创建了一个匿名的函数并立即执行它，由于外部无法引用它内部的变量，因此在执行之后很快就会被释放 不会污染全局对象</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>


<p><strong>缓存</strong></p>
<p>设想我们有一个处理过程很耗时的函数对象，每次调用都会花费很长时间，<br>那么我们就需要将计算出来的值存储起来，当调用这个函数的时候，首先在缓存中查找，如果找不到，则进行计算，然后更新缓存并返回值，如果找到了，直接返回查找到的值即可。闭包正是可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得以保留。</p>
<p><strong>实现封装</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var person = function(){    </span><br><span class="line">    //变量作用域为函数内部，外部无法访问    </span><br><span class="line">    var name = "default";       </span><br><span class="line"></span><br><span class="line">    return {    </span><br><span class="line">       getName : function(){    </span><br><span class="line">           return name;    </span><br><span class="line">       },    </span><br><span class="line">       setName : function(newName){    </span><br><span class="line">           name = newName;    </span><br><span class="line">       }    </span><br><span class="line">    }    </span><br><span class="line">}();    </span><br><span class="line"></span><br><span class="line">print(person.name);//直接访问，结果为undefined    </span><br><span class="line">print(person.getName());    </span><br><span class="line">person.setName("abruzzi");    </span><br><span class="line">print(person.getName());   </span><br></pre></td></tr></tbody></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://maying.ink/2017/04/20/ES6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
      <meta itemprop="name" content="亦舒">
      <meta itemprop="description" content="知识带来自由，我等风也等你 🍂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亦舒的海角">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/04/20/ES6/" class="post-title-link" itemprop="url">ES6 系列 (一)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-04-20 00:00:00" itemprop="dateCreated datePublished" datetime="2017-04-20T00:00:00+08:00">2017-04-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-10-23 02:41:42" itemprop="dateModified" datetime="2020-10-23T02:41:42+08:00">2020-10-23</time>
      </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>数组的扩展</strong><br>Array.form () 将两类对象转换为数组<br>1. 类似数组的对象<br>2. 可遍历的对象</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let arrayLike = {</span><br><span class="line">'0':'a',</span><br><span class="line">'1':'b',</span><br><span class="line">'2':'c',</span><br><span class="line">'3':'d'</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>ES5 写法</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = [].slice.call(arrayLike)</span><br></pre></td></tr></tbody></table></figure>
<p>ES6 写法</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let arr2 = Array.form(arrayLike)</span><br></pre></td></tr></tbody></table></figure>

<p>任何有 length 属性的对象，都可以通过 Array.from 方法转为数组，而此时扩展运算符就无法转换。</p>
<p>值得提醒的是，扩展运算符（…）也可以将某些数据结构转为数组。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// arguments对象</span><br><span class="line">function foo() {</span><br><span class="line">  var args = [...arguments];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// NodeList对象</span><br><span class="line">[...document.querySelectorAll('div')]</span><br><span class="line"></span><br><span class="line">Array.from还可以接受第二个参数，作用类似于数组的map方法</span><br><span class="line"></span><br><span class="line">Array.from(arrayLike, x =&gt; x * x);</span><br><span class="line">// 等同于</span><br><span class="line">Array.from(arrayLike).map(x =&gt; x * x);</span><br><span class="line"></span><br><span class="line">Array.of()</span><br><span class="line">Array.of方法用于将一组值，转换为数组。</span><br><span class="line"></span><br><span class="line">Array.of(3, 11, 8) // [3,11,8]</span><br><span class="line">Array.of(3) // [3]</span><br><span class="line">Array.of(3).length // 1</span><br><span class="line"></span><br><span class="line">[1, 5, 10, 15].find(function(value, index, arr) {</span><br><span class="line">  return value &gt; 9;</span><br><span class="line">}) // 10</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>fill 方法使用给定值，填充一个数组。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">['a', 'b', 'c'].fill(7)</span><br></pre></td></tr></tbody></table></figure>

<p>ES6 提供三个新的方法 ——<strong>entries()**，</strong>keys() <strong>和</strong> values ()**—— 用于遍历数组</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3].includes(2);     // true</span><br></pre></td></tr></tbody></table></figure>
<p><strong>for of 循环</strong></p>
<p>ES6 引入 rest 参数（形式为 “… 变量名”），用于获取函数的多余参数</p>
<p>扩展运算符（spread）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。<br>console.log(…[1, 2, 3])<br>// 1 2 3</p>
<p>函数的 name 属性，返回该函数的函数名。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function foo() {}</span><br><span class="line">foo.name // "foo"</span><br></pre></td></tr></tbody></table></figure>



<p><font face="STCAIYUN" color="red" size="4">（1）函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。</font></p>
<p>对象的扩展<br>var bax= {bac} = var baz = {bac:bac}</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var o = {</span><br><span class="line">method:function(){}</span><br><span class="line">} ==</span><br><span class="line">var o = {</span><br><span class="line"> method(){}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>let propKey = ‘foo’;</p>
<p>let obj = {<br>  [propKey]: true,<br>  [‘a’ + ‘bc’]: 123<br>};</p>
<p>const person = {<br>  sayName() {<br>    console.log(‘hello!’);<br>  },<br>};</p>
<p>person.sayName.name   // “sayName”</p>
<p>Object.is（）用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object.is('foo', 'foo')</span><br><span class="line">// true</span><br><span class="line">Object.is({}, {})</span><br><span class="line">// false</span><br><span class="line"></span><br><span class="line">不同之处只有两个：一是+0不等于-0，二是NaN等于自身</span><br></pre></td></tr></tbody></table></figure>


<p><font face="STCAIYUN" color="green" size="4">Object.is(+0, -0) // false<br></font></p>
<p><font face="STCAIYUN" color="blue" size="4">Object.is(NaN, NaN) // true<br></font></p>
<p>Object.assign () 实行的是<font face="STCAIYUN" color="red" size="4">浅拷贝不是深拷贝<br></font><br><strong>如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</strong></p>
<p>例子</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = {a: {b: 1}};</span><br><span class="line">var obj2 = Object.assign({}, obj1);</span><br><span class="line"></span><br><span class="line">obj1.a.b = 2; 如果值更改 则拷贝之后的值也是变化的</span><br><span class="line">obj2.a.b // 2</span><br><span class="line"></span><br><span class="line">如果该参数不是对象，则会先转成对象，然后返回。</span><br><span class="line"></span><br><span class="line">typeof Object.assign(2) // "object"</span><br><span class="line"></span><br><span class="line">Object.assign可以用来处理数组，但是会把数组视为对象。</span><br><span class="line"></span><br><span class="line">Object.assign([1, 2, 3], [4, 5])</span><br><span class="line">// [4, 5, 3]</span><br><span class="line"></span><br><span class="line">Object.assign(someClass.prototype,{</span><br><span class="line">someMethod(){</span><br><span class="line">...</span><br><span class="line">},</span><br><span class="line">antherMethod(){</span><br><span class="line">...</span><br><span class="line">}</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">===</span><br><span class="line">// 等同于下面的写法</span><br><span class="line">SomeClass.prototype.someMethod = function (arg1, arg2) {</span><br><span class="line">  ···</span><br><span class="line">};</span><br><span class="line">SomeClass.prototype.anotherMethod = function () {</span><br><span class="line">  ···</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong>克隆对象</strong><br>只能可通他自身的值而不能可通它继承的值</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function clone(origin){</span><br><span class="line"> return Object.assign({},origin)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function clone(origin) {</span><br><span class="line">  let originProto = Object.getPrototypeOf(origin);</span><br><span class="line">  return Object.assign(Object.create(originProto), origin);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Object.getOwnPropertyDescriptor 获取该属性的描述对象</span><br><span class="line">let obj = { foo: 123 };</span><br><span class="line">Object.getOwnPropertyDescriptor(obj, 'foo')</span><br><span class="line">//  {</span><br><span class="line">//    value: 123,</span><br><span class="line">//    writable: true,</span><br><span class="line">//    enumerable: true,</span><br><span class="line">//    configurable: true</span><br><span class="line">//  }</span><br></pre></td></tr></tbody></table></figure>

<p>Object.keys 方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = { foo: 'bar', baz: 42 };</span><br><span class="line">Object.keys(obj)</span><br><span class="line">// ["foo", "baz"]</span><br></pre></td></tr></tbody></table></figure>
<p><img src="media/14879652049673/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-25%20%E4%B8%8B%E5%8D%8812.58.09.png" alt="屏幕快照 2017-02-25 下午12.58.09"></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = { foo: 'bar', baz: 42 };</span><br><span class="line">Object.values(obj)</span><br><span class="line">// ["bar", 42]</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj = { foo: 'bar', baz: 42 };</span><br><span class="line">Object.entries(obj)</span><br><span class="line">// [ ["foo", "bar"], ["baz", 42] ]</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong>ES6 中遍历对象的属性</strong></p>
<p><font face="STCAIYUN" color="red" size="4">for…in </font>循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）<br> <font face="STCAIYUN" color="red" size="4">Object.keys</font> 返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）。<br> <font face="STCAIYUN" color="red" size="4">Object.getOwnPropertyNames</font> 返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）<br> <font face="STCAIYUN" color="red" size="4">Object.getOwnPropertySymbols</font> 返回一个数组，包含对象自身的所有 Symbol 属性。</p>
<p><font face="STCAIYUN" color="red" size="4">__proto__属性（前后各两个下划线）</font>，用来读取或设置当前对象的 prototype 对象。目前，所有浏览器（包括 IE11）都部署了这个属性。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// es6的写法</span><br><span class="line">var obj = {</span><br><span class="line">  method: function() { ... }</span><br><span class="line">};</span><br><span class="line">obj.__proto__ = someOtherObj;</span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let proto = {};</span><br><span class="line">let obj = { x: 10 };</span><br><span class="line">Object.setPrototypeOf(obj, proto);</span><br><span class="line"></span><br><span class="line">proto.y = 20;</span><br><span class="line">proto.z = 40;</span><br><span class="line"></span><br><span class="line">obj.x // 10</span><br><span class="line">obj.y // 20</span><br><span class="line">obj.z // 40</span><br><span class="line">上面代码将proto对象设为obj对象的原型，所以从obj对象可以读取proto对象的属性。</span><br></pre></td></tr></tbody></table></figure>


<p><strong>ES6 引入的原始类型 “</strong><br><font face="STCAIYUN" color="red" size="4">Symbol</font><br>凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。<br>Symbol 函数前<font face="STCAIYUN" color="red" size="4">不能使用 new 命令</font>，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象<br>由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。<br>Symbol 值不能与其他类型的值进行运算，会报错。<br>但是，Symbol 值可以显式转为字符串。<br>另外，Symbol 值也可以转为布尔值，但是不能转为数值。</p>
<p>let s = Symbol();</p>
<p>typeof s</p>
<p><strong>数组去重</strong></p>
<p>新增的数据结构 <font face="STCAIYUN" color="red" size="4">Set Map </font></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const s = new Set();</span><br><span class="line">[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var set = new Set([1, 2, 3, 4, 4]);</span><br><span class="line">[...set]</span><br></pre></td></tr></tbody></table></figure>

<p>// 去除数组的重复成员<br>在 Set 内部，两个 NaN 是相等。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[...new Set(array)]</span><br><span class="line">var set = new Set([1,1,2,2,3,4,5,5,6])</span><br><span class="line">[...set]</span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let map = new Map([</span><br><span class="line">  ['F', 'no'],</span><br><span class="line">  ['T',  'yes'],</span><br><span class="line">]);</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (let key of map.keys()) {</span><br><span class="line">  console.log(key);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><font face="STCAIYUN" color="red" size="4">Proxy（代理器） 元编程（对编程语言进行编程）</font></p>
<p><strong>在目标对象之前设置一层拦截 外界对它的访问必须先通过这一层拦截</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var obj = new Proxy({}, {</span><br><span class="line">  get: function (target, key, receiver) {</span><br><span class="line">    console.log(`getting ${key}!`);</span><br><span class="line">    return Reflect.get(target, key, receiver);</span><br><span class="line">  },</span><br><span class="line"></span><br><span class="line">  set: function (target, key, value, receiver) {</span><br><span class="line">    console.log(`setting ${key}!`);</span><br><span class="line">    return Reflect.set(target, key, value, receiver);</span><br><span class="line">  }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>
<p>重写了 get 和 set 方法</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var proxy = new Proxy(target, handler);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var proxy = new Proxy({}, {</span><br><span class="line">  get: function(target, property) {</span><br><span class="line">    return 35;</span><br><span class="line">  }</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">proxy.time // 35</span><br><span class="line">proxy.name // 35</span><br><span class="line">proxy.title // 35</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><font face="STCAIYUN" color="red" size="4">Promise (承诺)</font></p>
<p>所谓 Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var promise = new Promise(function(resolve,reject){</span><br><span class="line"></span><br><span class="line">if('异步操作成功'){</span><br><span class="line">resolve(value)</span><br><span class="line">}else{</span><br><span class="line">reject(error)</span><br><span class="line">}</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">promise.then(function(value){</span><br><span class="line">成功</span><br><span class="line">},function(error){</span><br><span class="line">失败</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p>遍历器对象本质上，就是一个指针对象。</p>
<p>回调函数<br>事件监听<br>发布 / 订阅<br>Promise 对象</p>
<p>Generator 函数<br>yield 表示执行到此处执行权将交给其它协程也就是说 yield 命令部两个阶段的分界线</p>
<p>Generator 函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function* gen(x){</span><br><span class="line"> try{</span><br><span class="line"> var y = yield x +2;</span><br><span class="line"> }catch(e){</span><br><span class="line"> console.log(e)</span><br><span class="line"> }</span><br><span class="line"> return y</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>




<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var fetch = require('node-fetch');</span><br><span class="line"></span><br><span class="line"> function* gen(){</span><br><span class="line"> var url = 'http://api.github.com/users/github';</span><br><span class="line"> var result = yield fetch (url);</span><br><span class="line"> console.log('ds')</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>

<p> Thunk 函数是自动执行 generator 函数的一种方法</p>
<p> 传名调用</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> f(x + 5)</span><br><span class="line">// 传名调用时，等同于</span><br><span class="line">f(x + 5)</span><br></pre></td></tr></tbody></table></figure>

<p> 传值调用</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> f(x + 5)</span><br><span class="line">// 传值调用时，等同于</span><br><span class="line">f(6)</span><br></pre></td></tr></tbody></table></figure>

<p><font face="STCAIYUN" color="red" size="4">Thunk 是传名调用的实现</font>，将参数放到一个临时的函数中，再将这个临时函数传入函数体</p>
<p>这个临时函数叫做 <strong>Thunk</strong> 函数</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var x = 1;</span><br><span class="line">function f(m){</span><br><span class="line"> return m*2;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">f(x+5)</span><br><span class="line"></span><br><span class="line">等同于</span><br><span class="line"></span><br><span class="line">var thunk = function(){</span><br><span class="line">  return x+5</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">function (thunk){</span><br><span class="line">return thunk()*2</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p><font face="STCAIYUN" color="red" size="4">async ：Generator 函数的语法糖</font></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var asyncReadFile = async function () {</span><br><span class="line">  var f1 = await readFile('/etc/fstab');</span><br><span class="line">  var f2 = await readFile('/etc/shells');</span><br><span class="line">  console.log(f1.toString());</span><br><span class="line">  console.log(f2.toString());</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p><strong>async 🌧️generator 比较</strong></p>
<ol>
<li>async 有内置执行器 不需要调用 next 方法<br>拥有更好的语义（比起星号和 yield 语义更清楚了）</li>
<li>async 函数返回的是 promise 对象比 Generator 函数返回值是 Iterator 对象方便多了 可以用 then 方法指定下一步操作</li>
</ol>
<p><strong>async 和 await</strong></p>
<ul>
<li>  async 表示函数中有异步操作</li>
<li>  await 表示紧跟在后面的表达式需要等待结果</li>
<li>  async 函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而 await 命令就是内部 then 命令的语法糖。</li>
<li> async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。当函数执行的时候，一旦遇到 await 就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</li>
</ul>
<p>错误处理</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">async function f() {</span><br><span class="line">  await new Promise(function (resolve, reject) {</span><br><span class="line">    throw new Error('出错了');</span><br><span class="line">  });</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">async function main() {</span><br><span class="line">  try {</span><br><span class="line">    var val1 = await firstStep();</span><br><span class="line">    var val2 = await secondStep(val1);</span><br><span class="line">    var val3 = await thirdStep(val1, val2);</span><br><span class="line"></span><br><span class="line">    console.log('Final: ', val3);</span><br><span class="line">  }</span><br><span class="line">  catch (err) {</span><br><span class="line">    console.error(err);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">async function myFunction() {</span><br><span class="line">  try {</span><br><span class="line">    await somethingThatReturnsAPromise();</span><br><span class="line">  } catch (err) {</span><br><span class="line">    console.log(err);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h3 id="class"><a href="#class" class="headerlink" title="class"></a>class</h3><p><strong>基本形式</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Point{</span><br><span class="line"></span><br><span class="line">constructor(x,y){</span><br><span class="line"></span><br><span class="line">this.x = x;</span><br><span class="line">this.y = y</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">toString(){</span><br><span class="line"> return  '(' + this.x + ', ' + this.y + ')';</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Class 不存在变量提升（hoist），这一点与 ES5 完全不同。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const MyClass = class Me {</span><br><span class="line">  getClassName() {</span><br><span class="line">    return Me.name;</span><br><span class="line">  }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>类名是 MyClass 而不是 me Me 只在 Class 的内部代码可用，指代当前类。</p>
<p>const MyClass = class { /* … */ };</p>
<p><strong>模块加载方案</strong></p>
<ul>
<li><p> CommonJs 应用于服务器</p>
</li>
<li><p>AMD 应用于浏览器</p>
<p>ES6 提供模块功能 尽量的静态化)</p>
</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import {stat，exut，readFile} from 'fs'</span><br></pre></td></tr></tbody></table></figure>
<p> Es6 模块是编译时加载<br> ES6 的模块自动采用严格模式</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function  f(){}</span><br><span class="line"> export {f}</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import {lastName as surname} from './profile'</span><br><span class="line">import命令具有提升效果</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">导出</span><br><span class="line">export default</span><br><span class="line"></span><br><span class="line">引入</span><br><span class="line">import * as circle from './circle'; 模块的整体加载</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>使用 import 命令的时候用户不需要知道所加载的变量名或者函数名 用这个语法可以为模块指定默认输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export default function (){</span><br><span class="line"> console.log('foo')</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>
<p> 引入的时候 import 可以为该匿名函数指定任意的名字，这个时候 import 的后面不使用大括号</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import customName from  ..</span><br><span class="line"></span><br><span class="line"> export default function ee (){</span><br><span class="line"> console.log('foo')</span><br><span class="line">}</span><br><span class="line">==</span><br><span class="line"></span><br><span class="line">function foo (){</span><br><span class="line">console.log('ee')</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">export default foo;</span><br></pre></td></tr></tbody></table></figure>

<p> foo 的函数名 foo 在模块外部时无效的 视同匿名函数加载</p>
<p> 使用 export 时，对应的 import 语句需要使用大括号。</p>
<p> 使用 export default  对应的 import 语句不需要大括号</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> // 第一组</span><br><span class="line">export default function crc32() { // 输出</span><br><span class="line">  // ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">import crc32 from 'crc32'; // 输入</span><br><span class="line"></span><br><span class="line">import { default as xxx } from 'modules';</span><br><span class="line"></span><br><span class="line">// 第二组</span><br><span class="line">export function crc32() { // 输出</span><br><span class="line">  // ...</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">import {crc32} from 'crc32'; // 输入</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>本质上，export default 就是输出一个叫做 default 的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。</p>
<p>import { default as xxx } from ‘modules’</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export {add as default};</span><br></pre></td></tr></tbody></table></figure>
<p>// 等同于</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// export default add;</span><br></pre></td></tr></tbody></table></figure>

<p>ES6 模块</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type="module" src="foo.js"&gt;&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了<script>标签的defer属性。</p>
<p>拷贝数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const itemCopy &#x3D; [];</span><br><span class="line">const item &#x3D; [1,2,3]</span><br><span class="line">itemCopy &#x3D; [...item]</span><br><span class="line">console.log(itemCopy)</span><br></pre></td></tr></table></figure>
</script></p>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">亦舒</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">273k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">4:08</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@next-theme/pjax@0.4.0/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '.page-configurations',
    '.main-inner',
    '.post-toc-wrap',
    '.languages',
    '.pjax'
  ],
  analytics: false,
  cacheBust: false,
  scrollRestoration: false,
  scrollTo: !CONFIG.bookmark.enable
});

document.addEventListener('pjax:success', () => {
  pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  const hasTOC = document.querySelector('.post-toc');
  document.querySelector('.sidebar-inner').classList.toggle('sidebar-nav-active', hasTOC);
  document.querySelector(hasTOC ? '.sidebar-nav-toc' : '.sidebar-nav-overview').click();
  NexT.utils.updateSidebarPosition();
});
</script>


  




  <script src="/js/local-search.js"></script>















  








    <div class="pjax">
  

  


    </div>
</body>
</html>
