<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>亦舒的海角</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://maying.ink/"/>
  <updated>2020-10-22T18:41:42.183Z</updated>
  <id>http://maying.ink/</id>
  
  <author>
    <name>亦舒</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Node.js 实战 - 技术预研</title>
    <link href="http://maying.ink/2020/03/23/node/"/>
    <id>http://maying.ink/2020/03/23/node/</id>
    <published>2020-03-22T16:25:24.000Z</published>
    <updated>2020-10-22T18:41:42.183Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>以一种要开发 Node.js 实战项目为最终目标<br>进行一系列的技术预研过程</p><p>有特点，有针对性，有目标</p><p>培养 Node 领域的全局观</p><h1 id="1-关于Nodejs"><a href="#1-关于Nodejs" class="headerlink" title="1 关于Nodejs"></a>1 关于 Nodejs</h1><h2 id="1-1-什么是Node-js"><a href="#1-1-什么是Node-js" class="headerlink" title="1.1 什么是Node.js"></a>1.1 什么是 Node.js</h2><p>官网的话：</p><ul><li>Node.js 是基于 ChromeV8 执行引擎的 JS 运行时环境</li><li> Node.js 使用了一个事件驱动，非阻塞式 I/O 的模型，使其轻量又高效</li></ul><p>每一个字其实都看得懂，聚合到一起就有点懵了</p><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1584894283204&amp;di=6e87b25c91207a1929250f11285d3a2c&amp;imgtype=0&amp;src=http://img2.biaoqingjia.com/biaoqing/201608/a70d12bb1f409850857c8d930cf2d6d1.gif" alt="image"></p><p>我们先不来说 nodejs 是什么，先根据以往的经验抛出问题</p><h3 id="1-1-1-在Node-js里运行Js跟在Chrome运行Js有啥不同？"><a href="#1-1-1-在Node-js里运行Js跟在Chrome运行Js有啥不同？" class="headerlink" title="1.1.1 在Node.js里运行Js跟在Chrome运行Js有啥不同？"></a>1.1.1 在 Node.js 里运行 Js 跟在 Chrome 运行 Js 有啥不同？</h3><p>已知 Chrome 浏览器用的是同样的 Javascript 引擎和模型</p><blockquote><p>其实，在 Node.js 里写 Js 和在 Chrome 里写 Js，<font color="red">几乎一样</font></p></blockquote><p>晃眼的<font color="red">几乎一样</font> 那就是有不一样的地方呗！</p><ul><li>Nodejs 没有浏览器 API，即 (Document,window 等)</li><li> 相应的，也增加了它专属的 API，比如文件系统，进程.</li></ul><p>有了这些差别，其实就不难理解了</p><h4 id="对于开发者来说"><a href="#对于开发者来说" class="headerlink" title="对于开发者来说"></a>对于开发者来说</h4><ul><li>你在 chrome 里写 js <strong>控制浏览器</strong></li><li> Node.js 让你用类似的方式，<strong>控制整个计算机</strong></li></ul><p>Node.js 的真谛，也就是官方抽象的释义，我们完全可以在不断深入的过程中慢慢理解～</p><a id="more"></a><h2 id="1-2-Node-js可以用来做什么？"><a href="#1-2-Node-js可以用来做什么？" class="headerlink" title="1.2 Node.js可以用来做什么？"></a>1.2 Node.js 可以用来做什么？</h2><h3 id="1-2-1-提供Web服务"><a href="#1-2-1-提供Web服务" class="headerlink" title="1.2.1 提供Web服务"></a>1.2.1 提供 Web 服务</h3><ul><li>搜索引擎优化 + 首屏速度优化 = 服务端渲染</li><li>服务端渲染 + 前后端同构 = Node.js</li></ul><h3 id="1-2-2-构建工作流"><a href="#1-2-2-构建工作流" class="headerlink" title="1.2.2 构建工作流"></a>1.2.2 构建工作流</h3><p>在 <code>gulp webpack</code> 之间，前端是如何做构建工具呢？</p><p>可能用 java,ruby 等</p><p>但</p><ul><li>构建工具不会永远不出问题</li><li>构建工具不会永远满足需求</li></ul><p>前端同学很难对这些工具进行修改或者升级</p><p>所以</p><blockquote><p>用 Node.js 做 js 的构建工具，是最保险的选择</p></blockquote><h3 id="1-2-3-开发工具"><a href="#1-2-3-开发工具" class="headerlink" title="1.2.3 开发工具"></a>1.2.3 开发工具</h3><p>VScode</p><p>在 nodejs 的基础上封装了 chrome 的内核，使 nodejs 具有控制计算机得到能力</p><h3 id="1-2-3-可扩展性较强大的沙盒游戏"><a href="#1-2-3-可扩展性较强大的沙盒游戏" class="headerlink" title="1.2.3 可扩展性较强大的沙盒游戏"></a>1.2.3 可扩展性较强大的沙盒游戏</h3><p>需要给使用者自定义模块的能力</p><p>使用 Nodejs 做复杂的本地应用</p><ul><li>可以利用 js 大的灵活性实现外部扩展</li><li> Js 庞大的的开发者基数让他们的灵活性得到利用</li></ul><h3 id="1-2-4-客户端应用"><a href="#1-2-4-客户端应用" class="headerlink" title="1.2.4 客户端应用"></a>1.2.4 客户端应用</h3><p>在已有网站的基础上需要开发新的客户端应用<br>使用 Node.js 客户端技术实现，可以最大限度的复用现有工程</p><h1 id="2-Node-js-初探"><a href="#2-Node-js-初探" class="headerlink" title="2 Node.js 初探"></a>2 Node.js 初探</h1><h2 id="2-1-实现剪刀石头布"><a href="#2-1-实现剪刀石头布" class="headerlink" title="2.1 实现剪刀石头布"></a>2.1 实现剪刀石头布</h2><ul><li>node 运行方式游戏</li><li>全局变量 </li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var playerAction = process.argv[process.argv.length - 1];</span><br><span class="line">console.log("playerAction", playerAction);</span><br><span class="line"></span><br><span class="line">var random1 = Math.random() * 3;</span><br><span class="line"></span><br><span class="line">if (random1 &lt; 1) {</span><br><span class="line">  var computerAction = "rock";</span><br><span class="line">} else if (random1 &gt; 2) {</span><br><span class="line">  var computerAction = "scissor";</span><br><span class="line">} else {</span><br><span class="line">  var computerAction = "paper";</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">if (computerAction === playerAction) {</span><br><span class="line">  console.log("平局");</span><br><span class="line">} else if (</span><br><span class="line">  (computerAction === "rock" &amp;&amp; playerAction === "paper") ||</span><br><span class="line">  (computerAction === "scissor" &amp;&amp; playerAction === "rock") ||</span><br><span class="line">  (computerAction === "paper" &amp;&amp; playerAction === "scissor")</span><br><span class="line">) {</span><br><span class="line">  console.log("你赢了！");</span><br><span class="line">} else {</span><br><span class="line">  console.log("你输了！");</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="2-1-使用Node-js模块规范改造游戏"><a href="#2-1-使用Node-js模块规范改造游戏" class="headerlink" title="2.1 使用Node.js模块规范改造游戏"></a>2.1 使用 Node.js 模块规范改造游戏</h2><h3 id="2-1-1-如何加载js"><a href="#2-1-1-如何加载js" class="headerlink" title="2.1.1 如何加载js"></a>2.1.1 如何加载 js</h3><p>浏览器端</p><ul><li>使用 <code>&lt;script/&gt;</code> 标签</li><li>脚本变多时，需要手动管理加载顺序</li><li>不同脚本之间的逻辑调用需要全局变量</li></ul><p>Node 端</p><ul><li>没有 html 文件，无法使用 <code>&lt;script/&gt;</code> 标签</li></ul><p><img src="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=45975645,3909583844&amp;fm=11&amp;gp=0.jpg" alt="image"></p><p>所以 Node.js 要重新去搞一个模块管理机制来管理 js 的加载，就是现在我们熟悉的<font color="red"> CommonJS 规范</font></p><h3 id="2-1-2-重构剪刀石头布游戏"><a href="#2-1-2-重构剪刀石头布游戏" class="headerlink" title="2.1.2 重构剪刀石头布游戏"></a>2.1.2 重构剪刀石头布游戏</h3><p>games.js</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">module.exports = function(playerAction) {</span><br><span class="line">  if (["rock", "scissor", "paper"].indexOf(playerAction) == -1) {</span><br><span class="line">    throw new Error("invalid playerAction");</span><br><span class="line">  }</span><br><span class="line">  // 计算电脑出的东西</span><br><span class="line">  var computerAction;</span><br><span class="line">  var random = Math.random() * 3;</span><br><span class="line">  if (random &lt; 1) {</span><br><span class="line">    computerAction = "rock";</span><br><span class="line">    console.log("电脑出了石头");</span><br><span class="line">  } else if (random &gt; 2) {</span><br><span class="line">    computerAction = "scissor";</span><br><span class="line">    console.log("电脑出了剪刀");</span><br><span class="line">  } else {</span><br><span class="line">    computerAction = "paper";</span><br><span class="line">    console.log("电脑出了布");</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  if (computerAction == playerAction) {</span><br><span class="line">    console.log("平局");</span><br><span class="line">    return 0;</span><br><span class="line">  } else if (</span><br><span class="line">    (computerAction == "rock" &amp;&amp; playerAction == "scissor") ||</span><br><span class="line">    (computerAction == "scissor" &amp;&amp; playerAction == "paper") ||</span><br><span class="line">    (computerAction == "paper" &amp;&amp; playerAction == "rock")</span><br><span class="line">  ) {</span><br><span class="line">    console.log("你输了");</span><br><span class="line">    return -1;</span><br><span class="line">  } else {</span><br><span class="line">    console.log("你赢了");</span><br><span class="line">    return 1;</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>index.js</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const game = require("./game.js");</span><br><span class="line"></span><br><span class="line">var winCount = 0;</span><br><span class="line">// 获取进程的标准输入</span><br><span class="line">process.stdin.on("data", buffer =&gt; {</span><br><span class="line">  // 回调的是buffer，需要处理成string</span><br><span class="line">  const action = buffer.toString().trim();</span><br><span class="line">  const result = game(action);</span><br><span class="line">  if (result == 1) {</span><br><span class="line">    winCount++;</span><br><span class="line">    if (winCount == 3) {</span><br><span class="line">      console.log("我不玩儿了！哼！");</span><br><span class="line">      process.exit();</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">});</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="3-Node内置模块"><a href="#3-Node内置模块" class="headerlink" title="3 Node内置模块"></a>3 Node 内置模块</h1><p><a href="http://nodejs.cn/api/">内置模块合集</a></p><h2 id="3-1-Node-js系统架构图"><a href="#3-1-Node-js系统架构图" class="headerlink" title="3.1 Node.js系统架构图"></a>3.1 Node.js 系统架构图</h2><p><img src="http://cdn.anruence.com/node-system-1.png" alt="image"></p><h2 id="3-2-理解Node-js精髓"><a href="#3-2-理解Node-js精髓" class="headerlink" title="3.2 理解Node.js精髓"></a>3.2 理解 Node.js 精髓</h2><blockquote><p>Node.js 是基于 ChromeV8 执行引擎的 JS 运行时环境</p></blockquote><p><font color="red">ChromeV8 执行引擎的 JS 运行时环境</font>：架构图的左侧部分就是其体现</p><ul><li>application 代表你写的 nodejs 的代码</li><li>通过 V8 引擎来来运行，里面会涉及到一些关于操作系统调用，这部分就由 V8 引擎帮你转发到操作系统层面</li><li>从操作系统层面得到返回结果之后再通过 V8 引擎返回到 Js 里去</li></ul><ol><li>从 Js 到 V8 再到操作系统的能力，大部分都是通过 Node.js 的内置模块来提供的</li><li>还有一些数据是从操作系统底层通知到我们的 Node.js 层</li></ol><p>示例</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 将进程设置为长期存在并且监听用户的输入</span><br><span class="line">process.stdin.on('data',e=&gt;{</span><br><span class="line">  const playerAction = e.toString().trim();</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>此时依赖的是 Node 的内置模块</p><ul><li>EventEmitter</li></ul><p>process 实际上是 EventEmitter 的实例，继承了 EventEmitter 使其具备了向上抛事件的能力</p><p>引出</p><h2 id="3-3-EventEmitter"><a href="#3-3-EventEmitter" class="headerlink" title="3.3 EventEmitter"></a>3.3 EventEmitter</h2><h3 id="3-3-1-解决了什么问题"><a href="#3-3-1-解决了什么问题" class="headerlink" title="3.3.1 解决了什么问题"></a>3.3.1 解决了什么问题</h3><ul><li>解决两个对象之间的通信问题<ul><li>函数调用</li><li>观察者模式（事件收发模式）- 抛事件<ul><li> addEventListener</li><li>removeEventListener</li></ul></li></ul></li></ul><h3 id="3-3-2-普通调用应用场景"><a href="#3-3-2-普通调用应用场景" class="headerlink" title="3.3.2 普通调用应用场景"></a>3.3.2 普通调用应用场景</h3><ul><li>老板通知秘书</li><li>说是通知，但是直接调用比较合适<h3 id="3-3-3-观察者模式应用场景"><a href="#3-3-3-观察者模式应用场景" class="headerlink" title="3.3.3 观察者模式应用场景"></a>3.3.3 观察者模式应用场景</h3></li><li>通知消息的人并不知道被通知者的存在（极客时间并不知道我的存在）</li><li>没有人接收事件，它还能继续下去（今天没有接收到 Geek 上新课的消息，但是它还是可以上新课）</li></ul><p>lib.js</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const EventEmitter = require('events')</span><br><span class="line">class Geektime extends EventEmitter{</span><br><span class="line">  constructor(){</span><br><span class="line">    super();</span><br><span class="line">    setInterval(() =&gt; {</span><br><span class="line">      this.emit('newlesson',{price:Math.random()* 100}) //触发事件</span><br><span class="line">    }, 3000);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">const geektime = new Geektime;</span><br><span class="line"></span><br><span class="line">module.exports = geektime</span><br></pre></td></tr></tbody></table></figure><p>index.js</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const geektime = require('./lib.js')</span><br><span class="line">geektime.addListener('newlesson',(res)=&gt;{</span><br><span class="line">  if(res.price &lt; 50){</span><br><span class="line">    console.log('buy!当前价格为---',res)</span><br><span class="line">  }</span><br><span class="line">})</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="4-Nodejs非阻塞I-O及异步编程"><a href="#4-Nodejs非阻塞I-O及异步编程" class="headerlink" title="4 Nodejs非阻塞I/O及异步编程"></a>4 Nodejs 非阻塞 I/O 及异步编程</h1><p>值得拿出来单独说，<a href="http://maying.ink/2019/03/19/promise/">戳此一览</a></p><h1 id="5-实现网页版石头剪刀布游戏"><a href="#5-实现网页版石头剪刀布游戏" class="headerlink" title="5 实现网页版石头剪刀布游戏"></a>5 实现网页版石头剪刀布游戏</h1><p>技术前置</p><h2 id="5-1-什么是HTTP服务"><a href="#5-1-什么是HTTP服务" class="headerlink" title="5.1 什么是HTTP服务"></a>5.1 什么是 HTTP 服务</h2><p>一个网页请求，包含两次 HTTP 包交换</p><ul><li>浏览器向 HTTP 服务器发送请求 HTTP 包</li><li> HTTP 服务器向浏览器返回 HTTP 包</li></ul><h2 id="5-2-HTTP服务要做什么事情"><a href="#5-2-HTTP服务要做什么事情" class="headerlink" title="5.2 HTTP服务要做什么事情"></a>5.2 HTTP 服务要做什么事情</h2><ul><li>解析进来的 HTTP 请求报文</li><li>返回对应的 HTTP 返回报文 </li></ul><h2 id="5-3-实现一个简单的HTTP服务器"><a href="#5-3-实现一个简单的HTTP服务器" class="headerlink" title="5.3 实现一个简单的HTTP服务器"></a>5.3 实现一个简单的 HTTP 服务器</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const http = require('http')</span><br><span class="line">const fs = require('fs')</span><br><span class="line">http</span><br><span class="line">.createServer((req,res)=&gt;{</span><br><span class="line">    res.writeHead(200);</span><br><span class="line">    res.end('hello')</span><br><span class="line"></span><br><span class="line">})</span><br><span class="line">.listen(8888)</span><br></pre></td></tr></tbody></table></figure><h2 id="5-4-server端加载模版"><a href="#5-4-server端加载模版" class="headerlink" title="5.4 server端加载模版"></a>5.4 server 端加载模版</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const http = require('http')</span><br><span class="line">const fs = require('fs')</span><br><span class="line">http</span><br><span class="line">.createServer((req,res)=&gt;{</span><br><span class="line">    res.writeHead(200);</span><br><span class="line">    res.end('hello')</span><br><span class="line">    fs.createReadStream(__dirname + '/index.html')</span><br><span class="line">    .pipe(res)</span><br><span class="line"></span><br><span class="line">})</span><br><span class="line">.listen(8888)</span><br></pre></td></tr></tbody></table></figure><h3 id="5-5-游戏逻辑"><a href="#5-5-游戏逻辑" class="headerlink" title="5.5 游戏逻辑"></a>5.5 游戏逻辑</h3><p>index.js  <a href="https://github.com/maying2020/nodejs-in-action/tree/master/http/nodeNative">源码点击</a></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">const http = require("http");</span><br><span class="line">const fs = require("fs");</span><br><span class="line">const url = require("url");</span><br><span class="line">const querystring = require("queryString");</span><br><span class="line">const game = require("./game.js");</span><br><span class="line"></span><br><span class="line">let playerLastAction = null; //玩家上次出的</span><br><span class="line">let playerWon = 0; //玩家赢得次数</span><br><span class="line">let sameCount = 0; //统计相同操作统计次数</span><br><span class="line"></span><br><span class="line">http</span><br><span class="line">  .createServer((req, res) =&gt; {</span><br><span class="line">    // 通过内置模块url，转换发送到该http服务上的http请求包的url，</span><br><span class="line">    // 将其分割成 协议(protocol)://域名(host):端口(port)/路径名(pathname)?请求参数(query)</span><br><span class="line">    const parsedUrl = url.parse(req.url);</span><br><span class="line">    if (parsedUrl.pathname == "/game") {</span><br><span class="line">      const query = querystring.parse(parsedUrl.query);</span><br><span class="line">      // 玩家出的</span><br><span class="line">      const playerAction = query.action;</span><br><span class="line"></span><br><span class="line">      // 需求2:如果玩家赢了三次或者玩家作弊，则电脑不给他玩了</span><br><span class="line">      if (playerWon &gt;= 3 || sameCount == 9) {</span><br><span class="line">        res.writeHead(500);</span><br><span class="line">        res.end("我再也不和你玩了！");</span><br><span class="line">        return;</span><br><span class="line">      }</span><br><span class="line">      // 需求1:如果玩家操作连续三次相同，视为玩家作弊</span><br><span class="line">      if (playerLastAction &amp; (playerLastAction == playerAction)) {</span><br><span class="line">        sameCount++;</span><br><span class="line">      } else {</span><br><span class="line">        sameCount++;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      playerLastAction = playerAction;</span><br><span class="line"></span><br><span class="line">      if (sameCount &gt;= 3) {</span><br><span class="line">        res.writeHead(400);</span><br><span class="line">        res.end("你作弊");</span><br><span class="line">        // 将sameCount设置为9</span><br><span class="line">        sameCount = 9;</span><br><span class="line">        return;</span><br><span class="line">      }</span><br><span class="line">      // 执行游戏逻辑</span><br><span class="line">      var gameResult = game(playerAction);</span><br><span class="line">      res.writeHead(200);</span><br><span class="line">      if (gameResult == 0) {</span><br><span class="line">        res.end("平局！");</span><br><span class="line">      } else if (gameResult == 1) {</span><br><span class="line">        res.end("你赢了！");</span><br><span class="line">        // 玩家胜利次数统计+1</span><br><span class="line">        playerWon++;</span><br><span class="line">      } else {</span><br><span class="line">        res.end("你输了！");</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    // 如果请求url是浏览器icon，比如 http://localhost:3000/favicon.ico的情况</span><br><span class="line">    // 就返回一个200就好了</span><br><span class="line">    if (parsedUrl.pathname == "/favicon.ico") {</span><br><span class="line">      res.writeHead(200);</span><br><span class="line">      res.end();</span><br><span class="line">      return;</span><br><span class="line">    }</span><br><span class="line">    // 如果访问的是根路径，就把游戏页面读出来返回出去</span><br><span class="line">    if (parsedUrl.pathname == "/") {</span><br><span class="line">      fs.createReadStream(__dirname + "/index.html").pipe(res);</span><br><span class="line">    }</span><br><span class="line">  })</span><br><span class="line">  .listen(6001);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="6-使用express优化石头剪刀布游戏"><a href="#6-使用express优化石头剪刀布游戏" class="headerlink" title="6 使用express优化石头剪刀布游戏"></a>6 使用 express 优化石头剪刀布游戏</h1><h2 id="6-1-了解express"><a href="#6-1-了解express" class="headerlink" title="6.1 了解express"></a>6.1 了解 express</h2><p>要了解一个框架，最好的方法是 </p><ol><li>了解它的关键功能</li><li>推导出它要解决的问题是什么</li></ol><p>核心功能</p><ul><li>路由</li><li> request/response 简化<ul><li> request:pathname、query 等</li><li> response:send ()、json ()、jsonp () 等</li></ul></li><li>中间件<ul><li>更好地组织流程代码</li><li>异步会打破 Express 的洋葱模型</li></ul></li></ul><h2 id="6-2-游戏逻辑"><a href="#6-2-游戏逻辑" class="headerlink" title="6.2 游戏逻辑"></a>6.2 游戏逻辑</h2><p>index.js <a href="https://github.com/maying2020/nodejs-in-action/tree/master/http/express">源码点击</a></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">const fs = require("fs");</span><br><span class="line">const game = require("./game");</span><br><span class="line">const express = require("express");</span><br><span class="line"></span><br><span class="line">// 玩家胜利次数，如果超过3，则后续往该服务器的请求都返回500</span><br><span class="line">var playerWinCount = 0;</span><br><span class="line">// 玩家的上一次游戏动作</span><br><span class="line">var lastPlayerAction = null;</span><br><span class="line">// 玩家连续出同一个动作的次数</span><br><span class="line">var sameCount = 0;</span><br><span class="line"></span><br><span class="line">const app = express();</span><br><span class="line"></span><br><span class="line">// 通过app.get设定 /favicon.ico 路径的路由</span><br><span class="line">// .get 代表请求 method 是 get，所以这里可以用 post、delete 等。这个能力很适合用于创建 rest 服务</span><br><span class="line">app.get("/favicon.ico", function(request, response) {</span><br><span class="line">  // 一句 status(200) 代替 writeHead(200); end();</span><br><span class="line">  response.status(200);</span><br><span class="line">  return;</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">// 设定 /game 路径的路由</span><br><span class="line">app.get(</span><br><span class="line">  "/game",</span><br><span class="line"></span><br><span class="line">  function(request, response, next) {</span><br><span class="line">    if (playerWinCount &gt;= 3 || sameCount == 9) {</span><br><span class="line">      response.status(500);</span><br><span class="line">      response.send("我不会再玩了！");</span><br><span class="line">      return;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 通过next执行后续中间件</span><br><span class="line">    next();</span><br><span class="line"></span><br><span class="line">    // 当后续中间件执行完之后，会执行到这个位置</span><br><span class="line">    if (response.playerWon) {</span><br><span class="line">      playerWinCount++;</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line"></span><br><span class="line">  function(request, response, next) {</span><br><span class="line">    // express自动帮我们把query处理好挂在request上</span><br><span class="line">    const query = request.query;</span><br><span class="line">    const playerAction = query.action;</span><br><span class="line"></span><br><span class="line">    if (!playerAction) {</span><br><span class="line">      response.status(400);</span><br><span class="line">      response.send();</span><br><span class="line">      return;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    if (lastPlayerAction == playerAction) {</span><br><span class="line">      sameCount++;</span><br><span class="line">      if (sameCount &gt;= 3) {</span><br><span class="line">        response.status(400);</span><br><span class="line">        response.send("你作弊！我再也不玩了");</span><br><span class="line">        sameCount = 9;</span><br><span class="line">        return;</span><br><span class="line">      }</span><br><span class="line">    } else {</span><br><span class="line">      sameCount = 0;</span><br><span class="line">    }</span><br><span class="line">    lastPlayerAction = playerAction;</span><br><span class="line"></span><br><span class="line">    // 把用户操作挂在response上传递给下一个中间件</span><br><span class="line">    response.playerAction = playerAction;</span><br><span class="line">    next();</span><br><span class="line">  },</span><br><span class="line"></span><br><span class="line">  function(req, response) {</span><br><span class="line">    const playerAction = response.playerAction;</span><br><span class="line">    const result = game(playerAction);</span><br><span class="line"></span><br><span class="line">    // 如果这里执行setTimeout，会导致前面的洋葱模型失效</span><br><span class="line">    // 因为playerWon不是在中间件执行流程所属的那个事件循环里赋值的</span><br><span class="line">    // setTimeout(()=&gt; {</span><br><span class="line">    response.status(200);</span><br><span class="line">    if (result == 0) {</span><br><span class="line">      response.send("平局");</span><br><span class="line">    } else if (result == -1) {</span><br><span class="line">      response.send("你输了");</span><br><span class="line">    } else {</span><br><span class="line">      response.send("你赢了");</span><br><span class="line">      response.playerWon = true;</span><br><span class="line">    }</span><br><span class="line">    // }, 500)</span><br><span class="line">  }</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">app.get("/", function(request, response) {</span><br><span class="line">  // send接口会判断你传入的值的类型，文本的话则会处理为text/html</span><br><span class="line">  // Buffer的话则会处理为下载</span><br><span class="line">  response.send(fs.readFileSync(__dirname + "/index.html", "utf-8"));</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">app.listen(6001);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="7-使用koa优化石头剪刀布游戏"><a href="#7-使用koa优化石头剪刀布游戏" class="headerlink" title="7 使用koa优化石头剪刀布游戏"></a>7 使用 koa 优化石头剪刀布游戏</h1><h2 id="7-1-了解koa"><a href="#7-1-了解koa" class="headerlink" title="7.1 了解koa"></a>7.1 了解 koa</h2><p>核心功能:</p><ul><li>比 Express 更极致的 request/response 简化<ul><li> ctx.status=200</li><li>ctx.body=’helloworld’</li></ul></li><li>使用 async function 实现的中间件<ul><li>有 “暂停执行” 的能力</li><li>在异步的情况下也符合洋葱模型</li></ul></li><li>精简内核，所有额外功能都移到中间件里实现</li></ul><h2 id="7-2-Express-vs-Koa"><a href="#7-2-Express-vs-Koa" class="headerlink" title="7.2 Express vs Koa"></a>7.2 Express vs Koa</h2><ul><li>Express 门槛更低，Koa 更强大优雅。</li><li>Express 封装更多东西，开发更快速，Koa 可定制型更高</li></ul><h2 id="7-3-孰“优”孰“劣”"><a href="#7-3-孰“优”孰“劣”" class="headerlink" title="7.3 孰“优”孰“劣”"></a>7.3 孰 “优” 孰 “劣”</h2><ul><li>框架之间其实没有优劣之分</li><li>不同的框架有不同的适用场景</li></ul><h2 id="7-4-游戏逻辑"><a href="#7-4-游戏逻辑" class="headerlink" title="7.4 游戏逻辑"></a>7.4 游戏逻辑</h2><p>index.js <a href="https://github.com/maying2020/nodejs-in-action/tree/master/http/koa">源码点击</a></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">const fs = require("fs");</span><br><span class="line">const game = require("./game");</span><br><span class="line">const koa = require("koa");</span><br><span class="line">const mount = require("koa-mount");</span><br><span class="line"></span><br><span class="line">// 玩家胜利次数，如果超过3，则后续往该服务器的请求都返回500</span><br><span class="line">var playerWinCount = 0;</span><br><span class="line">// 玩家的上一次游戏动作</span><br><span class="line">var lastPlayerAction = null;</span><br><span class="line">// 玩家连续出同一个动作的次数</span><br><span class="line">var sameCount = 0;</span><br><span class="line"></span><br><span class="line">const app = new koa();</span><br><span class="line"></span><br><span class="line">app.use(</span><br><span class="line">  mount("/favicon.ico", function(ctx) {</span><br><span class="line">    // koa比express做了更极致的response处理函数</span><br><span class="line">    // 因为koa使用异步函数作为中间件的实现方式</span><br><span class="line">    // 所以koa可以在等待所有中间件执行完毕之后再统一处理返回值，因此可以用赋值运算符</span><br><span class="line">    ctx.status = 200;</span><br><span class="line">  })</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">const gameKoa = new koa();</span><br><span class="line">app.use(mount("/game", gameKoa));</span><br><span class="line">gameKoa.use(async function(ctx, next) {</span><br><span class="line">  if (playerWinCount &gt;= 3) {</span><br><span class="line">    ctx.status = 500;</span><br><span class="line">    ctx.body = "我不会再玩了！";</span><br><span class="line">    return;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  // 使用await 关键字等待后续中间件执行完成</span><br><span class="line">  await next();</span><br><span class="line"></span><br><span class="line">  // 就能获得一个准确的洋葱模型效果</span><br><span class="line">  if (ctx.playerWon) {</span><br><span class="line">    playerWinCount++;</span><br><span class="line">  }</span><br><span class="line">});</span><br><span class="line">gameKoa.use(async function(ctx, next) {</span><br><span class="line">  const query = ctx.query;</span><br><span class="line">  const playerAction = query.action;</span><br><span class="line">  if (!playerAction) {</span><br><span class="line">    ctx.status = 400;</span><br><span class="line">    return;</span><br><span class="line">  }</span><br><span class="line">  if (sameCount == 9) {</span><br><span class="line">    ctx.status = 500;</span><br><span class="line">    ctx.body = "我不会再玩了！";</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  if (lastPlayerAction == playerAction) {</span><br><span class="line">    sameCount++;</span><br><span class="line">    if (sameCount &gt;= 3) {</span><br><span class="line">      ctx.status = 400;</span><br><span class="line">      ctx.body = "你作弊！我再也不玩了";</span><br><span class="line">      sameCount = 9;</span><br><span class="line">      return;</span><br><span class="line">    }</span><br><span class="line">  } else {</span><br><span class="line">    sameCount = 0;</span><br><span class="line">  }</span><br><span class="line">  lastPlayerAction = playerAction;</span><br><span class="line">  ctx.playerAction = playerAction;</span><br><span class="line">  await next();</span><br><span class="line">});</span><br><span class="line">gameKoa.use(async function(ctx, next) {</span><br><span class="line">  const playerAction = ctx.playerAction;</span><br><span class="line">  const result = game(playerAction);</span><br><span class="line"></span><br><span class="line">  // 对于一定需要在请求主流程里完成的操作，一定要使用await进行等待</span><br><span class="line">  // 否则koa就会在当前事件循环就把http response返回出去了</span><br><span class="line">  await new Promise(resolve =&gt; {</span><br><span class="line">    setTimeout(() =&gt; {</span><br><span class="line">      ctx.status = 200;</span><br><span class="line">      if (result == 0) {</span><br><span class="line">        ctx.body = "平局";</span><br><span class="line">      } else if (result == -1) {</span><br><span class="line">        ctx.body = "你输了";</span><br><span class="line">      } else {</span><br><span class="line">        ctx.body = "你赢了";</span><br><span class="line">        ctx.playerWon = true;</span><br><span class="line">      }</span><br><span class="line">      resolve();</span><br><span class="line">    }, 500);</span><br><span class="line">  });</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">app.use(</span><br><span class="line">  mount("/", function(ctx) {</span><br><span class="line">    ctx.body = fs.readFileSync(__dirname + "/index.html", "utf-8");</span><br><span class="line">  })</span><br><span class="line">);</span><br><span class="line">app.listen(6001);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;以一种要开发 Node.js 实战项目为最终目标&lt;br&gt;进行一系列的技术预研过程&lt;/p&gt;
&lt;p&gt;有特点，有针对性，有目标&lt;/p&gt;
&lt;p&gt;培养 Node 领域的全局观&lt;/p&gt;
&lt;h1 id=&quot;1-关于Nodejs&quot;&gt;&lt;a href=&quot;#1-关于Nodejs&quot; class=&quot;headerlink&quot; title=&quot;1 关于Nodejs&quot;&gt;&lt;/a&gt;1 关于 Nodejs&lt;/h1&gt;&lt;h2 id=&quot;1-1-什么是Node-js&quot;&gt;&lt;a href=&quot;#1-1-什么是Node-js&quot; class=&quot;headerlink&quot; title=&quot;1.1 什么是Node.js&quot;&gt;&lt;/a&gt;1.1 什么是 Node.js&lt;/h2&gt;&lt;p&gt;官网的话：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Node.js 是基于 ChromeV8 执行引擎的 JS 运行时环境&lt;/li&gt;
&lt;li&gt; Node.js 使用了一个事件驱动，非阻塞式 I/O 的模型，使其轻量又高效&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每一个字其实都看得懂，聚合到一起就有点懵了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1584894283204&amp;amp;di=6e87b25c91207a1929250f11285d3a2c&amp;amp;imgtype=0&amp;amp;src=http://img2.biaoqingjia.com/biaoqing/201608/a70d12bb1f409850857c8d930cf2d6d1.gif&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们先不来说 nodejs 是什么，先根据以往的经验抛出问题&lt;/p&gt;
&lt;h3 id=&quot;1-1-1-在Node-js里运行Js跟在Chrome运行Js有啥不同？&quot;&gt;&lt;a href=&quot;#1-1-1-在Node-js里运行Js跟在Chrome运行Js有啥不同？&quot; class=&quot;headerlink&quot; title=&quot;1.1.1 在Node.js里运行Js跟在Chrome运行Js有啥不同？&quot;&gt;&lt;/a&gt;1.1.1 在 Node.js 里运行 Js 跟在 Chrome 运行 Js 有啥不同？&lt;/h3&gt;&lt;p&gt;已知 Chrome 浏览器用的是同样的 Javascript 引擎和模型&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;其实，在 Node.js 里写 Js 和在 Chrome 里写 Js，&lt;font color=&quot;red&quot;&gt;几乎一样&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;晃眼的&lt;font color=&quot;red&quot;&gt;几乎一样&lt;/font&gt; 那就是有不一样的地方呗！&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Nodejs 没有浏览器 API，即 (Document,window 等)&lt;/li&gt;
&lt;li&gt; 相应的，也增加了它专属的 API，比如文件系统，进程.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有了这些差别，其实就不难理解了&lt;/p&gt;
&lt;h4 id=&quot;对于开发者来说&quot;&gt;&lt;a href=&quot;#对于开发者来说&quot; class=&quot;headerlink&quot; title=&quot;对于开发者来说&quot;&gt;&lt;/a&gt;对于开发者来说&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;你在 chrome 里写 js &lt;strong&gt;控制浏览器&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt; Node.js 让你用类似的方式，&lt;strong&gt;控制整个计算机&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Node.js 的真谛，也就是官方抽象的释义，我们完全可以在不断深入的过程中慢慢理解～&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用 Node.js 逐步建立多路复用的 RPC 通道</title>
    <link href="http://maying.ink/2020/03/23/rpc/"/>
    <id>http://maying.ink/2020/03/23/rpc/</id>
    <published>2020-03-22T16:22:49.000Z</published>
    <updated>2020-10-22T18:41:42.185Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>依托 Nodejs 使用 <code>Buffer</code>  <code>net</code> 等模块逐步构建满足应用场景的 RPC 通道</p><h1 id="1-RPC调用"><a href="#1-RPC调用" class="headerlink" title="1. RPC调用"></a>1. RPC 调用</h1><p>RPC</p><p>全称 <code>Remote Procedure Call</code> 翻译成中文：远程过程调用</p><p>emm.. 我只是个小前端..</p><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1584877960225&amp;di=1beedaa2bf83dbc8d438dc36164af7d3&amp;imgtype=0&amp;src=http://img3.cache.netease.com/photo/0005/2013-02-20/8O5Q4R5K0AI90005.jpg" alt="image"></p><h2 id="1-1-如何通俗的解释是RPC？"><a href="#1-1-如何通俗的解释是RPC？" class="headerlink" title="1.1 如何通俗的解释是RPC？"></a>1.1 如何通俗的解释是 RPC？</h2><h3 id="1-1-1-本地过程调用"><a href="#1-1-1-本地过程调用" class="headerlink" title="1.1.1 本地过程调用"></a>1.1.1 本地过程调用</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我现在在家里，我需要洗衣服，就把衣服扔到洗衣机洗了</span><br></pre></td></tr></tbody></table></figure><h3 id="1-1-2-远程过程调用-RPC"><a href="#1-1-2-远程过程调用-RPC" class="headerlink" title="1.1.2 远程过程调用(RPC)"></a>1.1.2 远程过程调用 (RPC)</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我现在在逛街，我需要洗衣服，于是给在家里的男票打个哥电话，他把衣服扔到洗衣机洗了</span><br><span class="line"></span><br><span class="line">那么我就实现了RPC调用！！</span><br></pre></td></tr></tbody></table></figure><a id="more"></a><h2 id="1-2-从前端的角度上来理解RPC调用？"><a href="#1-2-从前端的角度上来理解RPC调用？" class="headerlink" title="1.2 从前端的角度上来理解RPC调用？"></a>1.2 从前端的角度上来理解 RPC 调用？</h2><p>从我们熟悉的 Ajax 入手，它与 RPC 调用类似，我们来对比一下</p><h3 id="1-2-1-相同点"><a href="#1-2-1-相同点" class="headerlink" title="1.2.1 相同点"></a>1.2.1 相同点</h3><h4 id="1-2-1-1-都是两个计算机之间的网络通信"><a href="#1-2-1-1-都是两个计算机之间的网络通信" class="headerlink" title="1.2.1.1 都是两个计算机之间的网络通信"></a>1.2.1.1 都是两个计算机之间的网络通信</h4><ul><li>Ajax：客户端和服务端的通信</li><li> PRC：服务器和另外一台服务器的通信</li></ul><p>看图说话</p><p><img src="http://cdn.anruence.com/rpc.png" alt="image"></p><h4 id="1-2-1-2-需要双方约定一个数据格式"><a href="#1-2-1-2-需要双方约定一个数据格式" class="headerlink" title="1.2.1.2 需要双方约定一个数据格式"></a>1.2.1.2 需要双方约定一个数据格式</h4><h3 id="1-2-2-不同点"><a href="#1-2-2-不同点" class="headerlink" title="1.2.2 不同点"></a>1.2.2 不同点</h3><h4 id="1-2-2-1-不一定使用DNS作为寻址服务"><a href="#1-2-2-1-不一定使用DNS作为寻址服务" class="headerlink" title="1.2.2.1 不一定使用DNS作为寻址服务"></a>1.2.2.1 不一定使用 DNS 作为寻址服务</h4><ul><li>Ajax 是发一个 HTTP 请求，使用 DNS 进行寻址服务</li></ul><p>请求过程<br><img src="http://cdn.anruence.com/dns.png" alt="image"></p><ul><li>RPC 通信一般是在内网进行请求，使用特有的服务（比如 id）<br>请求过程<br><img src="http://cdn.anruence.com/rpcxunzhi.png" alt="image"></li></ul><h4 id="1-2-2-2-应用层协议一般不使用HTTP"><a href="#1-2-2-2-应用层协议一般不使用HTTP" class="headerlink" title="1.2.2.2 应用层协议一般不使用HTTP"></a>1.2.2.2 应用层协议一般不使用 HTTP</h4><p>Ajax：使用 HTTP 文本协议（html,json）<br>RPC: 服务端之间的通信，对效率要求更高所以使用一些二进制协议取代 HTTP，二进制协议性能上存在优势</p><ul><li>更小的数据包</li><li>更快的编码速率</li></ul><h4 id="1-2-2-3-基于TCP-UDP协议"><a href="#1-2-2-3-基于TCP-UDP协议" class="headerlink" title="1.2.2.3 基于TCP/UDP协议"></a>1.2.2.3 基于 TCP/UDP 协议</h4><ul><li>浏览器调用（Ajax）使用 TCP 是遵循 HTTP 的规范</li><li> RPC 调用使用了 TCP 多种通信方式<ol><li>  单工通信（独木桥）</li></ol></li></ul><p>类比独木桥，两岸同一时间内只能有一方通过<br><img src="http://cdn.anruence.com/dangong.png" alt="image"><br>    1.   半双工通信（轮番单工通信，独木桥）</p><p><img src="http://cdn.anruence.com/banshuanggongtongxin.png" alt="image"><br>    1.   全双工通信<br><img src="http://cdn.anruence.com/quanshuanggongtongxiin.png" alt="image"></p><h2 id="2-使用Buffter编解码二进制数据包"><a href="#2-使用Buffter编解码二进制数据包" class="headerlink" title="2. 使用Buffter编解码二进制数据包"></a>2. 使用 Buffter 编解码二进制数据包</h2><p>用来处理 TCP 链接中的流以及文件系统中的数据</p><p><a href="http://nodejs.cn/api/buffer.html">Buffer 官方介绍</a></p><h3 id="2-1-buffter创建"><a href="#2-1-buffter创建" class="headerlink" title="2.1 buffter创建"></a>2.1 buffter 创建</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const buffter1 = Buffer.from('yishu')</span><br><span class="line">const buffter2 = Buffer.alloc(20)</span><br><span class="line">console.log(buffter1)</span><br><span class="line">console.log(buffter2)</span><br><span class="line"></span><br><span class="line">&lt;Buffer 79 69 73 68 75&gt;</span><br><span class="line">&lt;Buffer 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="2-2-buffter读写"><a href="#2-2-buffter读写" class="headerlink" title="2.2 buffter读写"></a>2.2 buffter 读写</h3><p>二进制协议：不同字段塞在二进制流中的不同位置</p><p>基本操作</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buffter2.writeInt8(12,1)</span><br></pre></td></tr></tbody></table></figure><p>图示编码二进制包<br><img src="http://cdn.anruence.com/lll.png" alt="image"></p><p><strong>图解：</strong><br>前三位代表一个字段，中间代表一个字段，后面又代表一个字段<br>所以，编码二进制包的时候，我们需要执行三次 write 写操作</p><p>看起来还是稍许麻烦嗷</p><p><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=908304341,3029384854&amp;fm=26&amp;gp=0.jpg" alt="image"></p><p>有木有像 Json 格式化方式如此简单的编码方式</p><p>答案：有！</p><p><a href="https://www.npmjs.com/package/protocol-buffers">protocol-buffers-npm 包</a></p><p>使用示例</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test.proto</span><br><span class="line"></span><br><span class="line">message Test {</span><br><span class="line">  required int32 id  = 1;</span><br><span class="line">  required string payload = 2;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>index.js</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const fs = require('fs');</span><br><span class="line">var protobuf = require('protocol-buffers')</span><br><span class="line"></span><br><span class="line">// pass a proto file as a buffer/string or pass a parsed protobuf-schema object</span><br><span class="line">var messages = protobuf(fs.readFileSync(__dirname + '/test.proto','utf-8'))</span><br><span class="line">var buf = messages.Test.encode({</span><br><span class="line">  id: 42,</span><br><span class="line">  payload: 'hello world'</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">console.log(buf) // should print a buffer</span><br><span class="line">{/* &lt;Buffer 08 2a 12 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64&gt; */}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.log(messages.Test.decode(buf))</span><br><span class="line">// { id: 42, payload: 'hello world' }</span><br></pre></td></tr></tbody></table></figure><p>明显发现</p><ul><li>更直观</li><li>更好维护</li><li>更便于合作</li></ul><p>正是所期盼的这样鸭～<br><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1584891026316&amp;di=474986ffbe473f99d8664a54b1f89076&amp;imgtype=0&amp;src=http://p5.pccoo.cn/winccoo/20170317/2017031716023399665328.gif" alt="image"></p><h2 id="3-建立多路复用的RPC通道"><a href="#3-建立多路复用的RPC通道" class="headerlink" title="3. 建立多路复用的RPC通道"></a>3. 建立多路复用的 RPC 通道</h2><h3 id="3-1-需求1-实现单工通信通道"><a href="#3-1-需求1-实现单工通信通道" class="headerlink" title="3.1 需求1 实现单工通信通道"></a>3.1 需求 1 实现单工通信通道</h3><p>client.js</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const net = require('net');</span><br><span class="line">const socket  = new net.Socket({});</span><br><span class="line"></span><br><span class="line">socket.connect({</span><br><span class="line">    host:'127.0.0.1',</span><br><span class="line">    port:6002</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">socket.write('good!maying')  //单工通信</span><br></pre></td></tr></tbody></table></figure><p>server.js</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const net = require('net');</span><br><span class="line"></span><br><span class="line">net.createServer((socket)=&gt;{</span><br><span class="line">    socket.on('data',function(buffer){</span><br><span class="line">        console.log('buffer',buffer,buffer.toString())</span><br><span class="line">    })</span><br><span class="line">})</span><br><span class="line">.listen(6002)</span><br></pre></td></tr></tbody></table></figure><p>得到结果</p><p><img src="http://cdn.anruence.com/goodmoring.png" alt="image"></p><p>这里实现了 TCP 通信方式之一 <font color="red">单工通信</font></p><h3 id="3-1-需求2-实现半双工通信通道"><a href="#3-1-需求2-实现半双工通信通道" class="headerlink" title="3.1 需求2 实现半双工通信通道"></a>3.1 需求 2 实现半双工通信通道</h3><h4 id="3-1-1-客户端和服务器有来有回"><a href="#3-1-1-客户端和服务器有来有回" class="headerlink" title="3.1.1 客户端和服务器有来有回"></a>3.1.1 客户端和服务器有来有回</h4><ul><li>客户端请求一个正常数据</li><li>服务端返回一个相应的数据</li></ul><h4 id="3-1-2-重点逻辑"><a href="#3-1-2-重点逻辑" class="headerlink" title="3.1.2 重点逻辑"></a>3.1.2 重点逻辑</h4><p>在单工通信模式下</p><ul><li>client 端：发请求数据，等到服务器端返回结果之后，再次请求</li><li> server 端：接收到请求后，匹配返回</li></ul><h4 id="3-1-3-代码"><a href="#3-1-3-代码" class="headerlink" title="3.1.3 代码"></a>3.1.3 代码</h4><p>client.js</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">const net = require('net');</span><br><span class="line"></span><br><span class="line">// 创建socket</span><br><span class="line">const socket = new net.Socket({});</span><br><span class="line"></span><br><span class="line">// 连接服务器</span><br><span class="line">socket.connect({</span><br><span class="line">    host: '127.0.0.1',</span><br><span class="line">    port: 6002</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const lessonids = [</span><br><span class="line">    "136797",</span><br><span class="line">    "136798",</span><br><span class="line">    "136799",</span><br><span class="line">    "136800",</span><br><span class="line">    "136801",</span><br><span class="line">    "136803",</span><br><span class="line">    "136804",</span><br><span class="line">    "136806",</span><br><span class="line">    "136807",</span><br><span class="line">    "136808",</span><br><span class="line">    "136809",</span><br><span class="line">    "141994",</span><br><span class="line">    "143517",</span><br><span class="line">    "143557",</span><br><span class="line">    "143564",</span><br><span class="line">    "143644",</span><br><span class="line">    "146470",</span><br><span class="line">    "146569",</span><br><span class="line">    "146582"</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">let id = Math.floor(Math.random() * lessonids.length);</span><br><span class="line"></span><br><span class="line">// 往服务器传数据</span><br><span class="line">socket.write(encode(id));</span><br><span class="line"></span><br><span class="line">socket.on('data', (buffer) =&gt; {</span><br><span class="line">    console.log(buffer.toString())</span><br><span class="line"></span><br><span class="line">    // 接收到数据之后，按照半双工通信的逻辑，马上开始下一次请求</span><br><span class="line">    id = Math.floor(Math.random() * lessonids.length);</span><br><span class="line">    socket.write(encode(id));</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">// 把编码请求包的逻辑封装为一个函数</span><br><span class="line">function encode(index) {</span><br><span class="line">    buffer = Buffer.alloc(4);</span><br><span class="line">    buffer.writeInt32BE(</span><br><span class="line">        lessonids[index]</span><br><span class="line">    );</span><br><span class="line">    return buffer;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>server.js</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">const net = require('net');</span><br><span class="line"></span><br><span class="line">// 创建tcp服务器</span><br><span class="line">const server = net.createServer((socket) =&gt; {</span><br><span class="line"></span><br><span class="line">    socket.on('data', function(buffer) {</span><br><span class="line">        // 从传来的buffer里读出一个int32</span><br><span class="line">        const lessonid = buffer.readInt32BE();</span><br><span class="line"></span><br><span class="line">        // 50毫秒后回写数据</span><br><span class="line">        setTimeout(()=&gt; {</span><br><span class="line">            socket.write(</span><br><span class="line">                Buffer.from(data[lessonid])</span><br><span class="line">            );</span><br><span class="line">        }, 50)</span><br><span class="line">    })</span><br><span class="line"></span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">// 监听端口启动服务</span><br><span class="line">server.listen(6002);</span><br><span class="line"></span><br><span class="line">const data = {</span><br><span class="line">    136797: "01 | 课程介绍",</span><br><span class="line">    136798: "02 | 内容综述",</span><br><span class="line">    136799: "03 | Node.js是什么？",</span><br><span class="line">    136800: "04 | Node.js可以用来做什么？",</span><br><span class="line">    136801: "05 | 课程实战项目介绍",</span><br><span class="line">    136803: "06 | 什么是技术预研？",</span><br><span class="line">    136804: "07 | Node.js开发环境安装",</span><br><span class="line">    136806: "08 | 第一个Node.js程序：石头剪刀布游戏",</span><br><span class="line">    136807: "09 | 模块：CommonJS规范",</span><br><span class="line">    136808: "10 | 模块：使用模块规范改造石头剪刀布游戏",</span><br><span class="line">    136809: "11 | 模块：npm",</span><br><span class="line">    141994: "12 | 模块：Node.js内置模块",</span><br><span class="line">    143517: "13 | 异步：非阻塞I/O",</span><br><span class="line">    143557: "14 | 异步：异步编程之callback",</span><br><span class="line">    143564: "15 | 异步：事件循环",</span><br><span class="line">    143644: "16 | 异步：异步编程之Promise",</span><br><span class="line">    146470: "17 | 异步：异步编程之async/await",</span><br><span class="line">    146569: "18 | HTTP：什么是HTTP服务器？",</span><br><span class="line">    146582: "19 | HTTP：简单实现一个HTTP服务器"</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><img src="http://cdn.anruence.com/half.gif" alt="image"></p><h3 id="3-2-需求1-实现全双工通信通道"><a href="#3-2-需求1-实现全双工通信通道" class="headerlink" title="3.2 需求1 实现全双工通信通道"></a>3.2 需求 1 实现全双工通信通道</h3><p>client 端自由发送数据包，无需等待 server 端返回</p><h4 id="3-2-1-解决半双工通信的问题"><a href="#3-2-1-解决半双工通信的问题" class="headerlink" title="3.2.1 解决半双工通信的问题"></a>3.2.1 解决半双工通信的问题</h4><ul><li>半双工通信进行并发容易导致请求包和响应包时序错乱</li></ul><p>看图解释一下</p><p><img src="http://cdn.anruence.com/qwwqw.png" alt="image"></p><ol><li>client 同时发送 id1，id2 的请求</li><li> server 端处理…</li><li>server 返回 id2 的处理结果</li><li> server 返回 id1 的处理结果</li></ol><p>client 端如何将两个请求和返回数据对应呢？</p><p>如果根据返回的时间来进行匹配，就会造成错乱</p><p><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2814248882,3142720346&amp;fm=26&amp;gp=0.jpg" alt="image"></p><p><font color="red">如何解决？</font></p><p>这正是全双工通信模式要解决的问题</p><p>将请求包和返回包都加上一个序号</p><p>就像下图这样</p><p><img src="http://cdn.anruence.com/sasasas.png" alt="image"></p><h4 id="3-2-2-重点逻辑"><a href="#3-2-2-重点逻辑" class="headerlink" title="3.2.2 重点逻辑"></a>3.2.2 重点逻辑</h4><p>在半双工通信模式下 </p><ul><li>client 端：增加 seq，为数据包绑定特有的 id buffer</li><li>server 端：在返回的数据包里绑定 id buffer</li></ul><h4 id="3-2-3-代码"><a href="#3-2-3-代码" class="headerlink" title="3.2.3 代码"></a>3.2.3 代码</h4><p>client.js</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const net = require('net');</span><br><span class="line">const socket  = new net.Socket({});</span><br><span class="line">let seq =  0;</span><br><span class="line">socket.connect({</span><br><span class="line">    host:'127.0.0.1',</span><br><span class="line">    port:6002</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">const LESSON_IDS = [</span><br><span class="line">    "136797",</span><br><span class="line">    "136798",</span><br><span class="line">    "136799",</span><br><span class="line">    "136800",</span><br><span class="line">    "136801",</span><br><span class="line">    "136803",</span><br><span class="line">    "136804",</span><br><span class="line">    "136806",</span><br><span class="line">    "136807",</span><br><span class="line">    "136808",</span><br><span class="line">    "136809",</span><br><span class="line">    "141994",</span><br><span class="line">    "143517",</span><br><span class="line">    "143557",</span><br><span class="line">    "143564",</span><br><span class="line">    "143644",</span><br><span class="line">    "146470",</span><br><span class="line">    "146569",</span><br><span class="line">    "146582"</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let index = Math.floor(Math.random() * LESSON_IDS.length);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">socket.on('data',(buffer)=&gt;{</span><br><span class="line">    const seqBuffer = buffer.slice(0,2);</span><br><span class="line">    const titleBuffer = buffer.slice(2);</span><br><span class="line"></span><br><span class="line">    console.log(seqBuffer.readInt16BE(),titleBuffer.toString())</span><br><span class="line">    // 请求回来之后再次发送</span><br><span class="line">    index = Math.floor(Math.random() * LESSON_IDS.length);</span><br><span class="line">    socket.write(encode(index));</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">function encode(index){</span><br><span class="line">    buffer = Buffer.alloc(6);</span><br><span class="line">    buffer.writeInt16BE(seq)</span><br><span class="line">    buffer.writeInt32BE(</span><br><span class="line">        LESSON_IDS[index],2</span><br><span class="line">    )</span><br><span class="line">    console.log('发包',seq,LESSON_IDS[index])</span><br><span class="line">    seq++;</span><br><span class="line">    return buffer;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">setInterval(() =&gt; {</span><br><span class="line">    index = Math.floor(Math.random() * LESSON_IDS.length);</span><br><span class="line">    socket.write(encode(index));</span><br><span class="line">}, 50);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// for(let k = 0;k&lt; 100; k++){</span><br><span class="line">//     index = Math.floor(Math.random() * LESSON_IDS.length);</span><br><span class="line">//     socket.write(encode(index));</span><br><span class="line">// }</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>server.js</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">const net = require('net');</span><br><span class="line"></span><br><span class="line">net.createServer((socket)=&gt;{</span><br><span class="line">    // socket.write</span><br><span class="line">    socket.on('data',function(buffer){</span><br><span class="line">        // console.log('buffer',buffer)</span><br><span class="line">        const seqBuffer = buffer.slice(0,2);</span><br><span class="line">        const lessonId = buffer.readInt32BE(2);</span><br><span class="line">        setTimeout(function(){</span><br><span class="line">        let buffer = Buffer.concat([</span><br><span class="line">            seqBuffer,</span><br><span class="line">            Buffer.from(LESSON_DATA[lessonId])</span><br><span class="line">        ])</span><br><span class="line">        socket.write(buffer)</span><br><span class="line">    },10+Math.random() * 1000)</span><br><span class="line">    })</span><br><span class="line">})</span><br><span class="line">.listen(6002)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 假数据</span><br><span class="line">const LESSON_DATA = {</span><br><span class="line">    136797: "01 | 课程介绍",</span><br><span class="line">    136798: "02 | 内容综述",</span><br><span class="line">    136799: "03 | Node.js是什么？",</span><br><span class="line">    136800: "04 | Node.js可以用来做什么？",</span><br><span class="line">    136801: "05 | 课程实战项目介绍",</span><br><span class="line">    136803: "06 | 什么是技术预研？",</span><br><span class="line">    136804: "07 | Node.js开发环境安装",</span><br><span class="line">    136806: "08 | 第一个Node.js程序：石头剪刀布游戏",</span><br><span class="line">    136807: "09 | 模块： CommonJS规范",</span><br><span class="line">    136808: "10 | 模块：使用模块规范改造石头剪刀布游戏",</span><br><span class="line">    136809: "11 | 模块：npm",</span><br><span class="line">    141994: "12 | 模块：Node.js内置模块",</span><br><span class="line">    143517: "13 | 异步：非阻塞I/O",</span><br><span class="line">    143557: "14 | 异步：异步编程之callback",</span><br><span class="line">    143564: "15 | 异步：事件循环",</span><br><span class="line">    143644: "16 | 异步：异步编程之Promise",</span><br><span class="line">    146470: "17 | 异步：异步编程之async/await",</span><br><span class="line">    146569: "18 | HTTP：什么是HTTP服务器？",</span><br><span class="line">    146582: "19 | HTTP：简单实现一个HTTP服务器"</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>得到结果</p><p><img src="http://cdn.anruence.com/gif5%E6%96%B0%E6%96%87%E4%BB%B6.gif" alt="image"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们在大量前置知识的基础上，一步步推导出了全双工通道的搭建，当然了，这是不完整的，还有一些情况需要处理<br>回顾一下全双工通道搭建过程</p><ul><li>关键在于应用层协议需要有标记包号的字段✅</li><li>处理以下情况，需要有标记包长的字段<ul><li>出现原因：TCP 底层优化机制，把同时发的一些包拼起来</li><li>粘包❎</li><li>不完整包❎</li></ul></li><li>错误处理<ul><li>网络等 </li></ul></li></ul><p>希望读完本文，你会对 RPC 通道有些粗浅的认识</p><p>未完待续..</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;依托 Nodejs 使用 &lt;code&gt;Buffer&lt;/code&gt;  &lt;code&gt;net&lt;/code&gt; 等模块逐步构建满足应用场景的 RPC 通道&lt;/p&gt;
&lt;h1 id=&quot;1-RPC调用&quot;&gt;&lt;a href=&quot;#1-RPC调用&quot; class=&quot;headerlink&quot; title=&quot;1. RPC调用&quot;&gt;&lt;/a&gt;1. RPC 调用&lt;/h1&gt;&lt;p&gt;RPC&lt;/p&gt;
&lt;p&gt;全称 &lt;code&gt;Remote Procedure Call&lt;/code&gt; 翻译成中文：远程过程调用&lt;/p&gt;
&lt;p&gt;emm.. 我只是个小前端..&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1584877960225&amp;amp;di=1beedaa2bf83dbc8d438dc36164af7d3&amp;amp;imgtype=0&amp;amp;src=http://img3.cache.netease.com/photo/0005/2013-02-20/8O5Q4R5K0AI90005.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-1-如何通俗的解释是RPC？&quot;&gt;&lt;a href=&quot;#1-1-如何通俗的解释是RPC？&quot; class=&quot;headerlink&quot; title=&quot;1.1 如何通俗的解释是RPC？&quot;&gt;&lt;/a&gt;1.1 如何通俗的解释是 RPC？&lt;/h2&gt;&lt;h3 id=&quot;1-1-1-本地过程调用&quot;&gt;&lt;a href=&quot;#1-1-1-本地过程调用&quot; class=&quot;headerlink&quot; title=&quot;1.1.1 本地过程调用&quot;&gt;&lt;/a&gt;1.1.1 本地过程调用&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;我现在在家里，我需要洗衣服，就把衣服扔到洗衣机洗了&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;1-1-2-远程过程调用-RPC&quot;&gt;&lt;a href=&quot;#1-1-2-远程过程调用-RPC&quot; class=&quot;headerlink&quot; title=&quot;1.1.2 远程过程调用(RPC)&quot;&gt;&lt;/a&gt;1.1.2 远程过程调用 (RPC)&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;我现在在逛街，我需要洗衣服，于是给在家里的男票打个哥电话，他把衣服扔到洗衣机洗了&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;那么我就实现了RPC调用！！&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="前端" scheme="http://maying.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Node.js" scheme="http://maying.ink/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>重构前端体系系列 - 构建前端知识架构</title>
    <link href="http://maying.ink/2020/03/12/relearning_front-end/"/>
    <id>http://maying.ink/2020/03/12/relearning_front-end/</id>
    <published>2020-03-12T09:36:23.000Z</published>
    <updated>2020-10-22T18:51:11.112Z</updated>
    
    <content type="html"><![CDATA[<h2 id="重新理解前端"><a href="#重新理解前端" class="headerlink" title="重新理解前端"></a>重新理解前端</h2><p>前端工程师已经成为研发体系中重要的岗位，但与此相对是大部分前端工程师的知识其实都是来自于实践和工作中零散的学习，这个现状就引发了一系列的问题</p><ul><li>前端的基础知识薄弱：散点自学 + 基础不牢 </li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基础知识的欠缺会让你束手束脚，更限制你解决问题的思路</span><br></pre></td></tr></tbody></table></figure><ul><li>技术上存在短板，就会导致前端开发者的上升通道不甚顺畅 </li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小公司的程序员，只能靠自己摸索，这样就很容易陷入重复性劳动的陷阱，最终耽误自己的职业发展</span><br></pre></td></tr></tbody></table></figure><ul><li>前端工程师也会面临技术发展问题带来的挑战 </li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">前端社区高度活跃，前端标准也在快速更新，这样蓬勃发展对技术来说无疑是好事，但是副作用也显而易见，它使得前端工程师的学习压力变得很大。</span><br></pre></td></tr></tbody></table></figure><p>大部分人学前端的方式是 “土法学前端”，他们对于知识的理解基本都停留在点上，从来没有大范围把这些点串成线，形成自己的知识体系，因此才会出现遗漏和盲点</p><a id="more"></a><h3 id="前端工程师的成长视角"><a href="#前端工程师的成长视角" class="headerlink" title="前端工程师的成长视角"></a>前端工程师的成长视角</h3><ul><li>是立足标准，系统性总结和整理前端知识，建立自己的认知和方法论</li><li>是放眼团队，从业务和工程角度思考前端团队的价值和发展需要。只有这样做，才能够持续发展，在高速发展的技术和工程浪潮中稳稳立足</li><li>以完备、体系化的方式理解和思考前端的基础知识和工程实践</li></ul><p>事实上，前端的能力可以带来更多的业务场景，这些有待于我们去发掘<br>建立自己的知识体系和方法论，才能够保持领先优势</p><h2 id="明确前端的学习路线和方法"><a href="#明确前端的学习路线和方法" class="headerlink" title="明确前端的学习路线和方法"></a>明确前端的学习路线和方法</h2><h3 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h3><ul><li>摸索出适合你自己的前端学习方法</li><li>帮助建立前端技术的知识架构</li><li>理解前端技术背后的核心思想</li></ul><h3 id="前端学习方法"><a href="#前端学习方法" class="headerlink" title="前端学习方法"></a>前端学习方法</h3><h4 id="建立知识架构"><a href="#建立知识架构" class="headerlink" title="建立知识架构"></a>建立知识架构</h4><ul><li>学习的过程实际上就是知识架构不断进化的过程</li><li>通过知识架构的自然延伸，我们可以更轻松地记忆一些原本难以记住的点，还可以发现被忽视的知识盲点</li><li>建立知识架构同样利于面试</li></ul><h4 id="追本溯源"><a href="#追本溯源" class="headerlink" title="追本溯源"></a>追本溯源</h4><ul><li>有一些知识，背后有一个很大的体系</li><li>关注技术提出来的背景，找到知识的源头</li><li>关注原始的论文或者文章，关注作者说的话</li></ul><p>比如 关注 scheme，Java 与 JS 语言的异同</p><h2 id="前端知识图谱"><a href="#前端知识图谱" class="headerlink" title="前端知识图谱"></a>前端知识图谱</h2><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>用一定的词法和语法，表达一定语义，从而操作运行时</p><p>所以分为以下三个部分</p><ul><li>运行时</li><li>文法</li><li>语义</li></ul><p><img src="http://cdn.anruence.com/js%E5%9B%BE.png" alt="image"></p><h3 id="HTML-和-CSS"><a href="#HTML-和-CSS" class="headerlink" title="HTML 和 CSS"></a>HTML 和 CSS</h3><p>HTML 的功能主要由标签来承担，所以我们首先会把标签做一些分类</p><ul><li>文档元信息：通常是出现在 head 标签中的元素，包含了描述文档自身的一些信息；</li><li>语义相关：扩展了纯文本，表达文章结构、不同语言要素的标签；</li><li>链接：提供到文档内和文档外的链接；</li><li>替换型标签：引入声音、图片、视频等外部元素替换自身的一类标签；</li><li>表单：用于填写和提交信息的一类标签</li><li>表格：表头、表尾、单元格等表格的结构</li></ul><p><img src="http://cdn.anruence.com/html%E5%9B%BE.png" alt="image"></p><h3 id="浏览器的实现原理和-API"><a href="#浏览器的实现原理和-API" class="headerlink" title="浏览器的实现原理和 API"></a>浏览器的实现原理和 API</h3><p><img src="http://cdn.anruence.com/liulanqi.png" alt="image"></p><h3 id="前端工程实践"><a href="#前端工程实践" class="headerlink" title="前端工程实践"></a>前端工程实践</h3><p><img src="http://cdn.anruence.com/qianduangongcheng.jpg" alt="image"></p><h3 id="前端知识架构"><a href="#前端知识架构" class="headerlink" title="前端知识架构"></a>前端知识架构</h3><p><img src="http://cdn.anruence.com/qiandaunzhishikuangjia.png" alt="image"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>建立一个理解前端的全景图<br>这样，任何时候都能够体系地思考问题，分析问题，解决问题！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;重新理解前端&quot;&gt;&lt;a href=&quot;#重新理解前端&quot; class=&quot;headerlink&quot; title=&quot;重新理解前端&quot;&gt;&lt;/a&gt;重新理解前端&lt;/h2&gt;&lt;p&gt;前端工程师已经成为研发体系中重要的岗位，但与此相对是大部分前端工程师的知识其实都是来自于实践和工作中零散的学习，这个现状就引发了一系列的问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前端的基础知识薄弱：散点自学 + 基础不牢 &lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;基础知识的欠缺会让你束手束脚，更限制你解决问题的思路&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;技术上存在短板，就会导致前端开发者的上升通道不甚顺畅 &lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;小公司的程序员，只能靠自己摸索，这样就很容易陷入重复性劳动的陷阱，最终耽误自己的职业发展&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;前端工程师也会面临技术发展问题带来的挑战 &lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;前端社区高度活跃，前端标准也在快速更新，这样蓬勃发展对技术来说无疑是好事，但是副作用也显而易见，它使得前端工程师的学习压力变得很大。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;大部分人学前端的方式是 “土法学前端”，他们对于知识的理解基本都停留在点上，从来没有大范围把这些点串成线，形成自己的知识体系，因此才会出现遗漏和盲点&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://maying.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端体系" scheme="http://maying.ink/tags/%E5%89%8D%E7%AB%AF%E4%BD%93%E7%B3%BB/"/>
    
  </entry>
  
  <entry>
    <title>面向未来的 API-GraphQL</title>
    <link href="http://maying.ink/2019/12/23/GraphQL/"/>
    <id>http://maying.ink/2019/12/23/GraphQL/</id>
    <published>2019-12-23T08:59:30.000Z</published>
    <updated>2020-10-22T18:41:42.179Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p>你有没有遇到以下问题</p><ul><li>字段冗余</li></ul><p><img src="http://cdn.anruence.com/%E7%A3%90%E7%9F%B3%E6%95%B0%E6%8D%AE.png" alt="image"></p><ul><li>若干个不得不发的 HTTP 请求</li></ul><p><img src="http://cdn.anruence.com/graphql1.png" alt="image"></p><p>发生这些，并不是前端 er 本意，但是又要承担诸如页面渲染慢等副作用而被用户诟病<br>究其原因，是前端在数据层面没有主动权</p><p>针对但不限于以上种种<br>我们需要以前端的设计者和开发者的角度出发 设计新的数据查询方式</p><p>Facebook 工程师率先提出 RESTful 架构体系的替代方案</p><p>并且应用在了其应用中</p><p><a href="https://www.youtube.com/watch?v=WxPtYJRjLL0&amp;t=2s">Facebook 使用 graphql 重构他们的 pc 站</a></p><p>接下来 让我们站在巨人的肩膀上，由浅至深聊聊被称之为面向未来的 API 的 - GraphQL</p><a id="more"></a><h1 id="明确本文的边界"><a href="#明确本文的边界" class="headerlink" title="明确本文的边界"></a>明确本文的边界</h1><p>本文主要介绍接触 GraphQL 这段时间，觉得必须要掌握的一些核心 适合以下人群</p><ul><li>完全没听说过 GraphQL</li><li> 听说过 GraphQL 的读者，想深入了解一下</li><li>想系统地学习 GraphQL 的读者</li><li>正在调研 GraphQL 技术的读者</li></ul><p>帮助你对 GraphQL 建立一个统观全局的认知及原理性的解读</p><p>你可能会得到以下解答</p><ul><li>重新思考 RESTful</li><li>what GraphQL</li><li>RESTful &amp; GraphQL</li><li>how GraphQL</li><li>GraphQL 组成链路</li><li>阻碍你使用 GraphQL 的 N 个问题</li><li>现有应用的接入方式</li><li> GraphQL 不足</li><li>基于 GraphQL 的社区解决方案</li><li>小结</li></ul><h1 id="重新思考RESTful"><a href="#重新思考RESTful" class="headerlink" title="重新思考RESTful"></a>重新思考 RESTful</h1><ul><li>接口数膨胀，需自行组合多个接口才能获取到完整的数据结构</li><li> API 文档更新不及时，联调基本靠猜</li><li>客户端对接口数据类型校验 </li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 除了服务端要校验客户端传来的参数，客户端自己也需要去校验服务端返回的参数</span><br><span class="line">- 比如客户端要的是数组，你有没有返回数组</span><br><span class="line">- 需要依赖类似出var x = data?(data.obj?data.obj.name:null):null兼容</span><br></pre></td></tr></tbody></table></figure><ul><li>接口字段冗余，移动 / PC 需求无法满足 </li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 冗余数据的返回浪费了流量</span><br><span class="line">- 服务端决定有哪些数据获取方式，客户端只能挑选使用，如果数据过于冗余也只能默默接收再对数据进行处理</span><br><span class="line">- 而数据不能满足需求则需要请求更多的接口</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ul><li>前后端字段命名规范不一致，</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">依赖数据层逐量转换</span><br></pre></td></tr></tbody></table></figure><ul><li>维护多版本接口 </li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">任何的变动都会被视为一种破坏性的改变，而破坏性改变就需要更新API的版本</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="我的诉求"><a href="#我的诉求" class="headerlink" title="我的诉求"></a>我的诉求</h2><ol><li>可不可以客户端要什么字段，服务端就给什么字段的值？</li><li>可不可以定义一个返回数据格式与请求的数据格式的一个强类型的约束？</li><li>能不能客户端可以问服务端要 1、2、3 这些数据，服务端一次给我返回就行？</li></ol><p>GraphQL 的出现就是为了解决 RESTful 的痛点</p><h1 id="what-GraphQL"><a href="#what-GraphQL" class="headerlink" title="what GraphQL"></a>what GraphQL</h1><p><a href="http://graphql.org/">GraphQl 官网</a></p><p><a href="https://graphql.cn/">GraphQL 中文网</a></p><blockquote><p>它既是一种用于 API 的查询语言 (规范) 也是一个满足你数据查询的运行时</p></blockquote><p>强类型可以在查询执行之前进行验证</p><p>用于组织应用程序中数据的创建，读取，更新和删除（是的，CRUD）</p><p>脑袋里巨大的问号❓ API 怎么就可以查询呢？</p><p>这正是其强大之处</p><blockquote><p>ask exactly what you want.</p></blockquote><ul><li>用已有的代码和技术来进行数据源管理</li><li>对 API 数据提供了一套易于理解的完整描述</li><li>非数据库查询语言，不是一门语言 / 框架 </li><li>不绑定任何的数据库或者存储引擎</li><li>使得客户端能按需获取数据，无冗余</li><li>让 API 更容易随着时间推移而演进</li><li> GraphQL = Graph (图表化 / 可视化)+ QL (查询语言)</li><li> 是一种描述客户端如何向服务端请求数据的 API 语法</li></ul><h1 id="RESTful-amp-GraphQL"><a href="#RESTful-amp-GraphQL" class="headerlink" title="RESTful &amp; GraphQL"></a>RESTful &amp; GraphQL</h1><h2 id="资源获取"><a href="#资源获取" class="headerlink" title="资源获取"></a>资源获取</h2><p><img src="http://cdn.anruence.com/rest.png" alt="image"></p><ul><li>RESTful 用不同 URL 来区分资源，GraphQL 用特有的类型区分资源</li><li>获取相同资源 REST API 需要聚合多个接口</li><li>获取相同资源 GraphQL 只需一次请求获取多组数据</li><li> GraphQL 更有效率更强大更灵活，对前端更友好</li></ul><h2 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h2><p><img src="http://cdn.anruence.com/graphql%20%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96.png" alt="image"></p><ul><li>获取数据的方式由 == 这里有什么 == 向 == 你需要什么 == 转变 </li><li>GraphQL 可以简化理解成一个灵活的 ajax 接口</li><li>客户端完全自主决定获取信息的内容，服务端负责精确的返回目标数据</li></ul><h2 id="GraphQL优点"><a href="#GraphQL优点" class="headerlink" title="GraphQL优点"></a>GraphQL 优点</h2><ul><li>请求你所要的数据，不多不少 </li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 向你的 API 发出一个 GraphQL 请求就能准确获得你想要的数据，不多不少。</span><br><span class="line">- GraphQL 查询总是返回可预测的结果。使用 GraphQL 的应用可以工作得又快又稳，因为控制数据的是应用，而不是服务器。</span><br></pre></td></tr></tbody></table></figure><p><img src="http://cdn.anruence.com/graphql-fetchdata.png" alt="image"></p><ul><li>获取多个资源，只需要一个请求 </li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- GraphQL 查询不仅能够获得资源的属性，还能沿着资源间引用进一步查询</span><br><span class="line">- 典型的 REST API 请求多个资源时得载入多个 URL</span><br><span class="line">- GraphQL 可以通过一次请求就获取你应用所需的所有数据</span><br><span class="line">- 即使是比较慢的移动网络连接下，使用 GraphQL 的应用也能表现得足够迅速。</span><br></pre></td></tr></tbody></table></figure><p><img src="http://cdn.anruence.com/graphQL-huoqu.png" alt="image"></p><ul><li>描述所有可能的类型系统（强类型自身）</li></ul><p>强类型可以在查询执行之前进行验证</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- GraphQL API 基于类型和字段的方式进行组织，而非入口端点</span><br><span class="line">- 你可以通过一个单一入口端点得到你所有的数据能力</span><br><span class="line">- GraphQL 使用类型来保证应用只请求可能的数据</span><br><span class="line">- 还提供了清晰的辅助性错误信息</span><br><span class="line">- 应用可以使用类型，而避免编写手动解析代码。</span><br></pre></td></tr></tbody></table></figure><ul><li>强大的开发者工具 </li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 代码即文档</span><br><span class="line">- 不用离开编辑器就能准确知道你可以从 API 中请求的数据</span><br><span class="line">- 发送查询之前就能高亮潜在问题，高亮代码智能提示</span><br><span class="line">- 提供了GraphiQL图形界面编写可测试的查询语句</span><br></pre></td></tr></tbody></table></figure><ul><li>无版本约束 平滑演进（<font color="red">GraphQL 的设计精髓</font>）</li></ul><blockquote><p>由于仅返回明确的请求数据，所以设计良好的「GraphQL API」不存在「接口突变」的情况，这是从「版本化」到「无版本」的一个明确转变！</p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 给你的 GraphQL API 添加字段和类型而无需影响现有查询</span><br><span class="line">- 老旧的字段可以废弃，从工具中隐藏</span><br><span class="line">- 通过使用单一演进版本，GraphQL API 使得应用始终能够使用新的特性，并鼓励使用更加简洁、更好维护的服务端代码</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="GraphQL改善RESTful"><a href="#GraphQL改善RESTful" class="headerlink" title="GraphQL改善RESTful"></a>GraphQL 改善 RESTful</h1><p>了解了 GraphQL 的一大堆特点，我们开篇的诉求解决了吗？</p><p><img src="http://cdn.anruence.com/graphql99.png" alt="image"></p><p>到这里 我们看到了 GraphQL 原则上的可行性</p><h1 id="How-GraphQL"><a href="#How-GraphQL" class="headerlink" title="How GraphQL"></a>How GraphQL</h1><p>接下来 趁热打铁 来聊聊怎么用 GraphQL</p><p><img src="http://cdn.anruence.com/graphql-banner.png" alt="image"></p><p>官网上特别醒目的一张图，我们可以得到如下信息</p><ul><li>服务端定义好强类型的数据入参和返回的数据结构</li><li>客户端发送一个带有查询语句（GraphQL 查询协议）的请求，定义好返回数据的格式及类型</li><li>返回符合客户端预期的 Json 字符串结果</li></ul><p><font color="red">再通俗一点</font></p><p>我们拥有 UI，并且需要用数据填充它，因此我们向服务器进行查询<br>使用传统的 REST API，我们的查询将以 GET 请求的形式出现 借助 GraphQL，我们引入了一种用于请求数据的新语法</p><h3 id="一个基础的GraphQL服务"><a href="#一个基础的GraphQL服务" class="headerlink" title="一个基础的GraphQL服务"></a>一个基础的 GraphQL 服务</h3><h4 id="GraphQL服务-类型（schema）-解析器-（resolve）"><a href="#GraphQL服务-类型（schema）-解析器-（resolve）" class="headerlink" title="GraphQL服务 = 类型（schema） + 解析器 （resolve）"></a>GraphQL 服务 = 类型（schema） + 解析器 （resolve）</h4><p>明确以下知识点</p><ul><li>为了发出 GraphQL 请求，我们需要有一个 GraphQL 服务器</li><li> GraphQL 服务器是附加了 GraphQL 模式的常规 HTTP 服务器</li><li>类型系统描述了数据的类型与结构，但它只是形状，不包含真正的数据</li><li>通过编写 Resolver 函数，从而去获取真正的数据</li></ul><p><img src="http://cdn.anruence.com/graphQL%20lizi.png" alt="image"></p><ul><li>服务端（或中间层）需要描述所有可能的类型系统（schema）</li></ul><p><img src="http://cdn.anruence.com/graphql.png" alt="image"></p><ul><li>按你所需请求你所需要的数据，解决了不同客户端不同的渲染需求</li></ul><p>是不是贼简单～</p><p>不知道你没有注意到 上面我们提到了<font color="red"> GraphQL 查询协议</font></p><h2 id="GraphQL查询协议"><a href="#GraphQL查询协议" class="headerlink" title="GraphQL查询协议"></a>GraphQL 查询协议</h2><p>GraphQL 有三种请求方式</p><ul><li>query (请求)   </li><li>mutation (修改)</li><li>subscribe (订阅)</li></ul><p>GraphQL 的核心依赖于简单的 GET 或 POST 请求来将数据往返于客户端，而 GraphQL 只是一个经过修饰的 GET 或 POST 请求，通过 <a href="https://myapp.com/graphql">https://myapp.com/graphql</a><br>之类的 URL 发送到 GraphQL 服务器</p><p>是的，虽然 GraphQL 确实引入了一些新的概念来组织数据进行交互，但在幕后，但 GraphQL 仍然依靠良好的 HTTP 请求来实现其神奇效果</p><p>只需要为类型系统的字段编写函数，GraphQL 就能通过优化并发的方式来调用它们</p><p>具体参照如上的 demo，建议拷贝代码亲自感受一下</p><h1 id="GraphQL组成链路"><a href="#GraphQL组成链路" class="headerlink" title="GraphQL组成链路"></a>GraphQL 组成链路</h1><p>当然了 对于开发者来说，我们无非关注两点</p><ul><li>客户端做什么？</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">向服务端发送查询字符串</span><br></pre></td></tr></tbody></table></figure><ul><li>服务端做什么？</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">基于GraphQL构建类型系统 </span><br><span class="line">定义与Query下字段对应的resolver</span><br><span class="line">可以在resolver获取真正的数据</span><br></pre></td></tr></tbody></table></figure><h2 id="资源路径图"><a href="#资源路径图" class="headerlink" title="资源路径图"></a>资源路径图</h2><p><img src="http://cdn.anruence.com/ziyuanlujing.png" alt="image"></p><p>客户端 Schema 本质上就是一段字符串，服务端如何识别并响应这段字符串？</p><h2 id="服务端执行过程"><a href="#服务端执行过程" class="headerlink" title="服务端执行过程"></a>服务端执行过程</h2><p><img src="http://cdn.anruence.com/%E6%9C%8D%E5%8A%A1%E7%AB%AF.png" alt="image"></p><p>拿到客户端字符串之后，依赖官方类库 graphql-js, 服务端具体执行经历三个阶段</p><ul><li>解析：逐字符扫描，如果不符合服务端定义的 AST 规范，解析过程会直接跑出语法异常，当然了，是结构化报错</li><li>校验：发起了查询，GraphQL 会解析我们的查询语句，确保啊我们查询的结构是存在的，参数是足够的，类型是一致的，任何环节出了问题，都将返回错误信息</li><li>执行：验证通过后，GraphqL 会根据 query 语句包含的字段结构一一触发对应的 Resolver 函数，获取查询结果，也就是说 如果前端没有查询某个字段，就不会触发该字段对应的 Resolver 函数，也就不会产生对数据的获取行为</li></ul><p>注：如果 Reaolver 返回的数据结构，大于 Schema 里描绘的结构，那么多出来的部分会被忽略，这是一个合理的设计，我们可以通过控制 Schema 来控制前端的数据访问权限，防止意外的将用户的隐私信息泄漏出去 </p><h1 id="阻碍你使用GraphQL的N个问题"><a href="#阻碍你使用GraphQL的N个问题" class="headerlink" title="阻碍你使用GraphQL的N个问题"></a>阻碍你使用 GraphQL 的 N 个问题</h1><p>既然 GraphQL 那么方便，为啥没有大火呢？<br>结合了多篇文章，整理了若干了阻止你使用 GraphQL 的 N 个问题</p><p>一起来看一看</p><h2 id="GraphQL一定要操作数据库？"><a href="#GraphQL一定要操作数据库？" class="headerlink" title="GraphQL一定要操作数据库？"></a>GraphQL 一定要操作数据库？</h2><ul><li>数据提供方编写 GraphQL Schema</li><li> 数据消费方编写 GraphQL Query</li><li>GraphQL 只是关于 schema 和 resolver 的一一对应和调用，它并为对数据的获取方式和来源做任何假设</li></ul><h2 id="GraphQL-跟-RESTful-api-是对立的？"><a href="#GraphQL-跟-RESTful-api-是对立的？" class="headerlink" title="GraphQL 跟 RESTful api 是对立的？"></a>GraphQL 跟 RESTful api 是对立的？</h2><p>两者不仅不是对立的，还可以相互结合<br>事实上可以把 Query 下的字段，理解为一个个 RESTful API</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Query {</span><br><span class="line">   hello: String,</span><br><span class="line">   sayhi:String</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure><h2 id="GraphQL不一定需要Schema（类型系统）？"><a href="#GraphQL不一定需要Schema（类型系统）？" class="headerlink" title="GraphQL不一定需要Schema（类型系统）？"></a>GraphQL 不一定需要 Schema（类型系统）？</h2><ul><li>GraphQL Type System 是一个静态的类型系统，我们可以称之为静态类型 GraphQL</li><li> 此外，社区还有一种动态类型的 GraphQL 实践，它跟静态类型的 GraphQL 差别在于，没有了基于 Schema 的数据形状验证阶段，而是直接无脑地根据 query 查询语句里的字段，去触发 Resolver 函数，动态类型的 GraphQL 有一定的便利性，不过，它同时丧失了 GraphQL 的部分精髓</li></ul><h2 id="GraphQL-一定是后端服务？"><a href="#GraphQL-一定是后端服务？" class="headerlink" title="GraphQL 一定是后端服务？"></a>GraphQL 一定是后端服务？</h2><p>尽管绝大多数 GraphQL，都以 server 的形式存在。&nbsp;但它并没有限制在后端场景</p><p> <a href="https://codesandbox.io/s/youthful-mestorf-r8s38">在浏览器中运行</a> </p><h1 id="现有应用的接入方式"><a href="#现有应用的接入方式" class="headerlink" title="现有应用的接入方式"></a>现有应用的接入方式</h1><h2 id="暴力改造RESTful-Like模式"><a href="#暴力改造RESTful-Like模式" class="headerlink" title="暴力改造RESTful-Like模式"></a>暴力改造 RESTful-Like 模式</h2><p>RESTful -&gt; GraphQL</p><ul><li>就是简单粗暴的把 RESTful API 服务，替换成 GraphQL 实现。之前有多少 RESTful 服务，重构后就有多少 GraphQL 服务，</li><li>默认情况下，面向两个 GraphQL 服务发起的查询是两次请求，而不是一次 </li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">前端需要产品数据时，从之前调用产品相关的 RESTful API，变成查询产品相关的 GraphQL。不过，需要订单相关的数据时，可能要查询另一个 GraphQL 服务</span><br></pre></td></tr></tbody></table></figure><ul><li>它是一个简单的一对一关系</li></ul><p>收益甚微 选型失误</p><h2 id="作为中间层"><a href="#作为中间层" class="headerlink" title="作为中间层"></a>作为中间层</h2><p>同样是 API Gateway 角色的 GraphQL 服务，在实现方式上有不同的分类 </p><ul><li>1，传统意义上的后端服务（包含大量真实的数据操作和处理的 GraphQL）</li><li>2，<font color="red">GraphQL as BFF</font>（转发接口请求，聚合数据结果的 GraphQL）</li></ul><p>我们今天主要讨论 第二种</p><p><img src="http://cdn.anruence.com/%E6%8E%A5%E5%85%A5%E6%96%B9%E5%BC%8F.png" alt="image"></p><ul><li>前端不再直接调用具体的 RESTful 等接口，而是通过 GraphQL 去间接获取产品、订单、搜索等数据</li><li>在 GraphQL 这个中间层里，我们将各个微服务，按照它们的数据关联，整合成一个基于 GraphQL Schema 的数据关系网络。前端可以通过 GraphQL 查询语句，同时发起对多个微服务的数据的获取、筛选、裁剪等行为。</li><li>作为 API Gateway 的 GraphQL 服务，可以在其 Resolver 内，向前面提到的 RESTful-like 的 GraphQL 发起查询请求</li><li>既避免了前端需要一对多的问题，也解决了 API Gateway GraphQL 需要请求 RESTful 全量数据接口的内部冗余问题</li></ul><p><img src="http://cdn.anruence.com/airbnb.png" alt="image"></p><p>将 GraphQL schemas 转化为 Thhrift IDL，再统一操作底层数据</p><p><img src="http://cdn.anruence.com/%E5%BE%AE%E6%9C%8D%E5%8A%A1..png" alt="image"></p><h1 id="GraphQL不足"><a href="#GraphQL不足" class="headerlink" title="GraphQL不足"></a>GraphQL 不足</h1><ul><li>改造成本：后端服务需要按领域进行重构</li><li>存量大：迁移困难</li><li>数据库性能 </li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- GraphQL 虽然解决将多个 HTTP 请求聚合成了一个请求，但是schema 会逐层解析方式递归获取全部数据</span><br><span class="line">- 前端请求少了但是query很多 数据库设计影响日后性能</span><br><span class="line">- 后端对前端改造无感知：前端修改了GraphQL的请求格式，可能会造成深层嵌套，对后端服务有较大影响</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ul><li>侵入性：前端利好，却需要服务端鼎力支持</li><li>复杂性：学习成本高 </li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">需要了解GraphQL一整套类型系统</span><br></pre></td></tr></tbody></table></figure><ul><li>典型的 N+1 问题 </li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用REST API 是很容易评估 ，识别和解决N+1问题的</span><br><span class="line">使用GraphQL会使这个问题变得相对复杂</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ul><li>数据缓存问题 </li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">REST强制使用具有缓存机制的HTTP协议 ，可以通过它 避免活回去多余资源</span><br><span class="line">GraphQL没有缓存机制，它把缓存的重任交给了用户</span><br></pre></td></tr></tbody></table></figure><ul><li>可见，整体来看，实际接入 GraphQL 并非易事，它只是一套规范，各种语言实现不一致，周边生态不够完善，需要后端配合改造，成本大，</li><li>除此之外，还有各种错误处理，日志上报及缓存机制的处理办法良莠不齐</li></ul><p>正因如此，GraphQL 很长一段时间还不能发挥其巨大作用</p><p>这一切 随着 Apollo 登场 正在逐步改善</p><h1 id="基于GraphQL的社区解决方案"><a href="#基于GraphQL的社区解决方案" class="headerlink" title="基于GraphQL的社区解决方案"></a>基于 GraphQL 的社区解决方案</h1><h2 id="Apollo"><a href="#Apollo" class="headerlink" title="Apollo"></a>Apollo</h2><p>可以把 GraphQL 理解成 NodeJS 的 http 包，那么 Apollo-server 就类似于在前面基础上封装出来的框架</p><h3 id="Apollo-Client"><a href="#Apollo-Client" class="headerlink" title="Apollo-Client"></a>Apollo-Client</h3><p>web，iOS，Android 三端的实现</p><h3 id="Apollo-Server"><a href="#Apollo-Server" class="headerlink" title="Apollo-Server"></a>Apollo-Server</h3><p>koa，express 等 NodeJsWeb 的实现</p><p>还提供了如下能力</p><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>接口格式五花八门，错误处理也没有统一的方案，Apollo 会将所有的错误内容格式化统一的错误信息，从此可以摆脱后端带来的束缚，方便我们在前端去处理。</p><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>借助 GraphQL 的 makeExecutableSchema 和 mergeSchemas 方法，能够按模块去编写类型定义及 resolve，最后使用 mergeSchemas 将他们合并到一起</p><h3 id="错误监控"><a href="#错误监控" class="headerlink" title="错误监控"></a>错误监控</h3><p>Apollo server 提供 formatError，formatResponse，能够细化到每一次请求，每一次错误的发生，方便我们去上报日志及错误</p><p>工作流程</p><p><img src="http://cdn.anruence.com/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88wee.png" alt="image"></p><p>接入架构设想</p><p><img src="http://cdn.anruence.com/jiagoushaxiang.png" alt="image"></p><ul><li>通过复用现有的 REST 接口，做到无需后端配合改造</li><li>在我们开发的项目里，由于会对接不同的后端团队，伴随着一些历史遗留问题，接口格式五花八门，错误处理也没有统一的方案，Apollo 会将所有的错误内容格式化统一的错误信息，从此可以摆脱后端带来的束缚，方便我们在前端去处理</li><li>在开发大型应用中，模块是是必不可少的。借助 GraphQL 的 makeExecutableSchema 和 mergeSchemas 方法，能够按模块去编写类型定义及 resolve，最后使用 mergeSchemas 将他们合并到一起</li><li>由于接入了 node server，那么我们需要监控错误以及请求日志等内容，Apollo server 提供 formatError，formatResponse，能够细化到每一次请求，每一次错误的发生，方便我们去上报日志及错误</li></ul><p>接入成果设想<br><img src="http://cdn.anruence.com/chengguoshexiang.png" alt="image"></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li><font color="red">更准确的获取你想要的数据</font> - 核心诉求</li><li>控制数据的是应用而非服务器 </li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在应用层对数据模型的抽象</span><br></pre></td></tr></tbody></table></figure><ul><li>将你需要的数据汇聚成数据网格 </li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">前端不能通过一次查询直接得到自己所需要的数据，Graphql的查询不仅指定了要查询的信息同时给出了期望的数据结构</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ul><li>应对复杂场景的一种新思路 thinking in graph</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">设计 GraphQL接口更像是在建立资源与资源之间的关系，并最终得到一个单一内聚图的过程 GraphQL 给了我们一种基于「图」的设计思路</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;开篇&quot;&gt;&lt;a href=&quot;#开篇&quot; class=&quot;headerlink&quot; title=&quot;开篇&quot;&gt;&lt;/a&gt;开篇&lt;/h1&gt;&lt;p&gt;你有没有遇到以下问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字段冗余&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.anruence.com/%E7%A3%90%E7%9F%B3%E6%95%B0%E6%8D%AE.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若干个不得不发的 HTTP 请求&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.anruence.com/graphql1.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;发生这些，并不是前端 er 本意，但是又要承担诸如页面渲染慢等副作用而被用户诟病&lt;br&gt;究其原因，是前端在数据层面没有主动权&lt;/p&gt;
&lt;p&gt;针对但不限于以上种种&lt;br&gt;我们需要以前端的设计者和开发者的角度出发 设计新的数据查询方式&lt;/p&gt;
&lt;p&gt;Facebook 工程师率先提出 RESTful 架构体系的替代方案&lt;/p&gt;
&lt;p&gt;并且应用在了其应用中&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=WxPtYJRjLL0&amp;amp;t=2s&quot;&gt;Facebook 使用 graphql 重构他们的 pc 站&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;接下来 让我们站在巨人的肩膀上，由浅至深聊聊被称之为面向未来的 API 的 - GraphQL&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://maying.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue 开发中小技巧</title>
    <link href="http://maying.ink/2019/10/24/vue/"/>
    <id>http://maying.ink/2019/10/24/vue/</id>
    <published>2019-10-24T08:07:13.000Z</published>
    <updated>2020-10-22T18:41:42.188Z</updated>
    
    <content type="html"><![CDATA[<p>记录日常开发中不常用的一些小技巧</p><h1 id="require-context"><a href="#require-context" class="headerlink" title="require.context()"></a>require.context()</h1><p>1. 场景：如页面需要导入多个组件，原始写法:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import titleCom from '@/components/home/titleCom'</span><br><span class="line">import bannerCom from '@/components/home/bannerCom'</span><br><span class="line">import cellCom from '@/components/home/cellCom'</span><br><span class="line">components:{titleCom,bannerCom,cellCom}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>2. 这样就写了大量重复的代码，利用 require.context 可以写成</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const path = require('path')</span><br><span class="line">const files = require.context('@/components/home', false, /\.vue$/)</span><br><span class="line">const modules = {}</span><br><span class="line">files.keys().forEach(key =&gt; {</span><br><span class="line">  const name = path.basename(key, '.vue')</span><br><span class="line">  modules[name] = files(key).default || files(key)</span><br><span class="line">})</span><br><span class="line">components:modules</span><br></pre></td></tr></tbody></table></figure><p>API 方法</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">实际上是 webpack 的方法,vue 工程一般基于 webpack,所以可以使用</span><br><span class="line">require.context(directory,useSubdirectories,regExp)</span><br><span class="line">接收三个参数:</span><br><span class="line">directory：说明需要检索的目录</span><br><span class="line">useSubdirectories：是否检索子目录</span><br><span class="line">regExp: 匹配文件的正则表达式,一般是文件名</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><a id="more"></a><h1 id="watch用法"><a href="#watch用法" class="headerlink" title="watch用法"></a>watch 用法</h1><h2 id="常用用法"><a href="#常用用法" class="headerlink" title="常用用法"></a>常用用法</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">created(){</span><br><span class="line">  this.getList()</span><br><span class="line">},</span><br><span class="line">watch: {</span><br><span class="line">  inpVal(){</span><br><span class="line">    this.getList()</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="立即执行"><a href="#立即执行" class="headerlink" title="立即执行"></a>立即执行</h2><p>可以直接利用 watch 的 immediate 和 handler 属性简写</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">watch: {</span><br><span class="line">  inpVal:{</span><br><span class="line">    handler: 'getList',</span><br><span class="line">      immediate: true</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="深度监听"><a href="#深度监听" class="headerlink" title="深度监听"></a>深度监听</h2><p>watch 的 deep 属性，深度监听，也就是监听复杂数据类型</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">watch:{</span><br><span class="line">  inpValObj:{</span><br><span class="line">    handler(newVal,oldVal){</span><br><span class="line">      console.log(newVal)</span><br><span class="line">      console.log(oldVal)</span><br><span class="line">    },</span><br><span class="line">    deep:true</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h1><h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 数组:不建议使用</span><br><span class="line">props:[]</span><br><span class="line"></span><br><span class="line">// 对象</span><br><span class="line">props:{</span><br><span class="line"> inpVal:{</span><br><span class="line">  type:Number, //传入值限定类型</span><br><span class="line">  // type 值可为String,Number,Boolean,Array,Object,Date,Function,Symbol</span><br><span class="line">  // type 还可以是一个自定义的构造函数，并且通过 instanceof 来进行检查确认</span><br><span class="line">  required: true, //是否必传</span><br><span class="line">  default:200,  //默认值,对象或数组默认值必须从一个工厂函数获取如 default:()=&gt;[]</span><br><span class="line">  validator:(value) {</span><br><span class="line">    // 这个值必须匹配下列字符串中的一个</span><br><span class="line">    return ['success', 'warning', 'danger'].indexOf(value) !== -1</span><br><span class="line">  }</span><br><span class="line"> }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="Attr和listeners"><a href="#Attr和listeners" class="headerlink" title="Attr和listeners"></a>Attr 和 listeners</h1><h2 id="attrs"><a href="#attrs" class="headerlink" title="attrs"></a>attrs</h2><p>场景：如果父传子有很多值，那么在子组件需要定义多个 props</p><p>attrs 获取未在 props 定义的值</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;home title="这是标题" width="80" height="80" imgUrl="imgUrl"/&gt;</span><br><span class="line"></span><br><span class="line">// 子组件</span><br><span class="line">mounted() {</span><br><span class="line">  console.log(this.$attrs) //{title: "这是标题", width: "80", height: "80", imgUrl: "imgUrl"}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>相对应的如果子组件定义了 props, 打印的值就是剔除定义的属性</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">props: {</span><br><span class="line">  width: {</span><br><span class="line">    type: String,</span><br><span class="line">    default: ''</span><br><span class="line">  }</span><br><span class="line">},</span><br><span class="line">mounted() {</span><br><span class="line">  console.log(this.$attrs) //{title: "这是标题", height: "80", imgUrl: "imgUrl"}</span><br><span class="line">},</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="listeners场景"><a href="#listeners场景" class="headerlink" title="listeners场景"></a>listeners 场景</h2><p>子组件内需要调用父组件的方法解决：<br>父组件的方法可以通过 v-on=”listeners” 传入内部组件</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;home @change="change"/&gt;</span><br><span class="line"></span><br><span class="line">// 子组件</span><br><span class="line">mounted() {</span><br><span class="line">  console.log(this.$listeners) //即可拿到 change 事件</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="root"><a href="#root" class="headerlink" title="$root"></a>$root</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">mounted(){</span><br><span class="line">  console.log(this.$root) //获取根实例,最后所有组件都是挂载到根实例上</span><br><span class="line">  console.log(this.$root.$children[0]) //获取根实例的一级子组件</span><br><span class="line">  console.log(this.$root.$children[0].$children[0]) //获取根实例的二级子组件</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="sync"><a href="#sync" class="headerlink" title=".sync"></a>.sync</h1><p>在 <a href="mailto:vue@1.x">vue@1.x</a> 的时候曾作为双向绑定功能存在，即子组件可以修改父组件中的值；在 <a href="mailto:vue@2.0">vue@2.0</a> 的由于违背单项数据流的设计被干掉了；在 <a href="mailto:vue@2.3.0">vue@2.3.0</a>+ 以上版本又重新引入了这个 .sync 修饰符；</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;home :title.sync="title" /&gt;</span><br><span class="line">//编译时会被扩展为</span><br><span class="line">&lt;home :title="title"  @update:title="val =&gt; title = val"/&gt;</span><br><span class="line"></span><br><span class="line">// 子组件</span><br><span class="line">// 所以子组件可以通过$emit 触发 update 方法改变</span><br><span class="line">mounted(){</span><br><span class="line">  this.$emit("update:title", '这是新的title')</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="路由传参方案"><a href="#路由传参方案" class="headerlink" title="路由传参方案"></a>路由传参方案</h1><p>方案一</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 路由定义</span><br><span class="line">{</span><br><span class="line">  path: '/describe/:id',</span><br><span class="line">  name: 'Describe',</span><br><span class="line">  component: Describe</span><br><span class="line">}</span><br><span class="line">// 页面传参</span><br><span class="line">this.$router.push({</span><br><span class="line">  path: `/describe/${id}`,</span><br><span class="line">})</span><br><span class="line">// 页面获取</span><br><span class="line">this.$route.params.id</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>方案二</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 路由定义</span><br><span class="line">{</span><br><span class="line">  path: '/describe',</span><br><span class="line">  name: 'Describe',</span><br><span class="line">  omponent: Describe</span><br><span class="line">}</span><br><span class="line">// 页面传参</span><br><span class="line">this.$router.push({</span><br><span class="line">  name: 'Describe',</span><br><span class="line">  params: {</span><br><span class="line">    id: id</span><br><span class="line">  }</span><br><span class="line">})</span><br><span class="line">// 页面获取</span><br><span class="line">this.$route.params.id</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>方案三</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 路由定义</span><br><span class="line">{</span><br><span class="line">  path: '/describe',</span><br><span class="line">  name: 'Describe',</span><br><span class="line">  component: Describe</span><br><span class="line">}</span><br><span class="line">// 页面传参</span><br><span class="line">this.$router.push({</span><br><span class="line">  path: '/describe',</span><br><span class="line">    query: {</span><br><span class="line">      id: id</span><br><span class="line">  `}</span><br><span class="line">)</span><br><span class="line">// 页面获取</span><br><span class="line">this.$route.query.id</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>三种方案对比 方案二参数不会拼接在路由后面，页面刷新参数会丢失 方案一和三参数拼接在后面，丑，而且暴露了信息</p><h1 id="render函数"><a href="#render函数" class="headerlink" title="render函数"></a>render 函数</h1><p>场景：有些代码在 template 里面写会重复很多，所以这个时候 render 函数就有作用啦</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// 根据 props 生成标签</span><br><span class="line">// 初级</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div v-if="level === 1"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;</span><br><span class="line">    &lt;p v-else-if="level === 2"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/p&gt;</span><br><span class="line">    &lt;h1 v-else-if="level === 3"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h1&gt;</span><br><span class="line">    &lt;h2 v-else-if="level === 4"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h2&gt;</span><br><span class="line">    &lt;strong v-else-if="level === 5"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/stong&gt;</span><br><span class="line">    &lt;textarea v-else-if="level === 6"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/textarea&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">// 优化版,利用 render 函数减小了代码重复率</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;child :level="level"&gt;Hello world!&lt;/child&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type='text/javascript'&gt;</span><br><span class="line">  import Vue from 'vue'</span><br><span class="line">  Vue.component('child', {</span><br><span class="line">    render(h) {</span><br><span class="line">      const tag = ['div', 'p', 'strong', 'h1', 'h2', 'textarea'][this.level-1]</span><br><span class="line">      return h(tag, this.$slots.default)</span><br><span class="line">    },</span><br><span class="line">    props: {</span><br><span class="line">      level: {  type: Number,  required: true  } </span><br><span class="line">    }</span><br><span class="line">  })   </span><br><span class="line">  export default {</span><br><span class="line">    name: 'hehe',</span><br><span class="line">    data() { return { level: 3 } }</span><br><span class="line">  }</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><p>2.render 和 template 的对比 前者适合复杂逻辑，后者适合逻辑简单；后者属于声明是渲染，前者属于自定 Render 函数；前者的性能较高，后者性能较低。</p><h1 id="路由的按需加载"><a href="#路由的按需加载" class="headerlink" title="路由的按需加载"></a>路由的按需加载</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">webpack&lt; 2.4 时</span><br><span class="line">{</span><br><span class="line">  path:'/',</span><br><span class="line">  name:'home',</span><br><span class="line">  components:resolve=&gt;require(['@/components/home'],resolve)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">webpack&gt; 2.4 时</span><br><span class="line">{</span><br><span class="line">  path:'/',</span><br><span class="line">  name:'home',</span><br><span class="line">  components:()=&gt;import('@/components/home')</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">import()方法由es6提出，import()方法是动态加载，返回一个Promise对象，then方法的参数是加载到的模块。类似于Node.js的require方法，主要import()方法是异步加载的。</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;component v-bind:is="currentTabComponent"&gt;&lt;/component&gt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>但是这样每次组件都会重新加载，会消耗大量性能，所以 就起到了作用</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">  &lt;component v-bind:is="currentTabComponent"&gt;&lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>这样切换效果没有动画效果，这个也不用着急，可以利用内置的</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition&gt;</span><br><span class="line">&lt;keep-alive&gt;</span><br><span class="line">  &lt;component v-bind:is="currentTabComponent"&gt;&lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></tbody></table></figure><h1 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template functional&gt;</span><br><span class="line">  &lt;div v-for="(item,index) in props.arr"&gt;{{item}}&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></tbody></table></figure><h1 id="mixins"><a href="#mixins" class="headerlink" title="mixins"></a>mixins</h1><p>场景：有些组件有些重复的 js 逻辑，如校验手机验证码，解析时间等，mixins 就可以实现这种混入 mixins 值是一个数组</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const mixin={</span><br><span class="line">    created(){</span><br><span class="line">      this.dealTime()</span><br><span class="line">    },</span><br><span class="line">    methods:{</span><br><span class="line">      dealTime(){</span><br><span class="line">        console.log('这是mixin的dealTime里面的方法');</span><br><span class="line">      }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">export default{</span><br><span class="line">  mixins:[mixin]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="Vue-nextTick"><a href="#Vue-nextTick" class="headerlink" title="Vue.nextTick"></a>Vue.nextTick</h1><p>2.1.0 新增 场景：页面加载时需要让文本框获取焦点 用法：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mounted(){ //因为 mounted 阶段 dom 并未渲染完毕,所以需要$nextTick</span><br><span class="line">  this.$nextTick(() =&gt; {</span><br><span class="line">    this.$refs.inputs.focus() //通过 $refs 获取dom 并绑定 focus 方法</span><br><span class="line">  })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="Vue-version"><a href="#Vue-version" class="headerlink" title="Vue.version"></a>Vue.version</h1><p>场景：有些开发插件需要针对不同 vue 版本做兼容，所以就会用到 Vue.version 用法：Vue.version () 可以获取 vue 版本</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var version = Number(Vue.version.split('.')[0])</span><br><span class="line"></span><br><span class="line">if (version === 2) {</span><br><span class="line">  // Vue v2.x.x</span><br><span class="line">} else if (version === 1) {</span><br><span class="line">  // Vue v1.x.x</span><br><span class="line">} else {</span><br><span class="line">  // Unsupported versions of Vue</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="Vue-config-performance"><a href="#Vue-config-performance" class="headerlink" title="Vue.config.performance"></a>Vue.config.performance</h1><p>监听性能</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vue.config.performance = true</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="Vue-config-warnHandler"><a href="#Vue-config-warnHandler" class="headerlink" title="Vue.config.warnHandler"></a>Vue.config.warnHandler</h1><p>2.4.0 新增 1. 场景：为 Vue 的运行时警告赋予一个自定义处理函数，只会在开发者环境下生效 2. 用法:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.config.warnHandler = function (msg, vm, trace) {</span><br><span class="line">  // `trace` 是组件的继承关系追踪</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="v-pre"><a href="#v-pre" class="headerlink" title="v-pre"></a>v-pre</h1><p>场景:vue 是响应式系统，但是有些静态的标签不需要多次编译，这样可以节省性能</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;span v-pre&gt;{{ this will not be compiled }}&lt;/span&gt;   显示的是{{ this will not be compiled }}</span><br><span class="line">&lt;span v-pre&gt;{{msg}}&lt;/span&gt;&nbsp; &nbsp; &nbsp;即使data里面定义了msg这里仍然是显示的{{msg}}</span><br></pre></td></tr></tbody></table></figure><h1 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h1><p>场景：在网速慢的情况下，在使用 vue 绑定数据的时候，渲染页面时会出现变量闪烁<br>用法：这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 [v-cloak] { display: none } 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// template 中</span><br><span class="line">&lt;div class="#app" v-cloak&gt;</span><br><span class="line">    &lt;p&gt;{{value.name}}&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">// css 中</span><br><span class="line">[v-cloak] {</span><br><span class="line">    display: none;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这样就可以解决闪烁，但是会出现白屏，这样可以结合骨架屏使用</p><h1 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h1><p>场景：有些 template 中的静态 dom 没有改变，这时就只需要渲染一次，可以降低性能开销</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;span v-once&gt; 这时只需要加载一次的标签&lt;/span&gt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>v-once 和 v-pre 的区别: v-once 只渲染一次；v-pre 不编译，原样输出</p><h1 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.stop:阻止冒泡</span><br><span class="line">.prevent:阻止默认行为</span><br><span class="line">.self:仅绑定元素自身触发</span><br><span class="line">.once: 2.1.4 新增,只触发一次</span><br><span class="line">.passive: 2.3.0 新增,滚动事件的默认行为 (即滚动行为) 将会立即触发,不能和.prevent 一起使用</span><br></pre></td></tr></tbody></table></figure><h1 id="Vue-router"><a href="#Vue-router" class="headerlink" title="Vue.$router"></a>Vue.$router</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.$router.push():跳转到不同的url，但这个方法回向history栈添加一个记录，点击后退会返回到上一个页面</span><br><span class="line">this.$router.replace():不会有记录</span><br><span class="line">this.$router.go(n):n可为正数可为负数。正数返回上一个页面,类似 window.history.go(n)</span><br></pre></td></tr></tbody></table></figure><h1 id="Vue-route"><a href="#Vue-route" class="headerlink" title="Vue.$route"></a>Vue.$route</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this.$route.params.id:获取通过 params 或/:id传参的参数</span><br><span class="line">this.$route.query.id:获取通过 query 传参的参数</span><br></pre></td></tr></tbody></table></figure><h1 id="调试-template"><a href="#调试-template" class="headerlink" title="调试 template"></a>调试 template</h1><p>场景：在 Vue 开发过程中，经常会遇到 template 模板渲染时 JavaScript 变量出错的问题，此时也许你会通过 console.log 来进行调试 这时可以在开发环境挂载一个 log 函数</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// main.js</span><br><span class="line">Vue.prototype.$log = window.console.log;</span><br><span class="line"></span><br><span class="line">// 组件内部</span><br><span class="line">&lt;div&gt;{{$log(info)}}&lt;/div&gt;</span><br></pre></td></tr></tbody></table></figure><h1 id="vue-loader-小技巧"><a href="#vue-loader-小技巧" class="headerlink" title="vue-loader 小技巧"></a>vue-loader 小技巧</h1><h2 id="preserveWhitespace"><a href="#preserveWhitespace" class="headerlink" title="preserveWhitespace"></a>preserveWhitespace</h2><p>场景：开发 vue 代码一般会有空格，这个时候打包压缩如果不去掉空格会加大包的体积 配置 preserveWhitespace 可以减小包的体积</p><p>{<br>  vue: {<br>    preserveWhitespace: false<br>  }<br>}</p><h2 id="transformToRequire"><a href="#transformToRequire" class="headerlink" title="transformToRequire"></a>transformToRequire</h2><p>场景：以前在写 Vue 的时候经常会写到这样的代码：把图片提前 require 传给一个变量再传给组件</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// page 代码</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;avatar :img-src="imgSrc"&gt;&lt;/avatar&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default {</span><br><span class="line">    created () {</span><br><span class="line">      this.imgSrc = require('./assets/default-avatar.png')</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>现在：通过配置 transformToRequire 后，就可以直接配置，这样 vue-loader 会把对应的属性自动 require 之后传给组件</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// vue-cli 2.x在vue-loader.conf.js 默认配置是</span><br><span class="line">transformToRequire: {</span><br><span class="line">    video: ['src', 'poster'],</span><br><span class="line">    source: 'src',</span><br><span class="line">    img: 'src',</span><br><span class="line">    image: 'xlink:href'</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 配置文件,如果是vue-cli2.x 在vue-loader.conf.js里面修改</span><br><span class="line">  avatar: ['default-src']</span><br><span class="line"></span><br><span class="line">// vue-cli 3.x 在vue.config.js</span><br><span class="line">// vue-cli 3.x 将transformToRequire属性换为了transformAssetUrls</span><br><span class="line">module.exports = {</span><br><span class="line">  pages,</span><br><span class="line">  chainWebpack: config =&gt; {</span><br><span class="line">    config</span><br><span class="line">      .module</span><br><span class="line">        .rule('vue')</span><br><span class="line">        .use('vue-loader')</span><br><span class="line">        .loader('vue-loader')</span><br><span class="line">        .tap(options =&gt; {</span><br><span class="line">      options.transformAssetUrls = {</span><br><span class="line">        avatar: 'img-src',</span><br><span class="line">      }</span><br><span class="line">      return options;</span><br><span class="line">      });</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// page 代码可以简化为</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;avatar img-src="./assets/default-avatar.png"&gt;&lt;/avatar&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></tbody></table></figure><h1 id="为路径设置别名"><a href="#为路径设置别名" class="headerlink" title="为路径设置别名"></a>为路径设置别名</h1><p>1. 场景：在开发过程中，我们经常需要引入各种文件，如图片、CSS、JS 等，为了避免写很长的相对路径（../），我们可以为不同的目录配置一个别名</p><p>2.vue-cli 2.x 配置</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 在 webpack.base.config.js中的 resolve 配置项，在其 alias 中增加别名</span><br><span class="line">resolve: {</span><br><span class="line">    extensions: ['.js', '.vue', '.json'],</span><br><span class="line">    alias: {</span><br><span class="line">      'vue$': 'vue/dist/vue.esm.js',</span><br><span class="line">      '@': resolve('src'),</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>3.vue-cli 3.x 配置</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 在根目录下创建vue.config.js</span><br><span class="line">var path = require('path')</span><br><span class="line">function resolve (dir) {</span><br><span class="line">  console.log(__dirname)</span><br><span class="line">  return path.join(__dirname, dir)</span><br><span class="line">}</span><br><span class="line">module.exports = {</span><br><span class="line">  chainWebpack: config =&gt; {</span><br><span class="line">    config.resolve.alias</span><br><span class="line">      .set(key, value) // key,value自行定义，比如.set('@@', resolve('src/components'))</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="img-加载失败"><a href="#img-加载失败" class="headerlink" title="img 加载失败"></a>img 加载失败</h1><p>场景：有些时候后台返回图片地址不一定能打开，所以这个时候应该加一张默认图片</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// page 代码</span><br><span class="line">&lt;img :src="imgUrl" @error="handleError" alt=""&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default{</span><br><span class="line">  data(){</span><br><span class="line">    return{</span><br><span class="line">      imgUrl:''</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">  methods:{</span><br><span class="line">    handleError(e){</span><br><span class="line">      e.target.src=reqiure('图片路径') //当然如果项目配置了transformToRequire,参考上面 27.2</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="局部样式"><a href="#局部样式" class="headerlink" title="局部样式"></a>局部样式</h2><p>1.Vue 中 style 标签的 scoped 属性表示它的样式只作用于当前模块，是样式私有化.</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 原始代码</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class="demo"&gt;</span><br><span class="line">    &lt;span class="content"&gt;</span><br><span class="line">      Vue.js scoped</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang="less" scoped&gt;</span><br><span class="line">  .demo{</span><br><span class="line">    font-size: 16px;</span><br><span class="line">    .content{</span><br><span class="line">      color: red;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">// 浏览器渲染效果</span><br><span class="line">&lt;div data-v-fed36922&gt;</span><br><span class="line">  Vue.js scoped</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;style type="text/css"&gt;</span><br><span class="line">.demo[data-v-039c5b43] {</span><br><span class="line">  font-size: 14px;</span><br><span class="line">}</span><br><span class="line">.demo .content[data-v-039c5b43] { //.demo 上并没有加 data 属性</span><br><span class="line">  color: red;</span><br><span class="line">}</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="deep-属性"><a href="#deep-属性" class="headerlink" title="deep 属性"></a>deep 属性</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 上面样式加一个 /deep/</span><br><span class="line">&lt;style lang="less" scoped&gt;</span><br><span class="line">  .demo{</span><br><span class="line">    font-size: 14px;</span><br><span class="line">  }</span><br><span class="line">  .demo /deep/ .content{</span><br><span class="line">    color: blue;</span><br><span class="line">  }</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">// 浏览器编译后</span><br><span class="line">&lt;style type="text/css"&gt;</span><br><span class="line">.demo[data-v-039c5b43] {</span><br><span class="line">  font-size: 14px;</span><br><span class="line">}</span><br><span class="line">.demo[data-v-039c5b43] .content {</span><br><span class="line">  color: blue;</span><br><span class="line">}</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录日常开发中不常用的一些小技巧&lt;/p&gt;
&lt;h1 id=&quot;require-context&quot;&gt;&lt;a href=&quot;#require-context&quot; class=&quot;headerlink&quot; title=&quot;require.context()&quot;&gt;&lt;/a&gt;require.context()&lt;/h1&gt;&lt;p&gt;1. 场景：如页面需要导入多个组件，原始写法:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;import titleCom from &#39;@/components/home/titleCom&#39;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;import bannerCom from &#39;@/components/home/bannerCom&#39;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;import cellCom from &#39;@/components/home/cellCom&#39;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;components:{titleCom,bannerCom,cellCom}&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;2. 这样就写了大量重复的代码，利用 require.context 可以写成&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const path = require(&#39;path&#39;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;const files = require.context(&#39;@/components/home&#39;, false, /\.vue$/)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;const modules = {}&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;files.keys().forEach(key =&amp;gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  const name = path.basename(key, &#39;.vue&#39;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  modules[name] = files(key).default || files(key)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;})&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;components:modules&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;API 方法&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;实际上是 webpack 的方法,vue 工程一般基于 webpack,所以可以使用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;require.context(directory,useSubdirectories,regExp)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;接收三个参数:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;directory：说明需要检索的目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;useSubdirectories：是否检索子目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;regExp: 匹配文件的正则表达式,一般是文件名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Vue" scheme="http://maying.ink/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>看完这篇，我奶奶都会设计组件了</title>
    <link href="http://maying.ink/2019/07/29/part/"/>
    <id>http://maying.ink/2019/07/29/part/</id>
    <published>2019-07-28T17:40:30.000Z</published>
    <updated>2020-10-22T18:41:42.184Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://juejin.im/post/5d566e82f265da03f77e653c">掘金链接</a></p><p>组件化思想并不是前端独有的，但却是前端技术的延伸</p><p>随着三大框架崛起，前端组件化逐渐成为前端开发的迫切需求，一种主流，一种共识，它不仅提高开发效率，同时也降低了维组件内聚原则护成本<br>开发者们不需要再面对一堆晦涩难懂的代码，转而只需要关注以组件⽅式存在的代码⽚段</p><p>这是一场新的挑战！</p><h2 id="文章开始之前，明确本文的边界"><a href="#文章开始之前，明确本文的边界" class="headerlink" title="文章开始之前，明确本文的边界"></a>文章开始之前，明确本文的边界</h2><ul><li>从前端工程谈到组件化开发</li><li>组件的设计原则</li><li>组件的职能划分及利弊</li><li>组件设计的边界</li><li>落实到具体业务中如何做</li><li>一些感悟</li><li>总结</li></ul><h1 id="一个面试题引发的思考"><a href="#一个面试题引发的思考" class="headerlink" title="一个面试题引发的思考"></a>一个面试题引发的思考</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">面试官通常会问 写过前端通用组件吗？</span><br></pre></td></tr></tbody></table></figure><a id="more"></a><p>你可能会自信的表示： sure！</p><p>emm.. 是的吗？</p><h1 id="从前端工程谈到组件化开发"><a href="#从前端工程谈到组件化开发" class="headerlink" title="从前端工程谈到组件化开发"></a>从前端工程谈到组件化开发</h1><p>前端工程经历的三个阶段</p><h2 id="1-库-框架选型"><a href="#1-库-框架选型" class="headerlink" title="1. 库/框架选型"></a>1. 库 / 框架选型</h2><p><img src="http://cdn.anruence.com/ku.png" alt="image"><br>确定技术选型，为项目节省许多工程量<br>后来三大框架的横空出世，解放了不少生产力</p><h2 id="2-简单构建优化"><a href="#2-简单构建优化" class="headerlink" title="2. 简单构建优化"></a>2. 简单构建优化</h2><p><img src="http://cdn.anruence.com/tools.png" alt="image"></p><p>解决完开发效率，还需要兼顾运行性能，<br>故而选择某种构建工具，对代码进行压缩，校验，之后再以页面为单位进行简单的资源合并</p><h2 id="3-JS-CSS模块化开发"><a href="#3-JS-CSS模块化开发" class="headerlink" title="3. JS/CSS模块化开发"></a>3. JS/CSS 模块化开发</h2><p><img src="http://cdn.anruence.com/jsmokuaihua.png" alt="image"></p><p>解决了基本开发效率和运行效率之后，开始考虑维护效率了</p><p>分而治之（以分解降低复杂度）是软件工程中的重要思想，是复杂系统开发和维护的基石，<font color="red">模块化就是前端的分治手段</font></p><p>因此，模块化强调的是<strong>拆分</strong>，最大的价值就是分治，意味着不管你将来是否要复用这块儿代码，都有将他们拆成一个模块的理由</p><blockquote><p>将一个大问题，不断的拆解为各个小问题进行分析研究，然后再组合到一起 (分而治之原则)</p></blockquote><h3 id="模块化的方案"><a href="#模块化的方案" class="headerlink" title="模块化的方案"></a>模块化的方案</h3><ul><li>JS 模块化 </li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">无模块化-&gt;函数写法-&gt;对象写法-&gt;自执行函数-&gt;CommonJS/AMD/CMD-&gt;ES6 Module</span><br></pre></td></tr></tbody></table></figure><ul><li>CSS 模块化 </li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">css模块化是在less，sass等预处理器的支持下实现的</span><br></pre></td></tr></tbody></table></figure><h3 id="做到这些就够了吗？"><a href="#做到这些就够了吗？" class="headerlink" title="做到这些就够了吗？"></a>做到这些就够了吗？</h3><p>当然是不够的</p><p>模块化强调的是<strong>拆分</strong>，无论是从业务角度还是从架构、技术角度，模块化首先意味着将代码、数据等内容按照其职责不同分离</p><p>单纯的横向拆分业务功能模块有一些问题<br><img src="http://cdn.anruence.com/2.png"></p><ul><li>面向过程的代码 随着业务的发展不利于维护 </li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">随着业务发展，”过程线“也会越来越长，其他项目成员根据各自需要，在”过程线“ 加插各自逻辑，最终这个页面的逻辑变得难以维护</span><br><span class="line">我们需要摆脱【一泻而下】式的代码编写</span><br></pre></td></tr></tbody></table></figure><ul><li>仅仅有 JS/CSS 模块化是不够的，UI（页面）的分治也比较迫切 </li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">除了JS和CSS，界面也需要拆分，如何让模块化思想融入HTML语言</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="4-组件化开发（本文重点）"><a href="#4-组件化开发（本文重点）" class="headerlink" title="4. 组件化开发（本文重点）"></a><font color="red">4. 组件化开发（本文重点）</font></h2><h3 id="组件化开发的演变"><a href="#组件化开发的演变" class="headerlink" title="组件化开发的演变"></a>组件化开发的演变</h3><p>在大肆宣扬组件化开发概念之前，也经历了寻求组件化最佳实践的阶段</p><h4 id="页面结构模块化"><a href="#页面结构模块化" class="headerlink" title="页面结构模块化"></a>页面结构模块化</h4><p><img src="http://cdn.anruence.com/jimu" alt="image"><br>简单来说就是把页面想象成乐高机器人，需要不同零件组装，然后将各个部分拼到一起</p><p>落实到实际开发中像这样<br><img src="http://cdn.anruence.com/jiegouhua.png"></p><p>我们可以发现</p><ul><li>页面 pageModel 包含了 <code>tabContainer</code>，<code>listContainer</code> 和 <code>imgsContainer</code> 三个模块</li><li>我们根据不同的业务逻辑封装了不同类型的 model</li><li> 每个 model 有自己的数据，模板，逻辑，已经算是一个完整的功能单元</li></ul><p><font color="red">咦？嗅到一丝组件化的味道</font></p><h4 id="N年前微软的组件化的解决方案-HTML-Component"><a href="#N年前微软的组件化的解决方案-HTML-Component" class="headerlink" title="N年前微软的组件化的解决方案 HTML Component"></a>N 年前微软的组件化的解决方案 HTML Component</h4><p>历史总有遗🐖</p><p>早在 N 年前微软提出过一套解决方案，名为 <code>HTML Component</code></p><p><img src="http://cdn.anruence.com/4.jpg" alt="jsworke"></p><p>事实上已经是一个比较完整的组件化方案了，但最后却没能进入标准，从今天的角度看，它可以说是生不逢时</p><h4 id="WebComponents-标准"><a href="#WebComponents-标准" class="headerlink" title="WebComponents 标准"></a>WebComponents 标准</h4><p>当时” 所谓的组件 “</p><ul><li>此时的组件基本上只能达到某个功能单元上的集合，资源都是资源都是松散地分散在三种资源文件中</li><li>而且组件作用域暴露在全局作用域下，缺乏内聚性很容易就会跟其他组件产生冲突（如最简单的 css 命名冲突）</li></ul><p>于是 W3C 按耐不住了，制定一个 WebComponents 标准，为组件化的未来指引了明路</p><p>大致四部分功能</p><ul><li><code>&lt;template&gt;</code> 定义组件的 HTML 模板能力</li><li> Shadow Dom 封装组件的内部结构，并且保持其独立性</li><li> Custom Element 对外提供组件的标签，实现自定义标签</li><li> import 解决组件结合和依赖加载</li></ul><p>我们思考一下，可行的实践化方案需要具备哪些能力</p><ul><li>资源高内聚（组件资源内部高内聚，组件资源由自身加载控制）</li><li>作用域独立（内部结构密封，不与全局或其他组件产生影响）</li><li>自定义标签（定义组件的使用方式）</li><li>可相互组合（组件间组装整合）</li><li>接口规范化（组件接口有统一规范，或者是生命周期的管理）</li></ul><h4 id="三大框架出现"><a href="#三大框架出现" class="headerlink" title="三大框架出现"></a>三大框架出现</h4><p>今天的前端生态里面 React，Angular 和 Vue 三分天下，即使它们定位不同，但核心的共同点就是提供了组件化的能力，算是目前是比较好的组件化实践</p><h5 id="1-Vue-js采用了JSON的方法描述一个组件"><a href="#1-Vue-js采用了JSON的方法描述一个组件" class="headerlink" title="1. Vue.js采用了JSON的方法描述一个组件"></a>1. Vue.js 采用了 JSON 的方法描述一个组件</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import PageContainer from './layout/PageContainer'</span><br><span class="line">import PageFilter from './layout/PageFilter'</span><br><span class="line"></span><br><span class="line">export default {</span><br><span class="line">  install(Vue) {</span><br><span class="line">    Vue.component('PageContainer', PageContainer)</span><br><span class="line">    Vue.component('PageFilter', PageFilter)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>还提供了 SFC（Single File Component，单文件组件）‘.vue’文件格式</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">//...</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default {</span><br><span class="line">    data(){}</span><br><span class="line">  }</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang="scss"&gt;</span><br><span class="line">//...</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></tbody></table></figure><h5 id="2-React-js发明了JSX，把CSS和HTML都塞进JS文件里"><a href="#2-React-js发明了JSX，把CSS和HTML都塞进JS文件里" class="headerlink" title="2. React.js发明了JSX，把CSS和HTML都塞进JS文件里"></a>2. React.js 发明了 JSX，把 CSS 和 HTML 都塞进 JS 文件里</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Tabs extends React.Component {</span><br><span class="line">    render() {</span><br><span class="line">        if (!this.props.items) {</span><br><span class="line">            console.error('Tabs中需要传入数据');</span><br><span class="line">            return null;</span><br><span class="line">        }</span><br><span class="line">        const propId = this.props.id;</span><br><span class="line">        return (</span><br><span class="line">            &lt;ul className={this.props.className}&gt;</span><br><span class="line">              &lt;li&gt;测试&lt;/li&gt;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">        );</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="Angular-js选择在原本的HTML上扩展"><a href="#Angular-js选择在原本的HTML上扩展" class="headerlink" title="Angular.js选择在原本的HTML上扩展"></a>Angular.js 选择在原本的 HTML 上扩展</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type="text" ng-model="firstname"&gt;</span><br><span class="line"></span><br><span class="line">var app = angular.module('myApp', []);</span><br><span class="line">app.controller('formCtrl', function($scope) {</span><br><span class="line">    $scope.firstname = "John";</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><h3 id="标准下的资源整合"><a href="#标准下的资源整合" class="headerlink" title="标准下的资源整合"></a>标准下的资源整合</h3><p><img src="http://cdn.anruence.com/sss.png" alt="image"></p><h4 id="具有以下特点"><a href="#具有以下特点" class="headerlink" title="具有以下特点"></a>具有以下特点</h4><ul><li>每个组件对应一个目录，组件所需的各种资源都在这个目录下就近维护；（最具软件工程价值）</li><li>页面上的每个独立的可视 / 可交互区域视为一个组件；</li><li>由于组件具有独立性，可以自由组合；</li><li>页面是组件的容器，负责组合组件形成功能完整的界面；</li><li>当不需要某个组件，或者想要替换组件时，可以整个目录删除 / 替换</li></ul><h3 id="应用结构图"><a href="#应用结构图" class="headerlink" title="应用结构图"></a>应用结构图</h3><p><img src="http://cdn.anruence.com/niubi.png" alt="image"></p><ul><li>分子是由原子组成的，分子分成原子，原子也可以重新组合成新的分子</li><li>一个界面是由独立的分子组件搭建而成，分子组件由原子元件构成，这些原子可通过不同的组合方式，组成新分子组件，继而重组构成新的界面</li></ul><h3 id="模块化与组件化对比"><a href="#模块化与组件化对比" class="headerlink" title="模块化与组件化对比"></a>模块化与组件化对比</h3><p>如果你去网上搜【模块和组件的异同】<br>可能会得到截然不同的答案，大部分描述的都是片面的</p><p>它们之间的关系可以从以下三个方面分析：</p><h4 id="从整体概念来讲"><a href="#从整体概念来讲" class="headerlink" title="从整体概念来讲"></a>从整体概念来讲</h4><ul><li>模块化是一种分治的思想，诉求是解耦，一般指的是 js 模块，比如用来格式化时间的模块</li><li>组件化是模块化思想的实现手段，诉求是复用，包含了 <code>template</code>，<code>style</code>，<code>script</code>，script 又可以由各种模块组成</li></ul><h4 id="从复用的角度来讲"><a href="#从复用的角度来讲" class="headerlink" title="从复用的角度来讲"></a>从复用的角度来讲</h4><ul><li>模块一般是项目范围内按照项目业务内容来划分的，比如一个项目划分为子系统、模块、子模块，<strong>代码分开就是模块</strong></li><li>组件是按照一些小功能的通用性和可复用性抽象出来的，可以跨项目，是可复用的模块</li></ul><h4 id="从历史发展角度来讲"><a href="#从历史发展角度来讲" class="headerlink" title="从历史发展角度来讲"></a>从历史发展角度来讲</h4><p>随着前端开发越来越复杂、对效率要求越来高，由项目级模块化开发，进一步提升到通用功能组件化开发，<strong>模块化是组件化的前提，组件化是模块化的演进</strong></p><h1 id="组件的设计原则"><a href="#组件的设计原则" class="headerlink" title="组件的设计原则"></a>组件的设计原则</h1><p>组件化方案下，我们需要具有组件化设计思维，它是一种【整理术】帮助我们高效开发整合</p><ol><li>标准性 </li></ol><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">任何一个组件都应该遵守一套标准，可以使得不同区域的开发人员据此标准开发出一套标准统一的组件</span><br><span class="line"></span><br><span class="line">API尽量和已知概念保持一致</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>独立性 </li></ol><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">遵循单一职责原则，保持组件的纯粹性</span><br><span class="line">属性配置等API对外开放，组件内部状态对外封闭，尽可能的少与业务耦合</span><br><span class="line"></span><br><span class="line">避免暴露组件内部实现</span><br><span class="line"></span><br><span class="line">入口处检查参数的有效性，出口处检查返回的正确性</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li>复用与易用，适用 SPOT 法则 </li></ol><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UI差异，消化在组件内部（注意并不是写一堆if/else）</span><br><span class="line">输入输出友好，易用</span><br><span class="line"></span><br><span class="line">Single Point Of Truth，就是尽量不要重复代码，出自《The Art of Unix Programming》</span><br></pre></td></tr></tbody></table></figure><ol start="4"><li>避免直接操作 DOM，避免使用 ref</li></ol><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用父组件的 state 控制子组件的状态而不是直接通过 ref 操作子组件</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ol start="5"><li><strong>无环依赖原则 (ADP)</strong></li></ol><p>设计不当导致环形依赖示意图<br><img src="http://cdn.anruence.com/1111111111.png" alt="image"></p><p><strong>影响</strong></p><ul><li>组件间耦合度高，集成测试难</li><li>一处修改，处处影响，交付周期长</li><li>因为组件之间存在循环依赖，变成了 “先有鸡还是先有蛋” 的问题</li></ul><p><strong>那倘若我们真的遇到了这种问题，就要考虑如何处理？</strong></p><p><font color="red">消除环形依赖</font></p><blockquote><p>我们的追求是沿着逆向的依赖关系即可寻找到所有受影响的组件</p></blockquote><p>创建一个共同依赖的新组件</p><p><img src="http://cdn.anruence.com/xiaochu.png" alt="image"></p><ol start="6"><li>稳定抽象原则 (SAP)</li></ol><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 组件的抽象程度与其稳定程度成正比，</span><br><span class="line">- 一个稳定的组件应该是抽象的（逻辑无关的）</span><br><span class="line">- 一个不稳定的组件应该是具体的（逻辑相关的）</span><br><span class="line">- 为降低组件之间的耦合度，我们要针对抽象组件编程，而不是针对业务实现编程</span><br></pre></td></tr></tbody></table></figure><ol start="7"><li>避免冗余状态 </li></ol><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">如果一个数据可以由另一个 state 变换得到，那么这个数据就不是一个 state，只需要写一个变换的处理函数，在 Vue 中可以使用计算属性</span><br><span class="line"></span><br><span class="line">如果一个数据是固定的，不会变化的常量，那么这个数据就如同 HTML 固定的站点标题一样，写死或作为全局配置属性等，不属于 state</span><br><span class="line"></span><br><span class="line">如果兄弟组件拥有相同的 state，那么这个state 应该放到更高的层级，使用 props 传递到两个组件中</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ol start="8"><li>合理的依赖关系 </li></ol><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父组件不依赖子组件，删除某个子组件不会造成功能异常</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ol start="9"><li>扁平化参数 </li></ol><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">除了数据，避免复杂的对象，尽量只接收原始类型的值</span><br></pre></td></tr></tbody></table></figure><ol start="10"><li>良好的接口设计 <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">把组件内部可以完成的工作做到极致，虽然提倡拥抱变化，但接口不是越多越好</span><br><span class="line"></span><br><span class="line">如果常量变为 props 能应对更多的场景，那么就可以作为 props，原有的常量可作为默认值。</span><br><span class="line"></span><br><span class="line">如果需要为了某一调用者编写大量特定需求的代码，那么可以考虑通过扩展等方式构建一个新的组件。</span><br><span class="line"></span><br><span class="line">保证组件的属性和事件足够的给大多数的组件使用。</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li></ol><h1 id="组件的职能划分"><a href="#组件的职能划分" class="headerlink" title="组件的职能划分"></a>组件的职能划分</h1><p>那有了组件设计的 “API”，就一定能开发出高质量的组件吗？</p><blockquote><p>组件最大的不稳定性来自于展现层，一个组件只做一件事，基于功能做好职责划分</p></blockquote><p>根据以往经验，我将组件分为以下几类</p><ul><li>基础组件（通常在组件库里就解决了）</li><li>容器型组件（Container）</li><li>展示型组件（stateless）</li><li>业务组件</li><li>通用组件<ul><li> UI 组件</li><li>逻辑组件</li></ul></li><li>高阶组件（HOC）</li></ul><p><font color="red">除容器组件外，尽量保证组件都是 stateless 的，这并不冲突！</font></p><h2 id="基础组件"><a href="#基础组件" class="headerlink" title="基础组件"></a>基础组件</h2><p>为了让开发者更关注业务逻辑，涌现出了很多优秀的 UI 组件库<br>比如 <code>antd</code>，<code>element-ui</code>，我们只需要调用 API 便能满足大部分的业务场景，前端角色后置了，开发变得更简单了</p><h2 id="容器型组件"><a href="#容器型组件" class="headerlink" title="容器型组件"></a>容器型组件</h2><p>一个容器性质的组件，一般当作一个业务子模块的入口，比如一个路由指向的组件</p><p><img src="http://cdn.anruence.com/RONGQIZUJIAN.png" alt="image"></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>容器组件内的子组件通常具有业务或数据依赖关系</li><li>集中 / 统一的状态管理，向其他展示型 / 容器型组件提供数据（充当数据源）和行为逻辑处理（接收回调）</li><li>如果使用了全局状态管理，那么容器内部的业务组件可以自行调用全局状态处理业务</li><li>业务模块内子组件的通信等统筹处理，充当子级组件通信的状态中转站</li><li>模版基本都是子级组件的集合，很少包含 <code>DOM</code> 标签</li><li>辅助代码分离</li></ul><h3 id="表现形式🌰（vue）"><a href="#表现形式🌰（vue）" class="headerlink" title="表现形式🌰（vue）"></a>表现形式🌰（vue）</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div class="purchase-box"&gt;</span><br><span class="line">  &lt;!-- 面包屑导航 --&gt;</span><br><span class="line">  &lt;bread-crumbs /&gt;</span><br><span class="line">  &lt;div class="scroll-content"&gt;</span><br><span class="line">    &lt;!-- 搜索区域 --&gt;</span><br><span class="line">    &lt;Search v-show="toggleFilter" :form="form"/&gt;</span><br><span class="line">    &lt;!--展开收起区域--&gt;</span><br><span class="line">    &lt;Toggle :toggleFilter="toggleFilter"/&gt;</span><br><span class="line">    &lt;!-- 列表区域--&gt;</span><br><span class="line">    &lt;List :data="listData"/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></tbody></table></figure><h2 id="展示型（stateless）组件"><a href="#展示型（stateless）组件" class="headerlink" title="展示型（stateless）组件"></a>展示型（stateless）组件</h2><p>主要表现为组件是怎样渲染的，就像一个简单的模版渲染过程</p><p><img src="http://cdn.anruence.com/zhanshixing.png" alt="image"></p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul><li>只通过 props 接受数据和回调函数，不充当数据源</li><li>可能包含展示和容器组件 并且一般会有 Dom 标签和 css 样式</li><li>通常用 props.children (react) 或者 slot (vue) 来包含其他组件</li><li>对第三方没有依赖（对于一个应用级的组件来说可以有）</li><li>可以有状态，在其生命周期内可以操纵并改变其内部状态，职责单一，将不属于自己的行为通过回调传递出去，让父级去处理（搜索组件的搜索事件 / 表单的添加事件）</li></ul><h3 id="表现形式🌰（vue）-1"><a href="#表现形式🌰（vue）-1" class="headerlink" title="表现形式🌰（vue）"></a>表现形式🌰（vue）</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"> &lt;template&gt;</span><br><span class="line"> &lt;div class="purchase-box"&gt;</span><br><span class="line">    &lt;el-table</span><br><span class="line">      :data="data"</span><br><span class="line">      :class="{'is-empty': !data ||  data.length ==0 }"</span><br><span class="line">      &gt;</span><br><span class="line">      &lt;el-table-column</span><br><span class="line">        v-for = "(item, index) in listItemConfig"</span><br><span class="line">        :key="item + index" </span><br><span class="line">        :prop="item.prop" </span><br><span class="line">        :label="item.label" </span><br><span class="line">        :width="item.width ? item.width : ''"</span><br><span class="line">        :min-width="item.minWidth ? item.minWidth : ''"</span><br><span class="line">        :max-width="item.maxWidth ? item.maxWidth : ''"&gt;</span><br><span class="line">      &lt;/el-table-column&gt;</span><br><span class="line">      &lt;!-- 操作 --&gt;</span><br><span class="line">      &lt;el-table-column label="操作" align="right" width="60"&gt;</span><br><span class="line">        &lt;template slot-scope="scope"&gt;</span><br><span class="line">          &lt;slot :data="scope.row" name="listOption"&gt;&lt;/slot&gt;</span><br><span class="line">        &lt;/template&gt;</span><br><span class="line">      &lt;/el-table-column&gt;</span><br><span class="line">      &lt;!-- 列表为空 --&gt;</span><br><span class="line">      &lt;template slot="empty"&gt;</span><br><span class="line">        &lt;common-empty /&gt;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line">    &lt;/el-table&gt;</span><br><span class="line">    </span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default {</span><br><span class="line">    props: {</span><br><span class="line">        listItemConfig:{ //列表项配置</span><br><span class="line">        type:Array,</span><br><span class="line">        default: () =&gt; {</span><br><span class="line">            return [{</span><br><span class="line">                prop:'sku_name',</span><br><span class="line">                label:'商品名称',</span><br><span class="line">                minWidth:200</span><br><span class="line">            },{</span><br><span class="line">                prop:'sku_code',</span><br><span class="line">                label:'SKU',</span><br><span class="line">                minWidth:120</span><br><span class="line">            },{</span><br><span class="line">                prop:'product_barcode',</span><br><span class="line">                label:'条形码',</span><br><span class="line">                minWidth:120</span><br><span class="line">            }]</span><br><span class="line">      }</span><br><span class="line">    }}</span><br><span class="line">  }</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><h2 id="业务组件"><a href="#业务组件" class="headerlink" title="业务组件"></a>业务组件</h2><p>通常是根据最小业务状态抽象而出，有些业务组件也具有一定的复用性，但大多数是一次性组件</p><p><img src="http://cdn.anruence.com/yewu.png" alt="image"></p><h2 id="通用组件"><a href="#通用组件" class="headerlink" title="通用组件"></a>通用组件</h2><p>可以在一个或多个 APP 内通用的组件</p><h3 id="UI组件"><a href="#UI组件" class="headerlink" title="UI组件"></a>UI 组件</h3><ul><li>界面扩展类组件，比如弹窗</li></ul><p><img src="http://cdn.anruence.com/UI.png" alt="image"></p><p>特点：复用性强，只通过 props、events 和 slots 等组件接口与外部通信</p><h4 id="表现形式🌰（vue）-2"><a href="#表现形式🌰（vue）-2" class="headerlink" title="表现形式🌰（vue）"></a>表现形式🌰（vue）</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class="empty"&gt;</span><br><span class="line">    &lt;img src="/images/empty.png" alt&gt;</span><br><span class="line">    &lt;p&gt;暂无数据&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="逻辑组件"><a href="#逻辑组件" class="headerlink" title="逻辑组件"></a>逻辑组件</h3><ul><li>不包含 UI 层的某个功能的逻辑集合</li></ul><h2 id="高阶组件（HOC）"><a href="#高阶组件（HOC）" class="headerlink" title="高阶组件（HOC）"></a>高阶组件（HOC）</h2><p>高阶组件可以看做是函数式编程中的组合<br>可以把高阶组件看做是一个函数，他接收一个组件作为参数，并返回一个功能增强的组件</p><p>高阶组件可以抽象组件公共功能的方法而不污染你本身的组件<br>比如 <code>debounce</code> 与 <code>throttle</code></p><p>用一张图来表示</p><p><img src="http://cdn.anruence.com/hoc.png" alt="jsworke"></p><p>React 中高阶组件是比较常用的组件封装形式，Vue 官方内置了一个高阶组件 <a href="https://github.com/vuejs/vue/blob/dev/src/core/components/keep-alive.js">keep-alive</a>，但并未推荐使用 HOC :(</p><p><strong>猜想原因</strong></p><ul><li>React：写组件就是在写函数，函数拥有的功能组件都有</li><li> Vue：更像是高度封装的函数，能够让你轻松的完成一些事情的同时损失一定的灵活性，你需要按照一定规则才能使系统更好的运行</li></ul><h3 id="表现形式🌰（react）"><a href="#表现形式🌰（react）" class="headerlink" title="表现形式🌰（react）"></a>表现形式🌰（react）</h3><p>品牌车系滑动的动画</p><p><img src="http://cdn.anruence.com/reacthoc.png"></p><h2 id="各类组件协同组成业务模块"><a href="#各类组件协同组成业务模块" class="headerlink" title="各类组件协同组成业务模块"></a>各类组件协同组成业务模块</h2><p><img src="http://cdn.anruence.com/MOKUAITU.png" alt="image"></p><h2 id="容器-展示组件"><a href="#容器-展示组件" class="headerlink" title="容器/展示组件"></a>容器 / 展示组件</h2><p>对比图</p><p><img src="http://cdn.anruence.com/rongqitu.png" alt="image"></p><h3 id="引入容器组件的概念只是一种更好的组织方式"><a href="#引入容器组件的概念只是一种更好的组织方式" class="headerlink" title="引入容器组件的概念只是一种更好的组织方式"></a>引入容器组件的概念只是一种更好的组织方式</h3><ul><li>各司其职，不易出错，即使出错，也能快速定位问题</li><li>容器组件，一个载体的存在</li><li>展示型组件不与 store 耦合，通过 props 接口来定义所需的数据和方法，<strong>复用性与正确性更能保证 </strong></li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">展示型组件直接和store通信的话，那么它就会收到限制，因为你在store里面的字段已经限制他的使用次数和使用的位置</span><br></pre></td></tr></tbody></table></figure><p><font color="red">既然如此，那我什么时候引入容器组件，什么时候引入展示组件</font></p><h3 id="引入容器组件的时机"><a href="#引入容器组件的时机" class="headerlink" title="引入容器组件的时机"></a>引入容器组件的时机</h3><p>优先考虑展示组件，当你意识到有一些中间组件不使用它继承的 props 而是转而传递给他们的子级，每次子级组件需要更多数据时，都需要 “路过” 这些中间组件时就要考虑引入容器组件！</p><p>两者的区别并没有被严格定义，<font color="red">事实上不在技术上而是目的性上</font></p><h4 id="这里有几个供参考的点"><a href="#这里有几个供参考的点" class="headerlink" title="这里有几个供参考的点"></a>这里有几个供参考的点</h4><ul><li>容器组件倾向于有状态，展示组件倾向于无状态，这不是硬性规定，它们都是可以有状态的</li><li>不要把分离容器组件和展示组件当做教条，如果你不确定该组件是容器组件还是展示组件，就暂时不要分离，写成展示组件，也许是为时尚早，别着急！</li><li>这是一个持续的重构过程，不用试图一次就把它做好，习惯这种模式就会培养起一种直觉，知道何时引入容器 就像你知道何时封装一个函数那样！</li></ul><h2 id="进行组件职能划分的利弊"><a href="#进行组件职能划分的利弊" class="headerlink" title="进行组件职能划分的利弊"></a>进行组件职能划分的利弊</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>更好的关注分离 </li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用这种方式写组件，你可以更好的理解你的app和你的ui，甚至会逐渐形成你自己的开发套路</span><br></pre></td></tr></tbody></table></figure><ul><li>复用性高 </li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个组件只做一件事，解除了组件的耦合带来更高复用性</span><br></pre></td></tr></tbody></table></figure><ul><li>它是 app 的调色版，设计师可以随意调整它的 ui 而不用改变 app 的逻辑</li><li>这会强制你提取 “布局组件”，达到更高的易用性</li><li>提高健壮性 </li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">由于展示组件和容器组件是通过prop接口来连接，可以利用props的校验机制来增强代码的可靠性，混合的组件就没有这种好处</span><br><span class="line"></span><br><span class="line">举个🌰(Vue)</span><br><span class="line">  props: {</span><br><span class="line">    editData: Object,</span><br><span class="line">    statusConfig: {</span><br><span class="line">      type: Object,</span><br><span class="line">      default() {</span><br><span class="line">        return {</span><br><span class="line">          isShowOption: true, //是否有操作栏</span><br><span class="line">          isShowSaveBtn: false</span><br><span class="line">        };</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><ul><li>可测试性 </li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">组件做的事情更少了，测试也会变得容易</span><br><span class="line">容器组件不用关心UI的展示，只关心数据和更新</span><br><span class="line">展示组件只是呈现传入的props，写单元测试的时候也非常容易mock数据层</span><br></pre></td></tr></tbody></table></figure><h3 id="所谓的缺点"><a href="#所谓的缺点" class="headerlink" title="所谓的缺点"></a>所谓的缺点</h3><ul><li>设计组件初期会增加一些学习成本</li><li>由于需要封装一个容器，包装一些数据和接口给展示组件，<strong>会增加一些工作量</strong></li><li>在展示组件内对 props 的声明会带来少量的工作</li></ul><p><font color="red">长远来看，利大于弊，特别是项目初期，一定要有一个好的设计习惯</font></p><h1 id="组件设计的边界"><a href="#组件设计的边界" class="headerlink" title="组件设计的边界"></a>组件设计的边界</h1><p>物极必反，跃跃欲试前，常常思考以下几个问题以引导完善组件的设计</p><h2 id="页面层级不宜嵌套超过三层，切勿过度设计"><a href="#页面层级不宜嵌套超过三层，切勿过度设计" class="headerlink" title="页面层级不宜嵌套超过三层，切勿过度设计"></a>页面层级不宜嵌套超过三层，切勿过度设计</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原则上组件嵌套超过三层，数据传递的过程就会变得相对复杂</span><br></pre></td></tr></tbody></table></figure><h2 id="这个组件可否（有必要）再分？"><a href="#这个组件可否（有必要）再分？" class="headerlink" title="这个组件可否（有必要）再分？"></a>这个组件可否（有必要）再分？</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">划分粒度的根据实际情况权衡，太小会提升维护成本，太大又不够灵活和高复用性</span><br><span class="line"></span><br><span class="line">是否打破了一个逻辑上有意义的实体，倘若抽离的话，这个代码被复用的概率有多大？</span><br><span class="line"></span><br><span class="line">如果它只是几行代码，那么最终可能会创建更多的代码来分离它，有必要吗？我这么做的好处是否超过了成本？</span><br><span class="line"></span><br><span class="line">如果你当前的逻辑不太可能出现在其他地方，那么将它嵌入其中更好，如果需要，你可以随时抽离，毕竟组件化没有终点</span><br><span class="line"></span><br><span class="line">每一个组件都应该有其独特的划分目的的，有的是为了复用实现，有的是为了封装复杂度清晰业务实现</span><br><span class="line">组件划分的依据通常是业务逻辑、功能，要考虑各组件之间的关系是否明确，及可复用度</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="性能会受到影响吗？"><a href="#性能会受到影响吗？" class="headerlink" title="性能会受到影响吗？"></a>性能会受到影响吗？</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果状态频繁更改，并且当前在一个较大且关系比较紧密的组件里，为了避免性能受到影响最好抽离出来 与diff策略相关</span><br></pre></td></tr></tbody></table></figure><h2 id="这个组件的依赖是否可再缩减？"><a href="#这个组件的依赖是否可再缩减？" class="headerlink" title="这个组件的依赖是否可再缩减？"></a>这个组件的依赖是否可再缩减？</h2><p>缩减组件依赖可以提高组件的可复用度</p><h2 id="这个组件是否对其它组件造成侵入？"><a href="#这个组件是否对其它组件造成侵入？" class="headerlink" title="这个组件是否对其它组件造成侵入？"></a>这个组件是否对其它组件造成侵入？</h2><ul><li>封装性不足或自身越界操作，就可能对自身之外造成了侵入</li><li>一个组件不应对其它兄弟组件造成直接影响 </li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">常见的一种情况是：组件运行时对window对象添加resize监听事件以实现组件响应视窗尺寸变化事件</span><br><span class="line"></span><br><span class="line">最优的方案：组件提供刷新方法，由父组件实现调用</span><br><span class="line">次优的方案：组件destroy前清理恢复</span><br></pre></td></tr></tbody></table></figure><h2 id="接口设计是否兼容大部分场景？"><a href="#接口设计是否兼容大部分场景？" class="headerlink" title="接口设计是否兼容大部分场景？"></a>接口设计是否兼容大部分场景？</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">需要考虑需要适用的不同场景，在组件接口设计时进行必要的兼容</span><br></pre></td></tr></tbody></table></figure><h2 id="当别人使用这个组件时，会怎么想？"><a href="#当别人使用这个组件时，会怎么想？" class="headerlink" title="当别人使用这个组件时，会怎么想？"></a>当别人使用这个组件时，会怎么想？</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接口设计符合规范和大众习惯，尽量让别人用起来简单易上手，易上手是指更符合直觉</span><br></pre></td></tr></tbody></table></figure><h2 id="假如业务需要不需要这个功能，是否方便清除？"><a href="#假如业务需要不需要这个功能，是否方便清除？" class="headerlink" title="假如业务需要不需要这个功能，是否方便清除？"></a>假如业务需要不需要这个功能，是否方便清除？</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">各组件之前以组合的关系互相配合，也是对功能需求的模块化抽象，当需求变化时可以将实现以模块粒度进行调整</span><br></pre></td></tr></tbody></table></figure><p>上文提到的各种准则仅仅描述了一种开发理念，也可以认为是一种开发规范，倘若你认可这规范，对它的分治策略产生了共鸣，那我们就可以继续聊聊它的具体实现了</p><p>问自己一个问题</p><p><font color="red">你心中的相对完美的组件是什么样子的？</font></p><h1 id="落实到具体业务中如何做"><a href="#落实到具体业务中如何做" class="headerlink" title="落实到具体业务中如何做"></a>落实到具体业务中如何做</h1><h2 id="划分依据"><a href="#划分依据" class="headerlink" title="划分依据"></a>划分依据</h2><p>明确你的组件划分依据，目前是两种</p><ul><li>根据业务划分</li><li>根据技术划分</li></ul><ol><li>我更多的是根据业务去设计我应用中的组件树，可能会画个草图或 xmind，它可以帮我统观全局</li><li>明确各个组件的边界，内部 state 的设计，props 的设计以及与其他组件的关系（需要回调出去的事件）</li><li>明确各个组件的定位与职能划分，设计好父子组件、兄弟组件的通信机制</li><li>搭架子</li><li>架子有了，开始填空</li></ol><h2 id="切割模版（页面结构模块化）"><a href="#切割模版（页面结构模块化）" class="headerlink" title="切割模版（页面结构模块化）"></a>切割模版（页面结构模块化）</h2><p>这是最容易想到的方法，当一个组件渲染了很多元素，就需要尝试分离这些组件的渲染逻辑<br>我们以掘金页面为例</p><p><img src="http://cdn.anruence.com/5.png" alt="jsworke"></p><p>大体上看，可以分为 Part1，Part2，Part3</p><h3 id="初步开发"><a href="#初步开发" class="headerlink" title="初步开发"></a>初步开发</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id="app"&gt;</span><br><span class="line">    &lt;div class="panel"&gt;</span><br><span class="line">      &lt;div class="part1 left"&gt;</span><br><span class="line">        &lt;!--内容--&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div class="part1 right"&gt;</span><br><span class="line">        &lt;!--内容--&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div class="part1 right"&gt;</span><br><span class="line">        &lt;!--内容--&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>问题：</p><ul><li>代码量大，难以维护，难以测试</li><li>有些许重复量</li></ul><h3 id="化繁为简"><a href="#化繁为简" class="headerlink" title="化繁为简"></a>化繁为简</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id="app"&gt;</span><br><span class="line">      &lt;part1 /&gt;</span><br><span class="line">      &lt;part2 /&gt;</span><br><span class="line">      &lt;part3 /&gt; </span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>好处：</p><ul><li>同之前的方式相比，这个微妙的改进是革命性的</li><li>解决了测试困难，维护困难的问题</li></ul><p>问题：</p><ul><li>没有解决代码重复的问题，这种按模块划分，复用性低</li></ul><p>但我看过很多项目的代码，就是这么干的，认为自己做了组件化，抽象的还不错 (@_@)</p><h3 id="组件抽象"><a href="#组件抽象" class="headerlink" title="组件抽象"></a>组件抽象</h3><p>它们有相似的外层，part2 和 part3 更有相似的 titlebar，除了业务内容，完全就是一模一样</p><p>🌰（vue）</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class="part"&gt;</span><br><span class="line">    &lt;header&gt;</span><br><span class="line">      &lt;span&gt;{{ title }}&lt;/span&gt;</span><br><span class="line">    &lt;/header&gt;</span><br><span class="line">    &lt;slot name="content" /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>我们将 part 内可以抽象的数据都做成了 props，利用 slot 去做模版<br>那么我们在开发相应 Part1，Part2 时</p><p>🌰（vue）</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id="app"&gt;</span><br><span class="line">      &lt;part title="亦舒"&gt;</span><br><span class="line">        &lt;div slot="content"&gt;----&lt;/div&gt;</span><br><span class="line">      &lt;/part&gt;</span><br><span class="line">      &lt;part title="兴隆臻园户型"&gt;</span><br><span class="line">        &lt;div slot="content"&gt;-----&lt;/div&gt;</span><br><span class="line">      &lt;/part&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></tbody></table></figure><p>更具代表性的示例图</p><p><img src="http://cdn.anruence.com/6.png" alt="jsworke"></p><ul><li>UI 差异在哪里定义？</li></ul><p>在业务逻辑层处理</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先要明确一点，这些差异并不是组件本身造成的，是你自己的业务逻辑造成的，所以容器组件（父组件）应该为此买单</span><br></pre></td></tr></tbody></table></figure><ul><li>数据差异在哪里定义？</li></ul><p>结合组件本身和业务上下文将差异合理的消除在内部</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">比如part3中，其他的part只有一个类似更多&gt;&gt;的link，但是它却有多个(一居，二居...)</span><br><span class="line">这里我推荐将这种差异体现在组件内部，设计方法也很多：</span><br><span class="line">比如可以将link数组化为links；</span><br><span class="line">比如可以将更多&gt;&gt;看作是一个default的link，而多余的部分则是用户自定义的特殊link，这两者合并组成了links。用户自定义的默认是没有的，需要引用组件时进行传入。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ul><li>组件命名规则？</li></ul><p>组件设计初期，就应该拥有不耦合业务的名字</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一个通用的或者说未来可能通用的，要有相对合理的命名，比如 Search，List,尽量不要出现与业务耦合过深的业务名词，通用组件与业务无关，只与自身抽象的组件有关</span><br><span class="line">我们在设计组件初期，就应该有这种思想，等到真正可以抽出公用组件了，再去苦逼的名改名字？</span><br><span class="line">库通常都想让广大开发者用，我们在设计组件时，可以降低标准到先做到你的整个APP中通用</span><br></pre></td></tr></tbody></table></figure><h2 id="组件划分细粒度的考量（抽之有度）"><a href="#组件划分细粒度的考量（抽之有度）" class="headerlink" title="组件划分细粒度的考量（抽之有度）"></a>组件划分细粒度的考量（抽之有度）</h2><p>组件设计规则明明白白写着我们要遵循单一职责原则，这也带来了上文聊过的<font color="red">过度抽象（组件化）</font>的问题，我们结合具体的业务聊一下</p><p><img src="http://cdn.anruence.com/7.png" alt="jsworke"></p><p>要实现徽章组件，它有两部分组成</p><ul><li>按钮</li><li>右上角提示（小红点 /icon）</li></ul><p>两者都是符合单一职责的，可以将其抽离成一个独立组件，但是通常不要这么做</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为同一个app的风格必将是统一的，除此之外没别的应用场景了，就像上文所说的，抽离组件之前，多问自己为什么以及投入/产出比，没有绝对的规则</span><br></pre></td></tr></tbody></table></figure><h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><p><font color="red">单一职责组件要建立在可复用的基础上，对于不可复用的单⼀职责组件我们仅仅作为独立组件的内部组件即可</font></p><h3 id="某二手车网站体现其细粒度的例子"><a href="#某二手车网站体现其细粒度的例子" class="headerlink" title="某二手车网站体现其细粒度的例子"></a>某二手车网站体现其细粒度的例子</h3><p><img src="http://cdn.anruence.com/1.gif" alt="jsworke"></p><p>思考，如果让你实现你会如何设计…<br>我当初是这么设计的</p><p><img src="http://cdn.anruence.com/8.png" alt="jsworke"></p><p>index.js(react)</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className="select-brand-box" onTouchStart={touchStartHandler} onTouchMove={touchMoveHandler} onTouchEnd={touchEndHandler.bind(this, touchEndCallback)}&gt;</span><br><span class="line">     &lt;NavBar&gt;&lt;/NavBar&gt;</span><br><span class="line">     &lt;Brand key="brands-list" {...brandsProps} /&gt;</span><br><span class="line">     &lt;Series key="series-list" {...seriesProps} &gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line"> </span><br><span class="line"> export default BrandHoc(index);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>Brand.js(react)</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className="brand-box"&gt;</span><br><span class="line">    &lt;div className="brand-wrap" ref="brandWrap"&gt;</span><br><span class="line">        &lt;p className="brands-title hot-brands-title"&gt;热门品牌&lt;/p&gt;</span><br><span class="line">        &lt;FlexLayout onClick={hotBrandClick}&gt;</span><br><span class="line">            &lt;HotBrands HotBrands={hotBrands} /&gt;</span><br><span class="line">        &lt;/FlexLayout&gt;</span><br><span class="line">        {!isHideStar &amp;&amp; &lt;UnlimitType {...unlimitProps} /&gt;}</span><br><span class="line">        &lt;AllBrands {...brandsProps} /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;AsideLetter {...asideProps} /&gt;</span><br><span class="line">    {showPop ? &lt;PopTips key="pop-tips" tip={currentLetter} /&gt; : null}</span><br><span class="line">    {showBrandLoading ? &lt;Loading /&gt; : null}</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">            </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>FlexLayout.js(react)</p><p><img src="http://cdn.anruence.com/9.png" alt="jsworke"></p><p>这个示例几乎涵盖了所有的规则</p><ul><li>首先组件的设计是根据业务划分的，所以右侧字母导航（AsideLetter）才没有在最外层的容器组件，否则通信问题会占用一部分篇幅，事实上这是有解的</li><li>入口组件是容器组件，事实上把它当做一个规则就行了，业务逻辑的载体</li><li>除了容器组件外，其他的组件都被抽成公用的了，二手车平台类似的场景非常多</li></ul><p><img src="http://cdn.anruence.com/10.png" alt="jsworke"></p><ul><li>卖车平台类似的图文混排多且形态各不相同，应用场景广泛，抽！UI 差异消化在组件内部，参考 FlexLayout.js，给定 default props</li><li> 可提取的组件过多（业务驱动）导致通讯困难如何解决？ 那说明你需要新增可管理状态的容器组件，上例中 Brand，Series 也是容器组件，负责管理子组件的大小事宜</li><li>细粒度的考量，考虑付出产出比 </li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p className="brands-title hot-brands-title"&gt;热门品牌&lt;/p&gt; 只有一行，直接写就完了</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ul><li>组件抽离的过程就是无限向无状态（展示型）组件无限靠近的过程</li></ul><h2 id="通用性考量"><a href="#通用性考量" class="headerlink" title="通用性考量"></a>通用性考量</h2><p>组件的形态 (UI) 永远是千变万化的，但是其行为 (逻辑) 是固定的，因此通用组件的秘诀之⼀就是<font color="red">将 DOM 结构的控制权交给开发者，组件只负责⾏为和最基本的 DOM 结构</font></p><p>这是一个显眼的栗子</p><p>某一天，你接到这样儿的需求</p><p><img src="http://cdn.anruence.com/12.png" alt="jsworke"></p><p>开心，简单，三下五除二写完了</p><p>突然有一天又有这样儿的需求</p><p><img src="http://cdn.anruence.com/13.png" alt="jsworke"></p><p>emm.. 可定制？之前的 select 没法用了，怎么做？要修改上一个或者再写一个吗？<br>一旦出现了这种情况，证明之前的组件需要重新设计了</p><p>实现通用性设计的关键一点是<font color="red">放弃对 Dom 的掌控</font></p><h3 id="那么问题又来了，那么多需要自定义的地方，那组件会不会很难用？"><a href="#那么问题又来了，那么多需要自定义的地方，那组件会不会很难用？" class="headerlink" title="那么问题又来了，那么多需要自定义的地方，那组件会不会很难用？"></a>那么问题又来了，那么多需要自定义的地方，那组件会不会很难用？</h3><p>通用性设计在将 Dom 结构决定权交给开发者的同时指定默认值</p><p>这里是一个新鲜出炉 (vue)🌰</p><p>List 组件</p><p><img src="http://cdn.anruence.com/14.png" alt="jsworke"></p><p>父组件🌰(vue) 及 slot</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">模版（伪代码）</span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;List :data="tableData[item.type]" :loading="loading" @loadMore="loadMore" :noMore="noMore"&gt;</span><br><span class="line">    &lt;a v-if="item.type == 0" slot="listOption" slot-scope="childScope" class="edit-btn" @click="edit(childScope.data)" v-bind:key="childScope.data.id"&gt;{{Status[childScope.data.status]['text']}}&lt;/a&gt;</span><br><span class="line">&lt;/List&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">config(伪代码)</span><br><span class="line">export const Status = {</span><br><span class="line">  //....</span><br><span class="line">  1: {</span><br><span class="line">    label: '草稿',</span><br><span class="line">    type: '',</span><br><span class="line">    text: '编辑',</span><br><span class="line">    class: 'note'</span><br><span class="line">  }}</span><br><span class="line">  //...</span><br></pre></td></tr></tbody></table></figure><p>又有一个栗子 (vue)</p><p><img src="http://cdn.anruence.com/15.png" alt="jsworke"></p><ul><li>Dialog 只负责基础的逻辑，交出控制权给到业务，至于你的业务需要什么，在容器组件（业务逻辑层）去处理</li></ul><p>忍不住放上磐石业务的反面例子</p><p><img src="http://cdn.anruence.com/16.png" alt="jsworke"></p><p>难用无非是两方面的问题</p><ol><li>不肯移交控制权</li><li>没有 API 文档</li></ol><p>所有的业务逻辑与场景都包含在组件内部，外界只通过变量来控制，初衷是好的，但是随着业务发展，组件越来越庞大，开发者也越来越力不从心了</p><p>刚好现阶段 UI 改版，我们的工作量就由只改样式直接转化为推倒重来了，又没有详细的文档，工作量瞬间翻了 N 倍😭宝宝心里苦宝宝不说</p><h2 id="善用设计模式"><a href="#善用设计模式" class="headerlink" title="善用设计模式"></a>善用设计模式</h2><p>其实一开始，我并没有专门去套用设计模式，完全是业务驱使<br>你一定见到过这样儿的</p><p><img src="http://cdn.anruence.com/17.png" alt="jsworke"></p><p>一旦这样儿的逻辑多了，那是不是就跟业务耦合了，跟业务耦合多了，那组件自然没有什么通用性了，即使我们不考虑到通用性，那写的累吧？</p><p>考虑下这样写会不会好一点</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">config（伪代码）</span><br><span class="line">export const Status = {</span><br><span class="line">  4: {</span><br><span class="line">    label: '部分入库',</span><br><span class="line">    type: '',</span><br><span class="line">    text: '查看'</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line">模版(vue)</span><br><span class="line">&lt;a v-if="item.type == 0" slot="listOption" slot-scope="childScope" class="edit-btn" @click="edit(childScope.data)" v-bind:key="childScope.data.id"&gt;{{Status[childScope.data.status]['text']}}&lt;/a&gt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>世界上本没有设计模式，写的人多了，就自成一套脱颖而出进而被历史铭记了！不仅如此，一部分看似复杂的业务如果合理设计配置项，可以会为你省去一大篇 js</p><h1 id="一些感悟"><a href="#一些感悟" class="headerlink" title="一些感悟"></a>一些感悟</h1><p>像磐石这种底层的业务支持系统，离不开大量的列表，查询，编辑，详情等，我一般会花 30 秒搭好架子，像但不限于下面这种</p><p><img src="http://cdn.anruence.com/18.png" alt="jsworke"></p><ul><li>index: 模块入口（承担容器职责）</li><li>api：整块业务的 API</li><li>components 业务组件集合 </li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. Form：表单 一般会被add.vue（编辑） 和edit.vue（详情）引用</span><br><span class="line">2. List：列表</span><br><span class="line">3. Search: 搜索组件</span><br><span class="line">4. 其他业务中有但却没看到的基本上都已经抽离到common了 比如面包屑导航，收起展开功能等</span><br></pre></td></tr></tbody></table></figure><ul><li>libs 页面的各种配置</li></ul><h2 id="具体体现（磐石刚刚重构的模块）"><a href="#具体体现（磐石刚刚重构的模块）" class="headerlink" title="具体体现（磐石刚刚重构的模块）"></a>具体体现（磐石刚刚重构的模块）</h2><p>采购模块结构图</p><p><img src="http://cdn.anruence.com/2222323232323.png" alt="image"></p><p>Form</p><p><img src="http://cdn.anruence.com/edit.png" alt="image"></p><p>Edit</p><p><img src="http://cdn.anruence.com/form.png" alt="image"></p><p>无论有多少种状态，只在 edit 这层容器维护</p><h2 id="要这么做的原因"><a href="#要这么做的原因" class="headerlink" title="要这么做的原因"></a>要这么做的原因</h2><ul><li>components 中的组件只是暂存，都有可能被升级成通用组件，所以命名要注意，一类的保持了统一，防止业务耦合</li><li> bug 有迹可循，数据的问题我一定从外向里排查，样式问题从里向外排查，定位问题快</li><li>与重复代码做斗争，时刻保持一种强迫症的心态去整理各个模块，形成自己的编码风格，进而团队风格才有可能统一</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>对于组件设计，充分的准备固然，但在现实世界中，切实的结果才是最重要的，组件设计也不要过度设计更不要停滞不前，该做的时候就去做，发现不好就去改</li><li>有空闲时间就去思考早期不够理想的代码，它可以作为我们向前发展的基础</li><li>技术在变迁，但组件化的核心并没有改变，目标仍然是在 API 设计尽可能接近原生的情况下完成复用、解耦、封装、抽象的目标，最终服务于开发，提高效率降低错误率</li></ul><ul><li>组件化是对实现的分层，是更有效地代码组合方式</li><li>组件化是对资源的重组和优化，从而使项目资源管理更合理，方便拔插、方便集成、方便删除、方便删除后重新加入</li><li>这种化繁为简的思想在后端开发中的体现是微服务，而在前端开发中的体现就是组件化</li></ul><ul><li>组件化有利于单元测试与自测效率对重构较友好</li><li>新人加入可以直接分配组件进行开发、测试，而非需要熟悉整个项目，可以从一个组件的开发使新进人员比较快速熟悉项目、了解到开发规范</li><li>你的直接责任可能是编写代码，但你的终极目标是在创建产品</li></ul><p>最后说一句</p><p><font color="red">组件化没有终点，day day up</font></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://engineering.carsguide.com.au/front-end-component-design-principles-55c5963998c9?gi=b5b86599de92">https://engineering.carsguide.com.au/front-end-component-design-principles-55c5963998c9?gi=b5b86599de92</a></li><li><a href="https://segmentfault.com/a/1190000009952681">https://segmentfault.com/a/1190000009952681</a></li><li><a href="https://juejin.im/post/5a73d6435188257a6a789d0d">https://juejin.im/post/5a73d6435188257a6a789d0d</a></li><li><a href="https://medium.com/merrickchristensen/function-as-child-components-5f3920a9ace9">https://medium.com/merrickchristensen/function-as-child-components-5f3920a9ace9</a></li><li><a href="http://www.alloyteam.com/2015/11/we-will-be-componentized-web-long-text/">http://www.alloyteam.com/2015/11/we-will-be-componentized-web-long-text/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5d566e82f265da03f77e653c&quot;&gt;掘金链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;组件化思想并不是前端独有的，但却是前端技术的延伸&lt;/p&gt;
&lt;p&gt;随着三大框架崛起，前端组件化逐渐成为前端开发的迫切需求，一种主流，一种共识，它不仅提高开发效率，同时也降低了维组件内聚原则护成本&lt;br&gt;开发者们不需要再面对一堆晦涩难懂的代码，转而只需要关注以组件⽅式存在的代码⽚段&lt;/p&gt;
&lt;p&gt;这是一场新的挑战！&lt;/p&gt;
&lt;h2 id=&quot;文章开始之前，明确本文的边界&quot;&gt;&lt;a href=&quot;#文章开始之前，明确本文的边界&quot; class=&quot;headerlink&quot; title=&quot;文章开始之前，明确本文的边界&quot;&gt;&lt;/a&gt;文章开始之前，明确本文的边界&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;从前端工程谈到组件化开发&lt;/li&gt;
&lt;li&gt;组件的设计原则&lt;/li&gt;
&lt;li&gt;组件的职能划分及利弊&lt;/li&gt;
&lt;li&gt;组件设计的边界&lt;/li&gt;
&lt;li&gt;落实到具体业务中如何做&lt;/li&gt;
&lt;li&gt;一些感悟&lt;/li&gt;
&lt;li&gt;总结&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;一个面试题引发的思考&quot;&gt;&lt;a href=&quot;#一个面试题引发的思考&quot; class=&quot;headerlink&quot; title=&quot;一个面试题引发的思考&quot;&gt;&lt;/a&gt;一个面试题引发的思考&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;面试官通常会问 写过前端通用组件吗？&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="前端" scheme="http://maying.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="组件设计" scheme="http://maying.ink/tags/%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>React diff 算法</title>
    <link href="http://maying.ink/2019/04/01/diff/"/>
    <id>http://maying.ink/2019/04/01/diff/</id>
    <published>2019-03-31T16:00:00.000Z</published>
    <updated>2020-10-22T18:41:42.181Z</updated>
    
    <content type="html"><![CDATA[<p>理解 react 的 diff 算法</p><a id="more"></a><p><img src="/images/passive/diff.png" alt="jsworke"></p><h2 id="同级节点的移动-增加-删除的具体实现"><a href="#同级节点的移动-增加-删除的具体实现" class="headerlink" title="同级节点的移动 增加 删除的具体实现"></a>同级节点的移动 增加 删除的具体实现</h2><h3 id="场景一-新旧集合中存在相同节点但位置不同时，如何移动节点"><a href="#场景一-新旧集合中存在相同节点但位置不同时，如何移动节点" class="headerlink" title="场景一 新旧集合中存在相同节点但位置不同时，如何移动节点"></a>场景一 新旧集合中存在相同节点但位置不同时，如何移动节点</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">旧  a b c d</span><br><span class="line">新  b a d c</span><br></pre></td></tr></tbody></table></figure><p>React 先从新组合中取得 b，然后判断旧中是否存在相同节点 b，当发现存在节点 b 后，就去判断是否移动 b<br>涉及到两个变量 index 和 lastIndex</p><ul><li>index:b 在集合里下标 此时 index = 1</li><li>lastIndex：类似于一个 map 的索引，一开始默认值是 0，它会与 map 中的元素进行比较，比较完后，更新当前的值（取 index 和 lastIndex 的较大数）</li></ul><h4 id="比较规则："><a href="#比较规则：" class="headerlink" title="比较规则："></a>比较规则：</h4><p>如果 index &lt; lastIndex 那此元素就需要移动<br>在旧组合里将该元素移动到下标为 lastIndex 的位置</p><p>具体的计算过程看下图</p><p><img src="/images/passive/diff2.jpeg" alt="jsworke"></p><h3 id="场景一-新集合中有新加入的节点，旧集合中有删除的节点"><a href="#场景一-新集合中有新加入的节点，旧集合中有删除的节点" class="headerlink" title="场景一 新集合中有新加入的节点，旧集合中有删除的节点"></a>场景一 新集合中有新加入的节点，旧集合中有删除的节点</h3><p>规则同上</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">旧  a b c d</span><br><span class="line">新  b e c a</span><br></pre></td></tr></tbody></table></figure><p>比较 b 此时 index = 1 lastindex = 0  1&gt;0 b 不移动 更新 lastindex 为 1<br>当比较到 e 的时候，发现旧组合中不存在，故在旧组合下标为 1 的位置 创建 E，更新 lastIndex=1<br>…<br>对比到 a 因为是最后一个 所以 diff 操作结束</p><p>新组合对比完成后 再去对旧集合遍历 判断新集合没有，但旧集合有的元素（如 d），删除 d，diff 操作结束</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;理解 react 的 diff 算法&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="http://maying.ink/categories/web/"/>
    
    
  </entry>
  
  <entry>
    <title>一个页面从输入 url 到加载完成 这个过程发生了什么</title>
    <link href="http://maying.ink/2019/03/31/urlrender/"/>
    <id>http://maying.ink/2019/03/31/urlrender/</id>
    <published>2019-03-31T15:26:26.000Z</published>
    <updated>2020-10-22T18:41:42.187Z</updated>
    
    <content type="html"><![CDATA[<h4 id="先来了解以下-五层因特尔协议栈"><a href="#先来了解以下-五层因特尔协议栈" class="headerlink" title="先来了解以下 五层因特尔协议栈"></a>先来了解以下 五层因特尔协议栈</h4><ul><li>应用层（dns http） DNS 解析成 ip 并完成 http 请求发送</li><li>传输层（tcp udp）三次握手四次挥手建立 tcp 链接</li><li>网络层 （ip ARP） IP 寻址</li><li>数字链路层 将请求数据封装成帧</li><li>物理层 利用物理介质传输比特流</li></ul><a id="more"></a><h4 id="简介版本"><a href="#简介版本" class="headerlink" title="简介版本"></a>简介版本</h4><ol><li>浏览器根据请求的 url 交给 DNS 解析 找到这真实 IP 向服务器发起请求</li><li>服务器交给后台处理完成后返回数据，浏览器接收文件（html,css javascript) 等</li><li>浏览器对加载到的资源进行语法解析，构建相应的内部数据结构（Dom 树 css 树 render 树等）</li><li>载入解析到的资源文件渲染页面完成</li></ol><h4 id="详细版本"><a href="#详细版本" class="headerlink" title="详细版本"></a>详细版本</h4><ol><li>浏览器开启一个线程来处理这个请求，对 url 进行判断，如果是 http 协议，则就按照 web 的方式来处理</li><li>浏览器解析 url，一般我么输入的都是服务器域名，我们会先查找对应的 ip</li><li> 首先会查看浏览器的 DNS 缓存，如果存在，则域名解析到此完成</li><li>如果浏览器自身的缓存没有找到相应的条目，就会尝试读取操作系统的 host 文件来看时都存在对应的映射关系</li><li>如果 host 文件没有，继续查找本地的域名服务器</li><li>如果本地的域名服务器还没有找到的话 ，它就会向跟服务器发出请求，进行递归查询</li><li>查到了 IP 地址，会将记录存储在本地缓存，此时网络层便会通过 ip 地址寻得对应服务器的物理地址</li><li>寻得服务器的地址 客户端在网络传输层便可以和服务器通过三次握手建立 TCPIP 链接 </li></ol><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">TCPIP请求</span><br><span class="line"></span><br><span class="line">http的本质就是TCP/IP请求</span><br><span class="line">需要经历三次握手建立链接 4次挥手断开连接</span><br><span class="line">TCP将http长报文划分为短报文，通过三次握手与服务器建立链接进行可靠传输</span><br><span class="line"></span><br><span class="line">三次握手</span><br><span class="line"></span><br><span class="line">1. 客户端：你是XX服务器吗</span><br><span class="line">2. 服务端：我是XX服务器，你是客户端吗？</span><br><span class="line">3. 客户端：是的 我是客户端</span><br><span class="line">成功 </span><br><span class="line"></span><br><span class="line">四次挥手</span><br><span class="line">主动方：我已经关闭了向你那边的信息发送通道，只能被动接受信息了</span><br><span class="line">被动方：收到通道关闭信息</span><br><span class="line">被动方：我现在也关闭了</span><br><span class="line">主动方：收到消息 连接断开 之后双方无法通信</span><br><span class="line"></span><br><span class="line">TCPIP请求：浏览器在同一个域名下并发的TCP链接是有限制的（2-10个）</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ol start="9"><li>链接成功后 链路层将请求数据封装成帧</li><li>最后物理层通过物理介质进行传输</li><li>到了服务器就会通过相反的方式将数据一层一层的还原回去</li><li>请求到了后端服务器一般都会有统一的验证 如安全验证，跨域验证等，验证未通过就直接返回相应的 http 报文</li><li>验证通过后就会进入后台代码 此时程序收到请求执行相应的操作（如查询数据库等）</li><li>如果浏览器访问过 且缓存上有相应的资源便会与服务器最后的修改时间对比，一致便返回 304 告诉浏览器可以使用本地缓存</li><li>前端浏览器接收到响应成功的报文便开始下载网页<br>下载完的网页交给浏览器的内核（渲染进程）进行处理 </li></ol><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">* 根据顶部定义的DTD类型进行相应的解析方式</span><br><span class="line">* 渲染进程内部是多线程的 网页的解析会被交给内部的GUI渲染进程处理</span><br><span class="line">* 首先渲染进程中的html解释器将html网页和资源从字节流解释转化为字符流</span><br><span class="line">* 再通过词法分析器将字符流解释成词语</span><br><span class="line">* 之后通过语法分析器根据词语构成节点，最后通过这些节点组建一个DOM树</span><br><span class="line">* 这个过程中 如果遇到的DOM节点是js代码，就会调用js引擎对js代码进行解释执行。此时由于js引擎和GUI渲染进程的互斥，GUI渲染就会被挂起，渲染过程停止；如果js代码的运行中对dom树进行了修改，那么都没树的构建需要重新开始</span><br><span class="line">* 如果节点需要依赖其他资源（图片 css）便会调用网络模块的资源去加载它们，但他们是异步的所以不会阻塞当前dom树的构建</span><br><span class="line">* 如果遇到的是js资源url（没有标记异步）则需要停止当前dom的构建 直到js的资源加载并被js引擎执行后才继续构建dom</span><br><span class="line">* 对于css css解释器会将css文件解释成内部表示结构（同html解析 子节流-&gt;字符流-&gt;词语-&gt;节点），生成css规则树</span><br><span class="line">* 然后合并css树和dom树，生成render渲染树</span><br><span class="line">* 最后对render树进行布局和绘制，并将结果通过IO线程传递给Browser控制进程（浏览器主进程）进行显示</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;先来了解以下-五层因特尔协议栈&quot;&gt;&lt;a href=&quot;#先来了解以下-五层因特尔协议栈&quot; class=&quot;headerlink&quot; title=&quot;先来了解以下 五层因特尔协议栈&quot;&gt;&lt;/a&gt;先来了解以下 五层因特尔协议栈&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;应用层（dns http） DNS 解析成 ip 并完成 http 请求发送&lt;/li&gt;
&lt;li&gt;传输层（tcp udp）三次握手四次挥手建立 tcp 链接&lt;/li&gt;
&lt;li&gt;网络层 （ip ARP） IP 寻址&lt;/li&gt;
&lt;li&gt;数字链路层 将请求数据封装成帧&lt;/li&gt;
&lt;li&gt;物理层 利用物理介质传输比特流&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>你不知道的 JS 系列 - this 指向</title>
    <link href="http://maying.ink/2019/03/26/this/"/>
    <id>http://maying.ink/2019/03/26/this/</id>
    <published>2019-03-26T04:53:02.000Z</published>
    <updated>2020-10-22T18:41:42.186Z</updated>
    
    <content type="html"><![CDATA[<p>this 是 js 中最复杂的机制之一</p><blockquote><p>任何足够先进的技术都和魔法无异  - Arthur C.Clarke</p></blockquote><a id="more"></a><p>但其实 this 机制并没有那么先进，是我们的臆想把它想复杂了，在缺乏认知的情况下，this 对你来说就是魔法</p><h3 id="为什么要使用this？"><a href="#为什么要使用this？" class="headerlink" title="为什么要使用this？"></a>为什么要使用 this？</h3><p>它提供了一种更优雅的方式来隐式传递一个对象引用，因此可以将 API 设计得更加简洁并且易于使用</p><h3 id="对于this的误解"><a href="#对于this的误解" class="headerlink" title="对于this的误解"></a>对于 this 的误解</h3><ol><li>指向函数自身 </li></ol><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">常见需要指向自身的场景是递归</span><br><span class="line">匿名的函数无法指向自身</span><br><span class="line">传统的arguments.callee已经弃用</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>指向函数的词法作用域 </li></ol><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this在任何情况下都不指向函数的词法作用域，在js内部作用域和对象相似，可见的标识符都是它的属性,但是作用域“对象”无法通过js代码访问，它存在于JS引擎内部</span><br></pre></td></tr></tbody></table></figure><h3 id="this到底是什么？"><a href="#this到底是什么？" class="headerlink" title="this到底是什么？"></a>this 到底是什么？</h3><p>this 是运行时进行绑定的 并不是在编写时绑定的 它的上下文取决于函数调用时的各种条件 this 绑定和函数声明的位置没有任何关系 只取决于函数的调用方式</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当一个函数调用时 会创建一个活动记录（执行上下文）这个记录会包含函数在哪里被调用（调用栈）函数的调用方法 传入的参数等 this就是记录的其中一个属性会在函数执行的过程中用到</span><br><span class="line"></span><br><span class="line">this时函数被调用时发生的绑定 指向什么完全取决于函数在哪里被调用</span><br></pre></td></tr></tbody></table></figure><h4 id="调用位置"><a href="#调用位置" class="headerlink" title="调用位置"></a>调用位置</h4><p>寻找” 函数被调用的位置”<br>需要分析调用栈（为了到达当前执行位置所调用的所有函数）</p><h4 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h4><p>找到调用位置 然后按照结论中的四条规则判断</p><h4 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h4><p>独立函数调用时，如果在严格模式下，就绑定到 undefined 否则绑定到全局对象 </p><h4 id="隐式绑定-对象上的函数调用"><a href="#隐式绑定-对象上的函数调用" class="headerlink" title="隐式绑定(对象上的函数调用)"></a>隐式绑定 (对象上的函数调用)</h4><p>当函数引用有上下文对象时 隐式绑定规则会把函数中的 this 绑定到这个上下文对象</p><p><strong>对象属性引用链中只有最顶层或者说最后一层会影响调用位置</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function foo(){</span><br><span class="line">  console.log(this.a)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var obj2 = {</span><br><span class="line">  a:42,</span><br><span class="line">  foo:foo</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">var obj1 = {</span><br><span class="line">  a:2,</span><br><span class="line">  obj2:obj2</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">obj1.obj2.foo(); //42</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var a = 20;</span><br><span class="line">var obj = {</span><br><span class="line">    a: 10,</span><br><span class="line">    c: this.a + 20,</span><br><span class="line">    fn: function () {</span><br><span class="line">        return this.a;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">console.log(obj.c); //40</span><br><span class="line">console.log(obj.fn()); //10</span><br></pre></td></tr></tbody></table></figure><p>单独的 {} 是不会形成新的作用域的，因此这里的 <code>this.a</code>，由于并没有作用域的限制，所以它仍然处于全局作用域之中。所以这里的 <code>this</code> 其实是指向的 <code>window</code> 对象。</p><p><strong>被隐式绑定的函数会丢失绑定对象而执行默认绑定规则 下面是两个场景</strong></p><p>1.</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function foo(){</span><br><span class="line">  console.log(this.a)</span><br><span class="line">}</span><br><span class="line">var obj1 = {</span><br><span class="line">  a:2,</span><br><span class="line">  foo:foo</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var bar = obj1.foo; //函数别名</span><br><span class="line">var a = "global"; //全局属性a</span><br><span class="line">bar(); //bar引用的是foo本身 因此此时的bar其实是一个不带任何修饰符的函数调用 因此使用了默认绑定</span><br></pre></td></tr></tbody></table></figure><p><strong>2. 当传入回调函数时 使用默认绑定规则</strong></p><p>参数传递就是一种隐式赋值，因此我们传入函数时也会被隐式赋值</p><p>如果把函数传入语言内置函数 结果也是一样的</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function foo(){</span><br><span class="line">  console.log(this.a)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">function dofoo(fn){</span><br><span class="line">  fn();</span><br><span class="line">}</span><br><span class="line">var obj1 = {</span><br><span class="line">  a:2,</span><br><span class="line">  foo:foo</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var a = "global mama"; //全局属性a</span><br><span class="line"></span><br><span class="line">dofoo(obj1.foo) //global mama</span><br><span class="line"></span><br><span class="line">setTimeout(obj1.foo,100) //global mama 将函数传入语言内置的函数</span><br><span class="line">相当于</span><br><span class="line">function setTimeout(fn,delay){</span><br><span class="line">//等待delay之后</span><br><span class="line">fn() </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="显式绑定-使用call-apply-bind"><a href="#显式绑定-使用call-apply-bind" class="headerlink" title="显式绑定(使用call apply bind)"></a>显式绑定 (使用 call apply bind)</h4><p>通过固定 this 来修复，可以在某个对象上强制调用函数<br><code>使用 call apply 或者bind</code></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">他们的第一个参数式对象，它们会把这个对象绑定到this，接着在调用函数时指定这个this 因为你可以直接指定this的绑定对象 因此我们称之为显式绑定</span><br></pre></td></tr></tbody></table></figure><p>如果 foo.call (1) // 一个原始值当作对象 这个原始值会转换成它的对象形式 (装箱)</p><p><strong>可惜，显示绑定无法解决丢失绑定的问题</strong></p><p>但是显示绑定的一个变种 “硬绑定” 可以解决这个问题</p><p><strong>硬绑定</strong>：无论何时调用函数 bar 它总会手动在 obj 调用 foo 这种绑定是一种显式的强制绑定</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function foo(){</span><br><span class="line">  console.log(this.a)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var obj1 = {</span><br><span class="line">  a:2</span><br><span class="line">}</span><br><span class="line">var obj2 = {</span><br><span class="line">  a:4</span><br><span class="line">}</span><br><span class="line">var bar = function(){</span><br><span class="line">  foo.call(obj1)</span><br><span class="line">}</span><br><span class="line">bar(); //2</span><br><span class="line">setTimeout(bar,100) //2</span><br><span class="line">bar.call(obj2) // 2 硬绑定的bar不可能再修改它的this</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>由于硬绑定是一种常用的模式，所以 ES5 提供了内置的方法<br><code>Function.prototype.bind</code></p><p>了解了用法 我们来看一个 demo</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let a = {};</span><br><span class="line">let fn = function(){</span><br><span class="line">  console.log(this)</span><br><span class="line">}</span><br><span class="line">fn.bind().bind(a)() // ?</span><br></pre></td></tr></tbody></table></figure><p>答案应该是 <code>window</code> 你回答对了吗</p><p>事实上 我么可以改写一下</p><p>它类似于</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a = {};</span><br><span class="line">let fn = function(){console.log(this)}</span><br><span class="line">let fn2 = function fn1(){</span><br><span class="line">  return function(){</span><br><span class="line">    return fn.apply();</span><br><span class="line">  }.apply(a)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">fn2() //window</span><br></pre></td></tr></tbody></table></figure><p>这样儿结果能猜到了吗</p><p>fn 中的 this 永远由<code>第一个bind</code> 决定 所以 结果永远是 window</p><h4 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new 绑定</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">js中的构造函数只是一些使用new操作符时被调用的函数 他们不并不属于某个类也不会去实例化一个类 他们只是被new操作符调用的普通函数</span><br><span class="line"></span><br><span class="line">插播new调用的时候会自动执行下面的操作</span><br><span class="line">1. 创建（构造一个全新的对象）</span><br><span class="line">2. 这个对象会被执行原型链接</span><br><span class="line">3. 这个信贷想回绑定到函数调用的this</span><br><span class="line">4. 如果函数没有返回其他对象那么new表达式中的函数调用会自动返回这个新对象</span><br></pre></td></tr></tbody></table></figure><p>由此可以知道 new 操作符调用时，this 指向生成的新对象<br>⚠️new 调用时的返回值，如果没有显式返回对象或者函数，才会返回新对象<br>关于这一点</p><p><a href="">这应该是一篇关于模拟实现 JS 的 new 操作符的文章</a></p><h4 id="绑定优先级"><a href="#绑定优先级" class="headerlink" title="绑定优先级"></a>绑定优先级</h4><p>new 调用 &gt; 显示绑定 (apply,call,bind) &gt; 隐式绑定（对象上的函数调用） &gt; 默认绑定</p><h4 id="绑定例外"><a href="#绑定例外" class="headerlink" title="绑定例外"></a>绑定例外</h4><p>规则总有例外，这里也一样</p><p>当你把 <code>null</code> 或者 <code>undefined</code> 作为 <code>this</code> 的绑定对象传入 <code>call apply</code> 或者 <code>bind</code> 这些在调用时候会被忽略应用默认规则<br>应用场景：当你要传入参数时候 如果函数不关心 this 的话 你可以传入 null 当作一个占位值 但是这种方式不可取 绑定 this 可能会引起副作用</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function foo(){</span><br><span class="line">  console.log(this.a)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var obj = {</span><br><span class="line">  a:2</span><br><span class="line">}</span><br><span class="line">var a = 3</span><br><span class="line">foo.call(null)</span><br></pre></td></tr></tbody></table></figure><p>一种更安全的 this</p><p><code>Object.create(null) </code>创建的空对象不会创建 <code>object.prototype</code> 比 <code>{}</code> 更空 比 <code>null</code> 的语义更清楚</p><p>代码如下</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function foo(a,b){</span><br><span class="line">  console.log(a,b)</span><br><span class="line">}</span><br><span class="line">var w = Object.create(null);</span><br><span class="line"></span><br><span class="line">foo.apply(w,[2,3])</span><br><span class="line"></span><br><span class="line">//使用bind()进行柯里化</span><br><span class="line">var bar = foo.bind(w,2)</span><br><span class="line">bar(3)</span><br></pre></td></tr></tbody></table></figure><p><strong>间接引用</strong><br>你会有意无意的创建一个函数的间接引用，在这种情况下，调用这个函数会应用默认规则<br><strong>它最容易在赋值时产生</strong><br>类似这样儿的</p><p><code>(p.foo = o.foo)();</code> 它的返回值是目标函数的引用，因此调用的位置是 <code>foo()</code> 而不是 <code>p.foo()</code> 或者 <code>o.foo()</code> 所以使用默认绑定</p><h4 id="箭头函数调用模式"><a href="#箭头函数调用模式" class="headerlink" title="箭头函数调用模式"></a>箭头函数调用模式</h4><p>先看箭头函数和普通函数的重要区别：</p><ol><li>没有自己的 this、super、arguments 和 new.target 绑定。</li><li>不能使用 new 来调用。</li><li>没有原型对象。</li><li>不可以改变 this 的绑定。</li><li>形参名称不能重复。</li></ol><hr><p>箭头函数中没有 <code>this</code> 绑定，必须通过查找作用域链来决定其值。<br>如果箭头函数被非箭头函数包含，则 <code>this</code> 绑定的是最近一层非箭头函数的 <code>this</code>，否则 <code>this</code> 的值则被设置为全局对象。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var name = 'window';</span><br><span class="line">var student = {</span><br><span class="line">    name: 'ma',</span><br><span class="line">    doSth: function(){</span><br><span class="line">        // var self = this;</span><br><span class="line">        var arrowDoSth = () =&gt; {</span><br><span class="line">            // console.log(self.name);</span><br><span class="line">            console.log(this.name);</span><br><span class="line">        }</span><br><span class="line">        arrowDoSth();</span><br><span class="line">    },</span><br><span class="line">    arrowDoSth2: () =&gt; {</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">student.doSth(); // 'ma'</span><br><span class="line">student.arrowDoSth2(); // 'window'</span><br></pre></td></tr></tbody></table></figure><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul><li> this 不指向函数自身</li><li> this 不指向函数的词法作用域，当你想要把 this 和词法作用域查找混合使用时，一定要提醒自己 这是无法实现的</li><li> this 实际上是在函数被调用时发生绑定的，指向什么完全取决于函数在哪里被调用</li><li> 如果要判断一个运行中函数的 this 绑定 就需要找到这个函数的直接调用位置 找到之后按照下面这四条规则判断 this 的绑定对象 </li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.由new调用？绑定到新创建的对象</span><br><span class="line">2.由call或apply或bind调用(显示绑定)？绑定到指定的对象</span><br><span class="line">3.由上下文对象调用（隐式绑定）？绑定到上下文对象</span><br><span class="line">4.如果都不是的话 使用默认绑定，如果在严格模式下，就绑定到undefined 否则绑定到全局对象 </span><br></pre></td></tr></tbody></table></figure><ul><li>ES6 中的箭头函数不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定 this, 它会继承外层函数调用的 this 绑定 (无论 this 绑定到什么), 这跟 ES6 之前代码中的 <code>self=this</code> 机制一样（实际上箭头函数将程序猿们常犯的一个错误：<font color="red">混淆 this 绑定规则和词法作用域规则 </font>给标准化了，这点容易造成误解）</li><li>DOM 事件函数：一般指向绑定事件的 DOM 元素，但有些情况绑定到全局对象（比如 IE6~IE8 的 attachEvent）</li></ul><p>检验一下学习成果</p><p><a href="https://www.cnblogs.com/xxcanghai/p/5189353.html">小小沧海：一道常被人轻视的前端 JS 面试题</a><br><a href="https://segmentfault.com/a/1190000010981003">从这两套题，重新认识 JS 的 this、作用域、闭包、对象</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;this 是 js 中最复杂的机制之一&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;任何足够先进的技术都和魔法无异  - Arthur C.Clarke&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="js" scheme="http://maying.ink/categories/js/"/>
    
    
      <category term="this" scheme="http://maying.ink/tags/this/"/>
    
  </entry>
  
  <entry>
    <title>你不知道的 JS 系列 - 理解 JS 中 赋值，浅拷贝，深拷贝</title>
    <link href="http://maying.ink/2019/03/25/clone/"/>
    <id>http://maying.ink/2019/03/25/clone/</id>
    <published>2019-03-25T10:28:10.000Z</published>
    <updated>2020-10-22T18:41:42.181Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>又回到了这个老生常谈，新生绝望的问题上，通常遇到这种大家都比较熟悉的问题，反而不知道怎么列大纲，怕不够深入也怕脱离主题～<br>emm..<br>此文系 不要再问我 XX 系列之 <font color="red">不要再问我 JS Clone 的问题了</font></p><a id="more"></a><h2 id="为什么会存在这三种情况？三者有何差异"><a href="#为什么会存在这三种情况？三者有何差异" class="headerlink" title="为什么会存在这三种情况？三者有何差异"></a>为什么会存在这三种情况？三者有何差异</h2><p><code>clone</code> 本来很简单，只是因为 JS 中不同的数据类型存储方式 (<strong>堆和栈</strong>) 的差异，我们才会觉得它貌似有点‘复杂’</p><p><img src="/images/clone/clone1.png" alt="clone1"></p><p>基本类型和引用类型的差异如上图所示了<br>它们共同的目标就是<font color="red">以一个对象为原型 clone 出另外一个新对象，因为自身的问题产生一些副作用，三者的差异其实就体现在副作用的差异上</font></p><h3 id="差异（堆和栈）"><a href="#差异（堆和栈）" class="headerlink" title="差异（堆和栈）"></a>差异（堆和栈）</h3><ul><li>栈（stack）为自动分配的内存空间，它由系统自动释放</li><li>而堆（heap）则是动态分配的内存，大小不定也不会自动释放</li></ul><hr><p><font color="red">基础类型：</font> 值存放在栈中，<strong>比较是值的比较</strong><br><font color="red">引用类型：</font> 值存放在堆中，变量实际上是一个存放在栈内存的指针，这个指针指向堆内存中的地址。每个空间大小不一样，要根据情况开进行特定的分配，<strong>引用类型的比较是引用的比较</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var person1 = [1,2,3];</span><br><span class="line">var person2 = [1,2,3];</span><br><span class="line">console.log(a === b); // false</span><br></pre></td></tr></tbody></table></figure><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>赋值的概念 即使刚入行也不陌生，每天都在用的<code>'='</code></p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul><li>基本类型：在内存中新开辟一段栈内存，然后再把再将值赋值到新的栈中，是两个独立相互不影响的变量</li><li>引用类型：赋值是传址，是对象保存在栈中的地址的赋值，这样的话两个变量就指向堆内存的同一个对象，因此两者之间操作互相有影响</li></ul><h4 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = {</span><br><span class="line">  name:'maying',</span><br><span class="line">  age:22,</span><br><span class="line">  sex:'女',</span><br><span class="line">  language : [1,[2,3],[4,5],[9,0]]</span><br><span class="line">}</span><br><span class="line">var sringD = 'pre';</span><br><span class="line">var obj3 = sringD;</span><br><span class="line">sringD = 'post';</span><br><span class="line"></span><br><span class="line">var obj2 = obj1;</span><br><span class="line">obj1.name = 'gaile',</span><br><span class="line">obj1.language[0] = 'jjj'</span><br><span class="line">console.log('obj1',obj1)</span><br><span class="line">       /*</span><br><span class="line">        {</span><br><span class="line">            age: 22</span><br><span class="line">            language: (4) ["jjj", Array(2), Array(2), Array(2)]</span><br><span class="line">            name: "gaile"</span><br><span class="line">            sex: "女"</span><br><span class="line">        }</span><br><span class="line">       */</span><br><span class="line">console.log('obj2',obj2)</span><br><span class="line">        /*</span><br><span class="line">            age: 22</span><br><span class="line">            language: (4) ["jjj", Array(2), Array(2), Array(2)]</span><br><span class="line">            name: "gaile"</span><br><span class="line">            sex: "女"</span><br><span class="line">        */</span><br><span class="line">console.log('sringD',sringD) //post</span><br><span class="line">console.log('obj3',obj3) //pre</span><br></pre></td></tr></tbody></table></figure><h3 id="理解浅拷贝"><a href="#理解浅拷贝" class="headerlink" title="理解浅拷贝"></a>理解浅拷贝</h3><p>之前的很多年，我认为<strong>赋值差不多等于浅拷贝</strong><br>写个小 demo 发现它们之间的差异</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj2 = obj1;</span><br><span class="line">var obj3 = {...obj1};</span><br><span class="line">obj1.name = 'gaile',</span><br><span class="line">obj1.language[0] = 'jjj'</span><br><span class="line">console.log('obj1',obj1)</span><br><span class="line">console.log('obj2',obj2)</span><br><span class="line">console.log('obj3',obj3)</span><br></pre></td></tr></tbody></table></figure><p><img src="/images/clone/qiankaobei2.png" alt="qiankaobei2"><br>赋值对象，是将对象指针直接赋值给另一个变量<br>浅拷贝，是重新创建了新对象，所以你更改 <code>obj1.name</code> 的时候不会影响到它，但是改变引用类型时就不能幸免了</p><p><strong>所谓的浅拷贝就是：</strong></p><ul><li>当对简单的数据类型进行赋值的时候，其实就是直接在栈中新开辟一个地方专门来存储一样的值</li><li>当对引用类型进行浅拷贝，后面的对象和前面的对象在第一层数据结构中指向同一个堆地址，但是如果前面的数据不止有一层（<font color="red">属性值是一个指向对象的引用只拷贝那个引用值</font>），类似 </li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">language : [1,[2,3],[4,5],[9,0]]</span><br></pre></td></tr></tbody></table></figure><p><strong>内部的子对象的指针还是同一个地址</strong></p><p>如果要实现一直往下复制 就引出了接下来要说的<font color="red">深拷贝</font></p><p><strong>结论：浅复制要比复制来的深刻一点，至少它开辟了一个新对象，一块儿新的堆内存</strong></p><h4 id="目前可行的实现方式"><a href="#目前可行的实现方式" class="headerlink" title="目前可行的实现方式"></a>目前可行的实现方式</h4><p>站在巨人的肩膀上，我们可以轻松实现浅拷贝</p><ul><li>数组的浅拷贝 </li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. b = [...a]</span><br><span class="line">2. b = a.slice(0) / [].slice.call(a,0)</span><br><span class="line">3. b = a.concat() / [].concat.call(a)</span><br></pre></td></tr></tbody></table></figure><ul><li>对象的浅拷贝 </li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. b = Object.assign({},a)</span><br><span class="line">2. b = {...a}</span><br></pre></td></tr></tbody></table></figure><h4 id="如果要你自己实现呢"><a href="#如果要你自己实现呢" class="headerlink" title="如果要你自己实现呢"></a>如果要你自己实现呢</h4><p>原理：遍历对象的每个属性进行逐个拷贝</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function copy(obj) {</span><br><span class="line">  if (!obj || typeof obj !== 'object') {</span><br><span class="line">    return</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  var newObj = obj.constructor === Array ? [] : {}</span><br><span class="line">  for (var key in obj) {</span><br><span class="line">       if(obj.hasOwnProperty(key)){</span><br><span class="line">          newObj[key] = obj[key]</span><br><span class="line">        }</span><br><span class="line">  }</span><br><span class="line">  return newObj</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="理解深拷贝"><a href="#理解深拷贝" class="headerlink" title="理解深拷贝"></a>理解深拷贝</h3><p>深拷贝的意义，就是完全复制，如果你读了上文，应该就没有什么疑问了</p><p>将 a 对象复制一份给对象 b，不管 a 中的数据结构嵌套有多深，当改变 a 对象中的任意深度的某个值后，b 中的该值不会受任何影响</p><h4 id="目前可行的实现方式-1"><a href="#目前可行的实现方式-1" class="headerlink" title="目前可行的实现方式"></a>目前可行的实现方式</h4><ul><li><code>JSON.stringify()``和JSON.parse()</code> 的混合配对使用 </li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var obj4 = JSON.parse(JSON.stringify(obj1)) </span><br><span class="line"></span><br><span class="line">obj1.name='yishu',</span><br><span class="line"></span><br><span class="line">obj1.language[1] = ["二","三"];</span><br><span class="line">obj4.language[2] = ["四","五"];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.log(obj1);   </span><br><span class="line">console.log(obj4); </span><br></pre></td></tr></tbody></table></figure><p><img src="/images/clone/deepclone.png" alt="deepclone"><br><code>obj1</code>,<code>obj4</code> 是两个独立的对象，更改数据互不影响，达到了我们要的目的</p><p><strong>它粗暴，有用，但是也有缺点</strong></p><ol><li><code>在JSON.stringify()</code> 做序列化时，<code>undefined</code>、<code>function</code> 以及 <code>symbol</code> 值，会被忽略</li></ol><p>例如</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var obj = {</span><br><span class="line">  a: {b: 'old'}, </span><br><span class="line">  c:undefined, </span><br><span class="line">  d: function () {},</span><br><span class="line">  e:  Symbol('')</span><br><span class="line"> }</span><br><span class="line">var newObj = JSON.parse(JSON.stringify(obj))</span><br><span class="line">newObj.a.b = 'new'</span><br><span class="line">console.log(obj)</span><br><span class="line">console.log(newObj)</span><br></pre></td></tr></tbody></table></figure><p>结果<br><img src="/images/clone/jsonquedian.png" alt="jsonquedian"></p><h4 id="如果要你自己实现呢-1"><a href="#如果要你自己实现呢-1" class="headerlink" title="如果要你自己实现呢"></a>如果要你自己实现呢</h4><p>原理：使用递归，遍历每一个对象属性进行拷贝</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var obj = {</span><br><span class="line">  a: {b: 'old'}, </span><br><span class="line">  c:undefined, </span><br><span class="line">  d: function () {},</span><br><span class="line">  e:  Symbol('')</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function copy(obj) {</span><br><span class="line">  if (!obj || typeof obj !== 'object') {</span><br><span class="line">    return</span><br><span class="line">  }</span><br><span class="line">  var newObj = obj.constructor === Array ? [] : {}</span><br><span class="line">  for (var key in obj) {</span><br><span class="line">    if (obj.hasOwnProperty(key)) {</span><br><span class="line">      if (typeof obj[key] === 'object' &amp;&amp; obj[key]) {</span><br><span class="line">        newObj[key] = copy(obj[key])</span><br><span class="line">      } else {</span><br><span class="line">        newObj[key] = obj[key]</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  return newObj</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var newObj = copy(obj)</span><br><span class="line">newObj.a.b = 'new'</span><br><span class="line">console.log(obj)</span><br><span class="line">console.log(newObj)</span><br></pre></td></tr></tbody></table></figure><p><img src="/images/clone/jsonquedian.png" alt="jsonquedian"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>赋值：引用复制 执向同一个对象</li><li>浅拷贝 ：生成一个新对象，只能拷贝一层，当属性值是一个指向对象的引用只拷贝那个引用值</li><li>深拷贝：完全拷贝，前后对象没有任何关系</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.zhihu.com/question/23031215">https://www.zhihu.com/question/23031215</a><br><a href="https://segmentfault.com/a/1190000018204798">https://segmentfault.com/a/1190000018204798</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;开篇&quot;&gt;&lt;a href=&quot;#开篇&quot; class=&quot;headerlink&quot; title=&quot;开篇&quot;&gt;&lt;/a&gt;开篇&lt;/h2&gt;&lt;p&gt;又回到了这个老生常谈，新生绝望的问题上，通常遇到这种大家都比较熟悉的问题，反而不知道怎么列大纲，怕不够深入也怕脱离主题～&lt;br&gt;emm..&lt;br&gt;此文系 不要再问我 XX 系列之 &lt;font color=&quot;red&quot;&gt;不要再问我 JS Clone 的问题了&lt;/font&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="http://maying.ink/categories/js/"/>
    
    
      <category term="clone" scheme="http://maying.ink/tags/clone/"/>
    
  </entry>
  
  <entry>
    <title>你不知道的 JS 系列 - 作用域、变量提升、闭包</title>
    <link href="http://maying.ink/2019/03/25/actionScope/"/>
    <id>http://maying.ink/2019/03/25/actionScope/</id>
    <published>2019-03-25T08:48:08.000Z</published>
    <updated>2020-10-22T18:41:42.180Z</updated>
    
    <content type="html"><![CDATA[<p>来看几个既基本又重要的概念查漏补缺</p><a id="more"></a><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>几乎所有编程语言最基础的功能之一 就是存储变量当中的值，并能在之后对这个值进行访问和修改<br>引出下面两个问题</p><ul><li>那这些变量存储在哪里？</li><li>程序需要的时候 如何找到他们？</li></ul><p>我们需要一套设计良好的规则来存储变量，并且之后可以方便的找到这些变量，它叫 <font color="red">作用域</font></p><h3 id="js程序编译原理"><a href="#js程序编译原理" class="headerlink" title="js程序编译原理"></a>js 程序编译原理</h3><p>js 是一门编译语言，但是与传统的编译语言不同，他不是提前编译的</p><p>js 引擎进行编译的步骤和传统的编译语言非常相似，但是某些环节会更加复杂 例如：在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素的优化</p><ul><li>分词 / 词法分析</li><li>解析 / 语法分析 </li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将词法单元流（数组）转化为AST（抽象语法树）</span><br></pre></td></tr></tbody></table></figure><ul><li>代码生成 </li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将AST转化为可执行代码</span><br></pre></td></tr></tbody></table></figure><p>js 引擎执行一段可执行代码时，会创建对应的执行上下文，对于每个执行上下文，都有三个重要属性：</p><ul><li><p>变量对象</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每一个执行上下文都会分配一个变量对象，变量对象的属性由变量和函数声明构成，在函数上下文的情况下，参数列表也会被加入到变量对象作为属性,不同作用域的变量对象互不相同，它保存了当前作用域的所有函数和变量</span><br></pre></td></tr></tbody></table></figure></li><li><p>作用域链</p></li><li><p>this 指向</p><p>当你看到 <code>var a = 2</code> 程序内部的工作过程</p></li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">编译器将这端程序分解成词法单元 var a, a=2 然后将词法单元解析成一个树结构</span><br><span class="line"></span><br><span class="line">1.遇到var a 编译器会询问作用域是否已经有该变量的名称存在于同一个作用域中,如果是，编译器忽略该声明 否则会要求作用域在当前作用域的集合中声明一个新的变量 命名为a</span><br><span class="line">2.当为引擎生成运行时所需要的代码 a=2 js引擎运行时会询问作用域，当前作用域的集合中是否存在a 存在 就是用 不存在就继续查找 如果还是找不到 就抛出异常</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>总结：变量的赋值操作会执行两个过程</p><ul><li>编译器会在当前作用域中生成一个变量（之前没有生成过）这会在代码执行前进行</li><li>运行时 js 引擎会在作用域中查找（LHS 查询）该变量能找到就给他赋值</li></ul><h4 id="js引擎是如何查找变量的？"><a href="#js引擎是如何查找变量的？" class="headerlink" title="js引擎是如何查找变量的？"></a>js 引擎是如何查找变量的？</h4><p>LHS 查询 （赋值操作的目标是谁）<br>RHS 查询 （谁是赋值操作的源头）</p><h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><p>大部分的标准语言编译器的第一个工作就叫词法化<br>词法化的过程会对源代码进行检查<br>词法作用域就是定义在词法阶段的作用域<br>词法作用域意味着作用域是由书写代码时函数声明的位置决定的</p><h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><p>函数是 js 中最常见的作用域单元 声明在一个函数内部的变量或函数会在所处的作用域中隐藏起来 这符合最小授权（暴露）原则</p><h4 id="最小授权（暴露）原则的好处？"><a href="#最小授权（暴露）原则的好处？" class="headerlink" title="最小授权（暴露）原则的好处？"></a>最小授权（暴露）原则的好处？</h4><ol><li>隐藏内部实现 API 友好</li><li>规避冲突 （同名标识符之间的冲突）</li></ol><h3 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h3><p>块作用域是指变量和函数不仅可以属于所处的作用域也可以属于某个代码块儿 {…}<br>ES3 开始 try/catch 结构在 catch 分句中具有块作用域<br>ES6 引入了 let const 可以用在循环中 会将当前的值重新绑定到了循环的每一个迭代中</p><hr><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>作用域是一套规则，用于确定在何处以及如何查找变量，如果查找的目的是对变量进行赋值，那么就会使用 LHS 查询，如果目的是为了获取变量的值 那就进行 RHS 查询 赋值操作会导致 LHS 查询</li><li> LHS 与 RHS 查询都会从当前作用域中开始，如果有需要就会向上级作用域继续查找目标标识符。这样儿每次上升一级作用域，最后抵达迁居作用域 无论找到没找到都会停止</li><li>不成功的 RHS 引用会抛出异常 不成功的 RHS 引用会导致自动隐式创建一个全局变量</li><li>词法作用域意味着作用域是由书写代码时函数声明的位置决定的。编译的词法分析阶段基本能够知道全部标识符在哪里以及如何声明的，从而能够在执行过程中如何对他们进行查找</li><li> eval () 与 with () 可以扩充词法作用域 但是会有性能问题</li><li>函数是常见但不是唯一的作用域单元，函数作用域与块作用域的行为是一样儿的 任何声明在某个作用域内的变量都将附属于这个作用域</li><li> ES6 中引入了 let 关键字 用来在任意代码块中声明变量</li></ul><h2 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h2><ul><li>先有声明 后有赋值</li><li>只有声明本身会被提升，而赋值等其他运行逻辑会留在原地，提升不会改变代码的执行顺序</li><li>注意避免重复声明</li><li>每个作用域都会进行提升操作</li><li>函数声明会被提升，函数表达式不会被提升</li><li>函数提升优先于变量提升</li><li>一个普通块内部的函数声明通常会被提升到所在作用域的顶部</li><li>无论作用域中的声明出现在什么地方，都将会在代码本身被执行前首先被处理（所有的变量声明和函数声明）都会被移动到各自作用域的最顶端</li></ul><hr><h2 id="作用域闭包"><a href="#作用域闭包" class="headerlink" title="作用域闭包"></a>作用域闭包</h2><ul><li>闭包无处不在 你需要的是识别并且拥抱它</li><li>闭包是基于词法作用域书写代码时产生的自然结果</li><li>当函数可以记住并访问所在的词法作用域时就产生了闭包 即使函数是在当前词法作用域之外执行</li><li>闭包可以使得函数可以继续访问定义时的词法作用域</li><li>如果将函数当作第一级的值类型并到处传递 就会看到闭包在这些函数中的应用</li><li>在定时器，事件监听器 ajax 请求 或者任何其他的异步任务重 之要使用了回调函数 实际上就是在使用闭包</li><li>闭包 就是关于如何在函数作为值按需传递的词法环境中书写代码的</li></ul><h3 id="循环与闭包"><a href="#循环与闭包" class="headerlink" title="循环与闭包"></a>循环与闭包</h3><p>块作用域和闭包联手便可天下无敌</p><p>使用 IIFE（自执行函数）</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">for(var i =1; i&lt;=5;i++){</span><br><span class="line">  (function(j){</span><br><span class="line">    setTimeout(function timer(){</span><br><span class="line">    console.log('j',j);</span><br><span class="line">  },i*100)</span><br><span class="line">  })(i);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">let用来劫持块作用域 并且在这个块作用域中声明一个变量</span><br><span class="line"></span><br><span class="line">for(var i =1; i&lt;=5;i++){</span><br><span class="line">  let j = i</span><br><span class="line">  setTimeout(function timer(){</span><br><span class="line">    console.log(j);</span><br><span class="line">  },i*100)</span><br><span class="line">}</span><br><span class="line">for循环头部的let声明 每次迭代都会声明</span><br><span class="line">for(let i =1; i&lt;=5;i++){</span><br><span class="line">  setTimeout(function timer(){</span><br><span class="line">    console.log(i);</span><br><span class="line">  },i*100)</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来看几个既基本又重要的概念查漏补缺&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="http://maying.ink/categories/js/"/>
    
    
      <category term="作用域" scheme="http://maying.ink/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
      <category term="闭包" scheme="http://maying.ink/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>写在入职两周年</title>
    <link href="http://maying.ink/2019/03/22/twoYears/"/>
    <id>http://maying.ink/2019/03/22/twoYears/</id>
    <published>2019-03-22T02:14:12.000Z</published>
    <updated>2020-10-22T18:41:42.187Z</updated>
    
    <content type="html"><![CDATA[<p>博客计划</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;博客计划&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>异步编程方案的演进</title>
    <link href="http://maying.ink/2019/03/19/promise/"/>
    <id>http://maying.ink/2019/03/19/promise/</id>
    <published>2019-03-19T10:28:57.000Z</published>
    <updated>2020-10-22T18:41:42.185Z</updated>
    
    <content type="html"><![CDATA[<p>程序中<strong>现在运行的部分</strong>和<strong>将来运行的部分</strong>就是<strong>异步编程的核心</strong></p><p>异步编程的演进大致分以下几个时期</p><ul><li>回调函数时期</li><li> promise 时期</li><li>生成器 (ES6) + promise 时期</li><li> async/await 时期 (ES7)</li></ul><a id="more"></a><h1 id="你必须要知道的基本概念"><a href="#你必须要知道的基本概念" class="headerlink" title="你必须要知道的基本概念"></a>你必须要知道的基本概念</h1><h2 id="异步、并行，并发的区别"><a href="#异步、并行，并发的区别" class="headerlink" title="异步、并行，并发的区别"></a>异步、并行，并发的区别</h2><ul><li>异步：是关于现在和将来的事件间隙</li><li>并行：是关于同时完成多个任务的概念</li><li>并发：是指分别由任务 a 和任务 b 在一段时间内通过任务间的切换完成了这两个任务，<strong>单线程事件循环是并发的一种形式 </strong></li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">并发是指两个或者多个事件随着时间发展交替执行，以至于从更高的层次上看是同时在运行（尽管在任意时刻只处理一个事件）</span><br><span class="line"></span><br><span class="line">实际的并发场景</span><br><span class="line">比如社交网站，随着用户向下滚动列表加载更多资源 （一边触发ajax一边响应数据）..</span><br></pre></td></tr></tbody></table></figure><h2 id="js里的完整运行特性"><a href="#js里的完整运行特性" class="headerlink" title="js里的完整运行特性"></a>js 里的完整运行特性</h2><p>js 从不跨线程共享数据，并且由于 js 单线程的特性，函数块儿中的代码具有完整运行机制，也就是说，一旦 <code>foo()</code> 开始运行，它的所有代码都会在 <code>bar()</code> 中的任意代码运行之前完成</p><h2 id="事件循环队列与任务队列的区别"><a href="#事件循环队列与任务队列的区别" class="headerlink" title="事件循环队列与任务队列的区别"></a>事件循环队列与任务队列的区别</h2><p>ES6 中，有一个任务队列的概念，它是挂载在事件循环队列的每个 <code>tick</code> 之后的一个队列</p><p>js 引擎运行在宿主环境中（浏览器，node 端等），这些环境都有线程的概念，他们都提供了一种机制来处理程序中多个块儿的执行，且执行每块儿时调用 js 引擎，这种机制被称之为<strong>事件循环</strong></p><p>一旦有事件需要运行，事件循环就会运行，直到队列清空，事件循环的每一轮称为一个 tick，用户交互 IO 和定时器会向事件队列中加入事件，任意时刻，一次只能从队列中处理一个事件，执行事件的时候，可能直接或者间接地引发一个或者多个后续事件</p><p>一个比较形象的比喻</p><ul><li>事件循环队列：类似于一个游乐场游戏，玩过了一个游戏之后，你需要重新到队尾排队才能再玩一次</li><li>任务队列：玩过了游戏之后，插队接着玩</li></ul><h1 id="第一阶段-回调函数时期"><a href="#第一阶段-回调函数时期" class="headerlink" title="第一阶段(回调函数时期)"></a>第一阶段 (回调函数时期)</h1><p>任何时候，只要把一段代码包装成一个函数，并指定它在响应某个事件时执行，你就是在代码中创建了一个将来执行的块儿，也由此在这个程序中引入了异步机制。</p><h2 id="回调实现异步的特性"><a href="#回调实现异步的特性" class="headerlink" title="回调实现异步的特性"></a>回调实现异步的特性</h2><ul><li>回调函数是 <code>js</code> 异步的基本单元，但是随着 js 越来越成熟，对于异步编程的发展，回调已经不够用了以至于产生可怕的<strong>回调地狱</strong>，嵌套函数存在耦合性，一大有所改动就会牵一发而动全身，而且嵌套过多导致错误难以处理</li><li>回调表达异步流程的方式是非线性的，非顺序的，这使得正确推理这样儿的代码难度很大，难以理解，我们需要一种更同步更顺序更阻塞的方式来表达异步，就像我们的大脑一样。</li><li>回调会受到<strong>控制反转</strong>的影响，因为回调函数中把控制权交给第三方比如 <code>ajax()</code>，会造成一系列麻烦的<strong>信任问题</strong> </li></ul><p><font color="red">可能产生的信任问题</font></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 调用回调过早</span><br><span class="line">2. 调用回调过晚（或者不被调用）</span><br><span class="line">3. 调用回调次数过多或者过少</span><br><span class="line">4. 未能传递所需的环境和参数</span><br><span class="line">5. 吞掉可能出现的错误和异常</span><br></pre></td></tr></tbody></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我们需要一个通用的方案来解决这些信任问题，不管我们创建多少回调，这一方案都可以复用，且没有重复代码的开销 引出了 <strong>Promise</strong></p><h1 id="第二阶段-Promise时期"><a href="#第二阶段-Promise时期" class="headerlink" title="第二阶段(Promise时期)"></a>第二阶段 (Promise 时期)</h1><p>直到 <code>ES6 Promise</code> 的引入 JS 才真正有内建的异步概念</p><p>我们开篇就了解到了 异步编程分现在运行部分 和将来运行部分的概念</p><ul><li>回调函数的模式是关于<strong>如何处理将来值</strong></li><li><code>Promise</code> 是把现在和将来归一化了 把他们都变成了将来，也就是说 它把所有的操作都变成了异步的</li></ul><h2 id="Promise的特点"><a href="#Promise的特点" class="headerlink" title="Promise的特点"></a>Promise 的特点</h2><ul><li>我们通过某种方式在函数完成时候得到通知，以便我们可以继续下一步</li><li>类似于事件订阅 我们不需要关注谁订阅了这些事件，实现了关注点分离</li><li> Promise 封装了依赖时间的状态 - 它等待底层值的完成或者拒绝 所以 promise 本身是与时间无关的</li><li>它可以按照可预测的方式组合 而不用关心底层代码如何结束</li><li>一旦 <code>promise</code> 决议，它就永远保持在这个状态</li><li> promise 是一种封装和组合未来值的易于复用的机制</li></ul><h2 id="Promise基本用法"><a href="#Promise基本用法" class="headerlink" title="Promise基本用法"></a>Promise 基本用法</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var p = new Promise(function(resolve,reject){</span><br><span class="line"> //resolve()用于完成</span><br><span class="line"> //reject() 用于拒绝</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"> 他有三个状态 </span><br><span class="line"> pending,fulfilled，rejected </span><br><span class="line"> </span><br><span class="line"> 两个过程</span><br><span class="line"> </span><br><span class="line"> pending -&gt; fulfilled</span><br><span class="line"> pending -&gt; rejected</span><br><span class="line"> </span><br><span class="line">resolve：会将传入的真正的promise直接返回，对传入的thenable会展开,如果这个thenable展开是一个拒绝状态，那么从promise.resolve()返回的promise实际上就是这同一个拒绝状态</span><br><span class="line">所以resolve实际上的结果可能是完成或拒绝</span><br><span class="line"></span><br><span class="line">rejected ：拒绝状态</span><br></pre></td></tr></tbody></table></figure><p>实例的调用</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">promise.then(resolveFn,rejectFn)</span><br><span class="line">如下：</span><br><span class="line">promise.then(function(value) {</span><br><span class="line">  // success</span><br><span class="line">}, function(error) {</span><br><span class="line">  // failure</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><h3 id="如何确定某个值是不是真正的promise（或者说thenable）"><a href="#如何确定某个值是不是真正的promise（或者说thenable）" class="headerlink" title="如何确定某个值是不是真正的promise（或者说thenable）"></a>如何确定某个值是不是真正的 promise（或者说 thenable）</h3><p>利用鸭子模型<br>如果一个函数或对象具有.then () 方法，我们认为这样儿的值就是 <code>Promise</code> 一致的 <code>thenable</code></p><p>所以不要给函数或者对象添加<code>.then</code><br>方法，否则这个值就会误认为是一个 <code>thenable</code> 导致难以追踪的 <code>bug</code></p><p>既然我们已经知道亟待解决的问题，把回调的缺陷解决了，否则引入 <code>Promise</code> 没有任何意义</p><h2 id="解决控制反转问题"><a href="#解决控制反转问题" class="headerlink" title="解决控制反转问题"></a>解决控制反转问题</h2><p>之前 我们用回调函数封装程序中的代码，然后将其交给第三方等（比如 ajax），接着期待其能调用回调实现功能<br>现在我们要能够把控制反转再反转回来<br>我们希望第三方<strong>给我们提供其任务何时结束的能力</strong>，然后由我们自己的代码来决定下一步做什么</p><p><font color="red">老实说 绝大多数 JS/DOM 新增的异步 API 都是基于 Promise 构建的</font></p><h2 id="解决信任问题"><a href="#解决信任问题" class="headerlink" title="解决信任问题"></a>解决信任问题</h2><h3 id="promise解决调用过早"><a href="#promise解决调用过早" class="headerlink" title="promise解决调用过早"></a>promise 解决调用过早</h3><p>对一个 <code>promise</code> 调用 then 的时候，即使这个 <code>promise</code> 已经决议，提供给 <code>then()</code> 的回调总会被异步调用</p><h3 id="promise解决调用过晚"><a href="#promise解决调用过晚" class="headerlink" title="promise解决调用过晚"></a>promise 解决调用过晚</h3><p><code>promise</code> 对象创建 <code>resolve</code> 或者 <code>reject</code> 时，这个 promise 的 then 注册的观察回调就会被自动调度，可以确信，这些被调度的回调在下一个异步事件点上依次被立即调用，这些回调中的任意一个都无法影响或延误对其他回调的调用，这是 promise 的运作方式</p><h3 id="回调未调用"><a href="#回调未调用" class="headerlink" title="回调未调用"></a>回调未调用</h3><p>没有任何东西（甚至是 js 错误）能阻止 promise 向你通知他的决议，promise 在决议时总是会调用其中一个</p><p>如果 promise 本身永远不被决议。promise 也提供了解决方案</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">用于一个超时的promise</span><br><span class="line">function timeoutpromise(){</span><br><span class="line">return new promise(function(){</span><br><span class="line"> setTimeout(functiion(){</span><br><span class="line">  reject('timeout')</span><br><span class="line"> },delay)</span><br><span class="line">})</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="调用次数过多或过少"><a href="#调用次数过多或过少" class="headerlink" title="调用次数过多或过少"></a>调用次数过多或过少</h3><p>promise 定义方式使得它只能被决议一次<br>如果试图调用多次或者 resolve 和 reject 都调用，那么这个 promise 只接受第一个决议，并默默的忽略任何后续调用<br>当然了，如果你把同一个回调注册了不止一次 (p.then (f);p.then (f)) 那么它被调用的次数就会和注册次数相等</p><h3 id="未能传递参数-环境值"><a href="#未能传递参数-环境值" class="headerlink" title="未能传递参数/环境值"></a>未能传递参数 / 环境值</h3><p>promise 至多只能有一个决议值（完成或拒绝）<br>如果使用多个参数调用 resolve 或者 reject 第一个参数之后的所有参数都会默默忽略</p><p>如果要传递多个值，就必须把他们封装在单个值中传递 比如一个数组或者对象</p><h3 id="吞掉错误或者异常"><a href="#吞掉错误或者异常" class="headerlink" title="吞掉错误或者异常"></a>吞掉错误或者异常</h3><p>如果在 <code>Promise</code> 的创建过程中或者查看决议结果过程中的任何时间点上出现了 js 的异常错误，那么这个异常就会被捕捉，并且会使这个 <code>Promise</code> 拒绝 <code>reject</code></p><p>promise 甚至把 js 的异常也变成了异步行为，进而极大降低了静态条件出现的可能</p><p>但是如果 promise 完成后的回调中出现了 js 异常</p><p>因为 p.then () 本身返回了另外一个 promise 正是这个 promise (下一个 promise) 将会因 TypeError 异常而被拒绝</p><p><font color="red">注意：为什么它不是简单的调用我们的错误处理函数呢？</font><br>如果这样儿的话就违背了 promise 的基本原则：promise 一旦决议就不可改变<br>也会造成有些回调会调用，有些回调不会调用情况会非常不透明</p><h3 id="是可信任的Promise"><a href="#是可信任的Promise" class="headerlink" title="是可信任的Promise"></a>是可信任的 Promise</h3><p><strong>promise 并没有完全摆脱回调，他们只是改变了传递回调的位置</strong></p><ul><li><p>如果你向 <code>promise.resolve()</code> 传递一个<code>非promise</code> 就会得到用这个值填充的 Promise</p></li><li><p>如果你向 promise.resolve () 传递一个真正的 promise 就会返回同一个 promise</p></li><li><p><code>promise.resolve()</code> 可以接受任何 <code>thenable</code>，得到的是一个真正的 Promise 是一个可信任的值，如果你传入的已经是真的 Promise 那么就更值得信任了</p></li><li><p>对于用 promise.resolve () 为所有函数的返回值（不管是不是 thenable）都封装一层，这样儿做很容易把函数调用规范为定义良好的异步任务</p></li><li><p><code>Promise</code> 这种模式通过可信任的语义把回调当参数传递，使得这种行为更加可靠合理，通过把回调的控制反转回来，我们把控制权放在了一个可信任的系统，这种系统的设计目的就是为了使得异步编码更清晰</p></li></ul><hr><p>以上 promise 解决了回调函数的致命问题<br>接下来 我们将展示基于 promise 的链式流作用</p><h2 id="Promise的链式流"><a href="#Promise的链式流" class="headerlink" title="Promise的链式流"></a>Promise 的链式流</h2><p>Promise 并不是一个单步遵循 <code>this-then-that</code> 操作的机制，我们可以将多个 Promise 链接在一起表示一系列异步步骤</p><p>这种方式实现的有以下特性</p><ul><li>每次你对 promise 调用 then () 它会创建并返回一个新的 promise, 我们可以将其链接起来</li><li>不管从 then () 调用的完成回调（第一个参数）返回的值是什么，他都会被自动设置为被链接 promise（第一点中的）的完成</li><li>调用 promise 的 then () 会自动创建一个新的 promise 从调用返回</li><li>在完成或拒绝处理函数内部，如果返回一个值或者抛出一个异常。新返回的 promise（可链接的）就相应的决议</li><li>如果返回或拒绝处理函数返回一个 promise, 它将会被展开，这样儿一来，不管它的决议值是什么，都会成为当前 then () 返回的链接 promise 的决议值</li></ul><p>如下</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var p = Promise.resolve(21);</span><br><span class="line"> p.then(function(v){</span><br><span class="line">  console.log(v * 2)  //42</span><br><span class="line">  return v + 2 // ***</span><br><span class="line">})</span><br><span class="line">.then(function(v){</span><br><span class="line">  console.log('ceshi',v) //23</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>第一个 then 就是异步序列的第一步</p><p>第二个 then 是第二步，<strong>只要保证把先前的 then (..) 连到自动创建的每一个 promise 即可</strong></p><p>在这个 demo 中 我们用了立即返回的 return 语句</p><p>但是我们如果需要步骤二等待步骤一异步来完成一些事情怎么办？<br>也就是说我们想要使 promise 序列真正能够在每一步有异步能力？</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我们可以给promise.resolve()传递非（最终值）即 **真正的promise或thenable**，Promise会直接返回真正的promise 或展开接收到的thenable值，并在持续展开`thanable`的同时递归前进</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>如下</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var p = Promise.resolve(21);</span><br><span class="line"> p.then(function(v){</span><br><span class="line">  return new Promise(function(resolve,reject){</span><br><span class="line">    resolve(v*2) //42</span><br><span class="line">  })</span><br><span class="line">})</span><br><span class="line">.then(function(v){</span><br><span class="line">  console.log(v) //42</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>我们把 42 封装到了返回的 promise 中，但是它仍然会被展开并最终成为链接的 promise 的决议，因此第二个.then 函数中的到的仍然是 42</p><p>此时，如果向封装的 promise 中引入异步，仍然会正常工作</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var p = Promise.resolve(21);</span><br><span class="line"> p.then(function(v){</span><br><span class="line">  return new Promise(function(resolve,reject){</span><br><span class="line">    setTimeout(function(){</span><br><span class="line">      resolve(v*2)</span><br><span class="line">    },200)</span><br><span class="line">  })</span><br><span class="line">})</span><br><span class="line">.then(function(v){</span><br><span class="line">  console.log(v) //42</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>完美 我们可以实现一系列个异步步骤</p><p>在这些例子中，一步一步传递的值是可选的，不传的话就是隐式返回 <code>undefined</code> 并且这些 <code>Promise</code> 仍然会以同样的方式链接到一起 每一个 <code>Promise</code> 的决议就成了继续下一个步骤的信号</p><h3 id="存在默认的resolve和reject回调"><a href="#存在默认的resolve和reject回调" class="headerlink" title="存在默认的resolve和reject回调"></a>存在默认的 resolve 和 reject 回调</h3><p>默认的 reject</p><p>如果你调用.then () 函数并且只传入一个完成处理函数，一个默认拒绝处理函数就会顶替上来，默认拒绝处理函数只是把错误重新抛出，这使得错误可以继续沿着 Promise 链传播下去，直到遇到显式定义的拒绝处理函数</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var p = new Promise(function(resolve,reject){</span><br><span class="line">  reject('ooPs');</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">var p2 = p.then(</span><br><span class="line">  function fulfilled(){</span><br><span class="line">    //不会执行到这里</span><br><span class="line">  },</span><br><span class="line">  //默认的拒绝处理函数 当你没有传时</span><br><span class="line">  function (err){</span><br><span class="line">    throw err;</span><br><span class="line">  }</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure><p>默认的 reject</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var p = Promise.resolve(2)</span><br><span class="line"></span><br><span class="line">var p2 = p.then(</span><br><span class="line">  function (v){</span><br><span class="line">    //不会执行到这里</span><br><span class="line">    return v</span><br><span class="line">  },</span><br><span class="line">  //默认的拒绝处理函数 当你没有传时</span><br><span class="line">  function reject(err){</span><br><span class="line">    //..</span><br><span class="line">  }</span><br><span class="line">)</span><br><span class="line">.then(function(v){</span><br><span class="line">  console.log('ss',v) //2</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>默认的完成处理函数只是把接受到的任何传入值传递给下一个步骤的 <code>promise</code> 而已</p><h2 id="关于错误处理"><a href="#关于错误处理" class="headerlink" title="关于错误处理"></a>关于错误处理</h2><h3 id="之前同步的错误处理"><a href="#之前同步的错误处理" class="headerlink" title="之前同步的错误处理"></a>之前同步的错误处理</h3><hr><p>我们通常使用 try catch 处理异常<br>但是它只能是同步的，<strong>无法用于异步代码模式</strong><br>即使你在异步代码 比如 setTimeout 中谁用 try catch 仍然是有问题的，他们采用 error-first 回调风格，无法很好的组合，多级 error-first 回调交织，导致了回调地狱的风险</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function foo(cb){</span><br><span class="line">  setTimeout(function(){</span><br><span class="line">    try {</span><br><span class="line">      var x = baz.bar();</span><br><span class="line">      cb(null,x)</span><br><span class="line">    }</span><br><span class="line">    catch(err){</span><br><span class="line">      cb(err)</span><br><span class="line">    }</span><br><span class="line">  })</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">只有在 baz.bar()调用会同步地立即成功或失败的情况下，这里的try catch才能工作</span><br></pre></td></tr></tbody></table></figure><h3 id="promise的错误处理-增加-catch-方法"><a href="#promise的错误处理-增加-catch-方法" class="headerlink" title="promise的错误处理 增加 .catch(..)方法"></a>promise 的错误处理 增加 .catch (..) 方法</h3><p>.catch (..) 会创建并返回新的 promise，这个 promise 可用于实现 promise 链式流程控制<br>它没有采用 error-first 回调设计风格，而是使用了分离回调风格<br><code>一个回调用于完成情况 一个回调用于拒绝情况</code></p><p>我们了解到 在完成或拒绝处理函数内部，如果返回一个值或者抛出一个异常。新返回的 promise（可链接的）就相应的决议，默认情况下，如果你没有捕捉<code>.then</code> 的异常，它假定你想要 promise 状态吞掉所有的错误，如果你忘记查看这个状态，这个错误就会默默地在暗处凋零</p><p>所以为了避免被忽略的错误，<code>promise</code> 链的最佳实践就是最后总以一个 <code>catch</code> 结束</p><p>诸如</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var p = Promise.resolve(42);</span><br><span class="line">p.then(function fulfilled(msg){</span><br><span class="line">  console.log(msg.toLowerCase())</span><br><span class="line">})</span><br><span class="line">.catch((error) =&gt; {</span><br><span class="line">  console.log('捕获错误',error)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>这样儿可以成功的捕获错误</p><p>但是 <code>reject()</code> 函数的任何异常都会被作为一个全局未处理的错误抛出</p><h2 id="Promise其他的API"><a href="#Promise其他的API" class="headerlink" title="Promise其他的API"></a>Promise 其他的 API</h2><h3 id="Promise-done"><a href="#Promise-done" class="headerlink" title="Promise.done(..)"></a>Promise.done(..)</h3><p>标示 promise 链的结束<br>done () 不会创建和返回 promise</p><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all([])"></a>Promise.all([])</h3><p>在异步序列中，任意时刻都只能有一个异步任务正在执行<br>但是我们如果想要同时执行两个或更多步骤（“并行执行”）的时候，<code>Promise.all([])</code> 的魅力就体现出来<br>了</p><p>Promise.all ([]) 接收一个数组，值可以是（promise，thenable，甚至是立即值），列表里的每个值都要经过 Promise.resolve () 过滤，以确保要等待的是一个真正的 promise，<br>从返回的 promise 数据也是一个数组，与传入的顺序一致</p><p>如果返回的主 promise 在且仅在所有成员 promise 都完成后才会完成 如果有热和一个被拒绝，主 promise 就会立即被拒绝，并丢弃来自其他所有 promise 的结果</p><p>所以 要为每个 promise 关联一个错误处理函数</p><p>传入空数组时，它会立即完成</p><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race([])"></a>Promise.race([])</h3><p>与 promise.all 类似<br>它一旦有人黑一个 promise 决议为完成，promise.race 就会完成，一旦有任何一个 promise 决议为拒绝，它就会拒绝</p><p>它的完成值是单个消息，并不像 promise.all 那样儿是一个数组，其他的 promise 会被丢弃或者忽略</p><p>两者都会创建一个 promise 作为他们的返回值，这个 promise 的决议完全由传入的 promise 数组控制</p><p>传入空数组时，它会挂住，且永远不会决议</p><h3 id="Promise-finally"><a href="#Promise-finally" class="headerlink" title="Promise.finally()"></a>Promise.finally()</h3><p>从行为的角度上 有些开发者提出，promise 需要一个 <code>finally()</code> 的回调注册，这个回调在 <code>promise</code> 决议后总是会被调用，并且允许你执行任何必要的清理工作</p><p>如下</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var p = Promise.resolve(42);</span><br><span class="line">p.then(()=&gt;{})</span><br><span class="line">.finally(cleanup)</span><br><span class="line">.then(()=&gt;{})</span><br><span class="line">.finally(cleanup)</span><br></pre></td></tr></tbody></table></figure><p>finally 会创建并返回一个新的 promise 以支持链接继续</p><h3 id="new-Promise-构造器"><a href="#new-Promise-构造器" class="headerlink" title="new Promise(..)构造器"></a>new Promise (..) 构造器</h3><p>构造器 Promise 必须和 new 一起使用，并且必须提供一个函数回调，这个回调是同步的，这个函数接收到两个函数回调，用以支持 promise 的决议</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var p = new Promise(function(resolve,reject){</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h4 id="创建两种决议的快捷方式"><a href="#创建两种决议的快捷方式" class="headerlink" title="创建两种决议的快捷方式"></a>创建两种决议的快捷方式</h4><ol><li>Promise.resolve// 用于创建一个已完成的 promise</li><li>Promise.reject// 用于拒绝这个 promise</li></ol><p>以下是等价的</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var p = new Promise(function(resolve,reject){</span><br><span class="line">reject('oop');</span><br><span class="line">})</span><br><span class="line">var p = Promise.reject('oop')</span><br></pre></td></tr></tbody></table></figure><p>##promise 的局限性</p><ul><li>顺序错误处理 </li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">他们链接的方式 promise链中的错误容易被无意中忽略掉</span><br></pre></td></tr></tbody></table></figure><ul><li>单一值 </li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise只能有一个完成值或一个拒绝理由 对于复杂的场景信息有点局限</span><br></pre></td></tr></tbody></table></figure><ul><li> 单决议</li><li>无法取消的 promise</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一旦创建了一个promise并为其注册了完成和拒绝处理函数，如果出现某种情况使得这个任务悬而未决的话 你也没有办法从外部停止它的进程</span><br></pre></td></tr></tbody></table></figure><ul><li>promise 性能 </li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">更多的工作更多的保护 promise与回调相比 会慢一点</span><br><span class="line">但是作为交换你得到的是大量内建的可信任性</span><br></pre></td></tr></tbody></table></figure><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><ul><li><p>promise 非常好 他们解决了我们因只用回调的代码而备受困扰的控制反转的问题</p></li><li><p>它并没有摒弃回调，只是把回调的安排转交给了一个位于我么和其他工具之间的可信任的中介机制</p></li><li><p>promise 也开始提供（尽管不完美）以顺序的方式表达异步流的一个更好的办法，这有助于我们的大脑更好的几乎是和维护异步 js 代码</p></li></ul><hr><p>#第二阶段 (生成器 Generator 时期)</p><p>先来回顾一下 回调表达异步控制流程的两个关键缺陷</p><ol><li>基于回调的异步不符合大脑对任务步骤的规划方式</li><li>由于控制反转回调并不是可信任的</li></ol><p>然后我们用 <code>Promise</code> 解决了如何把回调的控制反转 反转回来，恢复了可信任性<br>但是它不会暂停<br>现在我们寻求一种顺序，看似同步的异步流程控制表达这个 (.then () 钱嵌套多了也受不了)，引出了<font color="red"> ES6 生成器</font>的概念</p><p>Generator 最大的特点就是可以控制函数的执行<br>它会创建出一个迭代器<br>Generator 函数是一个状态机，封装了多个内部状态。<br>调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是遍历器对象（Iterator Object）</p><p>它打破了完整执行 我们不再依赖<strong>一个函数一旦开始执行，就会运行到结束，期间不会有其他代码能够打破它并插入其间</strong>的假定</p><p>ES6 中指定暂停点的语法是 <code>yield</code> 这样礼貌的表达了一种合作式的控制放弃</p><p>如下</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var x = 1;</span><br><span class="line">function *foo(){</span><br><span class="line">  x++;</span><br><span class="line">  yield;</span><br><span class="line">  console.log('x:',x);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">function bar(){</span><br><span class="line">  x++</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var it = foo(); //构建了一个迭代器 并没有执行foo</span><br><span class="line">it.next(); //启动生成器 *foo 并运行了第一行的 x++  *foo在yield处暂停</span><br><span class="line">console.log('sws',x) //2</span><br><span class="line">bar();</span><br><span class="line">console.log('二',x) //3</span><br><span class="line">it.next(); //最后从暂停处恢复了生成器 *foo的执行 运行了  console.log('x:',x); //3</span><br></pre></td></tr></tbody></table></figure><p>生成器是一种特殊的函数，可以一次或者多次的启动和停止 构建生成器是作为异步流程控制的代码模式的基础构件之一</p><p>我们可以看到 我们在暂停之后做了我们想做的操作 还执行了我们想要执行的函数 <code>bar</code></p><h3 id="生成器的输入和输出"><a href="#生成器的输入和输出" class="headerlink" title="生成器的输入和输出"></a>生成器的输入和输出</h3><p><code>var it = foo();</code> 这行只是创建了一个生成器对象，把它赋给了变量 it，用于控制生成器，它是特殊的函数，也具有函数的特质，可以传递参数<br><code>it.next()</code> 指定生成器从当前位置开始继续运行，停在下一个 <code>yield</code> 处或者直到生成器结束，它调用的结果是一个对象，有一个 value 属性，持有从 <code>*foo</code> 返回的值（如果有的话）也就是说 <code>yield</code> 会导致生成器在执行过程中发送出一个值 (类似 <code>return</code>)</p><p>如下</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function *foo(x,y){</span><br><span class="line">  return x * y;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var it = foo(6,7); </span><br><span class="line">var obj = it.next(); </span><br><span class="line">console.log(obj) //{value: 42, done: true}</span><br></pre></td></tr></tbody></table></figure><h3 id="迭代消息传递"><a href="#迭代消息传递" class="headerlink" title="迭代消息传递"></a>迭代消息传递</h3><p>通过 <code>yield</code> 和 <code>next</code> 实现的内建消息输入输出能力</p><p><code>next()</code> 调用要比 <code>yield</code> 语句多一个<br>因为第一个 <code>next()</code> 总是启动一个生成器，并运行到第一个 <code>yield</code> 处，执行第一次 <code>next</code> 时候，传递参数值会被忽略</p><p>第一个 yield 基本上是提出了一个问题：我的值是多少？<br>谁来回答这一个问题 显然第一个 next 已经执行，因此由第二个 next 调用回答第一个 yield 提出的这个问题</p><p>从迭代器的角度看问题</p><p>消息是双向传递的 next 也可以向暂停的 yield 表达式发送值 yield 作为一个表达式可以发出消息响应 next 的调用</p><p>这里有一个例子能帮助你理解 generator 的执行</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//yield基本上就是提出了个问题 我的值等于什么 然后由下一个next()传递的参数回答</span><br><span class="line"></span><br><span class="line">function *foo(x){</span><br><span class="line">  let y = 2 *(yield(x+1));</span><br><span class="line">  let z = yield(y/3);</span><br><span class="line">  return x + y + z </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let it = foo(5);</span><br><span class="line"></span><br><span class="line">console.log(it.next()) //{value: 6, done: false}</span><br><span class="line">console.log(it.next(12)) //{value: 8, done: false}</span><br><span class="line">console.log(it.next(13)) //{value: 42, done: true}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">解析</span><br><span class="line">generator函数调用和普通函数不同 它会返回一个迭代器</span><br><span class="line"></span><br><span class="line">执行第一次next时候，传递参数值会被忽略，并且函数暂停在yield(x+1)处 所以返回 5+1</span><br><span class="line">执行第二次next时，传入的参数等于上一个yield的返回值 如果你不传参，yield永远返回undefined，此时  let y = 2 * 12 = 24，所以第二个z是24/3 =8</span><br><span class="line">当执行第三次next时 传递的参数会传递给z，所以z=13 x = 5 y = 24 相加等于42</span><br><span class="line">*/</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>多个迭代器</strong><br>每次构建一个迭代器实际上就是隐式构建生成器的一个实例 通过这个迭代器控制的是这个生成器的实例</p><p>同一个生成器的多个实例可以同时运行它们甚至可以彼此交互</p><h4 id="生产者与迭代器"><a href="#生产者与迭代器" class="headerlink" title="生产者与迭代器"></a>生产者与迭代器</h4><p>假设你要产生一系列值，其中每个值都与前面一个有特定的关系  需要一个有状态的生产者能够记住其生成的最后一个值<br>在此之前 我们可以使用函数闭包来实现</p><p>迭代器是一个定义良好的接口，用于从一个生产者一步步得到一系列值，js 迭代器的接口与多数语言类似，就是每次想要从生产者得到下一个值的时候调用 next ()<br>next 调用返回一个对象有两个属性</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">done是一个布尔值 表示迭代器的完成状态</span><br><span class="line">value中放置迭代值</span><br></pre></td></tr></tbody></table></figure><h4 id="同步错误处理"><a href="#同步错误处理" class="headerlink" title="同步错误处理"></a>同步错误处理</h4><p>类似</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try{</span><br><span class="line">    var text = yield foo(11,31);</span><br><span class="line">    console.log(text)</span><br><span class="line">}</span><br><span class="line">catch(err){</span><br><span class="line">    console.log(err)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>生成器 <code>yield</code> 暂停的特性意味着我们不仅能从异步函数调用的到看似同步的返回值，还可以同步捕获来自这些异步函数调用的错误 它使得生成器能够捕获错误是一个很大的进步</p><h1 id="第四阶段（async-await时期-ES7）"><a href="#第四阶段（async-await时期-ES7）" class="headerlink" title="第四阶段（async/await时期 ES7）"></a>第四阶段（async/await 时期 ES7）</h1><p>ES6 中最完美的时间就是生成器（看似同步的代码）和 promise（可信任可组合）的结合</p><p>我们不再 <code>yield</code> 出 <code>Promise</code> 而是用 <code>await</code> 等待它决议<br>它其实就是把前面的经验写进规范</p><h2 id="ES7的esync函数对于ES6的generator函数的改进体现了哪些方面"><a href="#ES7的esync函数对于ES6的generator函数的改进体现了哪些方面" class="headerlink" title="ES7的esync函数对于ES6的generator函数的改进体现了哪些方面"></a>ES7 的 esync 函数对于 ES6 的 generator 函数的改进体现了哪些方面</h2><ul><li>内置执行器 </li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">generator函数的执行必须依赖于执行器，而async函数自带执行器，也就是说async函数的执行，与普通函数一模一样，只需要一行</span><br><span class="line">asyncReadFile();</span><br><span class="line"></span><br><span class="line">像这样 直接调用函数 就可以直接得出结果 不像generator函数，需要调用next方法或者co模块 才能真正执行得到最后的结果</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ul><li>更好的语义 </li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">async和await比起 * 和 yield 语义更清楚了async表示函数有异步操作，await表示紧跟在后面的表达式需要等待的结果</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ul><li>更广的适用性 </li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">co模块规定 yield命令后面只能是thunk函数或者promise对象，而async函数的await后面 可以是promise对象和原始类型的值（数值，布尔等但这等同于同步操作）</span><br></pre></td></tr></tbody></table></figure><ul><li>返回值是 promise</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">async函数返回的是promise对象，这比generator函数的返回值是 Iterator对象方便多了，你可以用then方法指定下一步的操作</span><br><span class="line"></span><br><span class="line">进一步说 async函数可以看作是多个异步操作包装成的一个promise对象，而await命令就是内部then命令的语法糖</span><br></pre></td></tr></tbody></table></figure><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>一个函数如果加上 async 那么它就会返回 promise</li><li>async 就是将函数返回值使用 Promise.resolve () 包裹了下，和 then 中处理返回值一样</li><li> await 是异步操作，它内部实现了 generator, 如果后来的表达式不返回 promise 的话，它就会被包装成 Promise.resolve (返回值)，然后去执行函数的同步代码</li></ul><p>看下面这个等价的例子</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">async function async1(){</span><br><span class="line">    await async2();</span><br><span class="line">    console.log('async1 end')</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">async function async2(){</span><br><span class="line">  console.log('async2 end')</span><br><span class="line">}</span><br><span class="line">async1();</span><br><span class="line"></span><br><span class="line">等价于</span><br><span class="line"></span><br><span class="line">new Promise((resolve,reject)=&gt;{</span><br><span class="line">  console.log('async2 end')</span><br><span class="line">  resolve(Promise.resolve()) //Promise.resolve()决议之后将then代码插入到微任务队列的尾部</span><br><span class="line">})</span><br><span class="line">.then(()=&gt;{</span><br><span class="line">  console.log('async1 end')</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><ul><li> async 及 await 配合使用</li><li> await 就是 <code>generator</code> 加上 <code>promise</code> 的语法糖</li><li> <code>async/await</code> 是异步的终极解决方案</li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p> <font color="red">优势</font> </p><ul><li> 处理 then 的调用链，能更清晰的写出来代码，毕竟写一堆 then 也很</li><li> 能解决回调地狱的问题</li></ul><p><font color="red">缺点</font></p><ul><li> 因为 <code>await</code> 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 <code>await</code> 导致性能上的降低</li></ul><p>如下</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async function test(){</span><br><span class="line"> await fetch(url)</span><br><span class="line"> await fetch(url2)</span><br><span class="line"> await fetch(url3)</span><br><span class="line">}</span><br><span class="line">这样儿的代码 如果没有依赖最好用promise.all</span><br></pre></td></tr></tbody></table></figure><p>#总结</p><ul><li><p>生成器是 ES6 的一个新的函数类型 它并不像普通函数那样总是运行到结束，取而代之的是生成器可以在运行当中（完全保持其状态）暂停 并且将来再从咱题 ing 的地方恢复运行</p></li><li><p>这种简体的暂停和恢复是合作型的不是抢占型的，这意味着生成器具有独一无二的能力来暂停自身，这是通过关键字 <code>yield</code> 来实现的 不过 只有控制生成器的迭代器具有恢复生成器的能力（next (..)）</p></li><li><p>yield/next 不只是控制机制 实际上也是一种双向消息传递机制 yield 表达式备注上是暂停下来等待某个值 接下来的 next 调用则是会向被暂停的 yield 表达式传回一个值</p></li><li><p>在异步控制流程方便生成器的关键优点是 生成器内部的代码是以自然的同步 / 顺序方式表达任务的一系列步骤，其技巧在于 我们把可能的异步隐藏在关键字 yield 的后面 把异步移动到控制生成器的迭代器的代码部分</p></li><li><p>换句话说 生成器为异步代码保持了顺序同步 阻塞的代码模式 这使得大脑可以更自然的追踪代码 解决了基于回调的异步的缺陷</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;程序中&lt;strong&gt;现在运行的部分&lt;/strong&gt;和&lt;strong&gt;将来运行的部分&lt;/strong&gt;就是&lt;strong&gt;异步编程的核心&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;异步编程的演进大致分以下几个时期&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;回调函数时期&lt;/li&gt;
&lt;li&gt; promise 时期&lt;/li&gt;
&lt;li&gt;生成器 (ES6) + promise 时期&lt;/li&gt;
&lt;li&gt; async/await 时期 (ES7)&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="js" scheme="http://maying.ink/categories/js/"/>
    
    
      <category term="promise" scheme="http://maying.ink/tags/promise/"/>
    
  </entry>
  
  <entry>
    <title>你不知道的 JS 系列 - 细说 JS 继承</title>
    <link href="http://maying.ink/2019/03/15/jsIInheritance/"/>
    <id>http://maying.ink/2019/03/15/jsIInheritance/</id>
    <published>2019-03-15T08:16:28.000Z</published>
    <updated>2020-10-22T18:41:42.182Z</updated>
    
    <content type="html"><![CDATA[<p>面向对象语言支持两种继承方式：接口继承（只继承方法签名）和实现继承（继承实际的方法）由于函数没有签名，ECMAScript 只支持实现继承，而实现继承主要是依靠原型链实现的</p><p>下面就当下几种继承方式做一个对比参考</p><a id="more"></a><h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><p><font color="red">核心思想：</font>利用原型让一个引用类型继承另一个引用类型的属性和方法（将父类的实例作为子类的原型）</p><hr><h3 id="举个🌰"><a href="#举个🌰" class="headerlink" title="举个🌰"></a>举个🌰</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function SuperType(){</span><br><span class="line">  this.name = 'yishu';</span><br><span class="line">}</span><br><span class="line">SuperType.prototype.sayName = function(){</span><br><span class="line">  return this.name</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">function SubType (){</span><br><span class="line">  this.age = 25;</span><br><span class="line">} </span><br><span class="line"> //原型链继承</span><br><span class="line"> SubType.prototype = new SuperType();</span><br><span class="line"></span><br><span class="line"> SubType.prototype.sayAge = function(){</span><br><span class="line">  return this.age</span><br><span class="line"> }</span><br><span class="line"> </span><br><span class="line">  var instance = new SubType(); //原型链继承</span><br><span class="line">  console.log('age',instance.age) // 25</span><br><span class="line">  console.log('name',instance.name) //yishu</span><br><span class="line">  console.log('sayName',instance.sayName()) //yishu</span><br><span class="line">  console.log('sayAge',instance.sayAge()) //25</span><br><span class="line">  console.log(' instance.toString()', instance.toString()) //[object Object]</span><br></pre></td></tr></tbody></table></figure><hr><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>纯粹的继承关系，实例是子类的实例，也是父类的实例</li><li>父类新增原型方法 / 原型属性，子类都能访问到</li><li>简单 易于实现</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>无法实现多继承</li><li>创建子类型的实例时，不能向超类型的构造函数中传递参数</li><li><strong>包含引用类型值的原型会被所有的实例共享</strong>，通过原型来实现继承的时候，原型实际上会变成另一个类型的实例，于是原来的实例属性也就变成了现在的原型属性了 (<font color="red">来自原型对象的所有属性被所有实例共享</font>)</li><li> 想要为子类添加属性或方法 只能在 <code>new SubType()</code> 之后</li></ul><hr><p>推荐指数：❤️ （3，4 问题比较致命）</p><h2 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h2><p><font color="red">核心思想：</font>使用父类的构造函数来增强子类实例，相当于复制父类的实例属性给子类（没用到原型） （<strong>不涉及到原型</strong>）</p><p><font color="red">技术原理：</font><br>在子类型构造函数的内部调用超类型构造函数</p><p>** 插播:** 函数只不过是在特定环境中执行代码的对象，因此 你可以通过使用 <code>apply</code> 或者 <code>call</code> 方法也可以在将来新创建的对象上执行构造函数</p><p>举个🌰</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function SuperType(){</span><br><span class="line">this.colors = ['red','blue'];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">function SubType(){</span><br><span class="line">SuperType.call(this) //继承了SuperType</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var instance1 = new SubType();</span><br><span class="line">instance1.colors.push('black')</span><br><span class="line">console.log(instance1.colors) //["red", "blue", "black"]</span><br><span class="line"></span><br><span class="line">var instance2 = new SubType();</span><br><span class="line">console.log(instance2.colors) &nbsp;//["red", "blue"]</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li>解决实例共享问题 </li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这样儿会在`SubType`对象上执行`SuperType`函数中定义的所有对象初始化代码，`SubType`的每个实例就都会具有自己`colors`属性的副本了</span><br></pre></td></tr></tbody></table></figure><ul><li>解决传递参数的问题 </li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function SuperType(name){</span><br><span class="line">this.name= name</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">function SubType(name,age){</span><br><span class="line">SuperType.call(this,name) //继承了SuperType 同时传递了参数</span><br><span class="line">this.age = age;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var instance = new SubType('yishu',18);</span><br></pre></td></tr></tbody></table></figure><ul><li>可以实现多继承（call 多个父类对象）</li></ul><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul><li>只能继承父类的实例属性和方法，不能继承原型属性和方法</li><li>无法实现函数复用，每个子类都有父类实例函数的副本，影响性能</li></ul><hr><p>推荐指数：❤️❤️（缺点 2 比较致命）</p><h2 id="组合继承（最常用的继承模式）"><a href="#组合继承（最常用的继承模式）" class="headerlink" title="组合继承（最常用的继承模式）"></a>组合继承（最常用的继承模式）</h2><p><font color="red">核心思想：</font>将原型链和构造函数的技术组合到一起 从而发挥二者之长</p><p><font color="red">技术原理：</font><br>使用原型链实现对原型属性和方法的继承<br>使用构造函数来实现对实例属性的继承<br>这样能实现<strong>在原型上定义方法实现了函数的服用又能保证每个实例有它自己的属性</strong></p><h3 id="举个🌰-1"><a href="#举个🌰-1" class="headerlink" title="举个🌰"></a>举个🌰</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function SuperType(name){</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.colors = ['red','blue','green']</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = function(){</span><br><span class="line">  return this.name</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">function SubType (name,age){</span><br><span class="line">  SuperType.call(this,name); //继承实例属性 （第二次调用SuperType()）</span><br><span class="line">  this.age = age;</span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"> SubType.prototype = new SuperType(); //继承原型属性和方法（第一次调用SuperType()）</span><br><span class="line"> SubType.prototype.sayAge = function(){</span><br><span class="line">  return this.age;</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line">var instance1 = new SubType('yishu',25);</span><br><span class="line">instance1.colors.push('yellow');</span><br><span class="line">console.log('instance1.colors',instance1.colors); // ["red", "blue", "green", "yellow"]</span><br><span class="line">console.log('instance1.name',instance1.sayName()); //yishu</span><br><span class="line">console.log('instance1.age',instance1.sayAge());//25</span><br><span class="line"></span><br><span class="line">var instance2 = new SubType('Grei',29);</span><br><span class="line"> console.log('instance2.colors',instance2.colors); //["red", "blue", "green"]</span><br><span class="line">console.log('instance2.name',instance2.sayName());//Grei</span><br><span class="line">console.log('instance2.age',instance2.sayAge());//29</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ul><li>可以继承实例属性 / 方法，也可以继承原型属性 / 方法</li><li>不存在引用属性共享问题</li><li>可传参</li><li>函数可复用</li></ul><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><p>调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">具体的过程</span><br><span class="line"></span><br><span class="line">第一次调用的时候 SubType.prototype 会得到两个属性  name和colors  他们都来自于 SuperType 但是现在位于 SubType的原型中 当调用SubType构造函数时 又会调用一次</span><br><span class="line">SuperType的构造函数 这一次又在新对象SubType上创建了实例属性 name和colors  于是这两个属性屏蔽了原型中同名属性</span><br></pre></td></tr></tbody></table></figure><hr><p>推荐指数：❤️❤️❤️❤️（仅仅多消耗了一点内存）</p><h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><p><font color="red">核心原理：</font>借助原型可以基于已有的对象创建新的对象 同时还不必因此创建自定义类型</p><p><strong>ES5 以前</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function ObjectCreate(o){</span><br><span class="line">  function F(){} //创建了一个临时性的构造函数</span><br><span class="line">  F.prototype = o;//将传入的对象当作这个构造函数的原型</span><br><span class="line">  return new F(); //返回这个临时类型的新实例</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ObjectCreate 方法本质上对传入其中的对象执行了一次浅复制</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var person = {</span><br><span class="line">  name:'yishu',</span><br><span class="line">  friends:['xiaohong','xiaoming']</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var instance1 = ObjectCreate(person);</span><br><span class="line">instance1.age = 45;</span><br><span class="line">instance1.friends.push('xiaolan');</span><br><span class="line">console.log('instance1',instance1.age); //45</span><br><span class="line">console.log('instance1',instance1.friends);//&nbsp;["xiaohong", "xiaoming", "xiaolan"]</span><br><span class="line">console.log('person.friends',person.friends)//["xiaohong", "xiaoming", "xiaolan"]</span><br><span class="line">console.log('person.age',person.age)//undefined</span><br><span class="line"></span><br><span class="line">var instance2 = ObjectCreate(person);</span><br><span class="line">console.log('instance2',instance2.age); //undefined</span><br><span class="line">console.log('instance2',instance2.friends);//["xiaohong", "xiaoming", "xiaolan"]</span><br></pre></td></tr></tbody></table></figure><p><strong>ES5 以后</strong></p><p>通过新增 <code>Object.create(obj1，obj2)</code> 规范化了原型式继承</p><ul><li>obj1：用做新对象原型的对象</li><li> obj2（可选）为新对象定义额外属性的对象 在传入一个参数的情况下与 <code>ObjectCreate</code> 函数功能相同 </li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var person = {</span><br><span class="line">  name:'yishu',</span><br><span class="line">  friends:['xiaohong','xiaoming']</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var otherPerson = Object.create(person);</span><br><span class="line"></span><br><span class="line">otherPerson.name='maying';</span><br><span class="line">otherPerson.friends.push('wqs');</span><br><span class="line">console.log('otherPerson',otherPerson.name) // maying</span><br><span class="line">console.log('otherPerson',otherPerson.friends) //&nbsp;["xiaohong", "xiaoming", "wqs"]</span><br><span class="line"></span><br><span class="line">var otherPerson1 = Object.create(person,{name:{value:'dsdd'}});</span><br><span class="line">console.log('otherPerson1',otherPerson1.name) //dsdd</span><br><span class="line">console.log('otherPerson1',otherPerson1.friends)//&nbsp;["xiaohong", "xiaoming", "wqs"]</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><hr><h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><ul><li>不是类式继承，而是原型式基础，缺少了类的概念</li><li>对于引用类型值的属性依然是 共享状态的，这相当于创建了两个 person 的副本</li></ul><h2 id="寄生式组合继承（最理想的继承范式）"><a href="#寄生式组合继承（最理想的继承范式）" class="headerlink" title="寄生式组合继承（最理想的继承范式）"></a>寄生式组合继承（最理想的继承范式）</h2><p><font color="red">核心原理：</font><br>借用构造函数来继承属性<br>通过原型链的<strong>混成形式</strong>来继承方法</p><p><font color="red">技术原理：</font> 不必为了指定子类型的原型而调用超类型的构造函数 我们所需要的无非就是超类型原型的一个副本而已（使用寄生式来继承超类型的原型 然后再将结果指定给子类型的原型 ）</p><p>举个🌰</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">function inhertPrototype(SubType, SuperType){</span><br><span class="line"></span><br><span class="line">  var prototype = Object.create(SuperType.prototype); //创建对象</span><br><span class="line">  prototype.constructor = SubType; //如果你创建了一个新对象并替换了函数默认的.prototype对象引用,那么新对象不会自动获得.constructor属性</span><br><span class="line">  SubType.prototype = prototype;//指定对象</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">function SuperType(name){</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.colors = ['red','blue','green'];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = function(){</span><br><span class="line">  alert(this.name);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function SubType(name,age){</span><br><span class="line">  SuperType.call(this, name);//第二次调用SuperType()</span><br><span class="line">  this.age = age;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">inhertPrototype(SubType, SuperType);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SubType.prototype.sayAge = function(){</span><br><span class="line">  alert(this.age);         </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var dd = new SubType('yishu',22);</span><br><span class="line">dd.colors.push('gold');</span><br><span class="line">console.log('dd',dd.colors);  //["red", "blue", "green", "gold"]</span><br><span class="line">dd.sayAge(); //22</span><br><span class="line">dd.sayName(); //yishu</span><br><span class="line"></span><br><span class="line">var cc = new SubType('xiaogou',10);</span><br><span class="line"></span><br><span class="line">console.log('cc',cc.colors); ["red", "blue", "green"]</span><br><span class="line">cc.sayAge(); //10</span><br><span class="line">cc.sayName();//xiaogou</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h3><p>完美</p><ul><li>它只调用了一次构造函数 避免了在 SubType.prototype 上创建不必要的属性 与此同时 原型链还能保持不变<h3 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h3></li><li>实现不如组合式继承简单</li></ul><hr><p>推荐指数：❤️❤️❤️❤️（复杂度扣掉一颗心）</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ECMAscript 支持面向对象编程 但是不使用类或者接口 对象可以在代码执行过程中创建或增强 因此具有动态性而非严格定义的实体 在没有类的情况下 可以采用下列模式创建对象</p><ul><li>工厂模式 </li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用简单的函数创建对象 为对象天假属性和方法 然后返回对象被构造函数模式取代</span><br></pre></td></tr></tbody></table></figure><ul><li>构造函数模式 </li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">可以创建自定义引用类型 </span><br><span class="line">可以像创建内置对象实例一样使用new</span><br><span class="line"></span><br><span class="line">缺点：成员无法复用 包括函数</span><br></pre></td></tr></tbody></table></figure><ul><li>原型模式 </li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用构造函数的prototype属性来指定那些应该共享的属性和方法</span><br><span class="line"></span><br><span class="line">组合使用 构造函数模式和原型模式 分别定义属性和方法</span><br></pre></td></tr></tbody></table></figure><p>js 主要通过原型链实现继承 原型链的构建是通过<strong>将一个类型的实例复制给另一个构造函数的原型</strong>实现的，这样子类型就能访问到超类型所有的属性和方法 这一点与基于类的继承很相似。</p><p>原型链的问题是<strong>对象实例共享所有的属性和方法</strong> 因此不适合单独使用<br>解决这个问题的技术是借助构造函数 （在子类型构造函数中的内部调用超类型的构造函数） 这样就能做到每个实例具有自己的属性 同时还能保证只使用构造函数模式来定义类型</p><p>使用最多的继承模式是<strong>组合继承</strong><br>通过原型链继承共享的属性和方法<br>而通过借用构造函数继承实例属性</p><p>还有其他继承模式</p><ul><li>原型式继承 </li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以在不必预先定义构造函数的情况下实现继承 本质是执行对给定对象的浅复制 而复制的副本还可以进行进一步的加强 改造</span><br></pre></td></tr></tbody></table></figure><ul><li>寄生式继承 </li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">与 原型式继承相似</span><br></pre></td></tr></tbody></table></figure><ul><li>寄生组合式继承 </li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">集寄生式继承和组合继承的优点与一身</span><br><span class="line">是实现基于类型继承的最有效的方式</span><br></pre></td></tr></tbody></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>JavaScript 高级程序设计（第三版）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;面向对象语言支持两种继承方式：接口继承（只继承方法签名）和实现继承（继承实际的方法）由于函数没有签名，ECMAScript 只支持实现继承，而实现继承主要是依靠原型链实现的&lt;/p&gt;
&lt;p&gt;下面就当下几种继承方式做一个对比参考&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="http://maying.ink/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>深入理解 Flexbox</title>
    <link href="http://maying.ink/2019/03/14/flex/"/>
    <id>http://maying.ink/2019/03/14/flex/</id>
    <published>2019-03-14T11:08:59.000Z</published>
    <updated>2020-10-22T18:41:42.182Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>过去，我们总是不得不忍受 <code>float、display:table</code> 这些布局方式带来的痛苦，不过现在是时候去拥抱一个更简洁的制作智能布局的现代语法 <code>Flexbox</code></p><h2 id="Flexbox是什么"><a href="#Flexbox是什么" class="headerlink" title="Flexbox是什么"></a>Flexbox 是什么</h2><p>根据规范中的描述可知道，<code>Flexbox</code> 模块提供了一个有效的布局方式，即使不知道视窗大小或者未知元素情况之下都可以智能的，灵活的调整和分配元素和空间两者之间的关系</p><a id="more"></a><h2 id="如何开始使用Flexbox"><a href="#如何开始使用Flexbox" class="headerlink" title="如何开始使用Flexbox"></a>如何开始使用 Flexbox</h2><p>幸运的是，入门超级简单<br>你要做的第一件事就是声明一个 <code>Flex</code> 容器</p><p>就像这样儿，声明了 <code>Flex</code> 容器之后，一个 <code>Flexbox</code> 格式化上下文就立即启动了</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul class="oul"&gt;</span><br><span class="line">  &lt;li&gt;1&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;2&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;3&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></tbody></table></figure><p>正常情况下 div 在 CSS 中垂直堆栈的，也就是说从上到下排列显示</p><p>图一<br><img src="/images/flex/flex2.png" alt="flex2"></p><p>声明 <code>Flex容器</code></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.oul {</span><br><span class="line">    //...</span><br><span class="line">    display: flex</span><br><span class="line">    //...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>现在已经是一个 Flexbox 格式化上下文<br>图二<br><img src="/images/flex/flex1.png" alt="flex1"></p><p><strong>很简单 一行代码就能看到布局改变了子元素就像你使用了 float 一样是水平排列的</strong></p><p>拿这个例子来说此时 <code>ul</code> 自动变成了 <code>Flex</code>，而 <code>li</code> 变成了 <code>Flex</code> 项目</p><p>记住这些名词，它们是 <code>Flexbox</code> 模块的基础</p><h2 id="Flex容器属性"><a href="#Flex容器属性" class="headerlink" title="Flex容器属性"></a>Flex 容器属性</h2><p><code>flex-direction || flex-wrap || flex-flow || justify-content || align-items || align-content </code><br>解释这些属性之前，先来看一张 flex 世界比较重要的概念</p><p><img src="/images/flex/flex3.png" alt="flex3"></p><ul><li><code>Main-Axis</code> 就是水平方向，从左到右，这也是默认方向</li><li><code>Cross-Axis</code> 是垂直方向，从上往下</li></ul><h3 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h3><p>属性值</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> { <span class="attribute">flex-direction</span>: row || column || row-reverse || column-reverse; }</span><br></pre></td></tr></tbody></table></figure><p>默认值是 <code>row</code> 它让 Flex 项目沿着 Main-Axis 排列（从左向右，水平排列） 这也解释了图二的效果</p><h3 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h3><p>属性值</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> { <span class="attribute">flex-wrap</span>: wrap || nowrap || wrap-reverse; }</span><br><span class="line"></span><br><span class="line">*  <span class="selector-tag">nowrap</span>: <span class="selector-tag">Flex</span>容器内的<span class="selector-tag">Flex</span>项目不换行排列 （默认值）</span><br><span class="line">*  <span class="selector-tag">wrap</span>:换行排列 这种情况下，一行不能包含所有列表项的默认宽度，它们就会多行排列</span><br><span class="line">*  <span class="selector-tag">wrap-reverse</span>:反向换行</span><br></pre></td></tr></tbody></table></figure><h3 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h3><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">flex-flow</span>是<span class="selector-tag">flex-direction</span>和<span class="selector-tag">flex-wrap</span>两个属性的速记属性</span><br></pre></td></tr></tbody></table></figure><p>语法</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> { <span class="attribute">flex-flow</span>: row wrap; }</span><br></pre></td></tr></tbody></table></figure><h3 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h3><p>接下来感受来自 <code>flex</code> 容器的魔法</p><p>它主要定义了 Flex 项目在 <code>Main-Axis</code> 上的对齐方式</p><p>属性值</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> { <span class="attribute">justify-content</span>: flex-start || flex-end || center || space-between || space-around }</span><br><span class="line">* <span class="selector-tag">flex-start</span> 元素位于容器的开头。弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。</span><br><span class="line">* <span class="selector-tag">flex-end</span> 元素位于容器的结尾，弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界</span><br><span class="line">* <span class="selector-tag">center</span>：居中对齐</span><br><span class="line">* <span class="selector-tag">space-between</span>：让除了第一个和最一个<span class="selector-tag">Flex</span>项目的两者间间距相同（两端对齐）</span><br><span class="line">* <span class="selector-tag">space-around</span>：让每个<span class="selector-tag">Flex</span>项目具有相同的空间</span><br></pre></td></tr></tbody></table></figure><p><strong>space-between</strong><br><img src="/images/flex/between.png" alt="between"><br><strong>space-around</strong></p><p>和 space-between 有点不同，第一个 Flex 项目和最后一个 Flex 项目距 Main-Axis 开始边缘和结束边缘的的间距是其他相邻 Flex 项目间距的一半<br><img src="/images/flex/around.png" alt="around"></p><h3 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h3><p>它主要用来控制 Flex 项目在侧轴上的对齐方式</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> { <span class="attribute">align-items</span>: flex-start || flex-end || center || stretch || baseline }</span><br><span class="line"></span><br><span class="line">* <span class="selector-tag">stretch</span> 默认值 让所有的<span class="selector-tag">Flex</span>项目高度和<span class="selector-tag">Flex</span>容器高度一样。</span><br><span class="line">* <span class="selector-tag">flex-start</span> 元素位于容器的开头。弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。</span><br><span class="line">* <span class="selector-tag">flex-end</span> 元素位于容器的结尾，弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界</span><br><span class="line">* <span class="selector-tag">center</span> 元素位于容器的中心</span><br><span class="line">* <span class="selector-tag">baseline</span> 让所有<span class="selector-tag">Flex</span>项目在<span class="selector-tag">Cross-Axis</span>上沿着他们自己的基线对齐</span><br></pre></td></tr></tbody></table></figure><p><strong>baseline</strong><br>效果类似 <code>flex-start</code> 但略有不同<br>区别就在于 <code>baseline</code><br><img src="/images/flex/base.png" alt="base"></p><h3 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ul { align-items: stretch|center|flex-start|flex-end|space-between|space-around}</span><br><span class="line"></span><br><span class="line">* stretch 默认值 元素被拉伸以适应容器</span><br><span class="line">* flex-start 元素位于容器的开头。弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。</span><br><span class="line">* flex-end 元素位于容器的结尾，弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界</span><br><span class="line">* center 元素位于容器的中心</span><br><span class="line">* space-between：让除了第一个和最一个Flex项目的两者间间距相同（两端对齐）</span><br><span class="line">* space-around：让每个Flex项目具有相同的空间</span><br></pre></td></tr></tbody></table></figure><p><strong>stretch</strong><br><img src="/images/flex/align-content.png" alt="align-content"><br>flex-end<br><img src="/images/flex/ennd.png" alt="ennd"></p><p><strong>flex-start</strong></p><p><img src="/images/flex/align-content-start.png" alt="align-content-start"></p><p><strong>center</strong><br><img src="/images/flex/center.png" alt="cente"></p><h2 id="Flex项目属性"><a href="#Flex项目属性" class="headerlink" title="Flex项目属性"></a>Flex 项目属性</h2><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">order || flex-grow || flex-shrink || flex-basis</span><br></pre></td></tr></tbody></table></figure><h3 id="order"><a href="#order" class="headerlink" title="order"></a>order</h3><p>允许 Flex 项目在一个 Flex 容器中重新排序。基本上，你可以改变 Flex 项目的顺序，从一个位置移动到另一个地方而不改变源代码，所有 Flex 项目的 order 值都是 0，Flex 项目会根据 order 值从低到高重新排序</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.oul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(1)</span> {</span><br><span class="line">    <span class="attribute">order</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/*设置一个比0更大的值*/</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Flex 项目 2、3、4 的 order 值为 0。现在 Flex 项目 1 的 order 值为 1</p><p><img src="/images/flex/order.png" alt="orde"></p><p>Flex 项目 <code>2、3和4的order</code> 值都是 <code>0</code>。HTML 源代码秩序并没有修改过。如果给 <code>Flex</code> 项目 2 的 <code>order</code> 设置为 <code>2</code><br><img src="/images/flex/order2.png" alt="orde"></p><p>可见 它也增加堆栈。现在代表 <code>Flex</code> 项目的最高的 <code>order</code> 值</p><p>当两个 Flex 项目具有相同的 order 值呢？在下面的示例中，把 Flex 项目 1 和 3 设置相同的 order 值。<br><img src="/images/flex/order3.png" alt="orde"><br>现在仍是从低到高排列。这次 <code>Flex</code> 项目 <code>3</code> 排在 <code>Flex</code> 项目 <code>1</code> 后面，那是因为在 <code>HTML</code> 文档中 <code>Flex</code> 项目 <code>3</code> 出现在 <code>Flex</code> 项目 <code>1</code> 后面。</p><p>如果两个以下 <code>Flex</code> 项目有相同的 <code>order</code> 值时，<code>Flex</code> 项目重新排序是基于 <code>HTML</code> 源文件的位置进行排序</p><h3 id="flex-grow-和-flex-shrink"><a href="#flex-grow-和-flex-shrink" class="headerlink" title="flex-grow 和 flex-shrink"></a>flex-grow 和 flex-shrink</h3><ul><li>flex-grow ：控制 <code>Flex</code> 项目在容器有多余的空间如何放大（扩展）默认值是 0 表示开关是关闭的，即如果存在剩余空间，也不放大 </li></ul><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> {</span><br><span class="line">  <span class="attribute">flex-grow</span>: &lt;number&gt;; <span class="comment">/* default 0 */</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="/images/flex/flow-grow.png" alt="flow-gro"><br>属性值为 1 时<br><img src="/images/flex/flow-grow1.png" alt="flow-gro"></p><p>现在 <code>Flex</code> 项目扩展了，占据了 Flex 容器所有可用空间。也就是说开关打开了。如果你试着调整你浏览器的大小，<code>Flex</code> 项目也会缩小，以适应新的屏幕宽度</p><p>如果所有项目的 <code>flex-grow</code> 属性都为 <code>1</code>，则它们将等分剩余空间（如果有的话）<br>如果一个项目的 <code>flex-grow</code> 属性为 <code>2</code>，其他项目都为 <code>1</code>，则前者占据的剩余空间将比其他项多一倍</p><ul><li>flex-shrink：属性定义了项目的缩小比例，默认为 <code>1</code>（默认开启），即如果空间不足，该项目将缩小 </li></ul><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> {</span><br><span class="line">  <span class="attribute">flex-shrink</span>: &lt;number&gt;; <span class="comment">/* default 1 */</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h3><p>它用于设置或检索弹性盒伸缩基准值<br><code>浏览器</code>根据这个属性，计算主轴是否有多余空间一般配合 <code>flex-wrap </code>一起使用，flex 容器根据 <code>flex-basis</code> 计算是否需要换行</p><p>一些特性</p><h4 id="1-它的属性值可以是长度单位-em-rem-px-或百分比-，百分比是按照父元素的width为标准"><a href="#1-它的属性值可以是长度单位-em-rem-px-或百分比-，百分比是按照父元素的width为标准" class="headerlink" title="1.它的属性值可以是长度单位(em || rem || px)**或百分比(%)**，百分比是按照父元素的width为标准"></a>1. 它的属性值可以是<strong>长度单位 (em || rem || px)** 或</strong>百分比 (%)**，<font color="red">百分比是按照父元素的 width 为标准</font></h4><h4 id="2-默认值为-auto-MDN"><a href="#2-默认值为-auto-MDN" class="headerlink" title="2.默认值为 auto  MDN"></a>2. 默认值为 <font color="red">auto</font>  <a href="https://drafts.csswg.org/css-flexbox/#flexibility">MDN</a></h4> <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">取值为**auto**时，它的值就等于当前项的**width**（或者默认的大小，width没有设置的话）" </span><br><span class="line">flex-basis:auto" 的含义是 "参照我的width和height属性</span><br></pre></td></tr></tbody></table></figure><h4 id="当flex-item没有自身宽高，其默认大小由flex-basis决定"><a href="#当flex-item没有自身宽高，其默认大小由flex-basis决定" class="headerlink" title="当flex-item没有自身宽高，其默认大小由flex-basis决定"></a>当 flex-item 没有自身宽高，其默认大小由 flex-basis 决定</h4><p>即优先级： <font color="red">flex-basis &gt; width (非 auto)</font></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.oul2-li{</span><br><span class="line">      flex-basis: 200px;</span><br><span class="line">      width: 10px;</span><br><span class="line">      margin: 0px 4px;</span><br><span class="line">      background: red;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><p><img src="/images/flex/shiliflex1.png" alt="shiliflex1"></p><h4 id="4-当元素存在默认宽高（input）"><a href="#4-当元素存在默认宽高（input）" class="headerlink" title="4.当元素存在默认宽高（input）"></a>4. 当元素存在默认宽高（<font color="red">input</font>）</h4><p>并且设置了 <code>flex-basis</code>，那么它的初始大小<code>以固定宽高为下限</code>，如果 <code>flex-basis </code>超过了固定宽高，那么以 <code>flex-basis</code> 设置大小为准，如果 <code>flex-basis</code> 比固定宽高小，那么以固定宽高为准</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.Myinput {</span><br><span class="line">     background: greenyellow;</span><br><span class="line">     flex-basis: 200px;</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure><p><img src="/images/flex/gfdsdf.png" alt="gfdsdf"><br>当将 <code>flex-basis</code> 设置的比默认宽度大</p><p><img src="/images/flex/swqs.png" alt="swqs"></p><p>当将 <code>flex-basis</code> 设置的比默认宽度小 100<br><img src="/images/flex/jnjjjuuu.png" alt="jnjjjuuu"></p><h4 id="5-当元素存在-min-width-height-或者-max-width-height"><a href="#5-当元素存在-min-width-height-或者-max-width-height" class="headerlink" title="5.当元素存在 min-width[height] 或者 max-width[height]"></a>5. 当元素存在 min-width [height] 或者 max-width [height]</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果 `flex-basis` 的值 大于 `min-width[min-height]`，`flex-item content`的值为 `flex-basis`</span><br><span class="line">如果`flex-basis `的值小于` min-width[min-height]` 那么`flex-item content`以`min-width[min-height]`计算</span><br></pre></td></tr></tbody></table></figure><p><img src="/images/flex/jsjjsjsjjjsjsjs.png" alt="jsjjsjsjjjsjsjs"></p><h4 id="6-元素设置width-height-auto"><a href="#6-元素设置width-height-auto" class="headerlink" title="6.元素设置width[height]: auto;"></a>6. 元素设置 <code>width[height]: auto;</code></h4><p>CSS 解析器对比两者的值，两者<strong>谁大取谁</strong>作为 <code>item</code> 的基本尺寸，如果一个 <code>item</code> 没有内容，flex-item 初始大小就会以 <code>flex-basis</code> 来决定<br>但是如果 <code>item</code> 有了内容，且内容撑开的尺寸比 <code>flex-basis</code> 大，那么 <code>flex-item</code> 初始大小就会以 <code>width[height]: auto; </code>来决定<br><br>优先级：<font color="red">width[height]: auto == flex-basis</font></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> &lt;ul class="oul2"&gt;</span><br><span class="line">      &lt;li class="li1"&gt;666666666666666666666666666666666666666666666666666666666666666666666666666666666666&lt;/li&gt;</span><br><span class="line">      &lt;li class="li2"&gt;77777&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    </span><br><span class="line">    .li1{</span><br><span class="line">    flex-basis: 100px;</span><br><span class="line">    margin-right: 5px;</span><br><span class="line">    background: greenyellow;</span><br><span class="line">    width: auto;</span><br><span class="line">}</span><br><span class="line">.li2{</span><br><span class="line">    flex-basis: 300px;</span><br><span class="line">    width: auto;</span><br><span class="line">    background: red;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">.oul2{</span><br><span class="line">    display: flex;</span><br><span class="line">    list-style: none;</span><br><span class="line">    border: 1px solid #ccc;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="/images/flex/uuxsuudhdusd.png" alt="uuxsuudhdusd"></p><h2 id="绝对和相对Flex项目"><a href="#绝对和相对Flex项目" class="headerlink" title="绝对和相对Flex项目"></a>绝对和相对 Flex 项目</h2><p>绝对 Flex 项目的宽度只基于 flex 属性，而相对 Flex 项目的宽度基于内容大小</p><p><strong>相对项目</strong></p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.oul</span> {</span><br><span class="line">     <span class="attribute">display</span>: flex;</span><br><span class="line">     <span class="comment">/*触发弹性盒*/</span></span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> <span class="selector-class">.oul</span> <span class="selector-tag">li</span> {</span><br><span class="line">     //flex-basis: auto;</span><br><span class="line">     <span class="selector-tag">flex</span>: <span class="selector-tag">auto</span>; <span class="comment">/*记住这与 flex: 1 1 auto; 相同*/</span></span><br><span class="line">     <span class="selector-tag">border</span>: 2<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-tag">red</span>;</span><br><span class="line">     <span class="selector-tag">margin</span>: 2<span class="selector-tag">rem</span>;</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure><p><img src="/images/flex/xianngdui.png" alt="xianngdui"></p><p>Flex 项目的初始宽度是被自动计算的（<code>flex-basis: auto</code>），然后会伸展以适应可用空间（<code>flex-grow: 1</code>）</p><p>像这样 当 <code>Flex</code> 项目因为被设置为 <code>flex-basis: auto</code>，而导致宽度被自动计算时，是基于 <code>Flex</code> 项目内包含的内容的大小而计算的就是相对项目</p><p><strong>绝对项目</strong></p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.oul</span> <span class="selector-tag">li</span> {</span><br><span class="line">     <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">     <span class="attribute">flex-shrink</span>: <span class="number">1</span>;</span><br><span class="line">     <span class="attribute">flex-basis</span>: <span class="number">0</span>;</span><br><span class="line">     <span class="comment">/*与 flex: 1 1 0 相同*/</span></span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> solid red;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">2rem</span>;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><p><img src="/images/flex/juedui.png" alt="juedui"></p><p><code>Flex</code> 项目的初始宽度是零（<code>flex-basis: 0</code>），并且它们会伸展以适应可用空间。当有两到多个 <code>Flex</code> 项目的 <code>flex-basis</code> 取值为 <code>0</code> 时，它们会基于 <code>flex-grow</code> 值共享可用空间</p><h3 id="flex组合属性"><a href="#flex组合属性" class="headerlink" title="flex组合属性"></a>flex 组合属性</h3><p>flex 是 <code>flex-grow、flex-shrink和flex-basis</code> 三个属性的速记（简写）顺序缩写为 GSB </p><h4 id="一些取值规律"><a href="#一些取值规律" class="headerlink" title="一些取值规律"></a>一些取值规律</h4><p><strong>当 flex 取值为一个非负数字，则该数字为 flex-grow 值，flex-shrink 取 1，flex-basis 取 0%，例如：flex: 1; 相当于</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">li {</span><br><span class="line">    flex-grow: 1;</span><br><span class="line">    flex-shrink: 1;</span><br><span class="line">    flex-basis: 0%;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>⚠️ <code>flex-basis的</code>默认值为 <code>auto</code>，为什么此时是 <code>0%</code>？<br>当你创建一个 flexbox 上下文而不给 flex 项目设置任何属性，此时的默认值<br><img src="/images/flex/wwwaaaa111.png" alt="wwwaaaa111"><br>此时它是<font color="red">相对项目</font><br>一旦你设置了 <code>flex:1</code> 简写属性</p><p>参考 MDN 所说<br><img src="/images/flex/flexjianxie.png" alt="flexjianxie"><br>浏览器使其变成了<font color="red">绝对项目</font></p><p><strong>flex: auto;</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">li {</span><br><span class="line">    </span><br><span class="line">    flex-grow: 1;</span><br><span class="line">    flex-shrink: 1;</span><br><span class="line">    flex-basis: auto;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>当 flex 取值为一个长度或百分比，则视为 flex-basis 值，flex-grow 取 1，flex-shrink 取 1，有如下等同情况（注意 0% 是一个百分比而不是一个非负数字）</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.item-1 {flex: 0%;}</span><br><span class="line">.item-1 {</span><br><span class="line">    flex-grow: 1;</span><br><span class="line">    flex-shrink: 1;</span><br><span class="line">    flex-basis: 0%;</span><br><span class="line">}</span><br><span class="line">.item-2 {flex: 24px;}</span><br><span class="line">.item-1 {</span><br><span class="line">    flex-grow: 1;</span><br><span class="line">    flex-shrink: 1;</span><br><span class="line">    flex-basis: 24px;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>当 flex 取值为两个非负数字，则分别视为 flex-grow 和 flex-shrink 的值，flex-basis 取 0%，如下是等同的：</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.item {flex: 2 3;}</span><br><span class="line">.item {</span><br><span class="line">    flex-grow: 2;</span><br><span class="line">    flex-shrink: 3;</span><br><span class="line">    flex-basis: 0%;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>当 flex 取值为一个非负数字和一个长度或百分比，则分别视为 flex-grow 和 flex-basis 的值，flex-shrink 取 1，如下是等同的：</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.item {flex: 2333 3222px;}</span><br><span class="line">.item {</span><br><span class="line">    flex-grow: 2333;</span><br><span class="line">    flex-shrink: 1;</span><br><span class="line">    flex-basis: 3222px;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="深入flex"><a href="#深入flex" class="headerlink" title="深入flex"></a>深入 flex</h2><p>到这里 关于 <code>Flex</code> 的基础知识已经结束了，你可以用它们处理几乎任何问题<br>但是<br><font color="red">Flexbox 是如何弹性的计算子级项目的大小的，它有没有什么规则 </font><br>令我费解</p><p>好了，小🌻课堂开始了</p><p>flex 是应用在 X 轴和 Y 轴上的<br>每一根轴都包括三个东西 <code> 维度、方向、尺寸</code></p><ul><li>维度：子元素横着排 (X 轴) 还是竖着排 (Y 轴)</li><li> 方向：子元素的顺序 (顺序还是逆序)</li><li> 尺寸：即父元素的 <code>width</code>，子元素在当前轴方向所占的位置的总和</li></ul><p>如下图所示（来自 W3C 规范）</p><p><img src="/images/flex/w3c.png" alt="w3"></p><h2 id="FFC-flex-formatting-context"><a href="#FFC-flex-formatting-context" class="headerlink" title="FFC(flex formatting context)"></a>FFC(flex formatting context)</h2><p>Flexbox 布局新定义了格式化上下文，类似 BFC（block formatting context）<br>定义了 <code>display: flex;</code> 或 <code>display: inline-flex</code> 的元素，和 <code>BFC</code> 一样，不会被浮动的元素遮盖，不会垂直外边距坍塌等等</p><h2 id="与BFC的细微区别"><a href="#与BFC的细微区别" class="headerlink" title="与BFC的细微区别"></a>与 BFC 的细微区别</h2><ul><li>vertical-align 对 Flexbox 中的子元素 是没有效果的</li><li> float 和 clear 属性对 Flexbox 中的子元素是没有效果的，也不会使子元素脱离文档流 (但是对 Flexbox 是有效果的！)</li><li>Flexbox 下的子元素不会继承父级容器的宽</li></ul><h2 id="flex-item（flex-子元素）"><a href="#flex-item（flex-子元素）" class="headerlink" title="flex item（flex 子元素）"></a>flex item（flex 子元素）</h2><p>CSS 解析器会把 定义了 <code>display: flex;</code> 和 <code>display: inline-flex;</code> 的 <code>Flexbox </code>下的子元素外部装进一个看不见的盒子里，我们通过排列这些盒子来达到排序、布局、 伸缩的目的</p><h3 id="flex-item-size-是如何计算的"><a href="#flex-item-size-是如何计算的" class="headerlink" title="flex-item-size 是如何计算的"></a>flex-item-size 是如何计算的</h3><p>子元素的尺寸为主轴方向上元素的的自身宽度 再加上自身的 <code>margin 、 border 和 padding </code></p><p>W3C 规范中介绍了  <code>flex-item content</code> 的计算规则</p><h3 id="隐藏属性对-items-size-的影响"><a href="#隐藏属性对-items-size-的影响" class="headerlink" title="隐藏属性对 items-size 的影响"></a>隐藏属性对 items-size 的影响</h3><p>针对 <code>display: none; visibility: hidden; visibility: collapse; transform: scale;</code> 进行测试</p><p>结论</p><ul><li>如果设置了 <code>visibility: hidden; | visibility: collapse; | transform: scale;</code> 的 <code>flex-item content </code>依然被算进主轴尺寸，CSS 解析器依然将可用空间分配给他们</li><li>如果设置了 <code>display: none;</code> CSS 解析器不会对该 <code>item</code> 的空间进行计算</li></ul><h3 id="关于position-absolute-对item影响"><a href="#关于position-absolute-对item影响" class="headerlink" title="关于position: absolute 对item影响"></a>关于 position: absolute 对 item 影响</h3><p><code>position: absolute </code>也是适用 <code>Flexbox</code> 中的子元素的，并且，设置了 <code>position: absolute</code> 属性的子元素，也会受到 <code>Flexbox</code> 排列的影响</p><p>absolute 的子元素重叠在了一起，但是依然会受到 <code>align-items: center; </code>的影响而居中</p><p><img src="/images/flex/jjjjjdsd.png" alt="jjjjjdsd"></p><p>并且根据一系列的实验得知</p><p><code>flexbox</code> 下设置了 <code>absolute</code>：</p><ul><li>flexbox 流下面的 <code>justify-content</code> 和 <code>align-items</code></li><li><code>item</code> 的 <code>top、left、right、bottom</code></li><li><code>margin</code> 自始至终都会影响 <code>item</code> 的位置</li><li>脱离了文档流的 <code>item</code> 不会影响正常的 <code>flex</code> 布局</li></ul><p><strong>小结</strong><br><code>justify-content、align-items</code> 和 <code>top、left、right、bottom </code>都是位置属性 且 <code>top、left、right、bottom </code>的值会覆盖 <code>justify-content、align-items</code> 的值</p><p><code>margin </code>的优先级是和 <code>top、left、right、bottom</code> 一样的，也就是说 <code>margin 和 top、left、right、bottom</code> 所设置的值会<strong>同时生效</strong></p><h2 id="flex-basis、flex-grow、flex-shrink-以及相应的计算"><a href="#flex-basis、flex-grow、flex-shrink-以及相应的计算" class="headerlink" title="flex-basis、flex-grow、flex-shrink 以及相应的计算"></a>flex-basis、flex-grow、flex-shrink 以及相应的计算</h2><p>这三个属性只有父级元素设置了 <code>display: flex | inline-flex;</code> 才会生效，并且只针对主轴方向生效</p><ul><li>如果 主轴是水平的，即 <code>flex-direction: row</code>; 那么 <code>flex-basis、flex-grow、flex-shrink </code>控制的就是单个 <code>item</code> 的宽度</li><li>如果 主轴是垂直的，即 <code>flex-direction: column</code>; 那么 <code>flex-basis、flex-grow、flex-shrink</code> 控制的就是单个 item 的高度</li></ul><hr><p>那么所有 <code>items</code> 都会在主轴方向上的一条线上排列，<code>CSS解析器</code>会计算 <code>items</code> 在主轴方向上所占的空间 相对于 <code>Flexbox</code> 在主轴方向的所占的空间进行比较计算</p><ul><li>如果 <code>items</code> 所占的空间是小于 <code>Flexbox</code> 的 那么说明 <code>Flexbox</code> 还没有填满，<code>CSS解析器</code>就会计算还有多少空间没有填满，根据每一个 <code>item</code> 所设置的 <code>flex-grow</code> 设置的值，将这些空间分配按比例分配给每一个 <code>item</code></li></ul><p><img src="/images/flex/wwwqwq.png" alt="wwwqwq"></p><ul><li>如果 <code>items</code> 所占的空间是大于 <code>Flexbox</code> 的 那么说明 <code>Flexbox</code> 被填满了，<code>CSS解析器</code>就会计算超出了多少空间，根据每一个 <code>item</code> 所设置的 <code>flex-shrink</code> 设置的值，将这些空间分配按比例缩小每一个 <code>item</code><br><img src="/images/flex/fukeyongkongjian.png" alt="fukeyongkongjian"></li></ul><h3 id="超出的空间是如何计算的"><a href="#超出的空间是如何计算的" class="headerlink" title="超出的空间是如何计算的"></a>超出的空间是如何计算的</h3><p><strong><code>flow-grow</code> 的计算流程</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可用空间 = 将flexbox-content - 每个item-size的总和</span><br></pre></td></tr></tbody></table></figure><p>将元素设置的 <code>flow-grow</code> 值加起来设置为 <code>growSize</code><br><code>单位分配空间 = 可用空间/growSize</code><br>然后真正分配的时候根据自己的比例计算增加的值<br><code>应该增加的值 = 自己的grow值 *  单位分配空间 </code></p><p><img src="/images/flex/growfencdc.png" alt="growfencd"></p><p><strong><code>flow-shrink</code> 的计算流程</strong></p><p>它的流程与 <code>flow-grow</code> 的计算流程<font color="red">不同</font></p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shrink比例 = flex-shrink * item-size / 之前的总和</span><br><span class="line"></span><br><span class="line">应该缩减的值：超出的空间 <span class="selector-tag">-</span> <span class="selector-tag">shrink</span>比例 * <span class="selector-tag">item-size</span></span><br></pre></td></tr></tbody></table></figure><p>如图所示</p><p><img src="/images/flex/shrinksw.png" alt="shrinks"></p><p><strong>max-width [height] 情况下 flex-grow 的计算流程</strong></p><p>由于可能存在某一个或多个 <code>item</code> 设置了有 <code>max-width[height]</code>。所以，CSS 引擎会先进行一次分配，分配后，统计那些有 <code>max-width[height]的items</code>, 分配后是否有超出的剩余空间，然后对这些剩余空间再分配给那些没有设置 <code>max-width[height]</code> 的 <code>item</code></p><p><img src="/images/flex/sandjandjnsjdwednjsedf.png" alt="sandjandjnsjdwednjsedf"></p><p><strong>min-width [height] 情况下 flex-shrink</strong></p><p>由于可能存在某一个或多个 item 设置了有 <code>min-width[height]</code>。所以，<code>CSS引擎</code>会先进行一次 <code>shrink</code>， <code>shrink</code> 后，统计那些有 <code>min-width[height]</code> 的 <code>items</code>, <code>shrink</code> 后是否有的剩余的未 <code>shrink</code> 空间，然后对这些剩余空间再分配给那些没有设置 <code>min-width[height]</code> 的 <code>item</code></p><p><img src="/images/flex/iiisjindndnjsndjsdnxjksndj.png" alt="iiisjindndnjsndjsdnxjksndj"></p><h2 id="Flexbox的浏览器支持"><a href="#Flexbox的浏览器支持" class="headerlink" title="Flexbox的浏览器支持"></a>Flexbox 的浏览器支持</h2><p>让我们求助于 <a href="https://caniuse.com/#search=flex">caniuse</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>深入理解 Flex 还是挺不容易的。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.w3cplus.com/css3/understanding-flexbox-everything-you-need-to-know.html">理解 flexbox，你需要知道的一切</a><br><a href="https://www.w3cplus.com/css3/flexbox-adventures.html">探索 Flexbox</a><br><a href="https://www.w3cplus.com/css3/flexbox-layout-and-calculation.html?from=groupmessage">理解 flex</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;过去，我们总是不得不忍受 &lt;code&gt;float、display:table&lt;/code&gt; 这些布局方式带来的痛苦，不过现在是时候去拥抱一个更简洁的制作智能布局的现代语法 &lt;code&gt;Flexbox&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;Flexbox是什么&quot;&gt;&lt;a href=&quot;#Flexbox是什么&quot; class=&quot;headerlink&quot; title=&quot;Flexbox是什么&quot;&gt;&lt;/a&gt;Flexbox 是什么&lt;/h2&gt;&lt;p&gt;根据规范中的描述可知道，&lt;code&gt;Flexbox&lt;/code&gt; 模块提供了一个有效的布局方式，即使不知道视窗大小或者未知元素情况之下都可以智能的，灵活的调整和分配元素和空间两者之间的关系&lt;/p&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://maying.ink/categories/CSS/"/>
    
    
      <category term="flex" scheme="http://maying.ink/tags/flex/"/>
    
  </entry>
  
  <entry>
    <title>模拟实现 apply 和 call 方法</title>
    <link href="http://maying.ink/2019/03/13/apply-call/"/>
    <id>http://maying.ink/2019/03/13/apply-call/</id>
    <published>2019-03-13T08:12:37.000Z</published>
    <updated>2020-10-22T18:41:42.180Z</updated>
    
    <content type="html"><![CDATA[<h2 id="先来通过MDN认识下call和apply"><a href="#先来通过MDN认识下call和apply" class="headerlink" title="先来通过MDN认识下call和apply"></a>先来通过 MDN 认识下 call 和 apply</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p><code>func.apply(thisArg, [argsArray])</code></p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p><strong>thisArg</strong>：可选的，<code>func</code> 函数运行的时使用的 <code>this</code> 值</p><a id="more"></a><p>⚠️ </p><ul><li>如果这个函数处于<font color="red">非严格模式下</font> 指定其为 <code>null</code> 或者 <code>undefined</code> 时 this 绑定会应用<code>默认规则</code>（<font color="red">这在<a href="http://maying.ink/2019/03/11/this/#more">分析 js 指向问题</a>时有提到</font>）</li><li>如果 thisArg 是原始值会被包装称对象 <code>.apply(2)</code> 会被包装成<code>.apply(Number(2))</code></li></ul><hr><p><strong>argsArray</strong>：可选的。一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 func 函数。如果该参数的值为 null 或  undefined，则表示不需要传入任何参数。从 ECMAScript 5 开始可以使用类数组对象</p><hr><p><strong>返回值</strong>：<br>调用有指定 this 值和参数的函数的结果</p><hr><p>几个有用的例子感受下 apply 的魔力</p><p><strong>求数组最大最小值</strong></p><p>聪明的 apply 用法允许你在某些本来需要写成遍历数组变量的任务中使用内建的函数</p><p>使用 <code>Math.max/Math.min</code> 来找出一个数组中的最大 / 最小值</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [5, 6, 2, 3, 7];</span><br><span class="line">var max = Math.max.apply(null, numbers);</span><br><span class="line">console.log(max);</span><br><span class="line"></span><br><span class="line">var min = Math.min.apply(null, numbers);</span><br><span class="line">console.log(min);</span><br></pre></td></tr></tbody></table></figure><p><strong>apply 设置的 this 值</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var doSth = function(a, b){</span><br><span class="line">    console.log(this);</span><br><span class="line">    console.log([a, b]);</span><br><span class="line">}</span><br><span class="line">doSth.apply(null, [1, 2]); // this是window  // [1, 2]</span><br><span class="line">doSth.apply(0, [1, 2]); // this 是 Number(0) // [1, 2]</span><br><span class="line">doSth.apply(true); // this 是 Boolean(true) // [undefined, undefined]</span><br><span class="line">doSth.call(undefined, 1, 2); // this 是 window // [1, 2]</span><br></pre></td></tr></tbody></table></figure><p><strong>用 apply 将一个数组添加到另一个数组</strong></p><p>如果我们传递一个数组来推送，它实际上会将该数组作为单个元素添加，而不是单独添加元素，因此我们最终得到一个数组内的数组<br><code>concat</code> 确实具有我们想要的行为，但它实际上并不附加到现有数组，而是创建并返回一个新数组<br>用 <code>apply</code> 就能简单实现</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var array = ['a', 'b'];</span><br><span class="line">var elements = [0, 1, 2];</span><br><span class="line">array.push.apply(array,elements) //&nbsp;["a", "b", 0, 1, 2]</span><br><span class="line">//array.push(elements) //)&nbsp;["a", "b", 0, 1, 2, Array(3)]</span><br><span class="line">console.log(array);</span><br></pre></td></tr></tbody></table></figure><p>call () 与 apply () 非常相似</p><p><code>fun.call(thisArg, arg1, arg2, ...)</code></p><p><strong>call 和 apply 的不同点</strong></p><ul><li><code>apply</code> 只接收两个参数，第二个参数可以是<code>数组</code>也可以是<code>类数组</code>，其实也可以是对象，后续的参数忽略不计</li><li><code>call</code> 接收第二个及以后一系列的参数</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>重新认识了 call 和 apply 会发现<br>它们作用都是一样的，改变函数里的 this 指向为第一个参数 <code>thisArg</code>，如果明确有多少参数，那可以用 <code>call</code>，不明确则可以使用 <code>apply</code>。也就是说完全可以不使用 <code>call</code>，而使用 <code>apply</code> 代替，我们只需要模拟实现 <code>apply</code>，<code>call</code> 可以根据参数个数都放在一个数组中，给到 <code>apply</code> 即可</p><hr><h2 id="模拟实现的准备工作"><a href="#模拟实现的准备工作" class="headerlink" title="模拟实现的准备工作"></a>模拟实现的准备工作</h2><p>模拟之前 我们先得看看 <a href="http://yanhaijing.com/es5/#book">ES5 规范</a> 关于 apply 摘抄以下几条</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.apply (thisArg, argArray)</span><br><span class="line"></span><br><span class="line">当以 thisArg 和 argArray 为参数在一个 func 对象上调用 apply 方法，采用如下步骤：</span><br><span class="line"></span><br><span class="line">1.如果 IsCallable(func) 是 false, 则抛出一个 TypeError 异常。</span><br><span class="line"></span><br><span class="line">2.如果 argArray 是 null 或 undefined, 则返回提供 thisArg 作为 this 值并以空参数列表调用 func 的 [[Call]] 内部方法的结果。</span><br><span class="line"></span><br><span class="line">3.返回提供 thisArg 作为 this 值并以空参数列表调用 func 的 [[Call]] 内部方法的结果。</span><br><span class="line"></span><br><span class="line">4.如果 Type(argArray) 不是 Object, 则抛出一个 TypeError 异常。</span><br><span class="line">...</span><br><span class="line">9.提供 thisArg 作为 this 值并以 argList 作为参数列表，调用 func 的 [[Call]] 内部方法，返回结果。</span><br><span class="line"></span><br><span class="line">apply 方法的 length 属性是 2。</span><br><span class="line"></span><br><span class="line">10.在外面传入的 thisArg 值会修改并成为 this 值。thisArg 是 undefined 或 null 时它会被替换成全局对象，所有其他值会被应用 ToObject 并将结果作为 this 值，这是第三版引入的更改</span><br></pre></td></tr></tbody></table></figure><p>结合上文和规范 ，明确了要解决的问题，<strong>我们如何将函数里的 this（一般指向 window）指向第一个参数 thisArg 呢</strong><br>不由得想起来了<a href="http://maying.ink/2019/03/11/this/">介绍 this 指向那一篇文章</a><br>那就采用隐式绑定呀，也就是说 既然他现有的上下文环境是 window（全局作用域）, 那我们就手动给他创建一个<code>非全局上下文</code></p><p>看看这个熟悉的例子</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var doSth = function(){</span><br><span class="line">    console.log(this);</span><br><span class="line">    console.log(this.name);</span><br><span class="line">    console.log(arguments);</span><br><span class="line">}</span><br><span class="line">var student = {</span><br><span class="line">    name: 'yishu',</span><br><span class="line">    doSth: doSth,</span><br><span class="line">};</span><br><span class="line">student.doSth(1, 2); // this === student // true // 'yishu' // [1, 2]</span><br><span class="line"></span><br><span class="line">doSth.apply(student, [1, 2]); // this === student // true // 'yishu' // [1, 2]</span><br></pre></td></tr></tbody></table></figure><p>你能看出来什么？<br> 在对象 <code>student</code> 上加一个函数 doSth，再执行这个函数，这个函数里的 <code>this</code> 就指向了这个对象</p><p> 那我们就模拟这个对象，给他添加一个函数，使用函数调用之后再删除它</p><p> 第一版本</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// 浏览器环境 非严格模式</span><br><span class="line">function getGlobalObject(){</span><br><span class="line">    return this;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Function.prototype.applyFn = function apply(thisArg,argsArray){</span><br><span class="line">   // 1.如果 `IsCallable(func)` 是 `false`, 则抛出一个 `TypeError` 异常。</span><br><span class="line">  if(typeof this !='function'){</span><br><span class="line">    throw new TypeError(this + 'is not function')</span><br><span class="line">  }</span><br><span class="line">  // 1.如果 `IsCallable(func)` 是 `false`, 则抛出一个 `TypeError` 异常。</span><br><span class="line">  if(typeof argsArray === 'undefined' || argsArray === null){</span><br><span class="line">    argsArray = [];</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  //3.如果 Type(argArray) 不是 Object, 则抛出一个 TypeError 异常 .</span><br><span class="line">   if(argsArray !== new Object(argsArray)){</span><br><span class="line">        throw new TypeError('CreateListFromArrayLike called on non-object');</span><br><span class="line">    }</span><br><span class="line">  //4.改变this的指向 在外面传入的 thisArg 值会修改并成为 this 值 如果传入的是 undefined或者null 则this指向应用默认绑定</span><br><span class="line">    if(typeof thisArg === 'undefined' || thisArg === null){</span><br><span class="line">        // ES3: thisArg 是 undefined 或 null 时它会被替换成全局对象 浏览器里是window</span><br><span class="line">        thisArg = getGlobalObject();</span><br><span class="line">    }</span><br><span class="line">    //开始表演</span><br><span class="line">    thisArg = new Object(thisArg);</span><br><span class="line">    thisArg.fn = this;</span><br><span class="line">    //接收返回值</span><br><span class="line">    var fnResult = thisArg.fn(...argsArray);</span><br><span class="line">    delete thisArg.fn;</span><br><span class="line">    return fnResult;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var doSth = function(){</span><br><span class="line">    console.log(this);</span><br><span class="line">    console.log(this.name);</span><br><span class="line">    console.log(arguments);</span><br><span class="line">}</span><br><span class="line">var student = {</span><br><span class="line">    name: '马小莹',</span><br><span class="line">    //doSth: doSth, //我们主要模拟了这个函数</span><br><span class="line">};</span><br><span class="line">doSth.applyFn(student, [1, 2]); </span><br><span class="line"></span><br><span class="line">// {name: "马小莹", doSth: ƒ, fn: ƒ}</span><br><span class="line">// 马小莹</span><br><span class="line">// Arguments(2)&nbsp;[1, 2, callee: ƒ, Symbol(Symbol.iterator): ƒ]</span><br></pre></td></tr></tbody></table></figure><p>看起来很完美，那它有没有问题呢？ 其实是有的</p><p><strong>.fn 函数同名覆盖问题，<code>thisArg</code> 对象上有 <code>fn</code>，那就被覆盖了然后被删除了</strong></p><p>那我们就找一个唯一值的函数名</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">thisArg = new Object(thisArg);</span><br><span class="line">var _fn = '__fn' + new Date().getTime();</span><br><span class="line">thisArg[_fn] = this;</span><br><span class="line">//接收返回值</span><br><span class="line">var fnResult = thisArg[_fn](...argsArray);</span><br><span class="line">delete thisArg[_fn];</span><br><span class="line">return fnResult;</span><br></pre></td></tr></tbody></table></figure><p>到现在 简单版本的 <code>apply</code> 已经实现了，现实业务场景不需要去模拟实现 <code>call和apply</code>, 毕竟是 <code>ES3</code> 就提供的方法</p><p>既然实现了 <code>apply</code>,<code>call</code> 也就简单了，<strong>原理就是</strong>拿到 <code>call</code> 的参数 转换成数组，然后调用 <code>applyFn</code></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Function.prototype.applyFn = function apply(thisArg){</span><br><span class="line">  var argsArray = [];</span><br><span class="line">  var argumentsLength = arguments.length;</span><br><span class="line">  for(var i = 0; i &lt; argumentsLength - 1; i++){</span><br><span class="line">    argsArray.push(arguments[i + 1]);</span><br><span class="line">    }</span><br><span class="line">    return this.applyFn(thisArg, argsArray);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>通过 MDN 认识 call 和 apply，阅读 ES5 规范，到模拟实现 apply，再实现 call</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;先来通过MDN认识下call和apply&quot;&gt;&lt;a href=&quot;#先来通过MDN认识下call和apply&quot; class=&quot;headerlink&quot; title=&quot;先来通过MDN认识下call和apply&quot;&gt;&lt;/a&gt;先来通过 MDN 认识下 call 和 apply&lt;/h2&gt;&lt;h3 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h3&gt;&lt;p&gt;&lt;code&gt;func.apply(thisArg, [argsArray])&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;参数&quot;&gt;&lt;a href=&quot;#参数&quot; class=&quot;headerlink&quot; title=&quot;参数&quot;&gt;&lt;/a&gt;参数&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;thisArg&lt;/strong&gt;：可选的，&lt;code&gt;func&lt;/code&gt; 函数运行的时使用的 &lt;code&gt;this&lt;/code&gt; 值&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="http://maying.ink/categories/js/"/>
    
    
      <category term="call" scheme="http://maying.ink/tags/call/"/>
    
      <category term="apply" scheme="http://maying.ink/tags/apply/"/>
    
  </entry>
  
  <entry>
    <title>模拟实现 JS 的 bind 方法</title>
    <link href="http://maying.ink/2019/03/13/bind/"/>
    <id>http://maying.ink/2019/03/13/bind/</id>
    <published>2019-03-13T05:36:45.000Z</published>
    <updated>2020-10-22T18:41:42.181Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要实现一个bind函数？"><a href="#为什么要实现一个bind函数？" class="headerlink" title="为什么要实现一个bind函数？"></a>为什么要实现一个 bind 函数？</h2><p><code>bind()</code> 函数在 <code>ECMA-262 第五版</code>才被加入<br>它可能无法在所有浏览器上运行，为了世界和平，必要的时候我们要手动实现它</p><a id="more"></a><h2 id="现有bind函数的功能？"><a href="#现有bind函数的功能？" class="headerlink" title="现有bind函数的功能？"></a>现有 bind 函数的功能？</h2><p>改造之前要清楚现有 <code>bind()</code> 函数做了哪些事儿</p><p>从 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">MDN</a> 上找到一些关于它的定义</p><p>bind () 方法创建一个新的函数，在调用时设置 this 关键字为提供的值。并在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项</p><p><strong>语法</strong> <code>function.bind(thisArg[, arg1[, arg2[, ...]]])</code></p><p>函数会创建一个新绑定函数，它包装了原函数对象<br><code>ceshiFn.bind(myObject)</code></p><p>绑定函数也可以使用 <code>new</code> 运算符构造，此时提供的 <code>this</code> 值会被忽略，但前置参数（arg1,arg2）仍会提供给模拟函数</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var Fn = ceshiFn.bind(myObject,1,2)</span><br><span class="line">new Fn() </span><br></pre></td></tr></tbody></table></figure><p>此时 <code>myObject</code> 被忽略 但是 参数依然会传递给 <code>ceshiFn</code> 令其初始化</p><p><strong>参数：</strong></p><ul><li><font color="red">thisArg</font>：当被绑定的函数被调用时，将它的 <code>this</code> 关键字设置为 <code>thisArg</code></li><li><font color="red">arg1，arg2</font>: 被调用时，这些参数将传递给被绑定的方法</li></ul><p><strong>返回值：</strong><br>指定的 <code>this</code> 值和初始化参数改造过原函数拷贝</p><h3 id="继续探索bind函数的功能"><a href="#继续探索bind函数的功能" class="headerlink" title="继续探索bind函数的功能"></a>继续探索 bind 函数的功能</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj = {};</span><br><span class="line">console.log('obj',obj)</span><br><span class="line">console.log(typeof Function.prototype.bind)  // bind</span><br><span class="line">console.log(typeof Function.prototype.bind()) //bind</span><br><span class="line">console.log(Function.prototype.bind.name) //bind</span><br><span class="line">console.log(Function.prototype.bind().name) // bound</span><br></pre></td></tr></tbody></table></figure><p>由此我们可以得到得出以下结论</p><ol><li><code>bind</code> 是 <code>Function</code> 原型链中 <code>Function.prototype</code> 的一个属性，每个函数都可以调用它</li><li><code>bind</code> 本身是一个函数名为 <code>bind</code> 的函数，返回值是一个名为 <code>bound</code> 的函数</li></ol><p>下面这个例子</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var obj = {</span><br><span class="line">    name: 'yishu',</span><br><span class="line">};</span><br><span class="line">function original(a, b){</span><br><span class="line">    console.log(this.name);</span><br><span class="line">    console.log([a, b]);</span><br><span class="line">    return false;</span><br><span class="line">}</span><br><span class="line">var bound = original.bind(obj, 1);</span><br><span class="line">var boundResult = bound(2); // 'yishu', [1, 2]</span><br><span class="line"></span><br><span class="line">console.log(boundResult); // false</span><br><span class="line">console.log(original.bind.name); // 'bind'</span><br><span class="line">console.log(original.bind.length); // 1</span><br><span class="line">console.log(original.bind().length); // 2 返回original函数的形参个数</span><br><span class="line">console.log(bound.name); // 'bound original'</span><br><span class="line">console.log((function(){}).bind().name); // 'bound '</span><br><span class="line">console.log((function(){}).bind().length); // 0</span><br></pre></td></tr></tbody></table></figure><ol><li><code>bind</code> 是函数可被传参数，返回值 <code>bound</code> 也是函数，也可以传参数</li><li>被 <code>bind()</code> 绑定的函数的 this 关键字是 <code>bind()</code> 的第一个参数</li><li>传递 <code>bind</code> 的其他参数被接收处理了，<code>bind()</code> 之后返回的函数 <code>bound</code> 函数的参数也被接收处理了，也就是说被合并处理了</li><li>并且 <code>bind()</code> 后的 <code>name</code> 为 <code>bound + 空格 + 调用bind的函数名</code>。如果是匿名函数则是 <code>bound + 空格</code></li><li>bind 后的返回值函数 <code>bound</code>，执行后返回值是原函数（original）的返回值</li><li> bind 函数形参（即函数的 length）是 1。bind 后返回的 bound 函数形参根据绑定的函数原函数（original）形参个数确定</li></ol><p>到这里 我们根据得出的结论 就可以模拟一个简单版本的 bind 函数了</p><h3 id="核心功能的bindFn函数"><a href="#核心功能的bindFn函数" class="headerlink" title="核心功能的bindFn函数"></a>核心功能的 bindFn 函数</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bindFn = function(thisArg){</span><br><span class="line"></span><br><span class="line">  //保证是一个函数调用了bindFn函数</span><br><span class="line">  if (typeof this != 'function'){</span><br><span class="line">    throw new TypeError(this + 'must be a function');</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  //保存除了thisArg之外的其他形参 转成数组</span><br><span class="line">  console.log('bindFn',arguments)</span><br><span class="line">    let arg = [].slice.call(arguments ,1);</span><br><span class="line">   var self = this;</span><br><span class="line"></span><br><span class="line">   var bound = function(){</span><br><span class="line">        // bind返回的函数 的参数转成数组</span><br><span class="line">        var boundArgs = [].slice.call(arguments);</span><br><span class="line">        // apply修改this指向，把两个函数的参数合并传给self函数，并执行self函数，返回执行结果</span><br><span class="line">        return self.apply(thisArg, arg.concat(boundArgs));</span><br><span class="line">    }</span><br><span class="line">    return bound;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 测试</span><br><span class="line">var obj = {</span><br><span class="line">    name: 'yishu',</span><br><span class="line">    age:18</span><br><span class="line">};</span><br><span class="line">function original(){</span><br><span class="line">  console.log([].slice.call(arguments))</span><br><span class="line">}</span><br><span class="line">var bound = original.bindFn(obj,3,4,5)</span><br><span class="line">bound(7); // [3, 4, 5, 7]</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>到这里基本上把 bind 的核心功能写完了，也能够适用大部分场景了 <code>bindFn</code> 只能能做到的只是永久地绑定指定的 <code>this</code> ，但是我们发现 <code>MDN</code> 上关于 <code>bind函数</code>描述 还有一种情况，那就是<font color="red">当你使用 <code>new操作符</code>调用绑定函数时</font><br>是这么说的</p><blockquote><p>thisArg：当使用 new 操作符调用绑定函数时，该参数无效。<br>一个绑定函数也能使用 new 操作符创建对象：这种行为就像把原函数当成构造器。提供的 <code>this</code> 值被忽略，同时调用时的参数被提供给模拟函数</p></blockquote><p>我们可以通过一个实例来看原生的 bind 对于使用 new 的情况是怎么样的</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = {</span><br><span class="line">    name: 'yishu',</span><br><span class="line">};</span><br><span class="line">function original(){</span><br><span class="line">    console.log('this', this.name,[].slice.call(arguments));</span><br><span class="line">}</span><br><span class="line">var bound = original.bind(obj,1);</span><br><span class="line">bound(2,3) //this yishu (3)&nbsp;[1, 2, 3]</span><br><span class="line">new bound(2,3) //this undefined (3)&nbsp;[1, 2, 3]s</span><br></pre></td></tr></tbody></table></figure><p>此时 <code>this</code> 指向了 <code>new bound()</code> 生成的新对象，所以找不到 <code>name</code> 为 <code>yishu</code> 的值了，但是参数依然传递的</p><p><strong>结论</strong></p><ul><li><code>bind</code> 原先指向 <code>obj</code> 的失效了，其他参数有效。</li><li><code>new bound</code> 的返回值是以 <code>original</code> 原函数构造器生成的新对象。<code>original</code> 原函数的 <code>this</code> 指向的就是这个新对象</li></ul><p>我们看到 又涉及到 <code>new</code> 操作了，<a href="http://maying.ink/2019/03/13/new/">写过关于模拟 new 的文章</a><br>简单摘要 new 做了什么</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.创建了一个全新的对象。</span><br><span class="line">2.这个对象会被执行[[Prototype]]（也就是__proto__）链接。</span><br><span class="line">3.生成的新对象会绑定到函数调用的this。</span><br><span class="line">4.通过new创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上。</span><br><span class="line">5.如果函数没有返回对象类型Object(包含Functoin, Array, Date, RegExg, Error)，那么new表达式中的函数调用会自动返回这个新的对象。</span><br></pre></td></tr></tbody></table></figure><p>所以 ，当使用 <code>new</code> 调用的时候，<code>bind</code> 的返回值函数 <code>bound</code> 内部要模拟实现 <code>new</code> 实现的操作，似曾相识了</p><h3 id="bindFn函数的升级"><a href="#bindFn函数的升级" class="headerlink" title="bindFn函数的升级"></a>bindFn 函数的升级</h3><p>区分是否是 new 调用 当使用 new 调用需要在 bind 函数返回值函数里实现模拟 <code>new</code> 的操作</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bindFn = function bind(thisArg){</span><br><span class="line">    if(typeof this !== 'function'){</span><br><span class="line">        throw new TypeError(this + ' must be a function');</span><br><span class="line">    }</span><br><span class="line">    // 存储调用bind的函数本身</span><br><span class="line">    var self = this;</span><br><span class="line">    // 去除thisArg的其他参数 转成数组</span><br><span class="line">    var args = [].slice.call(arguments, 1);</span><br><span class="line">    var bound = function(){</span><br><span class="line">        // bind返回的函数 的参数转成数组</span><br><span class="line">        var boundArgs = [].slice.call(arguments);</span><br><span class="line">        var finalArgs = args.concat(boundArgs);</span><br><span class="line">        // new 调用时，其实this instanceof bound判断也不是很准确。es6 new.target就是解决这一问题的。</span><br><span class="line">        //new.target属性允许你检测函数或构造方法是否是通过new运算符被调用的</span><br><span class="line">        if(new.target){ //检测函数或构造方法是否是通过new运算符被调用的</span><br><span class="line">            // 这里是实现上文描述的 new 的第 1, 2, 4 步</span><br><span class="line">            // 1.创建一个全新的对象</span><br><span class="line">            // 2.并且执行[[Prototype]]链接</span><br><span class="line">            // 4.通过`new`创建的每个对象将最终被`[[Prototype]]`链接到这个函数的`prototype`对象上。</span><br><span class="line">            // self可能是ES6的箭头函数，没有prototype，所以就没必要再指向做prototype操作。</span><br><span class="line">            if(self.prototype){</span><br><span class="line">                // ES5 提供的方案 Object.create()</span><br><span class="line">                // bound.prototype = Object.create(self.prototype);</span><br><span class="line">                // 但既然是模拟ES5的bind，那浏览器也基本没有实现Object.create()</span><br><span class="line">                // 所以采用 MDN ployfill方案 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create</span><br><span class="line">                function Empty(){}</span><br><span class="line">                Empty.prototype = self.prototype;</span><br><span class="line">                bound.prototype = new Empty();</span><br><span class="line">            }</span><br><span class="line">            // 这里是实现上文描述的 new 的第 3 步</span><br><span class="line">            // 3.生成的新对象会绑定到函数调用的`this`。</span><br><span class="line">            var result = self.apply(this, finalArgs);</span><br><span class="line">            // 这里是实现上文描述的 new 的第 5 步</span><br><span class="line">            // 5.如果函数没有返回对象类型`Object`(包含`Functoin`, `Array`, `Date`, `RegExg`, `Error`)，</span><br><span class="line">            // 那么`new`表达式中的函数调用会自动返回这个新的对象。</span><br><span class="line">            var isObject = typeof result === 'object' &amp;&amp; result !== null;</span><br><span class="line">            var isFunction = typeof result === 'function';</span><br><span class="line">            if(isObject || isFunction){</span><br><span class="line">                return result;</span><br><span class="line">            }</span><br><span class="line">            return this;</span><br><span class="line">        }</span><br><span class="line">        else{</span><br><span class="line">           //不使用new操作符时</span><br><span class="line">            // apply修改this指向，把两个函数的参数合并传给self函数，并执行self函数，返回执行结果</span><br><span class="line">            return self.apply(thisArg, finalArgs);</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    return bound;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>bind 是 Function 原型链中的 Function.prototype 的一个属性，它是一个函数，修改 this 指向，合并参数传递给原函数，返回值是一个新的函数。</li><li>bind 返回的函数可以通过 new 调用，这时提供的 this 的参数被忽略，指向了 new 生成的全新对象。内部模拟实现了 new 操作符。</li><li>bindFn</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 最终版 删除注释 详细注释版请看上文</span><br><span class="line">Function.prototype.bind = Function.prototype.bind || function bind(thisArg){</span><br><span class="line">    if(typeof this !== 'function'){</span><br><span class="line">        throw new TypeError(this + ' must be a function');</span><br><span class="line">    }</span><br><span class="line">    var self = this;</span><br><span class="line">    var args = [].slice.call(arguments, 1);</span><br><span class="line">    var bound = function(){</span><br><span class="line">        var boundArgs = [].slice.call(arguments);</span><br><span class="line">        var finalArgs = args.concat(boundArgs);</span><br><span class="line">        if(new.target){</span><br><span class="line">            if(self.prototype){</span><br><span class="line">                function Empty(){}</span><br><span class="line">                Empty.prototype = self.prototype;</span><br><span class="line">                bound.prototype = new Empty();</span><br><span class="line">            }</span><br><span class="line">            var result = self.apply(this, finalArgs);</span><br><span class="line">            var isObject = typeof result === 'object' &amp;&amp; result !== null;</span><br><span class="line">            var isFunction = typeof result === 'function';</span><br><span class="line">            if(isObject || isFunction){</span><br><span class="line">                return result;</span><br><span class="line">            }</span><br><span class="line">            return this;</span><br><span class="line">        }</span><br><span class="line">        else{</span><br><span class="line">            return self.apply(thisArg, finalArgs);</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    return bound;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为什么要实现一个bind函数？&quot;&gt;&lt;a href=&quot;#为什么要实现一个bind函数？&quot; class=&quot;headerlink&quot; title=&quot;为什么要实现一个bind函数？&quot;&gt;&lt;/a&gt;为什么要实现一个 bind 函数？&lt;/h2&gt;&lt;p&gt;&lt;code&gt;bind()&lt;/code&gt; 函数在 &lt;code&gt;ECMA-262 第五版&lt;/code&gt;才被加入&lt;br&gt;它可能无法在所有浏览器上运行，为了世界和平，必要的时候我们要手动实现它&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="http://maying.ink/categories/js/"/>
    
    
      <category term="bind" scheme="http://maying.ink/tags/bind/"/>
    
  </entry>
  
  <entry>
    <title>模拟实现 JS 的 new 操作符</title>
    <link href="http://maying.ink/2019/03/13/new/"/>
    <id>http://maying.ink/2019/03/13/new/</id>
    <published>2019-03-12T16:15:39.000Z</published>
    <updated>2020-10-22T18:41:42.183Z</updated>
    
    <content type="html"><![CDATA[<p><code>JS</code> 中 <code>new</code> 关键字用来实例化构造函数，那么它背后到底做了什么，能否被模拟实现<br>答案是肯定的</p><h2 id="new关键字做了什么"><a href="#new关键字做了什么" class="headerlink" title="new关键字做了什么"></a>new 关键字做了什么</h2><p>你一定从别的文章或者在实际开发中感受到 <code>new</code> 的妙处，不错，总结下来它主要支持了四个功能</p><a id="more"></a><ol><li>创建了一个全新的对象</li><li>这个对象会被执行 [[prototype]]（也就是__proto__）链接</li><li>生成的新对象会绑定到函数调用的 this</li><li> 通过 <code>new</code> 创建的每个对象将最终被来接到这个函数的 prototype 对象上</li><li>如果函数没有返回对象类型 Object (包含 Functoin, Array, Date, RegExg, Error)，那么 new 表达式中的函数调用会自动返回这个新的对象</li></ol><h2 id="模拟实现new"><a href="#模拟实现new" class="headerlink" title="模拟实现new"></a>模拟实现 new</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function newOperator(ctor){</span><br><span class="line">    if(typeof ctor !== 'function'){</span><br><span class="line">      throw 'newOperator function the first param must be a function';</span><br><span class="line">    }</span><br><span class="line">    // ES6 new.target 是指向构造函数</span><br><span class="line">    newOperator.target = ctor;</span><br><span class="line">    // 1.创建一个全新的对象，</span><br><span class="line">    // 2.并且执行[[Prototype]]链接</span><br><span class="line">    // 4.通过`new`创建的每个对象将最终被`[[Prototype]]`链接到这个函数的`prototype`对象上。</span><br><span class="line">    var newObj = Object.create(ctor.prototype);</span><br><span class="line">    // ES5 arguments转成数组 当然也可以用ES6 [...arguments], Aarry.from(arguments);</span><br><span class="line">    // 除去ctor构造函数的其余参数</span><br><span class="line">    var argsArr = [].slice.call(arguments, 1);</span><br><span class="line">    // 3.生成的新对象会绑定到函数调用的`this`。</span><br><span class="line">    // 获取到ctor函数返回结果</span><br><span class="line">    var ctorReturnResult = ctor.apply(newObj, argsArr);</span><br><span class="line">    // 小结4 中这些类型中合并起来只有Object和Function两种类型 typeof null 也是'object'所以要不等于null，排除null</span><br><span class="line">    var isObject = typeof ctorReturnResult === 'object' &amp;&amp; ctorReturnResult !== null;</span><br><span class="line">    var isFunction = typeof ctorReturnResult === 'function';</span><br><span class="line">    if(isObject || isFunction){</span><br><span class="line">        return ctorReturnResult;</span><br><span class="line">    }</span><br><span class="line">    // 5.如果函数没有返回对象类型`Object`(包含`Functoin`, `Array`, `Date`, `RegExg`, `Error`)，那么`new`表达式中的函数调用会自动返回这个新的对象。</span><br><span class="line">    return newObj;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="实例验证"><a href="#实例验证" class="headerlink" title="实例验证"></a>实例验证</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function Student(name, age){</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    // this.doSth();</span><br><span class="line">    // return Error();</span><br><span class="line">}</span><br><span class="line">Student.prototype.doSth = function() {</span><br><span class="line">    console.log(this.name);</span><br><span class="line">};</span><br><span class="line">var student1 = newOperator(Student, '轩辕', 18);</span><br><span class="line">var student2 = newOperator(Student, 'Rowboat', 18);</span><br><span class="line">// var student1 = new Student('轩辕');</span><br><span class="line">// var student2 = new Student('Rowboat');</span><br><span class="line">console.log(student1, student1.doSth()); // {name: '轩辕'} '轩辕'</span><br><span class="line">console.log(student2, student2.doSth()); // {name: 'Rowboat'} 'Rowboat'</span><br><span class="line"></span><br><span class="line">student1.__proto__ === Student.prototype; // true</span><br><span class="line">student2.__proto__ === Student.prototype; // true</span><br><span class="line">// __proto__ 是浏览器实现的查看原型方案。</span><br><span class="line">// 用ES5 则是：</span><br><span class="line">Object.getPrototypeOf(student1) === Student.prototype; // true</span><br><span class="line">Object.getPrototypeOf(student2) === Student.prototype; // true</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>模拟 <code>new</code> 最大的功臣当属于 <code>Object.create()</code> 这个 ES5 提供的 API</p><p><code>Object.create(proto, [propertiesObject]) </code>方法创建一个新对象，使用现有的对象来提供新创建的对象的<code>__proto__</code> 它接收两个参数，不过第二个可选参数是属性描述符（不常用，默认是 <code>undefined</code>）</p><p>对于不支持 ES5 的浏览器，MDN 上提供了 ployfill 方案。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if (typeof Object.create !== "function") {</span><br><span class="line">    Object.create = function (proto, propertiesObject) {</span><br><span class="line">        if (typeof proto !== 'object' &amp;&amp; typeof proto !== 'function') {</span><br><span class="line">            throw new TypeError('Object prototype may only be an Object: ' + proto);</span><br><span class="line">        } else if (proto === null) {</span><br><span class="line">            throw new Error("This browser's implementation of Object.create is a shim and doesn't support 'null' as the first argument.");</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        if (typeof propertiesObject != 'undefined') throw new Error("This browser's implementation of Object.create is a shim and doesn't support a second argument.");</span><br><span class="line"></span><br><span class="line">        function F() {}</span><br><span class="line">        F.prototype = proto;</span><br><span class="line">        return new F();</span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>## 总结</p><p>模拟 new 洁净版</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 去除了注释</span><br><span class="line">function newOperator(ctor){</span><br><span class="line">    if(typeof ctor !== 'function'){</span><br><span class="line">      throw 'newOperator function the first param must be a function';</span><br><span class="line">    }</span><br><span class="line">    newOperator.target = ctor;</span><br><span class="line">    var newObj = Object.create(ctor.prototype);</span><br><span class="line">    var argsArr = [].slice.call(arguments, 1);</span><br><span class="line">    var ctorReturnResult = ctor.apply(newObj, argsArr);</span><br><span class="line"></span><br><span class="line">    var isObject = typeof ctorReturnResult === 'object' &amp;&amp; ctorReturnResult !== null;</span><br><span class="line">    var isFunction = typeof ctorReturnResult === 'function';</span><br><span class="line">    if(isObject || isFunction){</span><br><span class="line">        return ctorReturnResult;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return newObj;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;JS&lt;/code&gt; 中 &lt;code&gt;new&lt;/code&gt; 关键字用来实例化构造函数，那么它背后到底做了什么，能否被模拟实现&lt;br&gt;答案是肯定的&lt;/p&gt;
&lt;h2 id=&quot;new关键字做了什么&quot;&gt;&lt;a href=&quot;#new关键字做了什么&quot; class=&quot;headerlink&quot; title=&quot;new关键字做了什么&quot;&gt;&lt;/a&gt;new 关键字做了什么&lt;/h2&gt;&lt;p&gt;你一定从别的文章或者在实际开发中感受到 &lt;code&gt;new&lt;/code&gt; 的妙处，不错，总结下来它主要支持了四个功能&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>实现一个 SSR 同构应用</title>
    <link href="http://maying.ink/2019/03/06/SSRDemo/"/>
    <id>http://maying.ink/2019/03/06/SSRDemo/</id>
    <published>2019-03-06T07:51:42.000Z</published>
    <updated>2020-10-22T18:41:42.180Z</updated>
    
    <content type="html"><![CDATA[<p>纸上得来终觉浅，我们来实现一个简易的服务端渲染流程，意在体会 SSR 带来的红利</p><a id="more"></a><p>页面源码来自 <a href="">React 状态管理与同构实战</a></p><h2 id="几个重要的概念"><a href="#几个重要的概念" class="headerlink" title="几个重要的概念"></a>几个重要的概念</h2><p>实现 <code>SSR</code> 是依靠 <code>React</code> 提供的 <code>ReactDomServer</code> 对象</p><p>它主要提供了只能在服务端使用的 <code>renderToString()</code> 与 <code>renderToStaticMarkup()</code> 方法</p><h3 id="renderToString-renderToStaticMarkup"><a href="#renderToString-renderToStaticMarkup" class="headerlink" title="renderToString()/renderToStaticMarkup()"></a>renderToString()/renderToStaticMarkup()</h3><p><strong>使用方法：</strong> <code>ReactDomServer.renderTostring(element)</code>/<br><code>ReactDomServer.renderToStaticMarkup(element)</code></p><h4 id="共同点："><a href="#共同点：" class="headerlink" title="共同点："></a>共同点：</h4><ul><li>都接收一个 React Element 并<strong>将此 Element 转化为 HTML 字符串，通过浏览器返回</strong>，实现了在服务端将页面拼接字符串插入 HTML 文档中并返回给浏览器 完成初步服务端渲染的目的</li></ul><h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><ul><li>renderToString(<font color="red">注：React 15</font>) 生成的 HTML 字符串的每个 Dom 节点都有 <code>data-react-id</code> 属性，根节点会有一个 <code>data-react-checkSum</code> 属性</li><li> renderToStaticMarkup 不带 <code>data-react-checkSum</code> 属性 浏览器渲染时必会重新渲染组件</li></ul><hr><p><font color="red">关于 data-react-checkSum</font>：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果两个组件有相同的props和Dom结构，这个值是一样的</span><br><span class="line"></span><br><span class="line">我们知道 服务端渲染完页面内容难过之后，浏览器端也会渲染以完成组件的交互等能力，浏览器端会生成组件的data-react-checkSum值 然后跟服务端渲染组件的值做对比，如果相等，则不再重复渲染</span><br></pre></td></tr></tbody></table></figure><p>这里有一张草图能大概描述这个过程嘤嘤嘤.<br><img src="/images/ssr/ssrcc.png" alt="cache_detai"></p><hr><h3 id="ReactDom-hydrate"><a href="#ReactDom-hydrate" class="headerlink" title="ReactDom.hydrate()"></a>ReactDom.hydrate()</h3><p>React 16 以后通过<br><code>renderToString</code> 渲染的组件不再带有 <code>data-react-*</code> 属性，因此浏览器端的渲染方式无法简单通过 <code>data-react-checksum</code> 来判断是否需要重新渲染</p><p>基于这样儿的背景下 <code>ReactDom</code> 提供了一个新的 API <code>ReactDom.hydrate()</code> 用法同 <code>render()</code> 在浏览器端渲染组件</p><p>当然，react 是向下兼容的，浏览器端在渲染组件时使用 render () 仍然没有问题，但不论是面向未来，还是基于性能的考虑，都应该采用更好的模式</p><hr><h3 id="renderToNodeStream-renderToStaticNodeStream"><a href="#renderToNodeStream-renderToStaticNodeStream" class="headerlink" title="renderToNodeStream()/renderToStaticNodeStream()"></a>renderToNodeStream()/renderToStaticNodeStream()</h3><p><font color="red">React 16 </font>为了优化页面的初始加载速度缩短 TTFB 时间，提供了这两个方法</p><p><strong>概念</strong><br>该方法持续产生子节流 返回 <code>Readable stream</code> 最终<strong>通过流形式返回的 HTML 字符串</strong><br>这样 服务端处理内容时是实时向浏览器端传输数据而不是一次性处理完成后才开始返回结果的</p><p><code>renderToStaticNodeStream</code> 之于 <code>renderToNodeStream</code> 也是不会产生 <code>data-react-*</code> 属性，对于静态页面 可以采用此方法。</p><h2 id="实际开发中可能存在的问题"><a href="#实际开发中可能存在的问题" class="headerlink" title="实际开发中可能存在的问题"></a>实际开发中可能存在的问题</h2><ol><li>服务端不存在支持组件挂载的浏览器环境，所以 react 组件只有 <code>componentDidMount</code> 之前的生命周期方法有效，所以在其之前的生命周期方法中不能用到浏览器的特性，比如 <code>window、localStorage</code>.</li><li> 双端可能都有拉取数据的需求，所以为了实现代码的复用，一种典型的做法就是把请求数据的逻辑放到 React 组件的静态方法中 然后双端共用，双端请求方法不一致的问题可以通过服务端与浏览器端的判断来封装一下 <strong>比如根据 window 是浏览器特有对象</strong></li></ol><h2 id="React-16-在服务端渲染上的惊喜"><a href="#React-16-在服务端渲染上的惊喜" class="headerlink" title="React 16 在服务端渲染上的惊喜"></a>React 16 在服务端渲染上的惊喜</h2><p>前面也有混杂说过，在此总结一下</p><ul><li>在浏览器渲染组件需要配合服务端使用 <code>hydrate</code> 方法</li><li>提供了 <code>stream</code> 方式的接口</li><li>与浏览器的新特性相似，除了能处理 <code>React Element</code> 也能处理别的类型，比如<code> string number</code></li><li>因为在返回结果 Dom 中废除了 <code>data-react-checksum</code> 等属性，所以服务端生成 HTML 更加高效</li><li>允许在渲染 Dom 中加入非标准 Dom 属性</li></ul><hr><p>好了 测试一下，基于 Node.js 实现一个小 demo</p><p><code>Express4.15.3 进行服务端处理</code></p><p><img src="/images/ssr/ssrvs1.png" alt="ssrvs1"><br>browser: 浏览器端渲染<br>server：服务端逻辑<br>share：同构的部分</p><p>运行效果：<br><img src="/images/ssr/ssrvs100.png" alt="ssr"><br><strong>share/app.js</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import React, { Component } from "react";</span><br><span class="line">import logo from "./logo.svg";</span><br><span class="line">import "./App.css";</span><br><span class="line"></span><br><span class="line">class App extends Component {</span><br><span class="line">  constructor(props) {</span><br><span class="line">    super(props);</span><br><span class="line">    this.handleClick = this.handleClick.bind(this);</span><br><span class="line">  }</span><br><span class="line">  handleClick() {</span><br><span class="line">    alert('我被触发辣')</span><br><span class="line">  }</span><br><span class="line">  render() {</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className="App"&gt;</span><br><span class="line">        &lt;div className="App-header"&gt;</span><br><span class="line">          &lt;img src={logo} className="App-logo" alt="logo" /&gt;</span><br><span class="line">          &lt;h2&gt;Welcome to React in the Server&lt;/h2&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;p className="App-intro"&gt;点击按钮体验&lt;/p&gt;</span><br><span class="line">        &lt;button onClick={e =&gt; this.handleClick()}&gt; 我是按钮 &lt;/button&gt;  </span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></tbody></table></figure><p><strong>browser/index.js</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import React from "react";</span><br><span class="line">import { hydrate } from "react-dom";</span><br><span class="line">import App from "../shared/App";</span><br><span class="line"></span><br><span class="line">hydrate(&lt;App /&gt;, document.getElementById("root"));</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>server/index.js</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import express from "express";</span><br><span class="line">import React from "react";</span><br><span class="line">import { renderToString } from "react-dom/server";</span><br><span class="line">import App from "../shared/App";</span><br><span class="line"></span><br><span class="line">const app = express();</span><br><span class="line"></span><br><span class="line">app.use(express.static("public"));</span><br><span class="line"></span><br><span class="line">app.get("*", (req, res) =&gt; {</span><br><span class="line">  const htmlMarkup = renderToString(&lt;App /&gt;);</span><br><span class="line">  res.send(`</span><br><span class="line">      &lt;!DOCTYPE html&gt;</span><br><span class="line">      &lt;head&gt;</span><br><span class="line">        &lt;title&gt;Universal Reacl&lt;/title&gt;</span><br><span class="line">        &lt;link rel="stylesheet" href="/css/main.css"&gt;</span><br><span class="line">        &lt;script src="/bundle.js" defer&gt;&lt;/script&gt;</span><br><span class="line">      &lt;/head&gt;</span><br><span class="line"></span><br><span class="line">      &lt;body&gt;</span><br><span class="line">        &lt;div id="root"&gt;${htmlMarkup}&lt;/div&gt;</span><br><span class="line">      &lt;/body&gt;</span><br><span class="line">    &lt;/html&gt;</span><br><span class="line">  `);</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">app.listen(process.env.PORT || 3000, () =&gt; {</span><br><span class="line">  console.log("Server is listening");</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p><strong>server 端：</strong>使用 <code>renderToString</code> 生成的字符串，使用 <code>res.send</code> 发送给浏览器<br><strong>client 端：</strong> id 为 root 的 Dom 节点就来自服务端返回的结果，用了 <code>React.hydrate</code> 完成了浏览器端的逻辑处理部分</p><h3 id="假设一-client端渲染仍然使用render"><a href="#假设一-client端渲染仍然使用render" class="headerlink" title="假设一 client端渲染仍然使用render()"></a>假设一 client 端渲染仍然使用 render ()</h3><p><strong>测试</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import React from "react";</span><br><span class="line">import {render } from "react-dom";</span><br><span class="line">import App from "../shared/App";</span><br><span class="line"></span><br><span class="line">render(&lt;App /&gt;, document.getElementById("root"));</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>结果</strong><br>由于实现了向下兼容，所以是可以的，但是会给如下警告⚠️<br><img src="/images/ssr/hydrate_to_render.png" alt="hydrate_to_rende"></p><p><strong>结论</strong> 尽量使用新特性</p><hr><h3 id="假设二-完全依赖服务端渲染会发生什么"><a href="#假设二-完全依赖服务端渲染会发生什么" class="headerlink" title="假设二 完全依赖服务端渲染会发生什么"></a>假设二 完全依赖服务端渲染会发生什么</h3><p><strong>测试</strong><br>将 <code>browser/index.js</code> 代码注释掉<br><strong>结果</strong><br>页面正常显示，但是点击按钮没有不会弹窗<br><strong>结论</strong> 需要双端一起完成页面的展示与交互</p><hr><h3 id="假设三-使用React-16-renderToNodeStream渲染"><a href="#假设三-使用React-16-renderToNodeStream渲染" class="headerlink" title="假设三 使用React 16 renderToNodeStream渲染"></a>假设三 使用 React 16 renderToNodeStream 渲染</h3><p><strong>测试 更改 server/index.js</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import express from "express";</span><br><span class="line">import React from "react";</span><br><span class="line">import { renderToNodeStream } from "react-dom/server";</span><br><span class="line">import App from "../shared/App";</span><br><span class="line"></span><br><span class="line">const app = express();</span><br><span class="line"></span><br><span class="line">app.use(express.static("public"));</span><br><span class="line"></span><br><span class="line">app.get("*", (req, res) =&gt; {</span><br><span class="line">  res.write(`</span><br><span class="line">      &lt;!DOCTYPE html&gt;</span><br><span class="line">      &lt;head&gt;</span><br><span class="line">        &lt;meta http-equiv="content-type" content="text/html; charset=utf-8"&gt;</span><br><span class="line">        &lt;title&gt;Universal Reacl&lt;/title&gt;</span><br><span class="line">        &lt;link rel="stylesheet" href="/css/main.css"&gt;</span><br><span class="line">        &lt;script src="/bundle.js" defer&gt;&lt;/script&gt;</span><br><span class="line">      &lt;/head&gt;`</span><br><span class="line">  );</span><br><span class="line">  res.write("&lt;div id='root'&gt;"); </span><br><span class="line">  const stream = renderToNodeStream(&lt;App/&gt;);</span><br><span class="line">  stream.pipe(res, { end: false });</span><br><span class="line">  stream.on('end', () =&gt; {</span><br><span class="line">    res.write("&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;");</span><br><span class="line">    res.end();</span><br><span class="line">  });</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p><strong>说明：</strong> 为了配合返回一个流，使用 <code>res.write</code> 方法代替先前的 <code>res.end</code></p><p><strong>好处</strong><br>使用 <code>renderToString </code>页面 TTFB 时间</p><p><img src="/images/ssr/TTFB2.png" alt="TTFB2"><br>使用 <code>renderToNodeStream </code>页面 TTFB 时间</p><p><img src="/images/ssr/TTFB1.png" alt="TTFB1"></p><p><strong>结论</strong><br>采用渐进式流渲染可以最大限度的缩短服务器响应水间，从而使浏览器可以更快的接收到信息</p><hr><h3 id="假设三-同构应用与浏览器渲染优势对比"><a href="#假设三-同构应用与浏览器渲染优势对比" class="headerlink" title="假设三 同构应用与浏览器渲染优势对比"></a>假设三 同构应用与浏览器渲染优势对比</h3><p>浏览器渲染：<br><img src="/images/ssr/client_render.png" alt="client_rende"></p><p>同构应用：<br><img src="/images/ssr/ssr.png" alt="ss"></p><hr><h3 id="假设三-react16比react15渲染更加高效"><a href="#假设三-react16比react15渲染更加高效" class="headerlink" title="假设三 react16比react15渲染更加高效"></a>假设三 react16 比 react15 渲染更加高效</h3><p>React 15<br><img src="/images/ssr/react15_render.png" alt="react15_rende"><br>React 16<br><img src="/images/ssr/react16.png" alt="react16"></p><h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><ol><li>鉴于 <code>renderToNodeStream()/renderToStaticNodeStream()</code> 与<br><code>renderToString()/renderToStaticMarkup()</code><br>React 16 之后都不存在 <code>data-react-*</code> 了 双方还有什么区别？</li><li>react 16 之后 如何做双端对比？ 官方说是根据 <code>ReactDom.hydrate()</code> 与 <code>renderToString()</code> 结合判断.. 一脸懵逼</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;纸上得来终觉浅，我们来实现一个简易的服务端渲染流程，意在体会 SSR 带来的红利&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>前后端分离的演进</title>
    <link href="http://maying.ink/2019/03/05/FrontBackSeparation/"/>
    <id>http://maying.ink/2019/03/05/FrontBackSeparation/</id>
    <published>2019-03-04T16:08:59.000Z</published>
    <updated>2020-10-22T18:41:42.179Z</updated>
    
    <content type="html"><![CDATA[<p>有幸参与了所在项目的架构升级，初次接触到了 <code>SSR</code> 的概念，就越发感兴趣 我们站在巨人的肩膀上一边享受社区红利，一边躁动不安</p><p><strong>鲁迅先生说过</strong></p><blockquote><p>技术上的问题总有技术去解决<br>没错 比如我现在就学会问 <code>为什么</code><br>为什么会如此发展？为什么会有这个概念？它能解决什么问题？它从哪里来.. 又要到哪里去..emm..</p></blockquote><hr><p>事实上，任何一项技术的发展 都是由<strong>问题</strong>推动的，所以 <code>trouble is friends</code>！</p><p>工作时间不短不长，刚好经历了几个阶段.</p><a id="more"></a><h3 id="第一阶段（静态页面万岁）"><a href="#第一阶段（静态页面万岁）" class="headerlink" title="第一阶段（静态页面万岁）"></a>第一阶段（静态页面万岁）</h3><p>两年前入职的时候，就用的如此神奇的技术，当时 <code>react、vue</code> 等已经热火朝天了，我表示很惊讶，因为刚毕业就加入 <code>react</code> 大军了，当时还用的是蚂蚁金服还在 <code>degugger</code> 阶段的 <code>dva</code>, 对于当时的我来讲，这种歌神奇的技术第一次真正接触，写好页面，就扔给后端小哥哥了，还真的不习惯，比较闹心的一点是 没有 bug 还好，一旦需要调试，会跟后端小哥哥一起看，是真的浪费时间，重点是效率也贼低.</p><p>其实现在看来 ，这大概是最初的前后端分离<br>前端负责静态页面和交互，后端可能就要负责数据处理并返回完整的页面<br>一旦涉及到诸如 JSP、PHP smarty 模版的编写，就容易职责不清了.. 以至于互相甩锅！</p><p><strong>缺点明显：</strong></p><ol><li>前后端分工不明，难以实现效率最大化</li><li>前端会极度依赖后端环境，数据格式的沟通成本过高</li><li>不利于前端技术的发展</li></ol><h3 id="第二阶段（AJAX时代）"><a href="#第二阶段（AJAX时代）" class="headerlink" title="第二阶段（AJAX时代）"></a>第二阶段（AJAX 时代）</h3><p>随着前端技术的发展，尤其是 AJAX 和 Node.js 的出现，一种前后端分离的架构模式应运而生，极大的缓解了前后端 RD 会互相撕逼的 bug，前后端分工变得清晰，以 AJAX 接口当作桥梁，各取所需（😂）</p><p>emm.. 徒手画的还不是特别准确的图来意会一下用户请求页面的过程<br><img src="/images/cache/ssr1.jpeg" alt="cache_detai"></p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>分工明确，前后端各司其职，后端专注业务逻辑和功能的实现，前端专注页面设计。</li><li>接口明确，并行开发，在后端接口没有实现好之前，前端完全可以自己通过 Node.js 的的 Web 框架模拟接口<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4></li><li>数据请求，处理扽好复杂逻辑被移植到浏览器端，js 脚本越来越复杂</li><li>不利于 <strong>SEO</strong>（后面会解释）存在性能问题</li><li>这种模式下，用户必须等待 js 脚本加载完成，真正执行时发数据请求，等数据返回，脚本完成页面的渲染，才能看到页面，导致<strong>首屏展现时间拉长，特别是在移动互联网下，对首屏加载性能的影响很大</strong></li></ol><h3 id="第三阶段（SPA）"><a href="#第三阶段（SPA）" class="headerlink" title="第三阶段（SPA）"></a>第三阶段（SPA）</h3><p><strong>SPA</strong>（single page application）：是一种 网络应用程序 (WebApp) 模型<br>在传统的网站中，不同的页面之间的切换都是直接从服务器加载一整个新的页面，而 SPA 是通过动态重写页面的部分与用户交互，从而避免了过多的数据交换，响应速度更快</p><h4 id="目前常见的SPA框架"><a href="#目前常见的SPA框架" class="headerlink" title="目前常见的SPA框架"></a>目前常见的 SPA 框架</h4><ul><li>AngularJS</li><li>React</li><li>Vue.js</li></ul><p>任何技术架构的升级都不可能脱离时代永远存在，技术的演进一定会随着发展愈演愈烈</p><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ol><li>前后端分离的优点它都有除此之外，它页面之间的切换很快<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4></li><li>首屏打开速度很慢，因为用户首次加载需要先下载 SPA 框架及应用程序的代码，然后再渲染页面</li><li>不利于 <strong>SEO</strong></li></ol><p><strong>为什么 SPA 不利于 SEO？</strong><br>目前而言，部分搜索引擎如 Google、bing 等，它们的爬虫虽然已经支持执行 JS 甚至是通过 AJAX 获取数据了，但是对于异步数据的支持也还不足 (也可能是搜索引擎提供商觉得没必要)<br>SPA 应用中，通常通过 AJAX 获取数据，而这里就难以保证我们的页面能被搜索引擎正常收录到。并且有一些搜索引擎不支持执行 JS 和通过 AJAX 获取数据，那就更不用提 SEO 了</p><h3 id="第四阶段（服务端渲染SSR）"><a href="#第四阶段（服务端渲染SSR）" class="headerlink" title="第四阶段（服务端渲染SSR）"></a>第四阶段（服务端渲染 SSR）</h3><h4 id="什么是服务端渲染？"><a href="#什么是服务端渲染？" class="headerlink" title="什么是服务端渲染？"></a>什么是服务端渲染？</h4><p>服务端渲染会把数据请求过程放在服务端，相对于前后端分离的方式，获取数据提前，页面模版结合数据的渲染处理也会在服务端完成</p><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol><li>当浏览器初次请求页面后，用户第一次拿到的 HTML 文档已经进行了初步的内容渲染，<strong>利于 SEO 优化 也解决了首屏的性能问题</strong></li><li>总的请求数并没有变，只是把浏览器的一部分数据请求转移到了服务器上 事实上 <strong>服务端进行数据拉取的成本要小于浏览器端，传输更加高效，这也是性能提升的关键</strong></li><li>更快的响应时间，不用等待所有的 JS 都下载完成，浏览器便能显示比较完整的页面了</li><li>更好的 SEO，我们可以将 SEO 的关键信息直接在后台就渲染成 HTML，而保证搜索引擎的爬虫都能爬取到关键数据<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4></li><li>相对于仅仅需要提供静态文件的服务器，SSR 中使用的渲染程序自然会占用更多的 CPU 和内存资源</li><li>一些常用的浏览器 API 可能无法正常使用，比如 window、docment 和 alert 等，如果使用的话需要对运行的环境加以判断</li><li>服务器端渲染的结果与浏览器端的结果不一致</li></ol><p>技术的历史总是惊人的相似，这里的服务端渲染和开始的 <code>smarty</code> 等模版渲染并没有本质上的区别，当然了这并不是倒退，实际开发项目中，依赖 react 实现的服务端渲染并不是简单的渲染内容，也可以实现前后端代码复用 -&gt; <font color="red">同构</font></p><h3 id="第五阶段（SPA-SSR-同构）"><a href="#第五阶段（SPA-SSR-同构）" class="headerlink" title="第五阶段（SPA+ SSR 同构）"></a>第五阶段（SPA+ SSR 同构）</h3><h4 id="何为同构？"><a href="#何为同构？" class="headerlink" title="何为同构？"></a>何为同构？</h4><p>服务端渲染出最核心，最基本的信息，浏览器端针对交互完成进一步的渲染，事件绑定等增强功能</p><p><strong>但是 两端渲染必定有很对冗余代码逻辑（都有 fetch 数据的过程）</strong></p><p>同构：就是前后端共用一套代码逻辑，它就像是服务端与客户端渲染的交集，弥补了服务端和浏览器端的差异</p><p>好像很高级的样子</p><p>但是优劣也比较明显</p><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ol><li>更好的性能 渲染更加迅速 首屏展现的时间更快</li><li> SEO 优化支持，服务端收到请去后 会返回一个相对完整，包含 html 的文档，所以更有利于搜索引擎爬虫获取信息，同时，更快的加载时间也有利于搜索结果展现排名的提升</li><li>实现灵活，服务端渲染做客户端渲染的后续的工作，实现代码复用</li><li>可维护性更强（同一套代码逻辑维护成本低）</li><li>对于低端机型友好，因为页面内容是在服务端渲染的 不至于出现白屏</li><li>弱网有好 不会再等 js 执行完毕再去呈现页面</li><li>更好的用户体验 可以将最重要的先渲染次重要的后渲染</li></ol><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ol><li>服务端逻辑增多</li><li>服务端无法完全复用浏览器端代码</li><li>增加了服务器的 TTFB（time to frist byte）时间</li></ol><hr><p>总结</p><p>合理利用 SSR 结合 SPA 实现同构应用 是我们日后重心<br>下一篇将动手写个同构的 demo</p><p>就这样。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有幸参与了所在项目的架构升级，初次接触到了 &lt;code&gt;SSR&lt;/code&gt; 的概念，就越发感兴趣 我们站在巨人的肩膀上一边享受社区红利，一边躁动不安&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;鲁迅先生说过&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;技术上的问题总有技术去解决&lt;br&gt;没错 比如我现在就学会问 &lt;code&gt;为什么&lt;/code&gt;&lt;br&gt;为什么会如此发展？为什么会有这个概念？它能解决什么问题？它从哪里来.. 又要到哪里去..emm..&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;事实上，任何一项技术的发展 都是由&lt;strong&gt;问题&lt;/strong&gt;推动的，所以 &lt;code&gt;trouble is friends&lt;/code&gt;！&lt;/p&gt;
&lt;p&gt;工作时间不短不长，刚好经历了几个阶段.&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="http://maying.ink/categories/web/"/>
    
    
  </entry>
  
</feed>
