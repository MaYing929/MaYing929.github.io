{"meta":{"title":"亦舒的海角","subtitle":null,"description":"知识带来自由，我等风也等你 🍂","author":"亦舒","url":"http://maying.ink","root":"/"},"pages":[{"title":"categories","date":"2017-08-01T10:02:52.000Z","updated":"2020-10-22T18:41:42.193Z","comments":true,"path":"categories/index-1.html","permalink":"http://maying.ink/categories/index-1.html","excerpt":"","text":""},{"title":"categories","date":"2017-07-14T06:24:48.000Z","updated":"2020-10-22T18:41:42.194Z","comments":true,"path":"categories/index.html","permalink":"http://maying.ink/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-07-14T06:23:09.000Z","updated":"2020-10-22T18:41:42.589Z","comments":true,"path":"tags/index.html","permalink":"http://maying.ink/tags/index.html","excerpt":"","text":""},{"title":"关于我","date":"2017-08-01T09:17:36.000Z","updated":"2020-10-22T18:41:42.193Z","comments":true,"path":"about/index.html","permalink":"http://maying.ink/about/index.html","excerpt":"","text":"热爱生活 热爱前端 Email: maxiaoying929@gmail.com"}],"posts":[{"title":"Node.js 实战 - 技术预研","slug":"node","date":"2020-03-22T16:25:24.000Z","updated":"2020-10-22T18:41:42.183Z","comments":true,"path":"2020/03/23/node/","link":"","permalink":"http://maying.ink/2020/03/23/node/","excerpt":"前言以一种要开发 Node.js 实战项目为最终目标进行一系列的技术预研过程 有特点，有针对性，有目标 培养 Node 领域的全局观 1 关于 Nodejs1.1 什么是 Node.js官网的话： Node.js 是基于 ChromeV8 执行引擎的 JS 运行时环境 Node.js 使用了一个事件驱动，非阻塞式 I/O 的模型，使其轻量又高效 每一个字其实都看得懂，聚合到一起就有点懵了 我们先不来说 nodejs 是什么，先根据以往的经验抛出问题 1.1.1 在 Node.js 里运行 Js 跟在 Chrome 运行 Js 有啥不同？已知 Chrome 浏览器用的是同样的 Javascript 引擎和模型 其实，在 Node.js 里写 Js 和在 Chrome 里写 Js，几乎一样 晃眼的几乎一样 那就是有不一样的地方呗！ Nodejs 没有浏览器 API，即 (Document,window 等) 相应的，也增加了它专属的 API，比如文件系统，进程. 有了这些差别，其实就不难理解了 对于开发者来说 你在 chrome 里写 js 控制浏览器 Node.js 让你用类似的方式，控制整个计算机 Node.js 的真谛，也就是官方抽象的释义，我们完全可以在不断深入的过程中慢慢理解～","text":"前言以一种要开发 Node.js 实战项目为最终目标进行一系列的技术预研过程 有特点，有针对性，有目标 培养 Node 领域的全局观 1 关于 Nodejs1.1 什么是 Node.js官网的话： Node.js 是基于 ChromeV8 执行引擎的 JS 运行时环境 Node.js 使用了一个事件驱动，非阻塞式 I/O 的模型，使其轻量又高效 每一个字其实都看得懂，聚合到一起就有点懵了 我们先不来说 nodejs 是什么，先根据以往的经验抛出问题 1.1.1 在 Node.js 里运行 Js 跟在 Chrome 运行 Js 有啥不同？已知 Chrome 浏览器用的是同样的 Javascript 引擎和模型 其实，在 Node.js 里写 Js 和在 Chrome 里写 Js，几乎一样 晃眼的几乎一样 那就是有不一样的地方呗！ Nodejs 没有浏览器 API，即 (Document,window 等) 相应的，也增加了它专属的 API，比如文件系统，进程. 有了这些差别，其实就不难理解了 对于开发者来说 你在 chrome 里写 js 控制浏览器 Node.js 让你用类似的方式，控制整个计算机 Node.js 的真谛，也就是官方抽象的释义，我们完全可以在不断深入的过程中慢慢理解～ 1.2 Node.js 可以用来做什么？1.2.1 提供 Web 服务 搜索引擎优化 + 首屏速度优化 = 服务端渲染 服务端渲染 + 前后端同构 = Node.js 1.2.2 构建工作流在 gulp webpack 之间，前端是如何做构建工具呢？ 可能用 java,ruby 等 但 构建工具不会永远不出问题 构建工具不会永远满足需求 前端同学很难对这些工具进行修改或者升级 所以 用 Node.js 做 js 的构建工具，是最保险的选择 1.2.3 开发工具VScode 在 nodejs 的基础上封装了 chrome 的内核，使 nodejs 具有控制计算机得到能力 1.2.3 可扩展性较强大的沙盒游戏需要给使用者自定义模块的能力 使用 Nodejs 做复杂的本地应用 可以利用 js 大的灵活性实现外部扩展 Js 庞大的的开发者基数让他们的灵活性得到利用 1.2.4 客户端应用在已有网站的基础上需要开发新的客户端应用使用 Node.js 客户端技术实现，可以最大限度的复用现有工程 2 Node.js 初探2.1 实现剪刀石头布 node 运行方式游戏 全局变量 12345678910111213141516171819202122232425var playerAction = process.argv[process.argv.length - 1];console.log(\"playerAction\", playerAction);var random1 = Math.random() * 3;if (random1 &lt; 1) { var computerAction = \"rock\";} else if (random1 &gt; 2) { var computerAction = \"scissor\";} else { var computerAction = \"paper\";}if (computerAction === playerAction) { console.log(\"平局\");} else if ( (computerAction === \"rock\" &amp;&amp; playerAction === \"paper\") || (computerAction === \"scissor\" &amp;&amp; playerAction === \"rock\") || (computerAction === \"paper\" &amp;&amp; playerAction === \"scissor\")) { console.log(\"你赢了！\");} else { console.log(\"你输了！\");} 2.1 使用 Node.js 模块规范改造游戏2.1.1 如何加载 js浏览器端 使用 &lt;script/&gt; 标签 脚本变多时，需要手动管理加载顺序 不同脚本之间的逻辑调用需要全局变量 Node 端 没有 html 文件，无法使用 &lt;script/&gt; 标签 所以 Node.js 要重新去搞一个模块管理机制来管理 js 的加载，就是现在我们熟悉的 CommonJS 规范 2.1.2 重构剪刀石头布游戏games.js 12345678910111213141516171819202122232425262728293031323334module.exports = function(playerAction) { if ([\"rock\", \"scissor\", \"paper\"].indexOf(playerAction) == -1) { throw new Error(\"invalid playerAction\"); } // 计算电脑出的东西 var computerAction; var random = Math.random() * 3; if (random &lt; 1) { computerAction = \"rock\"; console.log(\"电脑出了石头\"); } else if (random &gt; 2) { computerAction = \"scissor\"; console.log(\"电脑出了剪刀\"); } else { computerAction = \"paper\"; console.log(\"电脑出了布\"); } if (computerAction == playerAction) { console.log(\"平局\"); return 0; } else if ( (computerAction == \"rock\" &amp;&amp; playerAction == \"scissor\") || (computerAction == \"scissor\" &amp;&amp; playerAction == \"paper\") || (computerAction == \"paper\" &amp;&amp; playerAction == \"rock\") ) { console.log(\"你输了\"); return -1; } else { console.log(\"你赢了\"); return 1; }}; index.js 1234567891011121314151617const game = require(\"./game.js\");var winCount = 0;// 获取进程的标准输入process.stdin.on(\"data\", buffer =&gt; { // 回调的是buffer，需要处理成string const action = buffer.toString().trim(); const result = game(action); if (result == 1) { winCount++; if (winCount == 3) { console.log(\"我不玩儿了！哼！\"); process.exit(); } }}); 3 Node 内置模块内置模块合集 3.1 Node.js 系统架构图 3.2 理解 Node.js 精髓 Node.js 是基于 ChromeV8 执行引擎的 JS 运行时环境 ChromeV8 执行引擎的 JS 运行时环境：架构图的左侧部分就是其体现 application 代表你写的 nodejs 的代码 通过 V8 引擎来来运行，里面会涉及到一些关于操作系统调用，这部分就由 V8 引擎帮你转发到操作系统层面 从操作系统层面得到返回结果之后再通过 V8 引擎返回到 Js 里去 从 Js 到 V8 再到操作系统的能力，大部分都是通过 Node.js 的内置模块来提供的 还有一些数据是从操作系统底层通知到我们的 Node.js 层 示例 1234// 将进程设置为长期存在并且监听用户的输入process.stdin.on('data',e=&gt;{ const playerAction = e.toString().trim();}) 此时依赖的是 Node 的内置模块 EventEmitter process 实际上是 EventEmitter 的实例，继承了 EventEmitter 使其具备了向上抛事件的能力 引出 3.3 EventEmitter3.3.1 解决了什么问题 解决两个对象之间的通信问题 函数调用 观察者模式（事件收发模式）- 抛事件 addEventListener removeEventListener 3.3.2 普通调用应用场景 老板通知秘书 说是通知，但是直接调用比较合适3.3.3 观察者模式应用场景 通知消息的人并不知道被通知者的存在（极客时间并不知道我的存在） 没有人接收事件，它还能继续下去（今天没有接收到 Geek 上新课的消息，但是它还是可以上新课） lib.js 12345678910111213const EventEmitter = require('events')class Geektime extends EventEmitter{ constructor(){ super(); setInterval(() =&gt; { this.emit('newlesson',{price:Math.random()* 100}) //触发事件 }, 3000); }}const geektime = new Geektime;module.exports = geektime index.js 1234567const geektime = require('./lib.js')geektime.addListener('newlesson',(res)=&gt;{ if(res.price &lt; 50){ console.log('buy!当前价格为---',res) }}) 4 Nodejs 非阻塞 I/O 及异步编程值得拿出来单独说，戳此一览 5 实现网页版石头剪刀布游戏技术前置 5.1 什么是 HTTP 服务一个网页请求，包含两次 HTTP 包交换 浏览器向 HTTP 服务器发送请求 HTTP 包 HTTP 服务器向浏览器返回 HTTP 包 5.2 HTTP 服务要做什么事情 解析进来的 HTTP 请求报文 返回对应的 HTTP 返回报文 5.3 实现一个简单的 HTTP 服务器123456789const http = require('http')const fs = require('fs')http.createServer((req,res)=&gt;{ res.writeHead(200); res.end('hello')}).listen(8888) 5.4 server 端加载模版1234567891011const http = require('http')const fs = require('fs')http.createServer((req,res)=&gt;{ res.writeHead(200); res.end('hello') fs.createReadStream(__dirname + '/index.html') .pipe(res)}).listen(8888) 5.5 游戏逻辑index.js 源码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869const http = require(\"http\");const fs = require(\"fs\");const url = require(\"url\");const querystring = require(\"queryString\");const game = require(\"./game.js\");let playerLastAction = null; //玩家上次出的let playerWon = 0; //玩家赢得次数let sameCount = 0; //统计相同操作统计次数http .createServer((req, res) =&gt; { // 通过内置模块url，转换发送到该http服务上的http请求包的url， // 将其分割成 协议(protocol)://域名(host):端口(port)/路径名(pathname)?请求参数(query) const parsedUrl = url.parse(req.url); if (parsedUrl.pathname == \"/game\") { const query = querystring.parse(parsedUrl.query); // 玩家出的 const playerAction = query.action; // 需求2:如果玩家赢了三次或者玩家作弊，则电脑不给他玩了 if (playerWon &gt;= 3 || sameCount == 9) { res.writeHead(500); res.end(\"我再也不和你玩了！\"); return; } // 需求1:如果玩家操作连续三次相同，视为玩家作弊 if (playerLastAction &amp; (playerLastAction == playerAction)) { sameCount++; } else { sameCount++; } playerLastAction = playerAction; if (sameCount &gt;= 3) { res.writeHead(400); res.end(\"你作弊\"); // 将sameCount设置为9 sameCount = 9; return; } // 执行游戏逻辑 var gameResult = game(playerAction); res.writeHead(200); if (gameResult == 0) { res.end(\"平局！\"); } else if (gameResult == 1) { res.end(\"你赢了！\"); // 玩家胜利次数统计+1 playerWon++; } else { res.end(\"你输了！\"); } } // 如果请求url是浏览器icon，比如 http://localhost:3000/favicon.ico的情况 // 就返回一个200就好了 if (parsedUrl.pathname == \"/favicon.ico\") { res.writeHead(200); res.end(); return; } // 如果访问的是根路径，就把游戏页面读出来返回出去 if (parsedUrl.pathname == \"/\") { fs.createReadStream(__dirname + \"/index.html\").pipe(res); } }) .listen(6001); 6 使用 express 优化石头剪刀布游戏6.1 了解 express要了解一个框架，最好的方法是 了解它的关键功能 推导出它要解决的问题是什么 核心功能 路由 request/response 简化 request:pathname、query 等 response:send ()、json ()、jsonp () 等 中间件 更好地组织流程代码 异步会打破 Express 的洋葱模型 6.2 游戏逻辑index.js 源码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798const fs = require(\"fs\");const game = require(\"./game\");const express = require(\"express\");// 玩家胜利次数，如果超过3，则后续往该服务器的请求都返回500var playerWinCount = 0;// 玩家的上一次游戏动作var lastPlayerAction = null;// 玩家连续出同一个动作的次数var sameCount = 0;const app = express();// 通过app.get设定 /favicon.ico 路径的路由// .get 代表请求 method 是 get，所以这里可以用 post、delete 等。这个能力很适合用于创建 rest 服务app.get(\"/favicon.ico\", function(request, response) { // 一句 status(200) 代替 writeHead(200); end(); response.status(200); return;});// 设定 /game 路径的路由app.get( \"/game\", function(request, response, next) { if (playerWinCount &gt;= 3 || sameCount == 9) { response.status(500); response.send(\"我不会再玩了！\"); return; } // 通过next执行后续中间件 next(); // 当后续中间件执行完之后，会执行到这个位置 if (response.playerWon) { playerWinCount++; } }, function(request, response, next) { // express自动帮我们把query处理好挂在request上 const query = request.query; const playerAction = query.action; if (!playerAction) { response.status(400); response.send(); return; } if (lastPlayerAction == playerAction) { sameCount++; if (sameCount &gt;= 3) { response.status(400); response.send(\"你作弊！我再也不玩了\"); sameCount = 9; return; } } else { sameCount = 0; } lastPlayerAction = playerAction; // 把用户操作挂在response上传递给下一个中间件 response.playerAction = playerAction; next(); }, function(req, response) { const playerAction = response.playerAction; const result = game(playerAction); // 如果这里执行setTimeout，会导致前面的洋葱模型失效 // 因为playerWon不是在中间件执行流程所属的那个事件循环里赋值的 // setTimeout(()=&gt; { response.status(200); if (result == 0) { response.send(\"平局\"); } else if (result == -1) { response.send(\"你输了\"); } else { response.send(\"你赢了\"); response.playerWon = true; } // }, 500) });app.get(\"/\", function(request, response) { // send接口会判断你传入的值的类型，文本的话则会处理为text/html // Buffer的话则会处理为下载 response.send(fs.readFileSync(__dirname + \"/index.html\", \"utf-8\"));});app.listen(6001); 7 使用 koa 优化石头剪刀布游戏7.1 了解 koa核心功能: 比 Express 更极致的 request/response 简化 ctx.status=200 ctx.body=’helloworld’ 使用 async function 实现的中间件 有 “暂停执行” 的能力 在异步的情况下也符合洋葱模型 精简内核，所有额外功能都移到中间件里实现 7.2 Express vs Koa Express 门槛更低，Koa 更强大优雅。 Express 封装更多东西，开发更快速，Koa 可定制型更高 7.3 孰 “优” 孰 “劣” 框架之间其实没有优劣之分 不同的框架有不同的适用场景 7.4 游戏逻辑index.js 源码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596const fs = require(\"fs\");const game = require(\"./game\");const koa = require(\"koa\");const mount = require(\"koa-mount\");// 玩家胜利次数，如果超过3，则后续往该服务器的请求都返回500var playerWinCount = 0;// 玩家的上一次游戏动作var lastPlayerAction = null;// 玩家连续出同一个动作的次数var sameCount = 0;const app = new koa();app.use( mount(\"/favicon.ico\", function(ctx) { // koa比express做了更极致的response处理函数 // 因为koa使用异步函数作为中间件的实现方式 // 所以koa可以在等待所有中间件执行完毕之后再统一处理返回值，因此可以用赋值运算符 ctx.status = 200; }));const gameKoa = new koa();app.use(mount(\"/game\", gameKoa));gameKoa.use(async function(ctx, next) { if (playerWinCount &gt;= 3) { ctx.status = 500; ctx.body = \"我不会再玩了！\"; return; } // 使用await 关键字等待后续中间件执行完成 await next(); // 就能获得一个准确的洋葱模型效果 if (ctx.playerWon) { playerWinCount++; }});gameKoa.use(async function(ctx, next) { const query = ctx.query; const playerAction = query.action; if (!playerAction) { ctx.status = 400; return; } if (sameCount == 9) { ctx.status = 500; ctx.body = \"我不会再玩了！\"; } if (lastPlayerAction == playerAction) { sameCount++; if (sameCount &gt;= 3) { ctx.status = 400; ctx.body = \"你作弊！我再也不玩了\"; sameCount = 9; return; } } else { sameCount = 0; } lastPlayerAction = playerAction; ctx.playerAction = playerAction; await next();});gameKoa.use(async function(ctx, next) { const playerAction = ctx.playerAction; const result = game(playerAction); // 对于一定需要在请求主流程里完成的操作，一定要使用await进行等待 // 否则koa就会在当前事件循环就把http response返回出去了 await new Promise(resolve =&gt; { setTimeout(() =&gt; { ctx.status = 200; if (result == 0) { ctx.body = \"平局\"; } else if (result == -1) { ctx.body = \"你输了\"; } else { ctx.body = \"你赢了\"; ctx.playerWon = true; } resolve(); }, 500); });});app.use( mount(\"/\", function(ctx) { ctx.body = fs.readFileSync(__dirname + \"/index.html\", \"utf-8\"); }));app.listen(6001);","categories":[],"tags":[]},{"title":"使用 Node.js 逐步建立多路复用的 RPC 通道","slug":"rpc","date":"2020-03-22T16:22:49.000Z","updated":"2020-10-22T18:41:42.185Z","comments":true,"path":"2020/03/23/rpc/","link":"","permalink":"http://maying.ink/2020/03/23/rpc/","excerpt":"前言依托 Nodejs 使用 Buffer net 等模块逐步构建满足应用场景的 RPC 通道 1. RPC 调用RPC 全称 Remote Procedure Call 翻译成中文：远程过程调用 emm.. 我只是个小前端.. 1.1 如何通俗的解释是 RPC？1.1.1 本地过程调用1我现在在家里，我需要洗衣服，就把衣服扔到洗衣机洗了 1.1.2 远程过程调用 (RPC)123我现在在逛街，我需要洗衣服，于是给在家里的男票打个哥电话，他把衣服扔到洗衣机洗了那么我就实现了RPC调用！！","text":"前言依托 Nodejs 使用 Buffer net 等模块逐步构建满足应用场景的 RPC 通道 1. RPC 调用RPC 全称 Remote Procedure Call 翻译成中文：远程过程调用 emm.. 我只是个小前端.. 1.1 如何通俗的解释是 RPC？1.1.1 本地过程调用1我现在在家里，我需要洗衣服，就把衣服扔到洗衣机洗了 1.1.2 远程过程调用 (RPC)123我现在在逛街，我需要洗衣服，于是给在家里的男票打个哥电话，他把衣服扔到洗衣机洗了那么我就实现了RPC调用！！ 1.2 从前端的角度上来理解 RPC 调用？从我们熟悉的 Ajax 入手，它与 RPC 调用类似，我们来对比一下 1.2.1 相同点1.2.1.1 都是两个计算机之间的网络通信 Ajax：客户端和服务端的通信 PRC：服务器和另外一台服务器的通信 看图说话 1.2.1.2 需要双方约定一个数据格式1.2.2 不同点1.2.2.1 不一定使用 DNS 作为寻址服务 Ajax 是发一个 HTTP 请求，使用 DNS 进行寻址服务 请求过程 RPC 通信一般是在内网进行请求，使用特有的服务（比如 id）请求过程 1.2.2.2 应用层协议一般不使用 HTTPAjax：使用 HTTP 文本协议（html,json）RPC: 服务端之间的通信，对效率要求更高所以使用一些二进制协议取代 HTTP，二进制协议性能上存在优势 更小的数据包 更快的编码速率 1.2.2.3 基于 TCP/UDP 协议 浏览器调用（Ajax）使用 TCP 是遵循 HTTP 的规范 RPC 调用使用了 TCP 多种通信方式 单工通信（独木桥） 类比独木桥，两岸同一时间内只能有一方通过 1. 半双工通信（轮番单工通信，独木桥） 1. 全双工通信 2. 使用 Buffter 编解码二进制数据包用来处理 TCP 链接中的流以及文件系统中的数据 Buffer 官方介绍 2.1 buffter 创建1234567const buffter1 = Buffer.from('yishu')const buffter2 = Buffer.alloc(20)console.log(buffter1)console.log(buffter2)&lt;Buffer 79 69 73 68 75&gt;&lt;Buffer 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00&gt; 2.2 buffter 读写二进制协议：不同字段塞在二进制流中的不同位置 基本操作 1buffter2.writeInt8(12,1) 图示编码二进制包 图解：前三位代表一个字段，中间代表一个字段，后面又代表一个字段所以，编码二进制包的时候，我们需要执行三次 write 写操作 看起来还是稍许麻烦嗷 有木有像 Json 格式化方式如此简单的编码方式 答案：有！ protocol-buffers-npm 包 使用示例 123456test.protomessage Test { required int32 id = 1; required string payload = 2;} index.js 12345678910111213141516const fs = require('fs');var protobuf = require('protocol-buffers')// pass a proto file as a buffer/string or pass a parsed protobuf-schema objectvar messages = protobuf(fs.readFileSync(__dirname + '/test.proto','utf-8'))var buf = messages.Test.encode({ id: 42, payload: 'hello world'})console.log(buf) // should print a buffer{/* &lt;Buffer 08 2a 12 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64&gt; */}console.log(messages.Test.decode(buf))// { id: 42, payload: 'hello world' } 明显发现 更直观 更好维护 更便于合作 正是所期盼的这样鸭～ 3. 建立多路复用的 RPC 通道3.1 需求 1 实现单工通信通道client.js 123456789const net = require('net');const socket = new net.Socket({});socket.connect({ host:'127.0.0.1', port:6002})socket.write('good!maying') //单工通信 server.js 12345678const net = require('net');net.createServer((socket)=&gt;{ socket.on('data',function(buffer){ console.log('buffer',buffer,buffer.toString()) })}).listen(6002) 得到结果 这里实现了 TCP 通信方式之一 单工通信 3.1 需求 2 实现半双工通信通道3.1.1 客户端和服务器有来有回 客户端请求一个正常数据 服务端返回一个相应的数据 3.1.2 重点逻辑在单工通信模式下 client 端：发请求数据，等到服务器端返回结果之后，再次请求 server 端：接收到请求后，匹配返回 3.1.3 代码client.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const net = require('net');// 创建socketconst socket = new net.Socket({});// 连接服务器socket.connect({ host: '127.0.0.1', port: 6002});const lessonids = [ \"136797\", \"136798\", \"136799\", \"136800\", \"136801\", \"136803\", \"136804\", \"136806\", \"136807\", \"136808\", \"136809\", \"141994\", \"143517\", \"143557\", \"143564\", \"143644\", \"146470\", \"146569\", \"146582\"]let id = Math.floor(Math.random() * lessonids.length);// 往服务器传数据socket.write(encode(id));socket.on('data', (buffer) =&gt; { console.log(buffer.toString()) // 接收到数据之后，按照半双工通信的逻辑，马上开始下一次请求 id = Math.floor(Math.random() * lessonids.length); socket.write(encode(id));})// 把编码请求包的逻辑封装为一个函数function encode(index) { buffer = Buffer.alloc(4); buffer.writeInt32BE( lessonids[index] ); return buffer;} server.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344const net = require('net');// 创建tcp服务器const server = net.createServer((socket) =&gt; { socket.on('data', function(buffer) { // 从传来的buffer里读出一个int32 const lessonid = buffer.readInt32BE(); // 50毫秒后回写数据 setTimeout(()=&gt; { socket.write( Buffer.from(data[lessonid]) ); }, 50) })});// 监听端口启动服务server.listen(6002);const data = { 136797: \"01 | 课程介绍\", 136798: \"02 | 内容综述\", 136799: \"03 | Node.js是什么？\", 136800: \"04 | Node.js可以用来做什么？\", 136801: \"05 | 课程实战项目介绍\", 136803: \"06 | 什么是技术预研？\", 136804: \"07 | Node.js开发环境安装\", 136806: \"08 | 第一个Node.js程序：石头剪刀布游戏\", 136807: \"09 | 模块：CommonJS规范\", 136808: \"10 | 模块：使用模块规范改造石头剪刀布游戏\", 136809: \"11 | 模块：npm\", 141994: \"12 | 模块：Node.js内置模块\", 143517: \"13 | 异步：非阻塞I/O\", 143557: \"14 | 异步：异步编程之callback\", 143564: \"15 | 异步：事件循环\", 143644: \"16 | 异步：异步编程之Promise\", 146470: \"17 | 异步：异步编程之async/await\", 146569: \"18 | HTTP：什么是HTTP服务器？\", 146582: \"19 | HTTP：简单实现一个HTTP服务器\"} 3.2 需求 1 实现全双工通信通道client 端自由发送数据包，无需等待 server 端返回 3.2.1 解决半双工通信的问题 半双工通信进行并发容易导致请求包和响应包时序错乱 看图解释一下 client 同时发送 id1，id2 的请求 server 端处理… server 返回 id2 的处理结果 server 返回 id1 的处理结果 client 端如何将两个请求和返回数据对应呢？ 如果根据返回的时间来进行匹配，就会造成错乱 如何解决？ 这正是全双工通信模式要解决的问题 将请求包和返回包都加上一个序号 就像下图这样 3.2.2 重点逻辑在半双工通信模式下 client 端：增加 seq，为数据包绑定特有的 id buffer server 端：在返回的数据包里绑定 id buffer 3.2.3 代码client.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869const net = require('net');const socket = new net.Socket({});let seq = 0;socket.connect({ host:'127.0.0.1', port:6002})const LESSON_IDS = [ \"136797\", \"136798\", \"136799\", \"136800\", \"136801\", \"136803\", \"136804\", \"136806\", \"136807\", \"136808\", \"136809\", \"141994\", \"143517\", \"143557\", \"143564\", \"143644\", \"146470\", \"146569\", \"146582\"]let index = Math.floor(Math.random() * LESSON_IDS.length);socket.on('data',(buffer)=&gt;{ const seqBuffer = buffer.slice(0,2); const titleBuffer = buffer.slice(2); console.log(seqBuffer.readInt16BE(),titleBuffer.toString()) // 请求回来之后再次发送 index = Math.floor(Math.random() * LESSON_IDS.length); socket.write(encode(index));})function encode(index){ buffer = Buffer.alloc(6); buffer.writeInt16BE(seq) buffer.writeInt32BE( LESSON_IDS[index],2 ) console.log('发包',seq,LESSON_IDS[index]) seq++; return buffer;}setInterval(() =&gt; { index = Math.floor(Math.random() * LESSON_IDS.length); socket.write(encode(index));}, 50);// for(let k = 0;k&lt; 100; k++){// index = Math.floor(Math.random() * LESSON_IDS.length);// socket.write(encode(index));// } server.js 12345678910111213141516171819202122232425262728293031323334353637383940414243const net = require('net');net.createServer((socket)=&gt;{ // socket.write socket.on('data',function(buffer){ // console.log('buffer',buffer) const seqBuffer = buffer.slice(0,2); const lessonId = buffer.readInt32BE(2); setTimeout(function(){ let buffer = Buffer.concat([ seqBuffer, Buffer.from(LESSON_DATA[lessonId]) ]) socket.write(buffer) },10+Math.random() * 1000) })}).listen(6002)// 假数据const LESSON_DATA = { 136797: \"01 | 课程介绍\", 136798: \"02 | 内容综述\", 136799: \"03 | Node.js是什么？\", 136800: \"04 | Node.js可以用来做什么？\", 136801: \"05 | 课程实战项目介绍\", 136803: \"06 | 什么是技术预研？\", 136804: \"07 | Node.js开发环境安装\", 136806: \"08 | 第一个Node.js程序：石头剪刀布游戏\", 136807: \"09 | 模块： CommonJS规范\", 136808: \"10 | 模块：使用模块规范改造石头剪刀布游戏\", 136809: \"11 | 模块：npm\", 141994: \"12 | 模块：Node.js内置模块\", 143517: \"13 | 异步：非阻塞I/O\", 143557: \"14 | 异步：异步编程之callback\", 143564: \"15 | 异步：事件循环\", 143644: \"16 | 异步：异步编程之Promise\", 146470: \"17 | 异步：异步编程之async/await\", 146569: \"18 | HTTP：什么是HTTP服务器？\", 146582: \"19 | HTTP：简单实现一个HTTP服务器\"} 得到结果 总结我们在大量前置知识的基础上，一步步推导出了全双工通道的搭建，当然了，这是不完整的，还有一些情况需要处理回顾一下全双工通道搭建过程 关键在于应用层协议需要有标记包号的字段✅ 处理以下情况，需要有标记包长的字段 出现原因：TCP 底层优化机制，把同时发的一些包拼起来 粘包❎ 不完整包❎ 错误处理 网络等 希望读完本文，你会对 RPC 通道有些粗浅的认识 未完待续..","categories":[{"name":"前端","slug":"前端","permalink":"http://maying.ink/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://maying.ink/tags/Node-js/"}]},{"title":"重构前端体系系列 - 构建前端知识架构","slug":"relearning_front-end","date":"2020-03-12T09:36:23.000Z","updated":"2020-10-22T18:51:11.112Z","comments":true,"path":"2020/03/12/relearning_front-end/","link":"","permalink":"http://maying.ink/2020/03/12/relearning_front-end/","excerpt":"重新理解前端前端工程师已经成为研发体系中重要的岗位，但与此相对是大部分前端工程师的知识其实都是来自于实践和工作中零散的学习，这个现状就引发了一系列的问题 前端的基础知识薄弱：散点自学 + 基础不牢 1基础知识的欠缺会让你束手束脚，更限制你解决问题的思路 技术上存在短板，就会导致前端开发者的上升通道不甚顺畅 1小公司的程序员，只能靠自己摸索，这样就很容易陷入重复性劳动的陷阱，最终耽误自己的职业发展 前端工程师也会面临技术发展问题带来的挑战 1前端社区高度活跃，前端标准也在快速更新，这样蓬勃发展对技术来说无疑是好事，但是副作用也显而易见，它使得前端工程师的学习压力变得很大。 大部分人学前端的方式是 “土法学前端”，他们对于知识的理解基本都停留在点上，从来没有大范围把这些点串成线，形成自己的知识体系，因此才会出现遗漏和盲点","text":"重新理解前端前端工程师已经成为研发体系中重要的岗位，但与此相对是大部分前端工程师的知识其实都是来自于实践和工作中零散的学习，这个现状就引发了一系列的问题 前端的基础知识薄弱：散点自学 + 基础不牢 1基础知识的欠缺会让你束手束脚，更限制你解决问题的思路 技术上存在短板，就会导致前端开发者的上升通道不甚顺畅 1小公司的程序员，只能靠自己摸索，这样就很容易陷入重复性劳动的陷阱，最终耽误自己的职业发展 前端工程师也会面临技术发展问题带来的挑战 1前端社区高度活跃，前端标准也在快速更新，这样蓬勃发展对技术来说无疑是好事，但是副作用也显而易见，它使得前端工程师的学习压力变得很大。 大部分人学前端的方式是 “土法学前端”，他们对于知识的理解基本都停留在点上，从来没有大范围把这些点串成线，形成自己的知识体系，因此才会出现遗漏和盲点 前端工程师的成长视角 是立足标准，系统性总结和整理前端知识，建立自己的认知和方法论 是放眼团队，从业务和工程角度思考前端团队的价值和发展需要。只有这样做，才能够持续发展，在高速发展的技术和工程浪潮中稳稳立足 以完备、体系化的方式理解和思考前端的基础知识和工程实践 事实上，前端的能力可以带来更多的业务场景，这些有待于我们去发掘建立自己的知识体系和方法论，才能够保持领先优势 明确前端的学习路线和方法学习目标 摸索出适合你自己的前端学习方法 帮助建立前端技术的知识架构 理解前端技术背后的核心思想 前端学习方法建立知识架构 学习的过程实际上就是知识架构不断进化的过程 通过知识架构的自然延伸，我们可以更轻松地记忆一些原本难以记住的点，还可以发现被忽视的知识盲点 建立知识架构同样利于面试 追本溯源 有一些知识，背后有一个很大的体系 关注技术提出来的背景，找到知识的源头 关注原始的论文或者文章，关注作者说的话 比如 关注 scheme，Java 与 JS 语言的异同 前端知识图谱JavaScript用一定的词法和语法，表达一定语义，从而操作运行时 所以分为以下三个部分 运行时 文法 语义 HTML 和 CSSHTML 的功能主要由标签来承担，所以我们首先会把标签做一些分类 文档元信息：通常是出现在 head 标签中的元素，包含了描述文档自身的一些信息； 语义相关：扩展了纯文本，表达文章结构、不同语言要素的标签； 链接：提供到文档内和文档外的链接； 替换型标签：引入声音、图片、视频等外部元素替换自身的一类标签； 表单：用于填写和提交信息的一类标签 表格：表头、表尾、单元格等表格的结构 浏览器的实现原理和 API 前端工程实践 前端知识架构 小结建立一个理解前端的全景图这样，任何时候都能够体系地思考问题，分析问题，解决问题！","categories":[{"name":"前端","slug":"前端","permalink":"http://maying.ink/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端体系","slug":"前端体系","permalink":"http://maying.ink/tags/%E5%89%8D%E7%AB%AF%E4%BD%93%E7%B3%BB/"}]},{"title":"面向未来的 API-GraphQL","slug":"GraphQL","date":"2019-12-23T08:59:30.000Z","updated":"2020-10-22T18:41:42.179Z","comments":true,"path":"2019/12/23/GraphQL/","link":"","permalink":"http://maying.ink/2019/12/23/GraphQL/","excerpt":"开篇你有没有遇到以下问题 字段冗余 若干个不得不发的 HTTP 请求 发生这些，并不是前端 er 本意，但是又要承担诸如页面渲染慢等副作用而被用户诟病究其原因，是前端在数据层面没有主动权 针对但不限于以上种种我们需要以前端的设计者和开发者的角度出发 设计新的数据查询方式 Facebook 工程师率先提出 RESTful 架构体系的替代方案 并且应用在了其应用中 Facebook 使用 graphql 重构他们的 pc 站 接下来 让我们站在巨人的肩膀上，由浅至深聊聊被称之为面向未来的 API 的 - GraphQL","text":"开篇你有没有遇到以下问题 字段冗余 若干个不得不发的 HTTP 请求 发生这些，并不是前端 er 本意，但是又要承担诸如页面渲染慢等副作用而被用户诟病究其原因，是前端在数据层面没有主动权 针对但不限于以上种种我们需要以前端的设计者和开发者的角度出发 设计新的数据查询方式 Facebook 工程师率先提出 RESTful 架构体系的替代方案 并且应用在了其应用中 Facebook 使用 graphql 重构他们的 pc 站 接下来 让我们站在巨人的肩膀上，由浅至深聊聊被称之为面向未来的 API 的 - GraphQL 明确本文的边界本文主要介绍接触 GraphQL 这段时间，觉得必须要掌握的一些核心 适合以下人群 完全没听说过 GraphQL 听说过 GraphQL 的读者，想深入了解一下 想系统地学习 GraphQL 的读者 正在调研 GraphQL 技术的读者 帮助你对 GraphQL 建立一个统观全局的认知及原理性的解读 你可能会得到以下解答 重新思考 RESTful what GraphQL RESTful &amp; GraphQL how GraphQL GraphQL 组成链路 阻碍你使用 GraphQL 的 N 个问题 现有应用的接入方式 GraphQL 不足 基于 GraphQL 的社区解决方案 小结 重新思考 RESTful 接口数膨胀，需自行组合多个接口才能获取到完整的数据结构 API 文档更新不及时，联调基本靠猜 客户端对接口数据类型校验 123- 除了服务端要校验客户端传来的参数，客户端自己也需要去校验服务端返回的参数- 比如客户端要的是数组，你有没有返回数组- 需要依赖类似出var x = data?(data.obj?data.obj.name:null):null兼容 接口字段冗余，移动 / PC 需求无法满足 1234- 冗余数据的返回浪费了流量- 服务端决定有哪些数据获取方式，客户端只能挑选使用，如果数据过于冗余也只能默默接收再对数据进行处理- 而数据不能满足需求则需要请求更多的接口 前后端字段命名规范不一致， 1依赖数据层逐量转换 维护多版本接口 12任何的变动都会被视为一种破坏性的改变，而破坏性改变就需要更新API的版本 我的诉求 可不可以客户端要什么字段，服务端就给什么字段的值？ 可不可以定义一个返回数据格式与请求的数据格式的一个强类型的约束？ 能不能客户端可以问服务端要 1、2、3 这些数据，服务端一次给我返回就行？ GraphQL 的出现就是为了解决 RESTful 的痛点 what GraphQLGraphQl 官网 GraphQL 中文网 它既是一种用于 API 的查询语言 (规范) 也是一个满足你数据查询的运行时 强类型可以在查询执行之前进行验证 用于组织应用程序中数据的创建，读取，更新和删除（是的，CRUD） 脑袋里巨大的问号❓ API 怎么就可以查询呢？ 这正是其强大之处 ask exactly what you want. 用已有的代码和技术来进行数据源管理 对 API 数据提供了一套易于理解的完整描述 非数据库查询语言，不是一门语言 / 框架 不绑定任何的数据库或者存储引擎 使得客户端能按需获取数据，无冗余 让 API 更容易随着时间推移而演进 GraphQL = Graph (图表化 / 可视化)+ QL (查询语言) 是一种描述客户端如何向服务端请求数据的 API 语法 RESTful &amp; GraphQL资源获取 RESTful 用不同 URL 来区分资源，GraphQL 用特有的类型区分资源 获取相同资源 REST API 需要聚合多个接口 获取相同资源 GraphQL 只需一次请求获取多组数据 GraphQL 更有效率更强大更灵活，对前端更友好 数据获取 获取数据的方式由 == 这里有什么 == 向 == 你需要什么 == 转变 GraphQL 可以简化理解成一个灵活的 ajax 接口 客户端完全自主决定获取信息的内容，服务端负责精确的返回目标数据 GraphQL 优点 请求你所要的数据，不多不少 12- 向你的 API 发出一个 GraphQL 请求就能准确获得你想要的数据，不多不少。- GraphQL 查询总是返回可预测的结果。使用 GraphQL 的应用可以工作得又快又稳，因为控制数据的是应用，而不是服务器。 获取多个资源，只需要一个请求 1234- GraphQL 查询不仅能够获得资源的属性，还能沿着资源间引用进一步查询- 典型的 REST API 请求多个资源时得载入多个 URL- GraphQL 可以通过一次请求就获取你应用所需的所有数据- 即使是比较慢的移动网络连接下，使用 GraphQL 的应用也能表现得足够迅速。 描述所有可能的类型系统（强类型自身） 强类型可以在查询执行之前进行验证 12345- GraphQL API 基于类型和字段的方式进行组织，而非入口端点- 你可以通过一个单一入口端点得到你所有的数据能力- GraphQL 使用类型来保证应用只请求可能的数据- 还提供了清晰的辅助性错误信息- 应用可以使用类型，而避免编写手动解析代码。 强大的开发者工具 1234- 代码即文档- 不用离开编辑器就能准确知道你可以从 API 中请求的数据- 发送查询之前就能高亮潜在问题，高亮代码智能提示- 提供了GraphiQL图形界面编写可测试的查询语句 无版本约束 平滑演进（GraphQL 的设计精髓） 由于仅返回明确的请求数据，所以设计良好的「GraphQL API」不存在「接口突变」的情况，这是从「版本化」到「无版本」的一个明确转变！ 1234- 给你的 GraphQL API 添加字段和类型而无需影响现有查询- 老旧的字段可以废弃，从工具中隐藏- 通过使用单一演进版本，GraphQL API 使得应用始终能够使用新的特性，并鼓励使用更加简洁、更好维护的服务端代码 GraphQL 改善 RESTful了解了 GraphQL 的一大堆特点，我们开篇的诉求解决了吗？ 到这里 我们看到了 GraphQL 原则上的可行性 How GraphQL接下来 趁热打铁 来聊聊怎么用 GraphQL 官网上特别醒目的一张图，我们可以得到如下信息 服务端定义好强类型的数据入参和返回的数据结构 客户端发送一个带有查询语句（GraphQL 查询协议）的请求，定义好返回数据的格式及类型 返回符合客户端预期的 Json 字符串结果 再通俗一点 我们拥有 UI，并且需要用数据填充它，因此我们向服务器进行查询使用传统的 REST API，我们的查询将以 GET 请求的形式出现 借助 GraphQL，我们引入了一种用于请求数据的新语法 一个基础的 GraphQL 服务GraphQL 服务 = 类型（schema） + 解析器 （resolve）明确以下知识点 为了发出 GraphQL 请求，我们需要有一个 GraphQL 服务器 GraphQL 服务器是附加了 GraphQL 模式的常规 HTTP 服务器 类型系统描述了数据的类型与结构，但它只是形状，不包含真正的数据 通过编写 Resolver 函数，从而去获取真正的数据 服务端（或中间层）需要描述所有可能的类型系统（schema） 按你所需请求你所需要的数据，解决了不同客户端不同的渲染需求 是不是贼简单～ 不知道你没有注意到 上面我们提到了 GraphQL 查询协议 GraphQL 查询协议GraphQL 有三种请求方式 query (请求) mutation (修改) subscribe (订阅) GraphQL 的核心依赖于简单的 GET 或 POST 请求来将数据往返于客户端，而 GraphQL 只是一个经过修饰的 GET 或 POST 请求，通过 https://myapp.com/graphql之类的 URL 发送到 GraphQL 服务器 是的，虽然 GraphQL 确实引入了一些新的概念来组织数据进行交互，但在幕后，但 GraphQL 仍然依靠良好的 HTTP 请求来实现其神奇效果 只需要为类型系统的字段编写函数，GraphQL 就能通过优化并发的方式来调用它们 具体参照如上的 demo，建议拷贝代码亲自感受一下 GraphQL 组成链路当然了 对于开发者来说，我们无非关注两点 客户端做什么？ 1向服务端发送查询字符串 服务端做什么？ 123基于GraphQL构建类型系统 定义与Query下字段对应的resolver可以在resolver获取真正的数据 资源路径图 客户端 Schema 本质上就是一段字符串，服务端如何识别并响应这段字符串？ 服务端执行过程 拿到客户端字符串之后，依赖官方类库 graphql-js, 服务端具体执行经历三个阶段 解析：逐字符扫描，如果不符合服务端定义的 AST 规范，解析过程会直接跑出语法异常，当然了，是结构化报错 校验：发起了查询，GraphQL 会解析我们的查询语句，确保啊我们查询的结构是存在的，参数是足够的，类型是一致的，任何环节出了问题，都将返回错误信息 执行：验证通过后，GraphqL 会根据 query 语句包含的字段结构一一触发对应的 Resolver 函数，获取查询结果，也就是说 如果前端没有查询某个字段，就不会触发该字段对应的 Resolver 函数，也就不会产生对数据的获取行为 注：如果 Reaolver 返回的数据结构，大于 Schema 里描绘的结构，那么多出来的部分会被忽略，这是一个合理的设计，我们可以通过控制 Schema 来控制前端的数据访问权限，防止意外的将用户的隐私信息泄漏出去 阻碍你使用 GraphQL 的 N 个问题既然 GraphQL 那么方便，为啥没有大火呢？结合了多篇文章，整理了若干了阻止你使用 GraphQL 的 N 个问题 一起来看一看 GraphQL 一定要操作数据库？ 数据提供方编写 GraphQL Schema 数据消费方编写 GraphQL Query GraphQL 只是关于 schema 和 resolver 的一一对应和调用，它并为对数据的获取方式和来源做任何假设 GraphQL 跟 RESTful api 是对立的？两者不仅不是对立的，还可以相互结合事实上可以把 Query 下的字段，理解为一个个 RESTful API 1234type Query { hello: String, sayhi:String } GraphQL 不一定需要 Schema（类型系统）？ GraphQL Type System 是一个静态的类型系统，我们可以称之为静态类型 GraphQL 此外，社区还有一种动态类型的 GraphQL 实践，它跟静态类型的 GraphQL 差别在于，没有了基于 Schema 的数据形状验证阶段，而是直接无脑地根据 query 查询语句里的字段，去触发 Resolver 函数，动态类型的 GraphQL 有一定的便利性，不过，它同时丧失了 GraphQL 的部分精髓 GraphQL 一定是后端服务？尽管绝大多数 GraphQL，都以 server 的形式存在。&nbsp;但它并没有限制在后端场景 在浏览器中运行 现有应用的接入方式暴力改造 RESTful-Like 模式RESTful -&gt; GraphQL 就是简单粗暴的把 RESTful API 服务，替换成 GraphQL 实现。之前有多少 RESTful 服务，重构后就有多少 GraphQL 服务， 默认情况下，面向两个 GraphQL 服务发起的查询是两次请求，而不是一次 1前端需要产品数据时，从之前调用产品相关的 RESTful API，变成查询产品相关的 GraphQL。不过，需要订单相关的数据时，可能要查询另一个 GraphQL 服务 它是一个简单的一对一关系 收益甚微 选型失误 作为中间层同样是 API Gateway 角色的 GraphQL 服务，在实现方式上有不同的分类 1，传统意义上的后端服务（包含大量真实的数据操作和处理的 GraphQL） 2，GraphQL as BFF（转发接口请求，聚合数据结果的 GraphQL） 我们今天主要讨论 第二种 前端不再直接调用具体的 RESTful 等接口，而是通过 GraphQL 去间接获取产品、订单、搜索等数据 在 GraphQL 这个中间层里，我们将各个微服务，按照它们的数据关联，整合成一个基于 GraphQL Schema 的数据关系网络。前端可以通过 GraphQL 查询语句，同时发起对多个微服务的数据的获取、筛选、裁剪等行为。 作为 API Gateway 的 GraphQL 服务，可以在其 Resolver 内，向前面提到的 RESTful-like 的 GraphQL 发起查询请求 既避免了前端需要一对多的问题，也解决了 API Gateway GraphQL 需要请求 RESTful 全量数据接口的内部冗余问题 将 GraphQL schemas 转化为 Thhrift IDL，再统一操作底层数据 GraphQL 不足 改造成本：后端服务需要按领域进行重构 存量大：迁移困难 数据库性能 1234- GraphQL 虽然解决将多个 HTTP 请求聚合成了一个请求，但是schema 会逐层解析方式递归获取全部数据- 前端请求少了但是query很多 数据库设计影响日后性能- 后端对前端改造无感知：前端修改了GraphQL的请求格式，可能会造成深层嵌套，对后端服务有较大影响 侵入性：前端利好，却需要服务端鼎力支持 复杂性：学习成本高 1需要了解GraphQL一整套类型系统 典型的 N+1 问题 123使用REST API 是很容易评估 ，识别和解决N+1问题的使用GraphQL会使这个问题变得相对复杂 数据缓存问题 12REST强制使用具有缓存机制的HTTP协议 ，可以通过它 避免活回去多余资源GraphQL没有缓存机制，它把缓存的重任交给了用户 可见，整体来看，实际接入 GraphQL 并非易事，它只是一套规范，各种语言实现不一致，周边生态不够完善，需要后端配合改造，成本大， 除此之外，还有各种错误处理，日志上报及缓存机制的处理办法良莠不齐 正因如此，GraphQL 很长一段时间还不能发挥其巨大作用 这一切 随着 Apollo 登场 正在逐步改善 基于 GraphQL 的社区解决方案Apollo可以把 GraphQL 理解成 NodeJS 的 http 包，那么 Apollo-server 就类似于在前面基础上封装出来的框架 Apollo-Clientweb，iOS，Android 三端的实现 Apollo-Serverkoa，express 等 NodeJsWeb 的实现 还提供了如下能力 错误处理接口格式五花八门，错误处理也没有统一的方案，Apollo 会将所有的错误内容格式化统一的错误信息，从此可以摆脱后端带来的束缚，方便我们在前端去处理。 模块化借助 GraphQL 的 makeExecutableSchema 和 mergeSchemas 方法，能够按模块去编写类型定义及 resolve，最后使用 mergeSchemas 将他们合并到一起 错误监控Apollo server 提供 formatError，formatResponse，能够细化到每一次请求，每一次错误的发生，方便我们去上报日志及错误 工作流程 接入架构设想 通过复用现有的 REST 接口，做到无需后端配合改造 在我们开发的项目里，由于会对接不同的后端团队，伴随着一些历史遗留问题，接口格式五花八门，错误处理也没有统一的方案，Apollo 会将所有的错误内容格式化统一的错误信息，从此可以摆脱后端带来的束缚，方便我们在前端去处理 在开发大型应用中，模块是是必不可少的。借助 GraphQL 的 makeExecutableSchema 和 mergeSchemas 方法，能够按模块去编写类型定义及 resolve，最后使用 mergeSchemas 将他们合并到一起 由于接入了 node server，那么我们需要监控错误以及请求日志等内容，Apollo server 提供 formatError，formatResponse，能够细化到每一次请求，每一次错误的发生，方便我们去上报日志及错误 接入成果设想 小结 更准确的获取你想要的数据 - 核心诉求 控制数据的是应用而非服务器 1在应用层对数据模型的抽象 将你需要的数据汇聚成数据网格 12前端不能通过一次查询直接得到自己所需要的数据，Graphql的查询不仅指定了要查询的信息同时给出了期望的数据结构 应对复杂场景的一种新思路 thinking in graph 1设计 GraphQL接口更像是在建立资源与资源之间的关系，并最终得到一个单一内聚图的过程 GraphQL 给了我们一种基于「图」的设计思路","categories":[{"name":"前端","slug":"前端","permalink":"http://maying.ink/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[]},{"title":"Vue 开发中小技巧","slug":"vue","date":"2019-10-24T08:07:13.000Z","updated":"2020-10-22T18:41:42.188Z","comments":true,"path":"2019/10/24/vue/","link":"","permalink":"http://maying.ink/2019/10/24/vue/","excerpt":"记录日常开发中不常用的一些小技巧 require.context()1. 场景：如页面需要导入多个组件，原始写法: 12345import titleCom from '@/components/home/titleCom'import bannerCom from '@/components/home/bannerCom'import cellCom from '@/components/home/cellCom'components:{titleCom,bannerCom,cellCom} 2. 这样就写了大量重复的代码，利用 require.context 可以写成 12345678const path = require('path')const files = require.context('@/components/home', false, /\\.vue$/)const modules = {}files.keys().forEach(key =&gt; { const name = path.basename(key, '.vue') modules[name] = files(key).default || files(key)})components:modules API 方法 1234567实际上是 webpack 的方法,vue 工程一般基于 webpack,所以可以使用require.context(directory,useSubdirectories,regExp)接收三个参数:directory：说明需要检索的目录useSubdirectories：是否检索子目录regExp: 匹配文件的正则表达式,一般是文件名","text":"记录日常开发中不常用的一些小技巧 require.context()1. 场景：如页面需要导入多个组件，原始写法: 12345import titleCom from '@/components/home/titleCom'import bannerCom from '@/components/home/bannerCom'import cellCom from '@/components/home/cellCom'components:{titleCom,bannerCom,cellCom} 2. 这样就写了大量重复的代码，利用 require.context 可以写成 12345678const path = require('path')const files = require.context('@/components/home', false, /\\.vue$/)const modules = {}files.keys().forEach(key =&gt; { const name = path.basename(key, '.vue') modules[name] = files(key).default || files(key)})components:modules API 方法 1234567实际上是 webpack 的方法,vue 工程一般基于 webpack,所以可以使用require.context(directory,useSubdirectories,regExp)接收三个参数:directory：说明需要检索的目录useSubdirectories：是否检索子目录regExp: 匹配文件的正则表达式,一般是文件名 watch 用法常用用法12345678created(){ this.getList()},watch: { inpVal(){ this.getList() }} 立即执行可以直接利用 watch 的 immediate 和 handler 属性简写 123456watch: { inpVal:{ handler: 'getList', immediate: true }} 深度监听watch 的 deep 属性，深度监听，也就是监听复杂数据类型 12345678910watch:{ inpValObj:{ handler(newVal,oldVal){ console.log(newVal) console.log(oldVal) }, deep:true }} 组件通信props123456789101112131415161718// 数组:不建议使用props:[]// 对象props:{ inpVal:{ type:Number, //传入值限定类型 // type 值可为String,Number,Boolean,Array,Object,Date,Function,Symbol // type 还可以是一个自定义的构造函数，并且通过 instanceof 来进行检查确认 required: true, //是否必传 default:200, //默认值,对象或数组默认值必须从一个工厂函数获取如 default:()=&gt;[] validator:(value) { // 这个值必须匹配下列字符串中的一个 return ['success', 'warning', 'danger'].indexOf(value) !== -1 } }} Attr 和 listenersattrs场景：如果父传子有很多值，那么在子组件需要定义多个 props attrs 获取未在 props 定义的值 1234567// 父组件&lt;home title=\"这是标题\" width=\"80\" height=\"80\" imgUrl=\"imgUrl\"/&gt;// 子组件mounted() { console.log(this.$attrs) //{title: \"这是标题\", width: \"80\", height: \"80\", imgUrl: \"imgUrl\"}} 相对应的如果子组件定义了 props, 打印的值就是剔除定义的属性 12345678910props: { width: { type: String, default: '' }},mounted() { console.log(this.$attrs) //{title: \"这是标题\", height: \"80\", imgUrl: \"imgUrl\"}}, listeners 场景子组件内需要调用父组件的方法解决：父组件的方法可以通过 v-on=”listeners” 传入内部组件 1234567// 父组件&lt;home @change=\"change\"/&gt;// 子组件mounted() { console.log(this.$listeners) //即可拿到 change 事件} $root1234567// 父组件mounted(){ console.log(this.$root) //获取根实例,最后所有组件都是挂载到根实例上 console.log(this.$root.$children[0]) //获取根实例的一级子组件 console.log(this.$root.$children[0].$children[0]) //获取根实例的二级子组件} .sync在 vue@1.x 的时候曾作为双向绑定功能存在，即子组件可以修改父组件中的值；在 vue@2.0 的由于违背单项数据流的设计被干掉了；在 vue@2.3.0+ 以上版本又重新引入了这个 .sync 修饰符； 12345678910// 父组件&lt;home :title.sync=\"title\" /&gt;//编译时会被扩展为&lt;home :title=\"title\" @update:title=\"val =&gt; title = val\"/&gt;// 子组件// 所以子组件可以通过$emit 触发 update 方法改变mounted(){ this.$emit(\"update:title\", '这是新的title')} 路由传参方案方案一 12345678910111213// 路由定义{ path: '/describe/:id', name: 'Describe', component: Describe}// 页面传参this.$router.push({ path: `/describe/${id}`,})// 页面获取this.$route.params.id 方案二 12345678910111213141516// 路由定义{ path: '/describe', name: 'Describe', omponent: Describe}// 页面传参this.$router.push({ name: 'Describe', params: { id: id }})// 页面获取this.$route.params.id 方案三 12345678910111213141516// 路由定义{ path: '/describe', name: 'Describe', component: Describe}// 页面传参this.$router.push({ path: '/describe', query: { id: id `})// 页面获取this.$route.query.id 三种方案对比 方案二参数不会拼接在路由后面，页面刷新参数会丢失 方案一和三参数拼接在后面，丑，而且暴露了信息 render 函数场景：有些代码在 template 里面写会重复很多，所以这个时候 render 函数就有作用啦 123456789101112131415161718192021222324252627282930313233343536// 根据 props 生成标签// 初级&lt;template&gt; &lt;div&gt; &lt;div v-if=\"level === 1\"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; &lt;p v-else-if=\"level === 2\"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/p&gt; &lt;h1 v-else-if=\"level === 3\"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h1&gt; &lt;h2 v-else-if=\"level === 4\"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h2&gt; &lt;strong v-else-if=\"level === 5\"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/stong&gt; &lt;textarea v-else-if=\"level === 6\"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/textarea&gt; &lt;/div&gt;&lt;/template&gt;// 优化版,利用 render 函数减小了代码重复率&lt;template&gt; &lt;div&gt; &lt;child :level=\"level\"&gt;Hello world!&lt;/child&gt; &lt;/div&gt;&lt;/template&gt;&lt;script type='text/javascript'&gt; import Vue from 'vue' Vue.component('child', { render(h) { const tag = ['div', 'p', 'strong', 'h1', 'h2', 'textarea'][this.level-1] return h(tag, this.$slots.default) }, props: { level: { type: Number, required: true } } }) export default { name: 'hehe', data() { return { level: 3 } } }&lt;/script&gt; 2.render 和 template 的对比 前者适合复杂逻辑，后者适合逻辑简单；后者属于声明是渲染，前者属于自定 Render 函数；前者的性能较高，后者性能较低。 路由的按需加载12345678910111213141516webpack&lt; 2.4 时{ path:'/', name:'home', components:resolve=&gt;require(['@/components/home'],resolve)}webpack&gt; 2.4 时{ path:'/', name:'home', components:()=&gt;import('@/components/home')}import()方法由es6提出，import()方法是动态加载，返回一个Promise对象，then方法的参数是加载到的模块。类似于Node.js的require方法，主要import()方法是异步加载的。 动态组件12&lt;component v-bind:is=\"currentTabComponent\"&gt;&lt;/component&gt; 但是这样每次组件都会重新加载，会消耗大量性能，所以 就起到了作用 1234&lt;keep-alive&gt; &lt;component v-bind:is=\"currentTabComponent\"&gt;&lt;/component&gt;&lt;/keep-alive&gt; 这样切换效果没有动画效果，这个也不用着急，可以利用内置的 12345&lt;transition&gt;&lt;keep-alive&gt; &lt;component v-bind:is=\"currentTabComponent\"&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;/transition&gt; 函数式组件123&lt;template functional&gt; &lt;div v-for=\"(item,index) in props.arr\"&gt;{{item}}&lt;/div&gt;&lt;/template&gt; mixins场景：有些组件有些重复的 js 逻辑，如校验手机验证码，解析时间等，mixins 就可以实现这种混入 mixins 值是一个数组 1234567891011121314const mixin={ created(){ this.dealTime() }, methods:{ dealTime(){ console.log('这是mixin的dealTime里面的方法'); } }}export default{ mixins:[mixin]} Vue.nextTick2.1.0 新增 场景：页面加载时需要让文本框获取焦点 用法：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM 12345mounted(){ //因为 mounted 阶段 dom 并未渲染完毕,所以需要$nextTick this.$nextTick(() =&gt; { this.$refs.inputs.focus() //通过 $refs 获取dom 并绑定 focus 方法 })} Vue.version场景：有些开发插件需要针对不同 vue 版本做兼容，所以就会用到 Vue.version 用法：Vue.version () 可以获取 vue 版本 12345678910var version = Number(Vue.version.split('.')[0])if (version === 2) { // Vue v2.x.x} else if (version === 1) { // Vue v1.x.x} else { // Unsupported versions of Vue} Vue.config.performance监听性能 12Vue.config.performance = true Vue.config.warnHandler2.4.0 新增 1. 场景：为 Vue 的运行时警告赋予一个自定义处理函数，只会在开发者环境下生效 2. 用法: 123Vue.config.warnHandler = function (msg, vm, trace) { // `trace` 是组件的继承关系追踪} v-pre场景:vue 是响应式系统，但是有些静态的标签不需要多次编译，这样可以节省性能 12&lt;span v-pre&gt;{{ this will not be compiled }}&lt;/span&gt; 显示的是{{ this will not be compiled }}&lt;span v-pre&gt;{{msg}}&lt;/span&gt;&nbsp; &nbsp; &nbsp;即使data里面定义了msg这里仍然是显示的{{msg}} v-cloak场景：在网速慢的情况下，在使用 vue 绑定数据的时候，渲染页面时会出现变量闪烁用法：这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 [v-cloak] { display: none } 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕 123456789// template 中&lt;div class=\"#app\" v-cloak&gt; &lt;p&gt;{{value.name}}&lt;/p&gt;&lt;/div&gt;// css 中[v-cloak] { display: none;} 这样就可以解决闪烁，但是会出现白屏，这样可以结合骨架屏使用 v-once场景：有些 template 中的静态 dom 没有改变，这时就只需要渲染一次，可以降低性能开销 12&lt;span v-once&gt; 这时只需要加载一次的标签&lt;/span&gt; v-once 和 v-pre 的区别: v-once 只渲染一次；v-pre 不编译，原样输出 事件修饰符12345.stop:阻止冒泡.prevent:阻止默认行为.self:仅绑定元素自身触发.once: 2.1.4 新增,只触发一次.passive: 2.3.0 新增,滚动事件的默认行为 (即滚动行为) 将会立即触发,不能和.prevent 一起使用 Vue.$router123this.$router.push():跳转到不同的url，但这个方法回向history栈添加一个记录，点击后退会返回到上一个页面this.$router.replace():不会有记录this.$router.go(n):n可为正数可为负数。正数返回上一个页面,类似 window.history.go(n) Vue.$route12this.$route.params.id:获取通过 params 或/:id传参的参数this.$route.query.id:获取通过 query 传参的参数 调试 template场景：在 Vue 开发过程中，经常会遇到 template 模板渲染时 JavaScript 变量出错的问题，此时也许你会通过 console.log 来进行调试 这时可以在开发环境挂载一个 log 函数 12345// main.jsVue.prototype.$log = window.console.log;// 组件内部&lt;div&gt;{{$log(info)}}&lt;/div&gt; vue-loader 小技巧preserveWhitespace场景：开发 vue 代码一般会有空格，这个时候打包压缩如果不去掉空格会加大包的体积 配置 preserveWhitespace 可以减小包的体积 { vue: { preserveWhitespace: false }} transformToRequire场景：以前在写 Vue 的时候经常会写到这样的代码：把图片提前 require 传给一个变量再传给组件 1234567891011121314// page 代码&lt;template&gt; &lt;div&gt; &lt;avatar :img-src=\"imgSrc\"&gt;&lt;/avatar&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { created () { this.imgSrc = require('./assets/default-avatar.png') } }&lt;/script&gt; 现在：通过配置 transformToRequire 后，就可以直接配置，这样 vue-loader 会把对应的属性自动 require 之后传给组件 123456789101112131415161718192021222324252627282930313233343536// vue-cli 2.x在vue-loader.conf.js 默认配置是transformToRequire: { video: ['src', 'poster'], source: 'src', img: 'src', image: 'xlink:href'}// 配置文件,如果是vue-cli2.x 在vue-loader.conf.js里面修改 avatar: ['default-src']// vue-cli 3.x 在vue.config.js// vue-cli 3.x 将transformToRequire属性换为了transformAssetUrlsmodule.exports = { pages, chainWebpack: config =&gt; { config .module .rule('vue') .use('vue-loader') .loader('vue-loader') .tap(options =&gt; { options.transformAssetUrls = { avatar: 'img-src', } return options; }); }}// page 代码可以简化为&lt;template&gt; &lt;div&gt; &lt;avatar img-src=\"./assets/default-avatar.png\"&gt;&lt;/avatar&gt; &lt;/div&gt;&lt;/template&gt; 为路径设置别名1. 场景：在开发过程中，我们经常需要引入各种文件，如图片、CSS、JS 等，为了避免写很长的相对路径（../），我们可以为不同的目录配置一个别名 2.vue-cli 2.x 配置 123456789// 在 webpack.base.config.js中的 resolve 配置项，在其 alias 中增加别名resolve: { extensions: ['.js', '.vue', '.json'], alias: { 'vue$': 'vue/dist/vue.esm.js', '@': resolve('src'), } }, 3.vue-cli 3.x 配置 123456789101112// 在根目录下创建vue.config.jsvar path = require('path')function resolve (dir) { console.log(__dirname) return path.join(__dirname, dir)}module.exports = { chainWebpack: config =&gt; { config.resolve.alias .set(key, value) // key,value自行定义，比如.set('@@', resolve('src/components')) }} img 加载失败场景：有些时候后台返回图片地址不一定能打开，所以这个时候应该加一张默认图片 1234567891011121314151617// page 代码&lt;img :src=\"imgUrl\" @error=\"handleError\" alt=\"\"&gt;&lt;script&gt;export default{ data(){ return{ imgUrl:'' } }, methods:{ handleError(e){ e.target.src=reqiure('图片路径') //当然如果项目配置了transformToRequire,参考上面 27.2 } }}&lt;/script&gt; CSS局部样式1.Vue 中 style 标签的 scoped 属性表示它的样式只作用于当前模块，是样式私有化. 12345678910111213141516171819202122232425262728293031// 原始代码&lt;template&gt; &lt;div class=\"demo\"&gt; &lt;span class=\"content\"&gt; Vue.js scoped &lt;/span&gt; &lt;/div&gt;&lt;/template&gt;&lt;style lang=\"less\" scoped&gt; .demo{ font-size: 16px; .content{ color: red; } }&lt;/style&gt;// 浏览器渲染效果&lt;div data-v-fed36922&gt; Vue.js scoped&lt;/div&gt;&lt;style type=\"text/css\"&gt;.demo[data-v-039c5b43] { font-size: 14px;}.demo .content[data-v-039c5b43] { //.demo 上并没有加 data 属性 color: red;}&lt;/style&gt; deep 属性1234567891011121314151617181920// 上面样式加一个 /deep/&lt;style lang=\"less\" scoped&gt; .demo{ font-size: 14px; } .demo /deep/ .content{ color: blue; }&lt;/style&gt;// 浏览器编译后&lt;style type=\"text/css\"&gt;.demo[data-v-039c5b43] { font-size: 14px;}.demo[data-v-039c5b43] .content { color: blue;}&lt;/style&gt;","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://maying.ink/tags/Vue/"}]},{"title":"看完这篇，我奶奶都会设计组件了","slug":"part","date":"2019-07-28T17:40:30.000Z","updated":"2020-10-22T18:41:42.184Z","comments":true,"path":"2019/07/29/part/","link":"","permalink":"http://maying.ink/2019/07/29/part/","excerpt":"前言掘金链接 组件化思想并不是前端独有的，但却是前端技术的延伸 随着三大框架崛起，前端组件化逐渐成为前端开发的迫切需求，一种主流，一种共识，它不仅提高开发效率，同时也降低了维组件内聚原则护成本开发者们不需要再面对一堆晦涩难懂的代码，转而只需要关注以组件⽅式存在的代码⽚段 这是一场新的挑战！ 文章开始之前，明确本文的边界 从前端工程谈到组件化开发 组件的设计原则 组件的职能划分及利弊 组件设计的边界 落实到具体业务中如何做 一些感悟 总结 一个面试题引发的思考1面试官通常会问 写过前端通用组件吗？","text":"前言掘金链接 组件化思想并不是前端独有的，但却是前端技术的延伸 随着三大框架崛起，前端组件化逐渐成为前端开发的迫切需求，一种主流，一种共识，它不仅提高开发效率，同时也降低了维组件内聚原则护成本开发者们不需要再面对一堆晦涩难懂的代码，转而只需要关注以组件⽅式存在的代码⽚段 这是一场新的挑战！ 文章开始之前，明确本文的边界 从前端工程谈到组件化开发 组件的设计原则 组件的职能划分及利弊 组件设计的边界 落实到具体业务中如何做 一些感悟 总结 一个面试题引发的思考1面试官通常会问 写过前端通用组件吗？ 你可能会自信的表示： sure！ emm.. 是的吗？ 从前端工程谈到组件化开发前端工程经历的三个阶段 1. 库 / 框架选型确定技术选型，为项目节省许多工程量后来三大框架的横空出世，解放了不少生产力 2. 简单构建优化 解决完开发效率，还需要兼顾运行性能，故而选择某种构建工具，对代码进行压缩，校验，之后再以页面为单位进行简单的资源合并 3. JS/CSS 模块化开发 解决了基本开发效率和运行效率之后，开始考虑维护效率了 分而治之（以分解降低复杂度）是软件工程中的重要思想，是复杂系统开发和维护的基石，模块化就是前端的分治手段 因此，模块化强调的是拆分，最大的价值就是分治，意味着不管你将来是否要复用这块儿代码，都有将他们拆成一个模块的理由 将一个大问题，不断的拆解为各个小问题进行分析研究，然后再组合到一起 (分而治之原则) 模块化的方案 JS 模块化 1无模块化-&gt;函数写法-&gt;对象写法-&gt;自执行函数-&gt;CommonJS/AMD/CMD-&gt;ES6 Module CSS 模块化 1css模块化是在less，sass等预处理器的支持下实现的 做到这些就够了吗？当然是不够的 模块化强调的是拆分，无论是从业务角度还是从架构、技术角度，模块化首先意味着将代码、数据等内容按照其职责不同分离 单纯的横向拆分业务功能模块有一些问题 面向过程的代码 随着业务的发展不利于维护 12随着业务发展，”过程线“也会越来越长，其他项目成员根据各自需要，在”过程线“ 加插各自逻辑，最终这个页面的逻辑变得难以维护我们需要摆脱【一泻而下】式的代码编写 仅仅有 JS/CSS 模块化是不够的，UI（页面）的分治也比较迫切 12除了JS和CSS，界面也需要拆分，如何让模块化思想融入HTML语言 4. 组件化开发（本文重点）组件化开发的演变在大肆宣扬组件化开发概念之前，也经历了寻求组件化最佳实践的阶段 页面结构模块化简单来说就是把页面想象成乐高机器人，需要不同零件组装，然后将各个部分拼到一起 落实到实际开发中像这样 我们可以发现 页面 pageModel 包含了 tabContainer，listContainer 和 imgsContainer 三个模块 我们根据不同的业务逻辑封装了不同类型的 model 每个 model 有自己的数据，模板，逻辑，已经算是一个完整的功能单元 咦？嗅到一丝组件化的味道 N 年前微软的组件化的解决方案 HTML Component历史总有遗🐖 早在 N 年前微软提出过一套解决方案，名为 HTML Component 事实上已经是一个比较完整的组件化方案了，但最后却没能进入标准，从今天的角度看，它可以说是生不逢时 WebComponents 标准当时” 所谓的组件 “ 此时的组件基本上只能达到某个功能单元上的集合，资源都是资源都是松散地分散在三种资源文件中 而且组件作用域暴露在全局作用域下，缺乏内聚性很容易就会跟其他组件产生冲突（如最简单的 css 命名冲突） 于是 W3C 按耐不住了，制定一个 WebComponents 标准，为组件化的未来指引了明路 大致四部分功能 &lt;template&gt; 定义组件的 HTML 模板能力 Shadow Dom 封装组件的内部结构，并且保持其独立性 Custom Element 对外提供组件的标签，实现自定义标签 import 解决组件结合和依赖加载 我们思考一下，可行的实践化方案需要具备哪些能力 资源高内聚（组件资源内部高内聚，组件资源由自身加载控制） 作用域独立（内部结构密封，不与全局或其他组件产生影响） 自定义标签（定义组件的使用方式） 可相互组合（组件间组装整合） 接口规范化（组件接口有统一规范，或者是生命周期的管理） 三大框架出现今天的前端生态里面 React，Angular 和 Vue 三分天下，即使它们定位不同，但核心的共同点就是提供了组件化的能力，算是目前是比较好的组件化实践 1. Vue.js 采用了 JSON 的方法描述一个组件12345678910import PageContainer from './layout/PageContainer'import PageFilter from './layout/PageFilter'export default { install(Vue) { Vue.component('PageContainer', PageContainer) Vue.component('PageFilter', PageFilter) }} 还提供了 SFC（Single File Component，单文件组件）‘.vue’文件格式 12345678910111213&lt;template&gt;//...&lt;/template&gt;&lt;script&gt; export default { data(){} }&lt;/script&gt;&lt;style lang=\"scss\"&gt;//...&lt;/style&gt; 2. React.js 发明了 JSX，把 CSS 和 HTML 都塞进 JS 文件里1234567891011121314class Tabs extends React.Component { render() { if (!this.props.items) { console.error('Tabs中需要传入数据'); return null; } const propId = this.props.id; return ( &lt;ul className={this.props.className}&gt; &lt;li&gt;测试&lt;/li&gt; &lt;/ul&gt; ); }} Angular.js 选择在原本的 HTML 上扩展123456&lt;input type=\"text\" ng-model=\"firstname\"&gt;var app = angular.module('myApp', []);app.controller('formCtrl', function($scope) { $scope.firstname = \"John\";}); 标准下的资源整合 具有以下特点 每个组件对应一个目录，组件所需的各种资源都在这个目录下就近维护；（最具软件工程价值） 页面上的每个独立的可视 / 可交互区域视为一个组件； 由于组件具有独立性，可以自由组合； 页面是组件的容器，负责组合组件形成功能完整的界面； 当不需要某个组件，或者想要替换组件时，可以整个目录删除 / 替换 应用结构图 分子是由原子组成的，分子分成原子，原子也可以重新组合成新的分子 一个界面是由独立的分子组件搭建而成，分子组件由原子元件构成，这些原子可通过不同的组合方式，组成新分子组件，继而重组构成新的界面 模块化与组件化对比如果你去网上搜【模块和组件的异同】可能会得到截然不同的答案，大部分描述的都是片面的 它们之间的关系可以从以下三个方面分析： 从整体概念来讲 模块化是一种分治的思想，诉求是解耦，一般指的是 js 模块，比如用来格式化时间的模块 组件化是模块化思想的实现手段，诉求是复用，包含了 template，style，script，script 又可以由各种模块组成 从复用的角度来讲 模块一般是项目范围内按照项目业务内容来划分的，比如一个项目划分为子系统、模块、子模块，代码分开就是模块 组件是按照一些小功能的通用性和可复用性抽象出来的，可以跨项目，是可复用的模块 从历史发展角度来讲随着前端开发越来越复杂、对效率要求越来高，由项目级模块化开发，进一步提升到通用功能组件化开发，模块化是组件化的前提，组件化是模块化的演进 组件的设计原则组件化方案下，我们需要具有组件化设计思维，它是一种【整理术】帮助我们高效开发整合 标准性 123任何一个组件都应该遵守一套标准，可以使得不同区域的开发人员据此标准开发出一套标准统一的组件API尽量和已知概念保持一致 独立性 123456遵循单一职责原则，保持组件的纯粹性属性配置等API对外开放，组件内部状态对外封闭，尽可能的少与业务耦合避免暴露组件内部实现入口处检查参数的有效性，出口处检查返回的正确性 复用与易用，适用 SPOT 法则 1234UI差异，消化在组件内部（注意并不是写一堆if/else）输入输出友好，易用Single Point Of Truth，就是尽量不要重复代码，出自《The Art of Unix Programming》 避免直接操作 DOM，避免使用 ref 12使用父组件的 state 控制子组件的状态而不是直接通过 ref 操作子组件 无环依赖原则 (ADP) 设计不当导致环形依赖示意图 影响 组件间耦合度高，集成测试难 一处修改，处处影响，交付周期长 因为组件之间存在循环依赖，变成了 “先有鸡还是先有蛋” 的问题 那倘若我们真的遇到了这种问题，就要考虑如何处理？ 消除环形依赖 我们的追求是沿着逆向的依赖关系即可寻找到所有受影响的组件 创建一个共同依赖的新组件 稳定抽象原则 (SAP) 1234- 组件的抽象程度与其稳定程度成正比，- 一个稳定的组件应该是抽象的（逻辑无关的）- 一个不稳定的组件应该是具体的（逻辑相关的）- 为降低组件之间的耦合度，我们要针对抽象组件编程，而不是针对业务实现编程 避免冗余状态 123456如果一个数据可以由另一个 state 变换得到，那么这个数据就不是一个 state，只需要写一个变换的处理函数，在 Vue 中可以使用计算属性如果一个数据是固定的，不会变化的常量，那么这个数据就如同 HTML 固定的站点标题一样，写死或作为全局配置属性等，不属于 state如果兄弟组件拥有相同的 state，那么这个state 应该放到更高的层级，使用 props 传递到两个组件中 合理的依赖关系 12父组件不依赖子组件，删除某个子组件不会造成功能异常 扁平化参数 1除了数据，避免复杂的对象，尽量只接收原始类型的值 良好的接口设计 12345678把组件内部可以完成的工作做到极致，虽然提倡拥抱变化，但接口不是越多越好如果常量变为 props 能应对更多的场景，那么就可以作为 props，原有的常量可作为默认值。如果需要为了某一调用者编写大量特定需求的代码，那么可以考虑通过扩展等方式构建一个新的组件。保证组件的属性和事件足够的给大多数的组件使用。 组件的职能划分那有了组件设计的 “API”，就一定能开发出高质量的组件吗？ 组件最大的不稳定性来自于展现层，一个组件只做一件事，基于功能做好职责划分 根据以往经验，我将组件分为以下几类 基础组件（通常在组件库里就解决了） 容器型组件（Container） 展示型组件（stateless） 业务组件 通用组件 UI 组件 逻辑组件 高阶组件（HOC） 除容器组件外，尽量保证组件都是 stateless 的，这并不冲突！ 基础组件为了让开发者更关注业务逻辑，涌现出了很多优秀的 UI 组件库比如 antd，element-ui，我们只需要调用 API 便能满足大部分的业务场景，前端角色后置了，开发变得更简单了 容器型组件一个容器性质的组件，一般当作一个业务子模块的入口，比如一个路由指向的组件 特点 容器组件内的子组件通常具有业务或数据依赖关系 集中 / 统一的状态管理，向其他展示型 / 容器型组件提供数据（充当数据源）和行为逻辑处理（接收回调） 如果使用了全局状态管理，那么容器内部的业务组件可以自行调用全局状态处理业务 业务模块内子组件的通信等统筹处理，充当子级组件通信的状态中转站 模版基本都是子级组件的集合，很少包含 DOM 标签 辅助代码分离 表现形式🌰（vue）12345678910111213&lt;template&gt;&lt;div class=\"purchase-box\"&gt; &lt;!-- 面包屑导航 --&gt; &lt;bread-crumbs /&gt; &lt;div class=\"scroll-content\"&gt; &lt;!-- 搜索区域 --&gt; &lt;Search v-show=\"toggleFilter\" :form=\"form\"/&gt; &lt;!--展开收起区域--&gt; &lt;Toggle :toggleFilter=\"toggleFilter\"/&gt; &lt;!-- 列表区域--&gt; &lt;List :data=\"listData\"/&gt; &lt;/div&gt;&lt;/template&gt; 展示型（stateless）组件主要表现为组件是怎样渲染的，就像一个简单的模版渲染过程 特点 只通过 props 接受数据和回调函数，不充当数据源 可能包含展示和容器组件 并且一般会有 Dom 标签和 css 样式 通常用 props.children (react) 或者 slot (vue) 来包含其他组件 对第三方没有依赖（对于一个应用级的组件来说可以有） 可以有状态，在其生命周期内可以操纵并改变其内部状态，职责单一，将不属于自己的行为通过回调传递出去，让父级去处理（搜索组件的搜索事件 / 表单的添加事件） 表现形式🌰（vue）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 &lt;template&gt; &lt;div class=\"purchase-box\"&gt; &lt;el-table :data=\"data\" :class=\"{'is-empty': !data || data.length ==0 }\" &gt; &lt;el-table-column v-for = \"(item, index) in listItemConfig\" :key=\"item + index\" :prop=\"item.prop\" :label=\"item.label\" :width=\"item.width ? item.width : ''\" :min-width=\"item.minWidth ? item.minWidth : ''\" :max-width=\"item.maxWidth ? item.maxWidth : ''\"&gt; &lt;/el-table-column&gt; &lt;!-- 操作 --&gt; &lt;el-table-column label=\"操作\" align=\"right\" width=\"60\"&gt; &lt;template slot-scope=\"scope\"&gt; &lt;slot :data=\"scope.row\" name=\"listOption\"&gt;&lt;/slot&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;!-- 列表为空 --&gt; &lt;template slot=\"empty\"&gt; &lt;common-empty /&gt; &lt;/template&gt; &lt;/el-table&gt; &lt;/div&gt; &lt;/template&gt;&lt;script&gt; export default { props: { listItemConfig:{ //列表项配置 type:Array, default: () =&gt; { return [{ prop:'sku_name', label:'商品名称', minWidth:200 },{ prop:'sku_code', label:'SKU', minWidth:120 },{ prop:'product_barcode', label:'条形码', minWidth:120 }] } }} }&lt;/script&gt; 业务组件通常是根据最小业务状态抽象而出，有些业务组件也具有一定的复用性，但大多数是一次性组件 通用组件可以在一个或多个 APP 内通用的组件 UI 组件 界面扩展类组件，比如弹窗 特点：复用性强，只通过 props、events 和 slots 等组件接口与外部通信 表现形式🌰（vue）123456&lt;template&gt; &lt;div class=\"empty\"&gt; &lt;img src=\"/images/empty.png\" alt&gt; &lt;p&gt;暂无数据&lt;/p&gt; &lt;/div&gt;&lt;/template&gt; 逻辑组件 不包含 UI 层的某个功能的逻辑集合 高阶组件（HOC）高阶组件可以看做是函数式编程中的组合可以把高阶组件看做是一个函数，他接收一个组件作为参数，并返回一个功能增强的组件 高阶组件可以抽象组件公共功能的方法而不污染你本身的组件比如 debounce 与 throttle 用一张图来表示 React 中高阶组件是比较常用的组件封装形式，Vue 官方内置了一个高阶组件 keep-alive，但并未推荐使用 HOC :( 猜想原因 React：写组件就是在写函数，函数拥有的功能组件都有 Vue：更像是高度封装的函数，能够让你轻松的完成一些事情的同时损失一定的灵活性，你需要按照一定规则才能使系统更好的运行 表现形式🌰（react）品牌车系滑动的动画 各类组件协同组成业务模块 容器 / 展示组件对比图 引入容器组件的概念只是一种更好的组织方式 各司其职，不易出错，即使出错，也能快速定位问题 容器组件，一个载体的存在 展示型组件不与 store 耦合，通过 props 接口来定义所需的数据和方法，复用性与正确性更能保证 1展示型组件直接和store通信的话，那么它就会收到限制，因为你在store里面的字段已经限制他的使用次数和使用的位置 既然如此，那我什么时候引入容器组件，什么时候引入展示组件 引入容器组件的时机优先考虑展示组件，当你意识到有一些中间组件不使用它继承的 props 而是转而传递给他们的子级，每次子级组件需要更多数据时，都需要 “路过” 这些中间组件时就要考虑引入容器组件！ 两者的区别并没有被严格定义，事实上不在技术上而是目的性上 这里有几个供参考的点 容器组件倾向于有状态，展示组件倾向于无状态，这不是硬性规定，它们都是可以有状态的 不要把分离容器组件和展示组件当做教条，如果你不确定该组件是容器组件还是展示组件，就暂时不要分离，写成展示组件，也许是为时尚早，别着急！ 这是一个持续的重构过程，不用试图一次就把它做好，习惯这种模式就会培养起一种直觉，知道何时引入容器 就像你知道何时封装一个函数那样！ 进行组件职能划分的利弊优点 更好的关注分离 1用这种方式写组件，你可以更好的理解你的app和你的ui，甚至会逐渐形成你自己的开发套路 复用性高 1一个组件只做一件事，解除了组件的耦合带来更高复用性 它是 app 的调色版，设计师可以随意调整它的 ui 而不用改变 app 的逻辑 这会强制你提取 “布局组件”，达到更高的易用性 提高健壮性 123456789101112131415由于展示组件和容器组件是通过prop接口来连接，可以利用props的校验机制来增强代码的可靠性，混合的组件就没有这种好处举个🌰(Vue) props: { editData: Object, statusConfig: { type: Object, default() { return { isShowOption: true, //是否有操作栏 isShowSaveBtn: false }; } } } 可测试性 123组件做的事情更少了，测试也会变得容易容器组件不用关心UI的展示，只关心数据和更新展示组件只是呈现传入的props，写单元测试的时候也非常容易mock数据层 所谓的缺点 设计组件初期会增加一些学习成本 由于需要封装一个容器，包装一些数据和接口给展示组件，会增加一些工作量 在展示组件内对 props 的声明会带来少量的工作 长远来看，利大于弊，特别是项目初期，一定要有一个好的设计习惯 组件设计的边界物极必反，跃跃欲试前，常常思考以下几个问题以引导完善组件的设计 页面层级不宜嵌套超过三层，切勿过度设计1原则上组件嵌套超过三层，数据传递的过程就会变得相对复杂 这个组件可否（有必要）再分？1234567891011划分粒度的根据实际情况权衡，太小会提升维护成本，太大又不够灵活和高复用性是否打破了一个逻辑上有意义的实体，倘若抽离的话，这个代码被复用的概率有多大？如果它只是几行代码，那么最终可能会创建更多的代码来分离它，有必要吗？我这么做的好处是否超过了成本？如果你当前的逻辑不太可能出现在其他地方，那么将它嵌入其中更好，如果需要，你可以随时抽离，毕竟组件化没有终点每一个组件都应该有其独特的划分目的的，有的是为了复用实现，有的是为了封装复杂度清晰业务实现组件划分的依据通常是业务逻辑、功能，要考虑各组件之间的关系是否明确，及可复用度 性能会受到影响吗？1如果状态频繁更改，并且当前在一个较大且关系比较紧密的组件里，为了避免性能受到影响最好抽离出来 与diff策略相关 这个组件的依赖是否可再缩减？缩减组件依赖可以提高组件的可复用度 这个组件是否对其它组件造成侵入？ 封装性不足或自身越界操作，就可能对自身之外造成了侵入 一个组件不应对其它兄弟组件造成直接影响 1234常见的一种情况是：组件运行时对window对象添加resize监听事件以实现组件响应视窗尺寸变化事件最优的方案：组件提供刷新方法，由父组件实现调用次优的方案：组件destroy前清理恢复 接口设计是否兼容大部分场景？1需要考虑需要适用的不同场景，在组件接口设计时进行必要的兼容 当别人使用这个组件时，会怎么想？1接口设计符合规范和大众习惯，尽量让别人用起来简单易上手，易上手是指更符合直觉 假如业务需要不需要这个功能，是否方便清除？1各组件之前以组合的关系互相配合，也是对功能需求的模块化抽象，当需求变化时可以将实现以模块粒度进行调整 上文提到的各种准则仅仅描述了一种开发理念，也可以认为是一种开发规范，倘若你认可这规范，对它的分治策略产生了共鸣，那我们就可以继续聊聊它的具体实现了 问自己一个问题 你心中的相对完美的组件是什么样子的？ 落实到具体业务中如何做划分依据明确你的组件划分依据，目前是两种 根据业务划分 根据技术划分 我更多的是根据业务去设计我应用中的组件树，可能会画个草图或 xmind，它可以帮我统观全局 明确各个组件的边界，内部 state 的设计，props 的设计以及与其他组件的关系（需要回调出去的事件） 明确各个组件的定位与职能划分，设计好父子组件、兄弟组件的通信机制 搭架子 架子有了，开始填空 切割模版（页面结构模块化）这是最容易想到的方法，当一个组件渲染了很多元素，就需要尝试分离这些组件的渲染逻辑我们以掘金页面为例 大体上看，可以分为 Part1，Part2，Part3 初步开发123456789101112131415&lt;template&gt; &lt;div id=\"app\"&gt; &lt;div class=\"panel\"&gt; &lt;div class=\"part1 left\"&gt; &lt;!--内容--&gt; &lt;/div&gt; &lt;div class=\"part1 right\"&gt; &lt;!--内容--&gt; &lt;/div&gt; &lt;div class=\"part1 right\"&gt; &lt;!--内容--&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 问题： 代码量大，难以维护，难以测试 有些许重复量 化繁为简12345678&lt;template&gt; &lt;div id=\"app\"&gt; &lt;part1 /&gt; &lt;part2 /&gt; &lt;part3 /&gt; &lt;/div&gt;&lt;/template&gt; 好处： 同之前的方式相比，这个微妙的改进是革命性的 解决了测试困难，维护困难的问题 问题： 没有解决代码重复的问题，这种按模块划分，复用性低 但我看过很多项目的代码，就是这么干的，认为自己做了组件化，抽象的还不错 (@_@) 组件抽象它们有相似的外层，part2 和 part3 更有相似的 titlebar，除了业务内容，完全就是一模一样 🌰（vue） 12345678910&lt;template&gt; &lt;div class=\"part\"&gt; &lt;header&gt; &lt;span&gt;{{ title }}&lt;/span&gt; &lt;/header&gt; &lt;slot name=\"content\" /&gt; &lt;/div&gt;&lt;/template&gt; 我们将 part 内可以抽象的数据都做成了 props，利用 slot 去做模版那么我们在开发相应 Part1，Part2 时 🌰（vue） 12345678910&lt;template&gt; &lt;div id=\"app\"&gt; &lt;part title=\"亦舒\"&gt; &lt;div slot=\"content\"&gt;----&lt;/div&gt; &lt;/part&gt; &lt;part title=\"兴隆臻园户型\"&gt; &lt;div slot=\"content\"&gt;-----&lt;/div&gt; &lt;/part&gt; &lt;/div&gt;&lt;/template&gt; 更具代表性的示例图 UI 差异在哪里定义？ 在业务逻辑层处理 1首先要明确一点，这些差异并不是组件本身造成的，是你自己的业务逻辑造成的，所以容器组件（父组件）应该为此买单 数据差异在哪里定义？ 结合组件本身和业务上下文将差异合理的消除在内部 123456比如part3中，其他的part只有一个类似更多&gt;&gt;的link，但是它却有多个(一居，二居...)这里我推荐将这种差异体现在组件内部，设计方法也很多：比如可以将link数组化为links；比如可以将更多&gt;&gt;看作是一个default的link，而多余的部分则是用户自定义的特殊link，这两者合并组成了links。用户自定义的默认是没有的，需要引用组件时进行传入。 组件命名规则？ 组件设计初期，就应该拥有不耦合业务的名字 123一个通用的或者说未来可能通用的，要有相对合理的命名，比如 Search，List,尽量不要出现与业务耦合过深的业务名词，通用组件与业务无关，只与自身抽象的组件有关我们在设计组件初期，就应该有这种思想，等到真正可以抽出公用组件了，再去苦逼的名改名字？库通常都想让广大开发者用，我们在设计组件时，可以降低标准到先做到你的整个APP中通用 组件划分细粒度的考量（抽之有度）组件设计规则明明白白写着我们要遵循单一职责原则，这也带来了上文聊过的过度抽象（组件化）的问题，我们结合具体的业务聊一下 要实现徽章组件，它有两部分组成 按钮 右上角提示（小红点 /icon） 两者都是符合单一职责的，可以将其抽离成一个独立组件，但是通常不要这么做 1因为同一个app的风格必将是统一的，除此之外没别的应用场景了，就像上文所说的，抽离组件之前，多问自己为什么以及投入/产出比，没有绝对的规则 tips单一职责组件要建立在可复用的基础上，对于不可复用的单⼀职责组件我们仅仅作为独立组件的内部组件即可 某二手车网站体现其细粒度的例子 思考，如果让你实现你会如何设计…我当初是这么设计的 index.js(react) 12345678&lt;div className=\"select-brand-box\" onTouchStart={touchStartHandler} onTouchMove={touchMoveHandler} onTouchEnd={touchEndHandler.bind(this, touchEndCallback)}&gt; &lt;NavBar&gt;&lt;/NavBar&gt; &lt;Brand key=\"brands-list\" {...brandsProps} /&gt; &lt;Series key=\"series-list\" {...seriesProps} &gt; &lt;/div&gt; export default BrandHoc(index); Brand.js(react) 123456789101112131415&lt;div className=\"brand-box\"&gt; &lt;div className=\"brand-wrap\" ref=\"brandWrap\"&gt; &lt;p className=\"brands-title hot-brands-title\"&gt;热门品牌&lt;/p&gt; &lt;FlexLayout onClick={hotBrandClick}&gt; &lt;HotBrands HotBrands={hotBrands} /&gt; &lt;/FlexLayout&gt; {!isHideStar &amp;&amp; &lt;UnlimitType {...unlimitProps} /&gt;} &lt;AllBrands {...brandsProps} /&gt; &lt;/div&gt; &lt;AsideLetter {...asideProps} /&gt; {showPop ? &lt;PopTips key=\"pop-tips\" tip={currentLetter} /&gt; : null} {showBrandLoading ? &lt;Loading /&gt; : null}&lt;/div&gt; FlexLayout.js(react) 这个示例几乎涵盖了所有的规则 首先组件的设计是根据业务划分的，所以右侧字母导航（AsideLetter）才没有在最外层的容器组件，否则通信问题会占用一部分篇幅，事实上这是有解的 入口组件是容器组件，事实上把它当做一个规则就行了，业务逻辑的载体 除了容器组件外，其他的组件都被抽成公用的了，二手车平台类似的场景非常多 卖车平台类似的图文混排多且形态各不相同，应用场景广泛，抽！UI 差异消化在组件内部，参考 FlexLayout.js，给定 default props 可提取的组件过多（业务驱动）导致通讯困难如何解决？ 那说明你需要新增可管理状态的容器组件，上例中 Brand，Series 也是容器组件，负责管理子组件的大小事宜 细粒度的考量，考虑付出产出比 12&lt;p className=\"brands-title hot-brands-title\"&gt;热门品牌&lt;/p&gt; 只有一行，直接写就完了 组件抽离的过程就是无限向无状态（展示型）组件无限靠近的过程 通用性考量组件的形态 (UI) 永远是千变万化的，但是其行为 (逻辑) 是固定的，因此通用组件的秘诀之⼀就是将 DOM 结构的控制权交给开发者，组件只负责⾏为和最基本的 DOM 结构 这是一个显眼的栗子 某一天，你接到这样儿的需求 开心，简单，三下五除二写完了 突然有一天又有这样儿的需求 emm.. 可定制？之前的 select 没法用了，怎么做？要修改上一个或者再写一个吗？一旦出现了这种情况，证明之前的组件需要重新设计了 实现通用性设计的关键一点是放弃对 Dom 的掌控 那么问题又来了，那么多需要自定义的地方，那组件会不会很难用？通用性设计在将 Dom 结构决定权交给开发者的同时指定默认值 这里是一个新鲜出炉 (vue)🌰 List 组件 父组件🌰(vue) 及 slot 1234567891011121314151617模版（伪代码）&lt;template&gt;&lt;List :data=\"tableData[item.type]\" :loading=\"loading\" @loadMore=\"loadMore\" :noMore=\"noMore\"&gt; &lt;a v-if=\"item.type == 0\" slot=\"listOption\" slot-scope=\"childScope\" class=\"edit-btn\" @click=\"edit(childScope.data)\" v-bind:key=\"childScope.data.id\"&gt;{{Status[childScope.data.status]['text']}}&lt;/a&gt;&lt;/List&gt;&lt;/template&gt;config(伪代码)export const Status = { //.... 1: { label: '草稿', type: '', text: '编辑', class: 'note' }} //... 又有一个栗子 (vue) Dialog 只负责基础的逻辑，交出控制权给到业务，至于你的业务需要什么，在容器组件（业务逻辑层）去处理 忍不住放上磐石业务的反面例子 难用无非是两方面的问题 不肯移交控制权 没有 API 文档 所有的业务逻辑与场景都包含在组件内部，外界只通过变量来控制，初衷是好的，但是随着业务发展，组件越来越庞大，开发者也越来越力不从心了 刚好现阶段 UI 改版，我们的工作量就由只改样式直接转化为推倒重来了，又没有详细的文档，工作量瞬间翻了 N 倍😭宝宝心里苦宝宝不说 善用设计模式其实一开始，我并没有专门去套用设计模式，完全是业务驱使你一定见到过这样儿的 一旦这样儿的逻辑多了，那是不是就跟业务耦合了，跟业务耦合多了，那组件自然没有什么通用性了，即使我们不考虑到通用性，那写的累吧？ 考虑下这样写会不会好一点 1234567891011config（伪代码）export const Status = { 4: { label: '部分入库', type: '', text: '查看' }}模版(vue)&lt;a v-if=\"item.type == 0\" slot=\"listOption\" slot-scope=\"childScope\" class=\"edit-btn\" @click=\"edit(childScope.data)\" v-bind:key=\"childScope.data.id\"&gt;{{Status[childScope.data.status]['text']}}&lt;/a&gt; 世界上本没有设计模式，写的人多了，就自成一套脱颖而出进而被历史铭记了！不仅如此，一部分看似复杂的业务如果合理设计配置项，可以会为你省去一大篇 js 一些感悟像磐石这种底层的业务支持系统，离不开大量的列表，查询，编辑，详情等，我一般会花 30 秒搭好架子，像但不限于下面这种 index: 模块入口（承担容器职责） api：整块业务的 API components 业务组件集合 12341. Form：表单 一般会被add.vue（编辑） 和edit.vue（详情）引用2. List：列表3. Search: 搜索组件4. 其他业务中有但却没看到的基本上都已经抽离到common了 比如面包屑导航，收起展开功能等 libs 页面的各种配置 具体体现（磐石刚刚重构的模块）采购模块结构图 Form Edit 无论有多少种状态，只在 edit 这层容器维护 要这么做的原因 components 中的组件只是暂存，都有可能被升级成通用组件，所以命名要注意，一类的保持了统一，防止业务耦合 bug 有迹可循，数据的问题我一定从外向里排查，样式问题从里向外排查，定位问题快 与重复代码做斗争，时刻保持一种强迫症的心态去整理各个模块，形成自己的编码风格，进而团队风格才有可能统一 总结 对于组件设计，充分的准备固然，但在现实世界中，切实的结果才是最重要的，组件设计也不要过度设计更不要停滞不前，该做的时候就去做，发现不好就去改 有空闲时间就去思考早期不够理想的代码，它可以作为我们向前发展的基础 技术在变迁，但组件化的核心并没有改变，目标仍然是在 API 设计尽可能接近原生的情况下完成复用、解耦、封装、抽象的目标，最终服务于开发，提高效率降低错误率 组件化是对实现的分层，是更有效地代码组合方式 组件化是对资源的重组和优化，从而使项目资源管理更合理，方便拔插、方便集成、方便删除、方便删除后重新加入 这种化繁为简的思想在后端开发中的体现是微服务，而在前端开发中的体现就是组件化 组件化有利于单元测试与自测效率对重构较友好 新人加入可以直接分配组件进行开发、测试，而非需要熟悉整个项目，可以从一个组件的开发使新进人员比较快速熟悉项目、了解到开发规范 你的直接责任可能是编写代码，但你的终极目标是在创建产品 最后说一句 组件化没有终点，day day up 参考链接 https://engineering.carsguide.com.au/front-end-component-design-principles-55c5963998c9?gi=b5b86599de92 https://segmentfault.com/a/1190000009952681 https://juejin.im/post/5a73d6435188257a6a789d0d https://medium.com/merrickchristensen/function-as-child-components-5f3920a9ace9 http://www.alloyteam.com/2015/11/we-will-be-componentized-web-long-text/","categories":[{"name":"前端","slug":"前端","permalink":"http://maying.ink/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"组件设计","slug":"组件设计","permalink":"http://maying.ink/tags/%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1/"}]},{"title":"React diff 算法","slug":"diff","date":"2019-03-31T16:00:00.000Z","updated":"2020-10-22T18:41:42.181Z","comments":true,"path":"2019/04/01/diff/","link":"","permalink":"http://maying.ink/2019/04/01/diff/","excerpt":"理解 react 的 diff 算法","text":"理解 react 的 diff 算法 同级节点的移动 增加 删除的具体实现场景一 新旧集合中存在相同节点但位置不同时，如何移动节点12旧 a b c d新 b a d c React 先从新组合中取得 b，然后判断旧中是否存在相同节点 b，当发现存在节点 b 后，就去判断是否移动 b涉及到两个变量 index 和 lastIndex index:b 在集合里下标 此时 index = 1 lastIndex：类似于一个 map 的索引，一开始默认值是 0，它会与 map 中的元素进行比较，比较完后，更新当前的值（取 index 和 lastIndex 的较大数） 比较规则：如果 index &lt; lastIndex 那此元素就需要移动在旧组合里将该元素移动到下标为 lastIndex 的位置 具体的计算过程看下图 场景一 新集合中有新加入的节点，旧集合中有删除的节点规则同上 12旧 a b c d新 b e c a 比较 b 此时 index = 1 lastindex = 0 1&gt;0 b 不移动 更新 lastindex 为 1当比较到 e 的时候，发现旧组合中不存在，故在旧组合下标为 1 的位置 创建 E，更新 lastIndex=1…对比到 a 因为是最后一个 所以 diff 操作结束 新组合对比完成后 再去对旧集合遍历 判断新集合没有，但旧集合有的元素（如 d），删除 d，diff 操作结束","categories":[{"name":"web","slug":"web","permalink":"http://maying.ink/categories/web/"}],"tags":[]},{"title":"一个页面从输入 url 到加载完成 这个过程发生了什么","slug":"urlrender","date":"2019-03-31T15:26:26.000Z","updated":"2020-10-22T18:41:42.187Z","comments":true,"path":"2019/03/31/urlrender/","link":"","permalink":"http://maying.ink/2019/03/31/urlrender/","excerpt":"先来了解以下 五层因特尔协议栈 应用层（dns http） DNS 解析成 ip 并完成 http 请求发送 传输层（tcp udp）三次握手四次挥手建立 tcp 链接 网络层 （ip ARP） IP 寻址 数字链路层 将请求数据封装成帧 物理层 利用物理介质传输比特流","text":"先来了解以下 五层因特尔协议栈 应用层（dns http） DNS 解析成 ip 并完成 http 请求发送 传输层（tcp udp）三次握手四次挥手建立 tcp 链接 网络层 （ip ARP） IP 寻址 数字链路层 将请求数据封装成帧 物理层 利用物理介质传输比特流 简介版本 浏览器根据请求的 url 交给 DNS 解析 找到这真实 IP 向服务器发起请求 服务器交给后台处理完成后返回数据，浏览器接收文件（html,css javascript) 等 浏览器对加载到的资源进行语法解析，构建相应的内部数据结构（Dom 树 css 树 render 树等） 载入解析到的资源文件渲染页面完成 详细版本 浏览器开启一个线程来处理这个请求，对 url 进行判断，如果是 http 协议，则就按照 web 的方式来处理 浏览器解析 url，一般我么输入的都是服务器域名，我们会先查找对应的 ip 首先会查看浏览器的 DNS 缓存，如果存在，则域名解析到此完成 如果浏览器自身的缓存没有找到相应的条目，就会尝试读取操作系统的 host 文件来看时都存在对应的映射关系 如果 host 文件没有，继续查找本地的域名服务器 如果本地的域名服务器还没有找到的话 ，它就会向跟服务器发出请求，进行递归查询 查到了 IP 地址，会将记录存储在本地缓存，此时网络层便会通过 ip 地址寻得对应服务器的物理地址 寻得服务器的地址 客户端在网络传输层便可以和服务器通过三次握手建立 TCPIP 链接 123456789101112131415161718192021TCPIP请求http的本质就是TCP/IP请求需要经历三次握手建立链接 4次挥手断开连接TCP将http长报文划分为短报文，通过三次握手与服务器建立链接进行可靠传输三次握手1. 客户端：你是XX服务器吗2. 服务端：我是XX服务器，你是客户端吗？3. 客户端：是的 我是客户端成功 四次挥手主动方：我已经关闭了向你那边的信息发送通道，只能被动接受信息了被动方：收到通道关闭信息被动方：我现在也关闭了主动方：收到消息 连接断开 之后双方无法通信TCPIP请求：浏览器在同一个域名下并发的TCP链接是有限制的（2-10个） 链接成功后 链路层将请求数据封装成帧 最后物理层通过物理介质进行传输 到了服务器就会通过相反的方式将数据一层一层的还原回去 请求到了后端服务器一般都会有统一的验证 如安全验证，跨域验证等，验证未通过就直接返回相应的 http 报文 验证通过后就会进入后台代码 此时程序收到请求执行相应的操作（如查询数据库等） 如果浏览器访问过 且缓存上有相应的资源便会与服务器最后的修改时间对比，一致便返回 304 告诉浏览器可以使用本地缓存 前端浏览器接收到响应成功的报文便开始下载网页下载完的网页交给浏览器的内核（渲染进程）进行处理 123456789101112* 根据顶部定义的DTD类型进行相应的解析方式* 渲染进程内部是多线程的 网页的解析会被交给内部的GUI渲染进程处理* 首先渲染进程中的html解释器将html网页和资源从字节流解释转化为字符流* 再通过词法分析器将字符流解释成词语* 之后通过语法分析器根据词语构成节点，最后通过这些节点组建一个DOM树* 这个过程中 如果遇到的DOM节点是js代码，就会调用js引擎对js代码进行解释执行。此时由于js引擎和GUI渲染进程的互斥，GUI渲染就会被挂起，渲染过程停止；如果js代码的运行中对dom树进行了修改，那么都没树的构建需要重新开始* 如果节点需要依赖其他资源（图片 css）便会调用网络模块的资源去加载它们，但他们是异步的所以不会阻塞当前dom树的构建* 如果遇到的是js资源url（没有标记异步）则需要停止当前dom的构建 直到js的资源加载并被js引擎执行后才继续构建dom* 对于css css解释器会将css文件解释成内部表示结构（同html解析 子节流-&gt;字符流-&gt;词语-&gt;节点），生成css规则树* 然后合并css树和dom树，生成render渲染树* 最后对render树进行布局和绘制，并将结果通过IO线程传递给Browser控制进程（浏览器主进程）进行显示","categories":[],"tags":[]},{"title":"你不知道的 JS 系列 - this 指向","slug":"this","date":"2019-03-26T04:53:02.000Z","updated":"2020-10-22T18:41:42.186Z","comments":true,"path":"2019/03/26/this/","link":"","permalink":"http://maying.ink/2019/03/26/this/","excerpt":"this 是 js 中最复杂的机制之一 任何足够先进的技术都和魔法无异 - Arthur C.Clarke","text":"this 是 js 中最复杂的机制之一 任何足够先进的技术都和魔法无异 - Arthur C.Clarke 但其实 this 机制并没有那么先进，是我们的臆想把它想复杂了，在缺乏认知的情况下，this 对你来说就是魔法 为什么要使用 this？它提供了一种更优雅的方式来隐式传递一个对象引用，因此可以将 API 设计得更加简洁并且易于使用 对于 this 的误解 指向函数自身 123常见需要指向自身的场景是递归匿名的函数无法指向自身传统的arguments.callee已经弃用 指向函数的词法作用域 1this在任何情况下都不指向函数的词法作用域，在js内部作用域和对象相似，可见的标识符都是它的属性,但是作用域“对象”无法通过js代码访问，它存在于JS引擎内部 this 到底是什么？this 是运行时进行绑定的 并不是在编写时绑定的 它的上下文取决于函数调用时的各种条件 this 绑定和函数声明的位置没有任何关系 只取决于函数的调用方式 123当一个函数调用时 会创建一个活动记录（执行上下文）这个记录会包含函数在哪里被调用（调用栈）函数的调用方法 传入的参数等 this就是记录的其中一个属性会在函数执行的过程中用到this时函数被调用时发生的绑定 指向什么完全取决于函数在哪里被调用 调用位置寻找” 函数被调用的位置”需要分析调用栈（为了到达当前执行位置所调用的所有函数） 绑定规则找到调用位置 然后按照结论中的四条规则判断 默认绑定独立函数调用时，如果在严格模式下，就绑定到 undefined 否则绑定到全局对象 隐式绑定 (对象上的函数调用)当函数引用有上下文对象时 隐式绑定规则会把函数中的 this 绑定到这个上下文对象 对象属性引用链中只有最顶层或者说最后一层会影响调用位置 123456789101112131415function foo(){ console.log(this.a)}var obj2 = { a:42, foo:foo};var obj1 = { a:2, obj2:obj2}obj1.obj2.foo(); //42 1234567891011var a = 20;var obj = { a: 10, c: this.a + 20, fn: function () { return this.a; }}console.log(obj.c); //40console.log(obj.fn()); //10 单独的 {} 是不会形成新的作用域的，因此这里的 this.a，由于并没有作用域的限制，所以它仍然处于全局作用域之中。所以这里的 this 其实是指向的 window 对象。 被隐式绑定的函数会丢失绑定对象而执行默认绑定规则 下面是两个场景 1. 1234567891011function foo(){ console.log(this.a)}var obj1 = { a:2, foo:foo}var bar = obj1.foo; //函数别名var a = \"global\"; //全局属性abar(); //bar引用的是foo本身 因此此时的bar其实是一个不带任何修饰符的函数调用 因此使用了默认绑定 2. 当传入回调函数时 使用默认绑定规则 参数传递就是一种隐式赋值，因此我们传入函数时也会被隐式赋值 如果把函数传入语言内置函数 结果也是一样的 12345678910111213141516171819202122function foo(){ console.log(this.a)}function dofoo(fn){ fn();}var obj1 = { a:2, foo:foo}var a = \"global mama\"; //全局属性adofoo(obj1.foo) //global mamasetTimeout(obj1.foo,100) //global mama 将函数传入语言内置的函数相当于function setTimeout(fn,delay){//等待delay之后fn() } 显式绑定 (使用 call apply bind)通过固定 this 来修复，可以在某个对象上强制调用函数使用 call apply 或者bind 1他们的第一个参数式对象，它们会把这个对象绑定到this，接着在调用函数时指定这个this 因为你可以直接指定this的绑定对象 因此我们称之为显式绑定 如果 foo.call (1) // 一个原始值当作对象 这个原始值会转换成它的对象形式 (装箱) 可惜，显示绑定无法解决丢失绑定的问题 但是显示绑定的一个变种 “硬绑定” 可以解决这个问题 硬绑定：无论何时调用函数 bar 它总会手动在 obj 调用 foo 这种绑定是一种显式的强制绑定 123456789101112131415161718function foo(){ console.log(this.a)}var obj1 = { a:2}var obj2 = { a:4}var bar = function(){ foo.call(obj1)}bar(); //2setTimeout(bar,100) //2bar.call(obj2) // 2 硬绑定的bar不可能再修改它的this 由于硬绑定是一种常用的模式，所以 ES5 提供了内置的方法Function.prototype.bind 了解了用法 我们来看一个 demo 12345let a = {};let fn = function(){ console.log(this)}fn.bind().bind(a)() // ? 答案应该是 window 你回答对了吗 事实上 我么可以改写一下 它类似于 123456789var a = {};let fn = function(){console.log(this)}let fn2 = function fn1(){ return function(){ return fn.apply(); }.apply(a)}fn2() //window 这样儿结果能猜到了吗 fn 中的 this 永远由第一个bind 决定 所以 结果永远是 window new 绑定1234567js中的构造函数只是一些使用new操作符时被调用的函数 他们不并不属于某个类也不会去实例化一个类 他们只是被new操作符调用的普通函数插播new调用的时候会自动执行下面的操作1. 创建（构造一个全新的对象）2. 这个对象会被执行原型链接3. 这个信贷想回绑定到函数调用的this4. 如果函数没有返回其他对象那么new表达式中的函数调用会自动返回这个新对象 由此可以知道 new 操作符调用时，this 指向生成的新对象⚠️new 调用时的返回值，如果没有显式返回对象或者函数，才会返回新对象关于这一点 这应该是一篇关于模拟实现 JS 的 new 操作符的文章 绑定优先级new 调用 &gt; 显示绑定 (apply,call,bind) &gt; 隐式绑定（对象上的函数调用） &gt; 默认绑定 绑定例外规则总有例外，这里也一样 当你把 null 或者 undefined 作为 this 的绑定对象传入 call apply 或者 bind 这些在调用时候会被忽略应用默认规则应用场景：当你要传入参数时候 如果函数不关心 this 的话 你可以传入 null 当作一个占位值 但是这种方式不可取 绑定 this 可能会引起副作用 123456789function foo(){ console.log(this.a)}var obj = { a:2}var a = 3foo.call(null) 一种更安全的 this Object.create(null) 创建的空对象不会创建 object.prototype 比 {} 更空 比 null 的语义更清楚 代码如下 12345678910function foo(a,b){ console.log(a,b)}var w = Object.create(null);foo.apply(w,[2,3])//使用bind()进行柯里化var bar = foo.bind(w,2)bar(3) 间接引用你会有意无意的创建一个函数的间接引用，在这种情况下，调用这个函数会应用默认规则它最容易在赋值时产生类似这样儿的 (p.foo = o.foo)(); 它的返回值是目标函数的引用，因此调用的位置是 foo() 而不是 p.foo() 或者 o.foo() 所以使用默认绑定 箭头函数调用模式先看箭头函数和普通函数的重要区别： 没有自己的 this、super、arguments 和 new.target 绑定。 不能使用 new 来调用。 没有原型对象。 不可以改变 this 的绑定。 形参名称不能重复。 箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值。如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则 this 的值则被设置为全局对象。 1234567891011121314151617var name = 'window';var student = { name: 'ma', doSth: function(){ // var self = this; var arrowDoSth = () =&gt; { // console.log(self.name); console.log(this.name); } arrowDoSth(); }, arrowDoSth2: () =&gt; { console.log(this.name); }}student.doSth(); // 'ma'student.arrowDoSth2(); // 'window' 结论 this 不指向函数自身 this 不指向函数的词法作用域，当你想要把 this 和词法作用域查找混合使用时，一定要提醒自己 这是无法实现的 this 实际上是在函数被调用时发生绑定的，指向什么完全取决于函数在哪里被调用 如果要判断一个运行中函数的 this 绑定 就需要找到这个函数的直接调用位置 找到之后按照下面这四条规则判断 this 的绑定对象 12341.由new调用？绑定到新创建的对象2.由call或apply或bind调用(显示绑定)？绑定到指定的对象3.由上下文对象调用（隐式绑定）？绑定到上下文对象4.如果都不是的话 使用默认绑定，如果在严格模式下，就绑定到undefined 否则绑定到全局对象 ES6 中的箭头函数不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定 this, 它会继承外层函数调用的 this 绑定 (无论 this 绑定到什么), 这跟 ES6 之前代码中的 self=this 机制一样（实际上箭头函数将程序猿们常犯的一个错误：混淆 this 绑定规则和词法作用域规则 给标准化了，这点容易造成误解） DOM 事件函数：一般指向绑定事件的 DOM 元素，但有些情况绑定到全局对象（比如 IE6~IE8 的 attachEvent） 检验一下学习成果 小小沧海：一道常被人轻视的前端 JS 面试题从这两套题，重新认识 JS 的 this、作用域、闭包、对象","categories":[{"name":"js","slug":"js","permalink":"http://maying.ink/categories/js/"}],"tags":[{"name":"this","slug":"this","permalink":"http://maying.ink/tags/this/"}]},{"title":"你不知道的 JS 系列 - 理解 JS 中 赋值，浅拷贝，深拷贝","slug":"clone","date":"2019-03-25T10:28:10.000Z","updated":"2020-10-22T18:41:42.181Z","comments":true,"path":"2019/03/25/clone/","link":"","permalink":"http://maying.ink/2019/03/25/clone/","excerpt":"开篇又回到了这个老生常谈，新生绝望的问题上，通常遇到这种大家都比较熟悉的问题，反而不知道怎么列大纲，怕不够深入也怕脱离主题～emm..此文系 不要再问我 XX 系列之 不要再问我 JS Clone 的问题了","text":"开篇又回到了这个老生常谈，新生绝望的问题上，通常遇到这种大家都比较熟悉的问题，反而不知道怎么列大纲，怕不够深入也怕脱离主题～emm..此文系 不要再问我 XX 系列之 不要再问我 JS Clone 的问题了 为什么会存在这三种情况？三者有何差异clone 本来很简单，只是因为 JS 中不同的数据类型存储方式 (堆和栈) 的差异，我们才会觉得它貌似有点‘复杂’ 基本类型和引用类型的差异如上图所示了它们共同的目标就是以一个对象为原型 clone 出另外一个新对象，因为自身的问题产生一些副作用，三者的差异其实就体现在副作用的差异上 差异（堆和栈） 栈（stack）为自动分配的内存空间，它由系统自动释放 而堆（heap）则是动态分配的内存，大小不定也不会自动释放 基础类型： 值存放在栈中，比较是值的比较引用类型： 值存放在堆中，变量实际上是一个存放在栈内存的指针，这个指针指向堆内存中的地址。每个空间大小不一样，要根据情况开进行特定的分配，引用类型的比较是引用的比较 123var person1 = [1,2,3];var person2 = [1,2,3];console.log(a === b); // false 赋值赋值的概念 即使刚入行也不陌生，每天都在用的'=' 原理 基本类型：在内存中新开辟一段栈内存，然后再把再将值赋值到新的栈中，是两个独立相互不影响的变量 引用类型：赋值是传址，是对象保存在栈中的地址的赋值，这样的话两个变量就指向堆内存的同一个对象，因此两者之间操作互相有影响 Demo12345678910111213141516171819202122232425262728293031var obj1 = { name:'maying', age:22, sex:'女', language : [1,[2,3],[4,5],[9,0]]}var sringD = 'pre';var obj3 = sringD;sringD = 'post';var obj2 = obj1;obj1.name = 'gaile',obj1.language[0] = 'jjj'console.log('obj1',obj1) /* { age: 22 language: (4) [\"jjj\", Array(2), Array(2), Array(2)] name: \"gaile\" sex: \"女\" } */console.log('obj2',obj2) /* age: 22 language: (4) [\"jjj\", Array(2), Array(2), Array(2)] name: \"gaile\" sex: \"女\" */console.log('sringD',sringD) //postconsole.log('obj3',obj3) //pre 理解浅拷贝之前的很多年，我认为赋值差不多等于浅拷贝写个小 demo 发现它们之间的差异 1234567var obj2 = obj1;var obj3 = {...obj1};obj1.name = 'gaile',obj1.language[0] = 'jjj'console.log('obj1',obj1)console.log('obj2',obj2)console.log('obj3',obj3) 赋值对象，是将对象指针直接赋值给另一个变量浅拷贝，是重新创建了新对象，所以你更改 obj1.name 的时候不会影响到它，但是改变引用类型时就不能幸免了 所谓的浅拷贝就是： 当对简单的数据类型进行赋值的时候，其实就是直接在栈中新开辟一个地方专门来存储一样的值 当对引用类型进行浅拷贝，后面的对象和前面的对象在第一层数据结构中指向同一个堆地址，但是如果前面的数据不止有一层（属性值是一个指向对象的引用只拷贝那个引用值），类似 1language : [1,[2,3],[4,5],[9,0]] 内部的子对象的指针还是同一个地址 如果要实现一直往下复制 就引出了接下来要说的深拷贝 结论：浅复制要比复制来的深刻一点，至少它开辟了一个新对象，一块儿新的堆内存 目前可行的实现方式站在巨人的肩膀上，我们可以轻松实现浅拷贝 数组的浅拷贝 1231. b = [...a]2. b = a.slice(0) / [].slice.call(a,0)3. b = a.concat() / [].concat.call(a) 对象的浅拷贝 121. b = Object.assign({},a)2. b = {...a} 如果要你自己实现呢原理：遍历对象的每个属性进行逐个拷贝 12345678910111213function copy(obj) { if (!obj || typeof obj !== 'object') { return } var newObj = obj.constructor === Array ? [] : {} for (var key in obj) { if(obj.hasOwnProperty(key)){ newObj[key] = obj[key] } } return newObj} 理解深拷贝深拷贝的意义，就是完全复制，如果你读了上文，应该就没有什么疑问了 将 a 对象复制一份给对象 b，不管 a 中的数据结构嵌套有多深，当改变 a 对象中的任意深度的某个值后，b 中的该值不会受任何影响 目前可行的实现方式 JSON.stringify()``和JSON.parse() 的混合配对使用 12345678910var obj4 = JSON.parse(JSON.stringify(obj1)) obj1.name='yishu',obj1.language[1] = [\"二\",\"三\"];obj4.language[2] = [\"四\",\"五\"];console.log(obj1); console.log(obj4); obj1,obj4 是两个独立的对象，更改数据互不影响，达到了我们要的目的 它粗暴，有用，但是也有缺点 在JSON.stringify() 做序列化时，undefined、function 以及 symbol 值，会被忽略 例如 12345678910var obj = { a: {b: 'old'}, c:undefined, d: function () {}, e: Symbol('') }var newObj = JSON.parse(JSON.stringify(obj))newObj.a.b = 'new'console.log(obj)console.log(newObj) 结果 如果要你自己实现呢原理：使用递归，遍历每一个对象属性进行拷贝 1234567891011121314151617181920212223242526272829var obj = { a: {b: 'old'}, c:undefined, d: function () {}, e: Symbol('') }function copy(obj) { if (!obj || typeof obj !== 'object') { return } var newObj = obj.constructor === Array ? [] : {} for (var key in obj) { if (obj.hasOwnProperty(key)) { if (typeof obj[key] === 'object' &amp;&amp; obj[key]) { newObj[key] = copy(obj[key]) } else { newObj[key] = obj[key] } } } return newObj}var newObj = copy(obj)newObj.a.b = 'new'console.log(obj)console.log(newObj) 总结 赋值：引用复制 执向同一个对象 浅拷贝 ：生成一个新对象，只能拷贝一层，当属性值是一个指向对象的引用只拷贝那个引用值 深拷贝：完全拷贝，前后对象没有任何关系 参考链接https://www.zhihu.com/question/23031215https://segmentfault.com/a/1190000018204798","categories":[{"name":"js","slug":"js","permalink":"http://maying.ink/categories/js/"}],"tags":[{"name":"clone","slug":"clone","permalink":"http://maying.ink/tags/clone/"}]},{"title":"你不知道的 JS 系列 - 作用域、变量提升、闭包","slug":"actionScope","date":"2019-03-25T08:48:08.000Z","updated":"2020-10-22T18:41:42.180Z","comments":true,"path":"2019/03/25/actionScope/","link":"","permalink":"http://maying.ink/2019/03/25/actionScope/","excerpt":"来看几个既基本又重要的概念查漏补缺","text":"来看几个既基本又重要的概念查漏补缺 作用域几乎所有编程语言最基础的功能之一 就是存储变量当中的值，并能在之后对这个值进行访问和修改引出下面两个问题 那这些变量存储在哪里？ 程序需要的时候 如何找到他们？ 我们需要一套设计良好的规则来存储变量，并且之后可以方便的找到这些变量，它叫 作用域 js 程序编译原理js 是一门编译语言，但是与传统的编译语言不同，他不是提前编译的 js 引擎进行编译的步骤和传统的编译语言非常相似，但是某些环节会更加复杂 例如：在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素的优化 分词 / 词法分析 解析 / 语法分析 1将词法单元流（数组）转化为AST（抽象语法树） 代码生成 1将AST转化为可执行代码 js 引擎执行一段可执行代码时，会创建对应的执行上下文，对于每个执行上下文，都有三个重要属性： 变量对象 1每一个执行上下文都会分配一个变量对象，变量对象的属性由变量和函数声明构成，在函数上下文的情况下，参数列表也会被加入到变量对象作为属性,不同作用域的变量对象互不相同，它保存了当前作用域的所有函数和变量 作用域链 this 指向 当你看到 var a = 2 程序内部的工作过程 12345编译器将这端程序分解成词法单元 var a, a=2 然后将词法单元解析成一个树结构1.遇到var a 编译器会询问作用域是否已经有该变量的名称存在于同一个作用域中,如果是，编译器忽略该声明 否则会要求作用域在当前作用域的集合中声明一个新的变量 命名为a2.当为引擎生成运行时所需要的代码 a=2 js引擎运行时会询问作用域，当前作用域的集合中是否存在a 存在 就是用 不存在就继续查找 如果还是找不到 就抛出异常 总结：变量的赋值操作会执行两个过程 编译器会在当前作用域中生成一个变量（之前没有生成过）这会在代码执行前进行 运行时 js 引擎会在作用域中查找（LHS 查询）该变量能找到就给他赋值 js 引擎是如何查找变量的？LHS 查询 （赋值操作的目标是谁）RHS 查询 （谁是赋值操作的源头） 词法作用域大部分的标准语言编译器的第一个工作就叫词法化词法化的过程会对源代码进行检查词法作用域就是定义在词法阶段的作用域词法作用域意味着作用域是由书写代码时函数声明的位置决定的 函数作用域函数是 js 中最常见的作用域单元 声明在一个函数内部的变量或函数会在所处的作用域中隐藏起来 这符合最小授权（暴露）原则 最小授权（暴露）原则的好处？ 隐藏内部实现 API 友好 规避冲突 （同名标识符之间的冲突） 块作用域块作用域是指变量和函数不仅可以属于所处的作用域也可以属于某个代码块儿 {…}ES3 开始 try/catch 结构在 catch 分句中具有块作用域ES6 引入了 let const 可以用在循环中 会将当前的值重新绑定到了循环的每一个迭代中 小结 作用域是一套规则，用于确定在何处以及如何查找变量，如果查找的目的是对变量进行赋值，那么就会使用 LHS 查询，如果目的是为了获取变量的值 那就进行 RHS 查询 赋值操作会导致 LHS 查询 LHS 与 RHS 查询都会从当前作用域中开始，如果有需要就会向上级作用域继续查找目标标识符。这样儿每次上升一级作用域，最后抵达迁居作用域 无论找到没找到都会停止 不成功的 RHS 引用会抛出异常 不成功的 RHS 引用会导致自动隐式创建一个全局变量 词法作用域意味着作用域是由书写代码时函数声明的位置决定的。编译的词法分析阶段基本能够知道全部标识符在哪里以及如何声明的，从而能够在执行过程中如何对他们进行查找 eval () 与 with () 可以扩充词法作用域 但是会有性能问题 函数是常见但不是唯一的作用域单元，函数作用域与块作用域的行为是一样儿的 任何声明在某个作用域内的变量都将附属于这个作用域 ES6 中引入了 let 关键字 用来在任意代码块中声明变量 提升 先有声明 后有赋值 只有声明本身会被提升，而赋值等其他运行逻辑会留在原地，提升不会改变代码的执行顺序 注意避免重复声明 每个作用域都会进行提升操作 函数声明会被提升，函数表达式不会被提升 函数提升优先于变量提升 一个普通块内部的函数声明通常会被提升到所在作用域的顶部 无论作用域中的声明出现在什么地方，都将会在代码本身被执行前首先被处理（所有的变量声明和函数声明）都会被移动到各自作用域的最顶端 作用域闭包 闭包无处不在 你需要的是识别并且拥抱它 闭包是基于词法作用域书写代码时产生的自然结果 当函数可以记住并访问所在的词法作用域时就产生了闭包 即使函数是在当前词法作用域之外执行 闭包可以使得函数可以继续访问定义时的词法作用域 如果将函数当作第一级的值类型并到处传递 就会看到闭包在这些函数中的应用 在定时器，事件监听器 ajax 请求 或者任何其他的异步任务重 之要使用了回调函数 实际上就是在使用闭包 闭包 就是关于如何在函数作为值按需传递的词法环境中书写代码的 循环与闭包块作用域和闭包联手便可天下无敌 使用 IIFE（自执行函数） 1234567891011121314151617181920212223for(var i =1; i&lt;=5;i++){ (function(j){ setTimeout(function timer(){ console.log('j',j); },i*100) })(i);}let用来劫持块作用域 并且在这个块作用域中声明一个变量for(var i =1; i&lt;=5;i++){ let j = i setTimeout(function timer(){ console.log(j); },i*100)}for循环头部的let声明 每次迭代都会声明for(let i =1; i&lt;=5;i++){ setTimeout(function timer(){ console.log(i); },i*100)}","categories":[{"name":"js","slug":"js","permalink":"http://maying.ink/categories/js/"}],"tags":[{"name":"作用域","slug":"作用域","permalink":"http://maying.ink/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"name":"闭包","slug":"闭包","permalink":"http://maying.ink/tags/%E9%97%AD%E5%8C%85/"}]},{"title":"写在入职两周年","slug":"twoYears","date":"2019-03-22T02:14:12.000Z","updated":"2020-10-22T18:41:42.187Z","comments":true,"path":"2019/03/22/twoYears/","link":"","permalink":"http://maying.ink/2019/03/22/twoYears/","excerpt":"","text":"博客计划","categories":[],"tags":[]},{"title":"异步编程方案的演进","slug":"promise","date":"2019-03-19T10:28:57.000Z","updated":"2020-10-22T18:41:42.185Z","comments":true,"path":"2019/03/19/promise/","link":"","permalink":"http://maying.ink/2019/03/19/promise/","excerpt":"程序中现在运行的部分和将来运行的部分就是异步编程的核心 异步编程的演进大致分以下几个时期 回调函数时期 promise 时期 生成器 (ES6) + promise 时期 async/await 时期 (ES7)","text":"程序中现在运行的部分和将来运行的部分就是异步编程的核心 异步编程的演进大致分以下几个时期 回调函数时期 promise 时期 生成器 (ES6) + promise 时期 async/await 时期 (ES7) 你必须要知道的基本概念异步、并行，并发的区别 异步：是关于现在和将来的事件间隙 并行：是关于同时完成多个任务的概念 并发：是指分别由任务 a 和任务 b 在一段时间内通过任务间的切换完成了这两个任务，单线程事件循环是并发的一种形式 1234并发是指两个或者多个事件随着时间发展交替执行，以至于从更高的层次上看是同时在运行（尽管在任意时刻只处理一个事件）实际的并发场景比如社交网站，随着用户向下滚动列表加载更多资源 （一边触发ajax一边响应数据）.. js 里的完整运行特性js 从不跨线程共享数据，并且由于 js 单线程的特性，函数块儿中的代码具有完整运行机制，也就是说，一旦 foo() 开始运行，它的所有代码都会在 bar() 中的任意代码运行之前完成 事件循环队列与任务队列的区别ES6 中，有一个任务队列的概念，它是挂载在事件循环队列的每个 tick 之后的一个队列 js 引擎运行在宿主环境中（浏览器，node 端等），这些环境都有线程的概念，他们都提供了一种机制来处理程序中多个块儿的执行，且执行每块儿时调用 js 引擎，这种机制被称之为事件循环 一旦有事件需要运行，事件循环就会运行，直到队列清空，事件循环的每一轮称为一个 tick，用户交互 IO 和定时器会向事件队列中加入事件，任意时刻，一次只能从队列中处理一个事件，执行事件的时候，可能直接或者间接地引发一个或者多个后续事件 一个比较形象的比喻 事件循环队列：类似于一个游乐场游戏，玩过了一个游戏之后，你需要重新到队尾排队才能再玩一次 任务队列：玩过了游戏之后，插队接着玩 第一阶段 (回调函数时期)任何时候，只要把一段代码包装成一个函数，并指定它在响应某个事件时执行，你就是在代码中创建了一个将来执行的块儿，也由此在这个程序中引入了异步机制。 回调实现异步的特性 回调函数是 js 异步的基本单元，但是随着 js 越来越成熟，对于异步编程的发展，回调已经不够用了以至于产生可怕的回调地狱，嵌套函数存在耦合性，一大有所改动就会牵一发而动全身，而且嵌套过多导致错误难以处理 回调表达异步流程的方式是非线性的，非顺序的，这使得正确推理这样儿的代码难度很大，难以理解，我们需要一种更同步更顺序更阻塞的方式来表达异步，就像我们的大脑一样。 回调会受到控制反转的影响，因为回调函数中把控制权交给第三方比如 ajax()，会造成一系列麻烦的信任问题 可能产生的信任问题 123451. 调用回调过早2. 调用回调过晚（或者不被调用）3. 调用回调次数过多或者过少4. 未能传递所需的环境和参数5. 吞掉可能出现的错误和异常 小结我们需要一个通用的方案来解决这些信任问题，不管我们创建多少回调，这一方案都可以复用，且没有重复代码的开销 引出了 Promise 第二阶段 (Promise 时期)直到 ES6 Promise 的引入 JS 才真正有内建的异步概念 我们开篇就了解到了 异步编程分现在运行部分 和将来运行部分的概念 回调函数的模式是关于如何处理将来值 Promise 是把现在和将来归一化了 把他们都变成了将来，也就是说 它把所有的操作都变成了异步的 Promise 的特点 我们通过某种方式在函数完成时候得到通知，以便我们可以继续下一步 类似于事件订阅 我们不需要关注谁订阅了这些事件，实现了关注点分离 Promise 封装了依赖时间的状态 - 它等待底层值的完成或者拒绝 所以 promise 本身是与时间无关的 它可以按照可预测的方式组合 而不用关心底层代码如何结束 一旦 promise 决议，它就永远保持在这个状态 promise 是一种封装和组合未来值的易于复用的机制 Promise 基本用法1234567891011121314151617var p = new Promise(function(resolve,reject){ //resolve()用于完成 //reject() 用于拒绝}) 他有三个状态 pending,fulfilled，rejected 两个过程 pending -&gt; fulfilled pending -&gt; rejected resolve：会将传入的真正的promise直接返回，对传入的thenable会展开,如果这个thenable展开是一个拒绝状态，那么从promise.resolve()返回的promise实际上就是这同一个拒绝状态所以resolve实际上的结果可能是完成或拒绝rejected ：拒绝状态 实例的调用 12345678promise.then(resolveFn,rejectFn)如下：promise.then(function(value) { // success}, function(error) { // failure}); 如何确定某个值是不是真正的 promise（或者说 thenable）利用鸭子模型如果一个函数或对象具有.then () 方法，我们认为这样儿的值就是 Promise 一致的 thenable 所以不要给函数或者对象添加.then方法，否则这个值就会误认为是一个 thenable 导致难以追踪的 bug 既然我们已经知道亟待解决的问题，把回调的缺陷解决了，否则引入 Promise 没有任何意义 解决控制反转问题之前 我们用回调函数封装程序中的代码，然后将其交给第三方等（比如 ajax），接着期待其能调用回调实现功能现在我们要能够把控制反转再反转回来我们希望第三方给我们提供其任务何时结束的能力，然后由我们自己的代码来决定下一步做什么 老实说 绝大多数 JS/DOM 新增的异步 API 都是基于 Promise 构建的 解决信任问题promise 解决调用过早对一个 promise 调用 then 的时候，即使这个 promise 已经决议，提供给 then() 的回调总会被异步调用 promise 解决调用过晚promise 对象创建 resolve 或者 reject 时，这个 promise 的 then 注册的观察回调就会被自动调度，可以确信，这些被调度的回调在下一个异步事件点上依次被立即调用，这些回调中的任意一个都无法影响或延误对其他回调的调用，这是 promise 的运作方式 回调未调用没有任何东西（甚至是 js 错误）能阻止 promise 向你通知他的决议，promise 在决议时总是会调用其中一个 如果 promise 本身永远不被决议。promise 也提供了解决方案 12345678用于一个超时的promisefunction timeoutpromise(){return new promise(function(){ setTimeout(functiion(){ reject('timeout') },delay)})} 调用次数过多或过少promise 定义方式使得它只能被决议一次如果试图调用多次或者 resolve 和 reject 都调用，那么这个 promise 只接受第一个决议，并默默的忽略任何后续调用当然了，如果你把同一个回调注册了不止一次 (p.then (f);p.then (f)) 那么它被调用的次数就会和注册次数相等 未能传递参数 / 环境值promise 至多只能有一个决议值（完成或拒绝）如果使用多个参数调用 resolve 或者 reject 第一个参数之后的所有参数都会默默忽略 如果要传递多个值，就必须把他们封装在单个值中传递 比如一个数组或者对象 吞掉错误或者异常如果在 Promise 的创建过程中或者查看决议结果过程中的任何时间点上出现了 js 的异常错误，那么这个异常就会被捕捉，并且会使这个 Promise 拒绝 reject promise 甚至把 js 的异常也变成了异步行为，进而极大降低了静态条件出现的可能 但是如果 promise 完成后的回调中出现了 js 异常 因为 p.then () 本身返回了另外一个 promise 正是这个 promise (下一个 promise) 将会因 TypeError 异常而被拒绝 注意：为什么它不是简单的调用我们的错误处理函数呢？如果这样儿的话就违背了 promise 的基本原则：promise 一旦决议就不可改变也会造成有些回调会调用，有些回调不会调用情况会非常不透明 是可信任的 Promisepromise 并没有完全摆脱回调，他们只是改变了传递回调的位置 如果你向 promise.resolve() 传递一个非promise 就会得到用这个值填充的 Promise 如果你向 promise.resolve () 传递一个真正的 promise 就会返回同一个 promise promise.resolve() 可以接受任何 thenable，得到的是一个真正的 Promise 是一个可信任的值，如果你传入的已经是真的 Promise 那么就更值得信任了 对于用 promise.resolve () 为所有函数的返回值（不管是不是 thenable）都封装一层，这样儿做很容易把函数调用规范为定义良好的异步任务 Promise 这种模式通过可信任的语义把回调当参数传递，使得这种行为更加可靠合理，通过把回调的控制反转回来，我们把控制权放在了一个可信任的系统，这种系统的设计目的就是为了使得异步编码更清晰 以上 promise 解决了回调函数的致命问题接下来 我们将展示基于 promise 的链式流作用 Promise 的链式流Promise 并不是一个单步遵循 this-then-that 操作的机制，我们可以将多个 Promise 链接在一起表示一系列异步步骤 这种方式实现的有以下特性 每次你对 promise 调用 then () 它会创建并返回一个新的 promise, 我们可以将其链接起来 不管从 then () 调用的完成回调（第一个参数）返回的值是什么，他都会被自动设置为被链接 promise（第一点中的）的完成 调用 promise 的 then () 会自动创建一个新的 promise 从调用返回 在完成或拒绝处理函数内部，如果返回一个值或者抛出一个异常。新返回的 promise（可链接的）就相应的决议 如果返回或拒绝处理函数返回一个 promise, 它将会被展开，这样儿一来，不管它的决议值是什么，都会成为当前 then () 返回的链接 promise 的决议值 如下 12345678var p = Promise.resolve(21); p.then(function(v){ console.log(v * 2) //42 return v + 2 // ***}).then(function(v){ console.log('ceshi',v) //23}) 第一个 then 就是异步序列的第一步 第二个 then 是第二步，只要保证把先前的 then (..) 连到自动创建的每一个 promise 即可 在这个 demo 中 我们用了立即返回的 return 语句 但是我们如果需要步骤二等待步骤一异步来完成一些事情怎么办？也就是说我们想要使 promise 序列真正能够在每一步有异步能力？ 12我们可以给promise.resolve()传递非（最终值）即 **真正的promise或thenable**，Promise会直接返回真正的promise 或展开接收到的thenable值，并在持续展开`thanable`的同时递归前进 如下 123456789var p = Promise.resolve(21); p.then(function(v){ return new Promise(function(resolve,reject){ resolve(v*2) //42 })}).then(function(v){ console.log(v) //42}) 我们把 42 封装到了返回的 promise 中，但是它仍然会被展开并最终成为链接的 promise 的决议，因此第二个.then 函数中的到的仍然是 42 此时，如果向封装的 promise 中引入异步，仍然会正常工作 1234567891011var p = Promise.resolve(21); p.then(function(v){ return new Promise(function(resolve,reject){ setTimeout(function(){ resolve(v*2) },200) })}).then(function(v){ console.log(v) //42}) 完美 我们可以实现一系列个异步步骤 在这些例子中，一步一步传递的值是可选的，不传的话就是隐式返回 undefined 并且这些 Promise 仍然会以同样的方式链接到一起 每一个 Promise 的决议就成了继续下一个步骤的信号 存在默认的 resolve 和 reject 回调默认的 reject 如果你调用.then () 函数并且只传入一个完成处理函数，一个默认拒绝处理函数就会顶替上来，默认拒绝处理函数只是把错误重新抛出，这使得错误可以继续沿着 Promise 链传播下去，直到遇到显式定义的拒绝处理函数 12345678910111213var p = new Promise(function(resolve,reject){ reject('ooPs');})var p2 = p.then( function fulfilled(){ //不会执行到这里 }, //默认的拒绝处理函数 当你没有传时 function (err){ throw err; }); 默认的 reject 123456789101112131415var p = Promise.resolve(2)var p2 = p.then( function (v){ //不会执行到这里 return v }, //默认的拒绝处理函数 当你没有传时 function reject(err){ //.. }).then(function(v){ console.log('ss',v) //2}) 默认的完成处理函数只是把接受到的任何传入值传递给下一个步骤的 promise 而已 关于错误处理之前同步的错误处理 我们通常使用 try catch 处理异常但是它只能是同步的，无法用于异步代码模式即使你在异步代码 比如 setTimeout 中谁用 try catch 仍然是有问题的，他们采用 error-first 回调风格，无法很好的组合，多级 error-first 回调交织，导致了回调地狱的风险 1234567891011121314function foo(cb){ setTimeout(function(){ try { var x = baz.bar(); cb(null,x) } catch(err){ cb(err) } })}只有在 baz.bar()调用会同步地立即成功或失败的情况下，这里的try catch才能工作 promise 的错误处理 增加 .catch (..) 方法.catch (..) 会创建并返回新的 promise，这个 promise 可用于实现 promise 链式流程控制它没有采用 error-first 回调设计风格，而是使用了分离回调风格一个回调用于完成情况 一个回调用于拒绝情况 我们了解到 在完成或拒绝处理函数内部，如果返回一个值或者抛出一个异常。新返回的 promise（可链接的）就相应的决议，默认情况下，如果你没有捕捉.then 的异常，它假定你想要 promise 状态吞掉所有的错误，如果你忘记查看这个状态，这个错误就会默默地在暗处凋零 所以为了避免被忽略的错误，promise 链的最佳实践就是最后总以一个 catch 结束 诸如 1234567var p = Promise.resolve(42);p.then(function fulfilled(msg){ console.log(msg.toLowerCase())}).catch((error) =&gt; { console.log('捕获错误',error)}) 这样儿可以成功的捕获错误 但是 reject() 函数的任何异常都会被作为一个全局未处理的错误抛出 Promise 其他的 APIPromise.done(..)标示 promise 链的结束done () 不会创建和返回 promise Promise.all([])在异步序列中，任意时刻都只能有一个异步任务正在执行但是我们如果想要同时执行两个或更多步骤（“并行执行”）的时候，Promise.all([]) 的魅力就体现出来了 Promise.all ([]) 接收一个数组，值可以是（promise，thenable，甚至是立即值），列表里的每个值都要经过 Promise.resolve () 过滤，以确保要等待的是一个真正的 promise，从返回的 promise 数据也是一个数组，与传入的顺序一致 如果返回的主 promise 在且仅在所有成员 promise 都完成后才会完成 如果有热和一个被拒绝，主 promise 就会立即被拒绝，并丢弃来自其他所有 promise 的结果 所以 要为每个 promise 关联一个错误处理函数 传入空数组时，它会立即完成 Promise.race([])与 promise.all 类似它一旦有人黑一个 promise 决议为完成，promise.race 就会完成，一旦有任何一个 promise 决议为拒绝，它就会拒绝 它的完成值是单个消息，并不像 promise.all 那样儿是一个数组，其他的 promise 会被丢弃或者忽略 两者都会创建一个 promise 作为他们的返回值，这个 promise 的决议完全由传入的 promise 数组控制 传入空数组时，它会挂住，且永远不会决议 Promise.finally()从行为的角度上 有些开发者提出，promise 需要一个 finally() 的回调注册，这个回调在 promise 决议后总是会被调用，并且允许你执行任何必要的清理工作 如下 12345var p = Promise.resolve(42);p.then(()=&gt;{}).finally(cleanup).then(()=&gt;{}).finally(cleanup) finally 会创建并返回一个新的 promise 以支持链接继续 new Promise (..) 构造器构造器 Promise 必须和 new 一起使用，并且必须提供一个函数回调，这个回调是同步的，这个函数接收到两个函数回调，用以支持 promise 的决议 12var p = new Promise(function(resolve,reject){}) 创建两种决议的快捷方式 Promise.resolve// 用于创建一个已完成的 promise Promise.reject// 用于拒绝这个 promise 以下是等价的 12345var p = new Promise(function(resolve,reject){reject('oop');})var p = Promise.reject('oop') ##promise 的局限性 顺序错误处理 1他们链接的方式 promise链中的错误容易被无意中忽略掉 单一值 1promise只能有一个完成值或一个拒绝理由 对于复杂的场景信息有点局限 单决议 无法取消的 promise 1一旦创建了一个promise并为其注册了完成和拒绝处理函数，如果出现某种情况使得这个任务悬而未决的话 你也没有办法从外部停止它的进程 promise 性能 12更多的工作更多的保护 promise与回调相比 会慢一点但是作为交换你得到的是大量内建的可信任性 小结 promise 非常好 他们解决了我们因只用回调的代码而备受困扰的控制反转的问题 它并没有摒弃回调，只是把回调的安排转交给了一个位于我么和其他工具之间的可信任的中介机制 promise 也开始提供（尽管不完美）以顺序的方式表达异步流的一个更好的办法，这有助于我们的大脑更好的几乎是和维护异步 js 代码 #第二阶段 (生成器 Generator 时期) 先来回顾一下 回调表达异步控制流程的两个关键缺陷 基于回调的异步不符合大脑对任务步骤的规划方式 由于控制反转回调并不是可信任的 然后我们用 Promise 解决了如何把回调的控制反转 反转回来，恢复了可信任性但是它不会暂停现在我们寻求一种顺序，看似同步的异步流程控制表达这个 (.then () 钱嵌套多了也受不了)，引出了 ES6 生成器的概念 Generator 最大的特点就是可以控制函数的执行它会创建出一个迭代器Generator 函数是一个状态机，封装了多个内部状态。调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是遍历器对象（Iterator Object） 它打破了完整执行 我们不再依赖一个函数一旦开始执行，就会运行到结束，期间不会有其他代码能够打破它并插入其间的假定 ES6 中指定暂停点的语法是 yield 这样礼貌的表达了一种合作式的控制放弃 如下 1234567891011121314151617var x = 1;function *foo(){ x++; yield; console.log('x:',x);}function bar(){ x++}var it = foo(); //构建了一个迭代器 并没有执行fooit.next(); //启动生成器 *foo 并运行了第一行的 x++ *foo在yield处暂停console.log('sws',x) //2bar();console.log('二',x) //3it.next(); //最后从暂停处恢复了生成器 *foo的执行 运行了 console.log('x:',x); //3 生成器是一种特殊的函数，可以一次或者多次的启动和停止 构建生成器是作为异步流程控制的代码模式的基础构件之一 我们可以看到 我们在暂停之后做了我们想做的操作 还执行了我们想要执行的函数 bar 生成器的输入和输出var it = foo(); 这行只是创建了一个生成器对象，把它赋给了变量 it，用于控制生成器，它是特殊的函数，也具有函数的特质，可以传递参数it.next() 指定生成器从当前位置开始继续运行，停在下一个 yield 处或者直到生成器结束，它调用的结果是一个对象，有一个 value 属性，持有从 *foo 返回的值（如果有的话）也就是说 yield 会导致生成器在执行过程中发送出一个值 (类似 return) 如下 1234567function *foo(x,y){ return x * y;}var it = foo(6,7); var obj = it.next(); console.log(obj) //{value: 42, done: true} 迭代消息传递通过 yield 和 next 实现的内建消息输入输出能力 next() 调用要比 yield 语句多一个因为第一个 next() 总是启动一个生成器，并运行到第一个 yield 处，执行第一次 next 时候，传递参数值会被忽略 第一个 yield 基本上是提出了一个问题：我的值是多少？谁来回答这一个问题 显然第一个 next 已经执行，因此由第二个 next 调用回答第一个 yield 提出的这个问题 从迭代器的角度看问题 消息是双向传递的 next 也可以向暂停的 yield 表达式发送值 yield 作为一个表达式可以发出消息响应 next 的调用 这里有一个例子能帮助你理解 generator 的执行 12345678910111213141516171819202122232425//yield基本上就是提出了个问题 我的值等于什么 然后由下一个next()传递的参数回答function *foo(x){ let y = 2 *(yield(x+1)); let z = yield(y/3); return x + y + z }let it = foo(5);console.log(it.next()) //{value: 6, done: false}console.log(it.next(12)) //{value: 8, done: false}console.log(it.next(13)) //{value: 42, done: true}/*解析generator函数调用和普通函数不同 它会返回一个迭代器执行第一次next时候，传递参数值会被忽略，并且函数暂停在yield(x+1)处 所以返回 5+1执行第二次next时，传入的参数等于上一个yield的返回值 如果你不传参，yield永远返回undefined，此时 let y = 2 * 12 = 24，所以第二个z是24/3 =8当执行第三次next时 传递的参数会传递给z，所以z=13 x = 5 y = 24 相加等于42*/ 多个迭代器每次构建一个迭代器实际上就是隐式构建生成器的一个实例 通过这个迭代器控制的是这个生成器的实例 同一个生成器的多个实例可以同时运行它们甚至可以彼此交互 生产者与迭代器假设你要产生一系列值，其中每个值都与前面一个有特定的关系 需要一个有状态的生产者能够记住其生成的最后一个值在此之前 我们可以使用函数闭包来实现 迭代器是一个定义良好的接口，用于从一个生产者一步步得到一系列值，js 迭代器的接口与多数语言类似，就是每次想要从生产者得到下一个值的时候调用 next ()next 调用返回一个对象有两个属性 12done是一个布尔值 表示迭代器的完成状态value中放置迭代值 同步错误处理类似 1234567try{ var text = yield foo(11,31); console.log(text)}catch(err){ console.log(err)} 生成器 yield 暂停的特性意味着我们不仅能从异步函数调用的到看似同步的返回值，还可以同步捕获来自这些异步函数调用的错误 它使得生成器能够捕获错误是一个很大的进步 第四阶段（async/await 时期 ES7）ES6 中最完美的时间就是生成器（看似同步的代码）和 promise（可信任可组合）的结合 我们不再 yield 出 Promise 而是用 await 等待它决议它其实就是把前面的经验写进规范 ES7 的 esync 函数对于 ES6 的 generator 函数的改进体现了哪些方面 内置执行器 12345generator函数的执行必须依赖于执行器，而async函数自带执行器，也就是说async函数的执行，与普通函数一模一样，只需要一行asyncReadFile();像这样 直接调用函数 就可以直接得出结果 不像generator函数，需要调用next方法或者co模块 才能真正执行得到最后的结果 更好的语义 12async和await比起 * 和 yield 语义更清楚了async表示函数有异步操作，await表示紧跟在后面的表达式需要等待的结果 更广的适用性 1co模块规定 yield命令后面只能是thunk函数或者promise对象，而async函数的await后面 可以是promise对象和原始类型的值（数值，布尔等但这等同于同步操作） 返回值是 promise 123async函数返回的是promise对象，这比generator函数的返回值是 Iterator对象方便多了，你可以用then方法指定下一步的操作进一步说 async函数可以看作是多个异步操作包装成的一个promise对象，而await命令就是内部then命令的语法糖 特点 一个函数如果加上 async 那么它就会返回 promise async 就是将函数返回值使用 Promise.resolve () 包裹了下，和 then 中处理返回值一样 await 是异步操作，它内部实现了 generator, 如果后来的表达式不返回 promise 的话，它就会被包装成 Promise.resolve (返回值)，然后去执行函数的同步代码 看下面这个等价的例子 1234567891011121314151617181920async function async1(){ await async2(); console.log('async1 end')}async function async2(){ console.log('async2 end')}async1();等价于new Promise((resolve,reject)=&gt;{ console.log('async2 end') resolve(Promise.resolve()) //Promise.resolve()决议之后将then代码插入到微任务队列的尾部}).then(()=&gt;{ console.log('async1 end')}) async 及 await 配合使用 await 就是 generator 加上 promise 的语法糖 async/await 是异步的终极解决方案 优缺点 优势 处理 then 的调用链，能更清晰的写出来代码，毕竟写一堆 then 也很 能解决回调地狱的问题 缺点 因为 await 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 await 导致性能上的降低 如下 123456async function test(){ await fetch(url) await fetch(url2) await fetch(url3)}这样儿的代码 如果没有依赖最好用promise.all #总结 生成器是 ES6 的一个新的函数类型 它并不像普通函数那样总是运行到结束，取而代之的是生成器可以在运行当中（完全保持其状态）暂停 并且将来再从咱题 ing 的地方恢复运行 这种简体的暂停和恢复是合作型的不是抢占型的，这意味着生成器具有独一无二的能力来暂停自身，这是通过关键字 yield 来实现的 不过 只有控制生成器的迭代器具有恢复生成器的能力（next (..)） yield/next 不只是控制机制 实际上也是一种双向消息传递机制 yield 表达式备注上是暂停下来等待某个值 接下来的 next 调用则是会向被暂停的 yield 表达式传回一个值 在异步控制流程方便生成器的关键优点是 生成器内部的代码是以自然的同步 / 顺序方式表达任务的一系列步骤，其技巧在于 我们把可能的异步隐藏在关键字 yield 的后面 把异步移动到控制生成器的迭代器的代码部分 换句话说 生成器为异步代码保持了顺序同步 阻塞的代码模式 这使得大脑可以更自然的追踪代码 解决了基于回调的异步的缺陷","categories":[{"name":"js","slug":"js","permalink":"http://maying.ink/categories/js/"}],"tags":[{"name":"promise","slug":"promise","permalink":"http://maying.ink/tags/promise/"}]},{"title":"你不知道的 JS 系列 - 细说 JS 继承","slug":"jsIInheritance","date":"2019-03-15T08:16:28.000Z","updated":"2020-10-22T18:41:42.182Z","comments":true,"path":"2019/03/15/jsIInheritance/","link":"","permalink":"http://maying.ink/2019/03/15/jsIInheritance/","excerpt":"面向对象语言支持两种继承方式：接口继承（只继承方法签名）和实现继承（继承实际的方法）由于函数没有签名，ECMAScript 只支持实现继承，而实现继承主要是依靠原型链实现的 下面就当下几种继承方式做一个对比参考","text":"面向对象语言支持两种继承方式：接口继承（只继承方法签名）和实现继承（继承实际的方法）由于函数没有签名，ECMAScript 只支持实现继承，而实现继承主要是依靠原型链实现的 下面就当下几种继承方式做一个对比参考 原型链继承核心思想：利用原型让一个引用类型继承另一个引用类型的属性和方法（将父类的实例作为子类的原型） 举个🌰1234567891011121314151617181920212223function SuperType(){ this.name = 'yishu';}SuperType.prototype.sayName = function(){ return this.name}function SubType (){ this.age = 25;} //原型链继承 SubType.prototype = new SuperType(); SubType.prototype.sayAge = function(){ return this.age } var instance = new SubType(); //原型链继承 console.log('age',instance.age) // 25 console.log('name',instance.name) //yishu console.log('sayName',instance.sayName()) //yishu console.log('sayAge',instance.sayAge()) //25 console.log(' instance.toString()', instance.toString()) //[object Object] 优点 纯粹的继承关系，实例是子类的实例，也是父类的实例 父类新增原型方法 / 原型属性，子类都能访问到 简单 易于实现 缺点 无法实现多继承 创建子类型的实例时，不能向超类型的构造函数中传递参数 包含引用类型值的原型会被所有的实例共享，通过原型来实现继承的时候，原型实际上会变成另一个类型的实例，于是原来的实例属性也就变成了现在的原型属性了 (来自原型对象的所有属性被所有实例共享) 想要为子类添加属性或方法 只能在 new SubType() 之后 推荐指数：❤️ （3，4 问题比较致命） 借用构造函数核心思想：使用父类的构造函数来增强子类实例，相当于复制父类的实例属性给子类（没用到原型） （不涉及到原型） 技术原理：在子类型构造函数的内部调用超类型构造函数 ** 插播:** 函数只不过是在特定环境中执行代码的对象，因此 你可以通过使用 apply 或者 call 方法也可以在将来新创建的对象上执行构造函数 举个🌰 123456789101112131415function SuperType(){this.colors = ['red','blue'];}function SubType(){SuperType.call(this) //继承了SuperType}var instance1 = new SubType();instance1.colors.push('black')console.log(instance1.colors) //[\"red\", \"blue\", \"black\"]var instance2 = new SubType();console.log(instance2.colors) &nbsp;//[\"red\", \"blue\"] 优点 解决实例共享问题 1这样儿会在`SubType`对象上执行`SuperType`函数中定义的所有对象初始化代码，`SubType`的每个实例就都会具有自己`colors`属性的副本了 解决传递参数的问题 12345678910function SuperType(name){this.name= name}function SubType(name,age){SuperType.call(this,name) //继承了SuperType 同时传递了参数this.age = age;}var instance = new SubType('yishu',18); 可以实现多继承（call 多个父类对象） 缺点 只能继承父类的实例属性和方法，不能继承原型属性和方法 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能 推荐指数：❤️❤️（缺点 2 比较致命） 组合继承（最常用的继承模式）核心思想：将原型链和构造函数的技术组合到一起 从而发挥二者之长 技术原理：使用原型链实现对原型属性和方法的继承使用构造函数来实现对实例属性的继承这样能实现在原型上定义方法实现了函数的服用又能保证每个实例有它自己的属性 举个🌰1234567891011121314151617181920212223242526272829function SuperType(name){ this.name = name; this.colors = ['red','blue','green']}SuperType.prototype.sayName = function(){ return this.name}function SubType (name,age){ SuperType.call(this,name); //继承实例属性 （第二次调用SuperType()） this.age = age;} SubType.prototype = new SuperType(); //继承原型属性和方法（第一次调用SuperType()） SubType.prototype.sayAge = function(){ return this.age; }var instance1 = new SubType('yishu',25);instance1.colors.push('yellow');console.log('instance1.colors',instance1.colors); // [\"red\", \"blue\", \"green\", \"yellow\"]console.log('instance1.name',instance1.sayName()); //yishuconsole.log('instance1.age',instance1.sayAge());//25var instance2 = new SubType('Grei',29); console.log('instance2.colors',instance2.colors); //[\"red\", \"blue\", \"green\"]console.log('instance2.name',instance2.sayName());//Greiconsole.log('instance2.age',instance2.sayAge());//29 优点 可以继承实例属性 / 方法，也可以继承原型属性 / 方法 不存在引用属性共享问题 可传参 函数可复用 缺点调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了） 1234具体的过程第一次调用的时候 SubType.prototype 会得到两个属性 name和colors 他们都来自于 SuperType 但是现在位于 SubType的原型中 当调用SubType构造函数时 又会调用一次SuperType的构造函数 这一次又在新对象SubType上创建了实例属性 name和colors 于是这两个属性屏蔽了原型中同名属性 推荐指数：❤️❤️❤️❤️（仅仅多消耗了一点内存） 原型式继承核心原理：借助原型可以基于已有的对象创建新的对象 同时还不必因此创建自定义类型 ES5 以前 12345678910111213141516171819202122232425function ObjectCreate(o){ function F(){} //创建了一个临时性的构造函数 F.prototype = o;//将传入的对象当作这个构造函数的原型 return new F(); //返回这个临时类型的新实例}ObjectCreate 方法本质上对传入其中的对象执行了一次浅复制var person = { name:'yishu', friends:['xiaohong','xiaoming']}var instance1 = ObjectCreate(person);instance1.age = 45;instance1.friends.push('xiaolan');console.log('instance1',instance1.age); //45console.log('instance1',instance1.friends);//&nbsp;[\"xiaohong\", \"xiaoming\", \"xiaolan\"]console.log('person.friends',person.friends)//[\"xiaohong\", \"xiaoming\", \"xiaolan\"]console.log('person.age',person.age)//undefinedvar instance2 = ObjectCreate(person);console.log('instance2',instance2.age); //undefinedconsole.log('instance2',instance2.friends);//[\"xiaohong\", \"xiaoming\", \"xiaolan\"] ES5 以后 通过新增 Object.create(obj1，obj2) 规范化了原型式继承 obj1：用做新对象原型的对象 obj2（可选）为新对象定义额外属性的对象 在传入一个参数的情况下与 ObjectCreate 函数功能相同 12345678910111213141516var person = { name:'yishu', friends:['xiaohong','xiaoming']}var otherPerson = Object.create(person);otherPerson.name='maying';otherPerson.friends.push('wqs');console.log('otherPerson',otherPerson.name) // mayingconsole.log('otherPerson',otherPerson.friends) //&nbsp;[\"xiaohong\", \"xiaoming\", \"wqs\"]var otherPerson1 = Object.create(person,{name:{value:'dsdd'}});console.log('otherPerson1',otherPerson1.name) //dsddconsole.log('otherPerson1',otherPerson1.friends)//&nbsp;[\"xiaohong\", \"xiaoming\", \"wqs\"] 缺点 不是类式继承，而是原型式基础，缺少了类的概念 对于引用类型值的属性依然是 共享状态的，这相当于创建了两个 person 的副本 寄生式组合继承（最理想的继承范式）核心原理：借用构造函数来继承属性通过原型链的混成形式来继承方法 技术原理： 不必为了指定子类型的原型而调用超类型的构造函数 我们所需要的无非就是超类型原型的一个副本而已（使用寄生式来继承超类型的原型 然后再将结果指定给子类型的原型 ） 举个🌰 1234567891011121314151617181920212223242526272829303132333435363738394041function inhertPrototype(SubType, SuperType){ var prototype = Object.create(SuperType.prototype); //创建对象 prototype.constructor = SubType; //如果你创建了一个新对象并替换了函数默认的.prototype对象引用,那么新对象不会自动获得.constructor属性 SubType.prototype = prototype;//指定对象}function SuperType(name){ this.name = name; this.colors = ['red','blue','green'];}SuperType.prototype.sayName = function(){ alert(this.name);}function SubType(name,age){ SuperType.call(this, name);//第二次调用SuperType() this.age = age;}inhertPrototype(SubType, SuperType);SubType.prototype.sayAge = function(){ alert(this.age); }var dd = new SubType('yishu',22);dd.colors.push('gold');console.log('dd',dd.colors); //[\"red\", \"blue\", \"green\", \"gold\"]dd.sayAge(); //22dd.sayName(); //yishuvar cc = new SubType('xiaogou',10);console.log('cc',cc.colors); [\"red\", \"blue\", \"green\"]cc.sayAge(); //10cc.sayName();//xiaogou 优点完美 它只调用了一次构造函数 避免了在 SubType.prototype 上创建不必要的属性 与此同时 原型链还能保持不变缺点 实现不如组合式继承简单 推荐指数：❤️❤️❤️❤️（复杂度扣掉一颗心） 总结ECMAscript 支持面向对象编程 但是不使用类或者接口 对象可以在代码执行过程中创建或增强 因此具有动态性而非严格定义的实体 在没有类的情况下 可以采用下列模式创建对象 工厂模式 1使用简单的函数创建对象 为对象天假属性和方法 然后返回对象被构造函数模式取代 构造函数模式 1234可以创建自定义引用类型 可以像创建内置对象实例一样使用new缺点：成员无法复用 包括函数 原型模式 123使用构造函数的prototype属性来指定那些应该共享的属性和方法组合使用 构造函数模式和原型模式 分别定义属性和方法 js 主要通过原型链实现继承 原型链的构建是通过将一个类型的实例复制给另一个构造函数的原型实现的，这样子类型就能访问到超类型所有的属性和方法 这一点与基于类的继承很相似。 原型链的问题是对象实例共享所有的属性和方法 因此不适合单独使用解决这个问题的技术是借助构造函数 （在子类型构造函数中的内部调用超类型的构造函数） 这样就能做到每个实例具有自己的属性 同时还能保证只使用构造函数模式来定义类型 使用最多的继承模式是组合继承通过原型链继承共享的属性和方法而通过借用构造函数继承实例属性 还有其他继承模式 原型式继承 1可以在不必预先定义构造函数的情况下实现继承 本质是执行对给定对象的浅复制 而复制的副本还可以进行进一步的加强 改造 寄生式继承 1与 原型式继承相似 寄生组合式继承 12集寄生式继承和组合继承的优点与一身是实现基于类型继承的最有效的方式 参考JavaScript 高级程序设计（第三版）","categories":[{"name":"js","slug":"js","permalink":"http://maying.ink/categories/js/"}],"tags":[]},{"title":"深入理解 Flexbox","slug":"flex","date":"2019-03-14T11:08:59.000Z","updated":"2020-10-22T18:41:42.182Z","comments":true,"path":"2019/03/14/flex/","link":"","permalink":"http://maying.ink/2019/03/14/flex/","excerpt":"前言过去，我们总是不得不忍受 float、display:table 这些布局方式带来的痛苦，不过现在是时候去拥抱一个更简洁的制作智能布局的现代语法 Flexbox Flexbox 是什么根据规范中的描述可知道，Flexbox 模块提供了一个有效的布局方式，即使不知道视窗大小或者未知元素情况之下都可以智能的，灵活的调整和分配元素和空间两者之间的关系","text":"前言过去，我们总是不得不忍受 float、display:table 这些布局方式带来的痛苦，不过现在是时候去拥抱一个更简洁的制作智能布局的现代语法 Flexbox Flexbox 是什么根据规范中的描述可知道，Flexbox 模块提供了一个有效的布局方式，即使不知道视窗大小或者未知元素情况之下都可以智能的，灵活的调整和分配元素和空间两者之间的关系 如何开始使用 Flexbox幸运的是，入门超级简单你要做的第一件事就是声明一个 Flex 容器 就像这样儿，声明了 Flex 容器之后，一个 Flexbox 格式化上下文就立即启动了 12345&lt;ul class=\"oul\"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt;&lt;/ul&gt; 正常情况下 div 在 CSS 中垂直堆栈的，也就是说从上到下排列显示 图一 声明 Flex容器 12345.oul { //... display: flex //...} 现在已经是一个 Flexbox 格式化上下文图二 很简单 一行代码就能看到布局改变了子元素就像你使用了 float 一样是水平排列的 拿这个例子来说此时 ul 自动变成了 Flex，而 li 变成了 Flex 项目 记住这些名词，它们是 Flexbox 模块的基础 Flex 容器属性flex-direction || flex-wrap || flex-flow || justify-content || align-items || align-content 解释这些属性之前，先来看一张 flex 世界比较重要的概念 Main-Axis 就是水平方向，从左到右，这也是默认方向 Cross-Axis 是垂直方向，从上往下 flex-direction属性值 1ul { flex-direction: row || column || row-reverse || column-reverse; } 默认值是 row 它让 Flex 项目沿着 Main-Axis 排列（从左向右，水平排列） 这也解释了图二的效果 flex-wrap属性值 12345ul { flex-wrap: wrap || nowrap || wrap-reverse; }* nowrap: Flex容器内的Flex项目不换行排列 （默认值）* wrap:换行排列 这种情况下，一行不能包含所有列表项的默认宽度，它们就会多行排列* wrap-reverse:反向换行 flex-flow1flex-flow是flex-direction和flex-wrap两个属性的速记属性 语法 1ul { flex-flow: row wrap; } justify-content接下来感受来自 flex 容器的魔法 它主要定义了 Flex 项目在 Main-Axis 上的对齐方式 属性值 123456ul { justify-content: flex-start || flex-end || center || space-between || space-around }* flex-start 元素位于容器的开头。弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。* flex-end 元素位于容器的结尾，弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界* center：居中对齐* space-between：让除了第一个和最一个Flex项目的两者间间距相同（两端对齐）* space-around：让每个Flex项目具有相同的空间 space-betweenspace-around 和 space-between 有点不同，第一个 Flex 项目和最后一个 Flex 项目距 Main-Axis 开始边缘和结束边缘的的间距是其他相邻 Flex 项目间距的一半 align-items它主要用来控制 Flex 项目在侧轴上的对齐方式 1234567ul { align-items: flex-start || flex-end || center || stretch || baseline }* stretch 默认值 让所有的Flex项目高度和Flex容器高度一样。* flex-start 元素位于容器的开头。弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。* flex-end 元素位于容器的结尾，弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界* center 元素位于容器的中心* baseline 让所有Flex项目在Cross-Axis上沿着他们自己的基线对齐 baseline效果类似 flex-start 但略有不同区别就在于 baseline align-content12345678ul { align-items: stretch|center|flex-start|flex-end|space-between|space-around}* stretch 默认值 元素被拉伸以适应容器* flex-start 元素位于容器的开头。弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。* flex-end 元素位于容器的结尾，弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界* center 元素位于容器的中心* space-between：让除了第一个和最一个Flex项目的两者间间距相同（两端对齐）* space-around：让每个Flex项目具有相同的空间 stretchflex-end flex-start center Flex 项目属性1order || flex-grow || flex-shrink || flex-basis order允许 Flex 项目在一个 Flex 容器中重新排序。基本上，你可以改变 Flex 项目的顺序，从一个位置移动到另一个地方而不改变源代码，所有 Flex 项目的 order 值都是 0，Flex 项目会根据 order 值从低到高重新排序 1234.oul li:nth-child(1) { order: 1; /*设置一个比0更大的值*/} Flex 项目 2、3、4 的 order 值为 0。现在 Flex 项目 1 的 order 值为 1 Flex 项目 2、3和4的order 值都是 0。HTML 源代码秩序并没有修改过。如果给 Flex 项目 2 的 order 设置为 2 可见 它也增加堆栈。现在代表 Flex 项目的最高的 order 值 当两个 Flex 项目具有相同的 order 值呢？在下面的示例中，把 Flex 项目 1 和 3 设置相同的 order 值。现在仍是从低到高排列。这次 Flex 项目 3 排在 Flex 项目 1 后面，那是因为在 HTML 文档中 Flex 项目 3 出现在 Flex 项目 1 后面。 如果两个以下 Flex 项目有相同的 order 值时，Flex 项目重新排序是基于 HTML 源文件的位置进行排序 flex-grow 和 flex-shrink flex-grow ：控制 Flex 项目在容器有多余的空间如何放大（扩展）默认值是 0 表示开关是关闭的，即如果存在剩余空间，也不放大 123.item { flex-grow: &lt;number&gt;; /* default 0 */} 属性值为 1 时 现在 Flex 项目扩展了，占据了 Flex 容器所有可用空间。也就是说开关打开了。如果你试着调整你浏览器的大小，Flex 项目也会缩小，以适应新的屏幕宽度 如果所有项目的 flex-grow 属性都为 1，则它们将等分剩余空间（如果有的话）如果一个项目的 flex-grow 属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍 flex-shrink：属性定义了项目的缩小比例，默认为 1（默认开启），即如果空间不足，该项目将缩小 123.item { flex-shrink: &lt;number&gt;; /* default 1 */} flex-basis它用于设置或检索弹性盒伸缩基准值浏览器根据这个属性，计算主轴是否有多余空间一般配合 flex-wrap 一起使用，flex 容器根据 flex-basis 计算是否需要换行 一些特性 1. 它的属性值可以是长度单位 (em || rem || px)** 或百分比 (%)**，百分比是按照父元素的 width 为标准2. 默认值为 auto MDN 12取值为**auto**时，它的值就等于当前项的**width**（或者默认的大小，width没有设置的话）\" flex-basis:auto\" 的含义是 \"参照我的width和height属性 当 flex-item 没有自身宽高，其默认大小由 flex-basis 决定即优先级： flex-basis &gt; width (非 auto) 123456.oul2-li{ flex-basis: 200px; width: 10px; margin: 0px 4px; background: red; } 4. 当元素存在默认宽高（input）并且设置了 flex-basis，那么它的初始大小以固定宽高为下限，如果 flex-basis 超过了固定宽高，那么以 flex-basis 设置大小为准，如果 flex-basis 比固定宽高小，那么以固定宽高为准 1234.Myinput { background: greenyellow; flex-basis: 200px; } 当将 flex-basis 设置的比默认宽度大 当将 flex-basis 设置的比默认宽度小 100 5. 当元素存在 min-width [height] 或者 max-width [height]12如果 `flex-basis` 的值 大于 `min-width[min-height]`，`flex-item content`的值为 `flex-basis`如果`flex-basis `的值小于` min-width[min-height]` 那么`flex-item content`以`min-width[min-height]`计算 6. 元素设置 width[height]: auto;CSS 解析器对比两者的值，两者谁大取谁作为 item 的基本尺寸，如果一个 item 没有内容，flex-item 初始大小就会以 flex-basis 来决定但是如果 item 有了内容，且内容撑开的尺寸比 flex-basis 大，那么 flex-item 初始大小就会以 width[height]: auto; 来决定优先级：width[height]: auto == flex-basis 12345678910111213141516171819202122 &lt;ul class=\"oul2\"&gt; &lt;li class=\"li1\"&gt;666666666666666666666666666666666666666666666666666666666666666666666666666666666666&lt;/li&gt; &lt;li class=\"li2\"&gt;77777&lt;/li&gt; &lt;/ul&gt; .li1{ flex-basis: 100px; margin-right: 5px; background: greenyellow; width: auto;}.li2{ flex-basis: 300px; width: auto; background: red;}.oul2{ display: flex; list-style: none; border: 1px solid #ccc;} 绝对和相对 Flex 项目绝对 Flex 项目的宽度只基于 flex 属性，而相对 Flex 项目的宽度基于内容大小 相对项目 1234567891011.oul { display: flex; /*触发弹性盒*/ } .oul li { //flex-basis: auto; flex: auto; /*记住这与 flex: 1 1 auto; 相同*/ border: 2px solid red; margin: 2rem; } Flex 项目的初始宽度是被自动计算的（flex-basis: auto），然后会伸展以适应可用空间（flex-grow: 1） 像这样 当 Flex 项目因为被设置为 flex-basis: auto，而导致宽度被自动计算时，是基于 Flex 项目内包含的内容的大小而计算的就是相对项目 绝对项目 12345678.oul li { flex-grow: 1; flex-shrink: 1; flex-basis: 0; /*与 flex: 1 1 0 相同*/ border: 2px solid red; margin: 2rem; } Flex 项目的初始宽度是零（flex-basis: 0），并且它们会伸展以适应可用空间。当有两到多个 Flex 项目的 flex-basis 取值为 0 时，它们会基于 flex-grow 值共享可用空间 flex 组合属性flex 是 flex-grow、flex-shrink和flex-basis 三个属性的速记（简写）顺序缩写为 GSB 一些取值规律当 flex 取值为一个非负数字，则该数字为 flex-grow 值，flex-shrink 取 1，flex-basis 取 0%，例如：flex: 1; 相当于 12345li { flex-grow: 1; flex-shrink: 1; flex-basis: 0%;} ⚠️ flex-basis的默认值为 auto，为什么此时是 0%？当你创建一个 flexbox 上下文而不给 flex 项目设置任何属性，此时的默认值此时它是相对项目一旦你设置了 flex:1 简写属性 参考 MDN 所说浏览器使其变成了绝对项目 flex: auto; 123456li { flex-grow: 1; flex-shrink: 1; flex-basis: auto;} 当 flex 取值为一个长度或百分比，则视为 flex-basis 值，flex-grow 取 1，flex-shrink 取 1，有如下等同情况（注意 0% 是一个百分比而不是一个非负数字） 123456789101112.item-1 {flex: 0%;}.item-1 { flex-grow: 1; flex-shrink: 1; flex-basis: 0%;}.item-2 {flex: 24px;}.item-1 { flex-grow: 1; flex-shrink: 1; flex-basis: 24px;} 当 flex 取值为两个非负数字，则分别视为 flex-grow 和 flex-shrink 的值，flex-basis 取 0%，如下是等同的： 123456.item {flex: 2 3;}.item { flex-grow: 2; flex-shrink: 3; flex-basis: 0%;} 当 flex 取值为一个非负数字和一个长度或百分比，则分别视为 flex-grow 和 flex-basis 的值，flex-shrink 取 1，如下是等同的： 123456.item {flex: 2333 3222px;}.item { flex-grow: 2333; flex-shrink: 1; flex-basis: 3222px;} 深入 flex到这里 关于 Flex 的基础知识已经结束了，你可以用它们处理几乎任何问题但是Flexbox 是如何弹性的计算子级项目的大小的，它有没有什么规则 令我费解 好了，小🌻课堂开始了 flex 是应用在 X 轴和 Y 轴上的每一根轴都包括三个东西 维度、方向、尺寸 维度：子元素横着排 (X 轴) 还是竖着排 (Y 轴) 方向：子元素的顺序 (顺序还是逆序) 尺寸：即父元素的 width，子元素在当前轴方向所占的位置的总和 如下图所示（来自 W3C 规范） FFC(flex formatting context)Flexbox 布局新定义了格式化上下文，类似 BFC（block formatting context）定义了 display: flex; 或 display: inline-flex 的元素，和 BFC 一样，不会被浮动的元素遮盖，不会垂直外边距坍塌等等 与 BFC 的细微区别 vertical-align 对 Flexbox 中的子元素 是没有效果的 float 和 clear 属性对 Flexbox 中的子元素是没有效果的，也不会使子元素脱离文档流 (但是对 Flexbox 是有效果的！) Flexbox 下的子元素不会继承父级容器的宽 flex item（flex 子元素）CSS 解析器会把 定义了 display: flex; 和 display: inline-flex; 的 Flexbox 下的子元素外部装进一个看不见的盒子里，我们通过排列这些盒子来达到排序、布局、 伸缩的目的 flex-item-size 是如何计算的子元素的尺寸为主轴方向上元素的的自身宽度 再加上自身的 margin 、 border 和 padding W3C 规范中介绍了 flex-item content 的计算规则 隐藏属性对 items-size 的影响针对 display: none; visibility: hidden; visibility: collapse; transform: scale; 进行测试 结论 如果设置了 visibility: hidden; | visibility: collapse; | transform: scale; 的 flex-item content 依然被算进主轴尺寸，CSS 解析器依然将可用空间分配给他们 如果设置了 display: none; CSS 解析器不会对该 item 的空间进行计算 关于 position: absolute 对 item 影响position: absolute 也是适用 Flexbox 中的子元素的，并且，设置了 position: absolute 属性的子元素，也会受到 Flexbox 排列的影响 absolute 的子元素重叠在了一起，但是依然会受到 align-items: center; 的影响而居中 并且根据一系列的实验得知 flexbox 下设置了 absolute： flexbox 流下面的 justify-content 和 align-items item 的 top、left、right、bottom margin 自始至终都会影响 item 的位置 脱离了文档流的 item 不会影响正常的 flex 布局 小结justify-content、align-items 和 top、left、right、bottom 都是位置属性 且 top、left、right、bottom 的值会覆盖 justify-content、align-items 的值 margin 的优先级是和 top、left、right、bottom 一样的，也就是说 margin 和 top、left、right、bottom 所设置的值会同时生效 flex-basis、flex-grow、flex-shrink 以及相应的计算这三个属性只有父级元素设置了 display: flex | inline-flex; 才会生效，并且只针对主轴方向生效 如果 主轴是水平的，即 flex-direction: row; 那么 flex-basis、flex-grow、flex-shrink 控制的就是单个 item 的宽度 如果 主轴是垂直的，即 flex-direction: column; 那么 flex-basis、flex-grow、flex-shrink 控制的就是单个 item 的高度 那么所有 items 都会在主轴方向上的一条线上排列，CSS解析器会计算 items 在主轴方向上所占的空间 相对于 Flexbox 在主轴方向的所占的空间进行比较计算 如果 items 所占的空间是小于 Flexbox 的 那么说明 Flexbox 还没有填满，CSS解析器就会计算还有多少空间没有填满，根据每一个 item 所设置的 flex-grow 设置的值，将这些空间分配按比例分配给每一个 item 如果 items 所占的空间是大于 Flexbox 的 那么说明 Flexbox 被填满了，CSS解析器就会计算超出了多少空间，根据每一个 item 所设置的 flex-shrink 设置的值，将这些空间分配按比例缩小每一个 item 超出的空间是如何计算的flow-grow 的计算流程 1可用空间 = 将flexbox-content - 每个item-size的总和 将元素设置的 flow-grow 值加起来设置为 growSize单位分配空间 = 可用空间/growSize然后真正分配的时候根据自己的比例计算增加的值应该增加的值 = 自己的grow值 * 单位分配空间 flow-shrink 的计算流程 它的流程与 flow-grow 的计算流程不同 123shrink比例 = flex-shrink * item-size / 之前的总和应该缩减的值：超出的空间 - shrink比例 * item-size 如图所示 max-width [height] 情况下 flex-grow 的计算流程 由于可能存在某一个或多个 item 设置了有 max-width[height]。所以，CSS 引擎会先进行一次分配，分配后，统计那些有 max-width[height]的items, 分配后是否有超出的剩余空间，然后对这些剩余空间再分配给那些没有设置 max-width[height] 的 item min-width [height] 情况下 flex-shrink 由于可能存在某一个或多个 item 设置了有 min-width[height]。所以，CSS引擎会先进行一次 shrink， shrink 后，统计那些有 min-width[height] 的 items, shrink 后是否有的剩余的未 shrink 空间，然后对这些剩余空间再分配给那些没有设置 min-width[height] 的 item Flexbox 的浏览器支持让我们求助于 caniuse 总结深入理解 Flex 还是挺不容易的。 参考链接理解 flexbox，你需要知道的一切探索 Flexbox理解 flex","categories":[{"name":"CSS","slug":"CSS","permalink":"http://maying.ink/categories/CSS/"}],"tags":[{"name":"flex","slug":"flex","permalink":"http://maying.ink/tags/flex/"}]},{"title":"模拟实现 apply 和 call 方法","slug":"apply-call","date":"2019-03-13T08:12:37.000Z","updated":"2020-10-22T18:41:42.180Z","comments":true,"path":"2019/03/13/apply-call/","link":"","permalink":"http://maying.ink/2019/03/13/apply-call/","excerpt":"先来通过 MDN 认识下 call 和 apply语法func.apply(thisArg, [argsArray]) 参数thisArg：可选的，func 函数运行的时使用的 this 值","text":"先来通过 MDN 认识下 call 和 apply语法func.apply(thisArg, [argsArray]) 参数thisArg：可选的，func 函数运行的时使用的 this 值 ⚠️ 如果这个函数处于非严格模式下 指定其为 null 或者 undefined 时 this 绑定会应用默认规则（这在分析 js 指向问题时有提到） 如果 thisArg 是原始值会被包装称对象 .apply(2) 会被包装成.apply(Number(2)) argsArray：可选的。一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 func 函数。如果该参数的值为 null 或 undefined，则表示不需要传入任何参数。从 ECMAScript 5 开始可以使用类数组对象 返回值：调用有指定 this 值和参数的函数的结果 几个有用的例子感受下 apply 的魔力 求数组最大最小值 聪明的 apply 用法允许你在某些本来需要写成遍历数组变量的任务中使用内建的函数 使用 Math.max/Math.min 来找出一个数组中的最大 / 最小值 123456var numbers = [5, 6, 2, 3, 7];var max = Math.max.apply(null, numbers);console.log(max);var min = Math.min.apply(null, numbers);console.log(min); apply 设置的 this 值 12345678var doSth = function(a, b){ console.log(this); console.log([a, b]);}doSth.apply(null, [1, 2]); // this是window // [1, 2]doSth.apply(0, [1, 2]); // this 是 Number(0) // [1, 2]doSth.apply(true); // this 是 Boolean(true) // [undefined, undefined]doSth.call(undefined, 1, 2); // this 是 window // [1, 2] 用 apply 将一个数组添加到另一个数组 如果我们传递一个数组来推送，它实际上会将该数组作为单个元素添加，而不是单独添加元素，因此我们最终得到一个数组内的数组concat 确实具有我们想要的行为，但它实际上并不附加到现有数组，而是创建并返回一个新数组用 apply 就能简单实现 12345var array = ['a', 'b'];var elements = [0, 1, 2];array.push.apply(array,elements) //&nbsp;[\"a\", \"b\", 0, 1, 2]//array.push(elements) //)&nbsp;[\"a\", \"b\", 0, 1, 2, Array(3)]console.log(array); call () 与 apply () 非常相似 fun.call(thisArg, arg1, arg2, ...) call 和 apply 的不同点 apply 只接收两个参数，第二个参数可以是数组也可以是类数组，其实也可以是对象，后续的参数忽略不计 call 接收第二个及以后一系列的参数 小结重新认识了 call 和 apply 会发现它们作用都是一样的，改变函数里的 this 指向为第一个参数 thisArg，如果明确有多少参数，那可以用 call，不明确则可以使用 apply。也就是说完全可以不使用 call，而使用 apply 代替，我们只需要模拟实现 apply，call 可以根据参数个数都放在一个数组中，给到 apply 即可 模拟实现的准备工作模拟之前 我们先得看看 ES5 规范 关于 apply 摘抄以下几条 1234567891011121314151617Function.prototype.apply (thisArg, argArray)当以 thisArg 和 argArray 为参数在一个 func 对象上调用 apply 方法，采用如下步骤：1.如果 IsCallable(func) 是 false, 则抛出一个 TypeError 异常。2.如果 argArray 是 null 或 undefined, 则返回提供 thisArg 作为 this 值并以空参数列表调用 func 的 [[Call]] 内部方法的结果。3.返回提供 thisArg 作为 this 值并以空参数列表调用 func 的 [[Call]] 内部方法的结果。4.如果 Type(argArray) 不是 Object, 则抛出一个 TypeError 异常。...9.提供 thisArg 作为 this 值并以 argList 作为参数列表，调用 func 的 [[Call]] 内部方法，返回结果。apply 方法的 length 属性是 2。10.在外面传入的 thisArg 值会修改并成为 this 值。thisArg 是 undefined 或 null 时它会被替换成全局对象，所有其他值会被应用 ToObject 并将结果作为 this 值，这是第三版引入的更改 结合上文和规范 ，明确了要解决的问题，我们如何将函数里的 this（一般指向 window）指向第一个参数 thisArg 呢不由得想起来了介绍 this 指向那一篇文章那就采用隐式绑定呀，也就是说 既然他现有的上下文环境是 window（全局作用域）, 那我们就手动给他创建一个非全局上下文 看看这个熟悉的例子 123456789101112var doSth = function(){ console.log(this); console.log(this.name); console.log(arguments);}var student = { name: 'yishu', doSth: doSth,};student.doSth(1, 2); // this === student // true // 'yishu' // [1, 2]doSth.apply(student, [1, 2]); // this === student // true // 'yishu' // [1, 2] 你能看出来什么？ 在对象 student 上加一个函数 doSth，再执行这个函数，这个函数里的 this 就指向了这个对象 那我们就模拟这个对象，给他添加一个函数，使用函数调用之后再删除它 第一版本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 浏览器环境 非严格模式function getGlobalObject(){ return this;}Function.prototype.applyFn = function apply(thisArg,argsArray){ // 1.如果 `IsCallable(func)` 是 `false`, 则抛出一个 `TypeError` 异常。 if(typeof this !='function'){ throw new TypeError(this + 'is not function') } // 1.如果 `IsCallable(func)` 是 `false`, 则抛出一个 `TypeError` 异常。 if(typeof argsArray === 'undefined' || argsArray === null){ argsArray = []; } //3.如果 Type(argArray) 不是 Object, 则抛出一个 TypeError 异常 . if(argsArray !== new Object(argsArray)){ throw new TypeError('CreateListFromArrayLike called on non-object'); } //4.改变this的指向 在外面传入的 thisArg 值会修改并成为 this 值 如果传入的是 undefined或者null 则this指向应用默认绑定 if(typeof thisArg === 'undefined' || thisArg === null){ // ES3: thisArg 是 undefined 或 null 时它会被替换成全局对象 浏览器里是window thisArg = getGlobalObject(); } //开始表演 thisArg = new Object(thisArg); thisArg.fn = this; //接收返回值 var fnResult = thisArg.fn(...argsArray); delete thisArg.fn; return fnResult;}var doSth = function(){ console.log(this); console.log(this.name); console.log(arguments);}var student = { name: '马小莹', //doSth: doSth, //我们主要模拟了这个函数};doSth.applyFn(student, [1, 2]); // {name: \"马小莹\", doSth: ƒ, fn: ƒ}// 马小莹// Arguments(2)&nbsp;[1, 2, callee: ƒ, Symbol(Symbol.iterator): ƒ] 看起来很完美，那它有没有问题呢？ 其实是有的 .fn 函数同名覆盖问题，thisArg 对象上有 fn，那就被覆盖了然后被删除了 那我们就找一个唯一值的函数名 1234567thisArg = new Object(thisArg);var _fn = '__fn' + new Date().getTime();thisArg[_fn] = this;//接收返回值var fnResult = thisArg[_fn](...argsArray);delete thisArg[_fn];return fnResult; 到现在 简单版本的 apply 已经实现了，现实业务场景不需要去模拟实现 call和apply, 毕竟是 ES3 就提供的方法 既然实现了 apply,call 也就简单了，原理就是拿到 call 的参数 转换成数组，然后调用 applyFn 123456789Function.prototype.applyFn = function apply(thisArg){ var argsArray = []; var argumentsLength = arguments.length; for(var i = 0; i &lt; argumentsLength - 1; i++){ argsArray.push(arguments[i + 1]); } return this.applyFn(thisArg, argsArray);} 总结 通过 MDN 认识 call 和 apply，阅读 ES5 规范，到模拟实现 apply，再实现 call","categories":[{"name":"js","slug":"js","permalink":"http://maying.ink/categories/js/"}],"tags":[{"name":"call","slug":"call","permalink":"http://maying.ink/tags/call/"},{"name":"apply","slug":"apply","permalink":"http://maying.ink/tags/apply/"}]},{"title":"模拟实现 JS 的 bind 方法","slug":"bind","date":"2019-03-13T05:36:45.000Z","updated":"2020-10-22T18:41:42.181Z","comments":true,"path":"2019/03/13/bind/","link":"","permalink":"http://maying.ink/2019/03/13/bind/","excerpt":"为什么要实现一个 bind 函数？bind() 函数在 ECMA-262 第五版才被加入它可能无法在所有浏览器上运行，为了世界和平，必要的时候我们要手动实现它","text":"为什么要实现一个 bind 函数？bind() 函数在 ECMA-262 第五版才被加入它可能无法在所有浏览器上运行，为了世界和平，必要的时候我们要手动实现它 现有 bind 函数的功能？改造之前要清楚现有 bind() 函数做了哪些事儿 从 MDN 上找到一些关于它的定义 bind () 方法创建一个新的函数，在调用时设置 this 关键字为提供的值。并在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项 语法 function.bind(thisArg[, arg1[, arg2[, ...]]]) 函数会创建一个新绑定函数，它包装了原函数对象ceshiFn.bind(myObject) 绑定函数也可以使用 new 运算符构造，此时提供的 this 值会被忽略，但前置参数（arg1,arg2）仍会提供给模拟函数 12var Fn = ceshiFn.bind(myObject,1,2)new Fn() 此时 myObject 被忽略 但是 参数依然会传递给 ceshiFn 令其初始化 参数： thisArg：当被绑定的函数被调用时，将它的 this 关键字设置为 thisArg arg1，arg2: 被调用时，这些参数将传递给被绑定的方法 返回值：指定的 this 值和初始化参数改造过原函数拷贝 继续探索 bind 函数的功能123456var obj = {};console.log('obj',obj)console.log(typeof Function.prototype.bind) // bindconsole.log(typeof Function.prototype.bind()) //bindconsole.log(Function.prototype.bind.name) //bindconsole.log(Function.prototype.bind().name) // bound 由此我们可以得到得出以下结论 bind 是 Function 原型链中 Function.prototype 的一个属性，每个函数都可以调用它 bind 本身是一个函数名为 bind 的函数，返回值是一个名为 bound 的函数 下面这个例子 123456789101112131415161718var obj = { name: 'yishu',};function original(a, b){ console.log(this.name); console.log([a, b]); return false;}var bound = original.bind(obj, 1);var boundResult = bound(2); // 'yishu', [1, 2]console.log(boundResult); // falseconsole.log(original.bind.name); // 'bind'console.log(original.bind.length); // 1console.log(original.bind().length); // 2 返回original函数的形参个数console.log(bound.name); // 'bound original'console.log((function(){}).bind().name); // 'bound 'console.log((function(){}).bind().length); // 0 bind 是函数可被传参数，返回值 bound 也是函数，也可以传参数 被 bind() 绑定的函数的 this 关键字是 bind() 的第一个参数 传递 bind 的其他参数被接收处理了，bind() 之后返回的函数 bound 函数的参数也被接收处理了，也就是说被合并处理了 并且 bind() 后的 name 为 bound + 空格 + 调用bind的函数名。如果是匿名函数则是 bound + 空格 bind 后的返回值函数 bound，执行后返回值是原函数（original）的返回值 bind 函数形参（即函数的 length）是 1。bind 后返回的 bound 函数形参根据绑定的函数原函数（original）形参个数确定 到这里 我们根据得出的结论 就可以模拟一个简单版本的 bind 函数了 核心功能的 bindFn 函数1234567891011121314151617181920212223242526272829303132Function.prototype.bindFn = function(thisArg){ //保证是一个函数调用了bindFn函数 if (typeof this != 'function'){ throw new TypeError(this + 'must be a function'); } //保存除了thisArg之外的其他形参 转成数组 console.log('bindFn',arguments) let arg = [].slice.call(arguments ,1); var self = this; var bound = function(){ // bind返回的函数 的参数转成数组 var boundArgs = [].slice.call(arguments); // apply修改this指向，把两个函数的参数合并传给self函数，并执行self函数，返回执行结果 return self.apply(thisArg, arg.concat(boundArgs)); } return bound;}// 测试var obj = { name: 'yishu', age:18};function original(){ console.log([].slice.call(arguments))}var bound = original.bindFn(obj,3,4,5)bound(7); // [3, 4, 5, 7] 到这里基本上把 bind 的核心功能写完了，也能够适用大部分场景了 bindFn 只能能做到的只是永久地绑定指定的 this ，但是我们发现 MDN 上关于 bind函数描述 还有一种情况，那就是当你使用 new操作符调用绑定函数时是这么说的 thisArg：当使用 new 操作符调用绑定函数时，该参数无效。一个绑定函数也能使用 new 操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数 我们可以通过一个实例来看原生的 bind 对于使用 new 的情况是怎么样的 123456789var obj = { name: 'yishu',};function original(){ console.log('this', this.name,[].slice.call(arguments));}var bound = original.bind(obj,1);bound(2,3) //this yishu (3)&nbsp;[1, 2, 3]new bound(2,3) //this undefined (3)&nbsp;[1, 2, 3]s 此时 this 指向了 new bound() 生成的新对象，所以找不到 name 为 yishu 的值了，但是参数依然传递的 结论 bind 原先指向 obj 的失效了，其他参数有效。 new bound 的返回值是以 original 原函数构造器生成的新对象。original 原函数的 this 指向的就是这个新对象 我们看到 又涉及到 new 操作了，写过关于模拟 new 的文章简单摘要 new 做了什么 123451.创建了一个全新的对象。2.这个对象会被执行[[Prototype]]（也就是__proto__）链接。3.生成的新对象会绑定到函数调用的this。4.通过new创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上。5.如果函数没有返回对象类型Object(包含Functoin, Array, Date, RegExg, Error)，那么new表达式中的函数调用会自动返回这个新的对象。 所以 ，当使用 new 调用的时候，bind 的返回值函数 bound 内部要模拟实现 new 实现的操作，似曾相识了 bindFn 函数的升级区分是否是 new 调用 当使用 new 调用需要在 bind 函数返回值函数里实现模拟 new 的操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950Function.prototype.bindFn = function bind(thisArg){ if(typeof this !== 'function'){ throw new TypeError(this + ' must be a function'); } // 存储调用bind的函数本身 var self = this; // 去除thisArg的其他参数 转成数组 var args = [].slice.call(arguments, 1); var bound = function(){ // bind返回的函数 的参数转成数组 var boundArgs = [].slice.call(arguments); var finalArgs = args.concat(boundArgs); // new 调用时，其实this instanceof bound判断也不是很准确。es6 new.target就是解决这一问题的。 //new.target属性允许你检测函数或构造方法是否是通过new运算符被调用的 if(new.target){ //检测函数或构造方法是否是通过new运算符被调用的 // 这里是实现上文描述的 new 的第 1, 2, 4 步 // 1.创建一个全新的对象 // 2.并且执行[[Prototype]]链接 // 4.通过`new`创建的每个对象将最终被`[[Prototype]]`链接到这个函数的`prototype`对象上。 // self可能是ES6的箭头函数，没有prototype，所以就没必要再指向做prototype操作。 if(self.prototype){ // ES5 提供的方案 Object.create() // bound.prototype = Object.create(self.prototype); // 但既然是模拟ES5的bind，那浏览器也基本没有实现Object.create() // 所以采用 MDN ployfill方案 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create function Empty(){} Empty.prototype = self.prototype; bound.prototype = new Empty(); } // 这里是实现上文描述的 new 的第 3 步 // 3.生成的新对象会绑定到函数调用的`this`。 var result = self.apply(this, finalArgs); // 这里是实现上文描述的 new 的第 5 步 // 5.如果函数没有返回对象类型`Object`(包含`Functoin`, `Array`, `Date`, `RegExg`, `Error`)， // 那么`new`表达式中的函数调用会自动返回这个新的对象。 var isObject = typeof result === 'object' &amp;&amp; result !== null; var isFunction = typeof result === 'function'; if(isObject || isFunction){ return result; } return this; } else{ //不使用new操作符时 // apply修改this指向，把两个函数的参数合并传给self函数，并执行self函数，返回执行结果 return self.apply(thisArg, finalArgs); } }; return bound;} 总结 bind 是 Function 原型链中的 Function.prototype 的一个属性，它是一个函数，修改 this 指向，合并参数传递给原函数，返回值是一个新的函数。 bind 返回的函数可以通过 new 调用，这时提供的 this 的参数被忽略，指向了 new 生成的全新对象。内部模拟实现了 new 操作符。 bindFn 12345678910111213141516171819202122232425262728293031// 最终版 删除注释 详细注释版请看上文Function.prototype.bind = Function.prototype.bind || function bind(thisArg){ if(typeof this !== 'function'){ throw new TypeError(this + ' must be a function'); } var self = this; var args = [].slice.call(arguments, 1); var bound = function(){ var boundArgs = [].slice.call(arguments); var finalArgs = args.concat(boundArgs); if(new.target){ if(self.prototype){ function Empty(){} Empty.prototype = self.prototype; bound.prototype = new Empty(); } var result = self.apply(this, finalArgs); var isObject = typeof result === 'object' &amp;&amp; result !== null; var isFunction = typeof result === 'function'; if(isObject || isFunction){ return result; } return this; } else{ return self.apply(thisArg, finalArgs); } }; return bound;}","categories":[{"name":"js","slug":"js","permalink":"http://maying.ink/categories/js/"}],"tags":[{"name":"bind","slug":"bind","permalink":"http://maying.ink/tags/bind/"}]},{"title":"模拟实现 JS 的 new 操作符","slug":"new","date":"2019-03-12T16:15:39.000Z","updated":"2020-10-22T18:41:42.183Z","comments":true,"path":"2019/03/13/new/","link":"","permalink":"http://maying.ink/2019/03/13/new/","excerpt":"JS 中 new 关键字用来实例化构造函数，那么它背后到底做了什么，能否被模拟实现答案是肯定的 new 关键字做了什么你一定从别的文章或者在实际开发中感受到 new 的妙处，不错，总结下来它主要支持了四个功能","text":"JS 中 new 关键字用来实例化构造函数，那么它背后到底做了什么，能否被模拟实现答案是肯定的 new 关键字做了什么你一定从别的文章或者在实际开发中感受到 new 的妙处，不错，总结下来它主要支持了四个功能 创建了一个全新的对象 这个对象会被执行 [[prototype]]（也就是__proto__）链接 生成的新对象会绑定到函数调用的 this 通过 new 创建的每个对象将最终被来接到这个函数的 prototype 对象上 如果函数没有返回对象类型 Object (包含 Functoin, Array, Date, RegExg, Error)，那么 new 表达式中的函数调用会自动返回这个新的对象 模拟实现 new12345678910111213141516171819202122232425function newOperator(ctor){ if(typeof ctor !== 'function'){ throw 'newOperator function the first param must be a function'; } // ES6 new.target 是指向构造函数 newOperator.target = ctor; // 1.创建一个全新的对象， // 2.并且执行[[Prototype]]链接 // 4.通过`new`创建的每个对象将最终被`[[Prototype]]`链接到这个函数的`prototype`对象上。 var newObj = Object.create(ctor.prototype); // ES5 arguments转成数组 当然也可以用ES6 [...arguments], Aarry.from(arguments); // 除去ctor构造函数的其余参数 var argsArr = [].slice.call(arguments, 1); // 3.生成的新对象会绑定到函数调用的`this`。 // 获取到ctor函数返回结果 var ctorReturnResult = ctor.apply(newObj, argsArr); // 小结4 中这些类型中合并起来只有Object和Function两种类型 typeof null 也是'object'所以要不等于null，排除null var isObject = typeof ctorReturnResult === 'object' &amp;&amp; ctorReturnResult !== null; var isFunction = typeof ctorReturnResult === 'function'; if(isObject || isFunction){ return ctorReturnResult; } // 5.如果函数没有返回对象类型`Object`(包含`Functoin`, `Array`, `Date`, `RegExg`, `Error`)，那么`new`表达式中的函数调用会自动返回这个新的对象。 return newObj;} 实例验证1234567891011121314151617181920212223function Student(name, age){ this.name = name; this.age = age; // this.doSth(); // return Error();}Student.prototype.doSth = function() { console.log(this.name);};var student1 = newOperator(Student, '轩辕', 18);var student2 = newOperator(Student, 'Rowboat', 18);// var student1 = new Student('轩辕');// var student2 = new Student('Rowboat');console.log(student1, student1.doSth()); // {name: '轩辕'} '轩辕'console.log(student2, student2.doSth()); // {name: 'Rowboat'} 'Rowboat'student1.__proto__ === Student.prototype; // truestudent2.__proto__ === Student.prototype; // true// __proto__ 是浏览器实现的查看原型方案。// 用ES5 则是：Object.getPrototypeOf(student1) === Student.prototype; // trueObject.getPrototypeOf(student2) === Student.prototype; // true 模拟 new 最大的功臣当属于 Object.create() 这个 ES5 提供的 API Object.create(proto, [propertiesObject]) 方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__ 它接收两个参数，不过第二个可选参数是属性描述符（不常用，默认是 undefined） 对于不支持 ES5 的浏览器，MDN 上提供了 ployfill 方案。 123456789101112131415if (typeof Object.create !== \"function\") { Object.create = function (proto, propertiesObject) { if (typeof proto !== 'object' &amp;&amp; typeof proto !== 'function') { throw new TypeError('Object prototype may only be an Object: ' + proto); } else if (proto === null) { throw new Error(\"This browser's implementation of Object.create is a shim and doesn't support 'null' as the first argument.\"); } if (typeof propertiesObject != 'undefined') throw new Error(\"This browser's implementation of Object.create is a shim and doesn't support a second argument.\"); function F() {} F.prototype = proto; return new F(); };} ## 总结 模拟 new 洁净版 1234567891011121314151617181920// 去除了注释function newOperator(ctor){ if(typeof ctor !== 'function'){ throw 'newOperator function the first param must be a function'; } newOperator.target = ctor; var newObj = Object.create(ctor.prototype); var argsArr = [].slice.call(arguments, 1); var ctorReturnResult = ctor.apply(newObj, argsArr); var isObject = typeof ctorReturnResult === 'object' &amp;&amp; ctorReturnResult !== null; var isFunction = typeof ctorReturnResult === 'function'; if(isObject || isFunction){ return ctorReturnResult; } return newObj;}","categories":[],"tags":[]},{"title":"实现一个 SSR 同构应用","slug":"SSRDemo","date":"2019-03-06T07:51:42.000Z","updated":"2020-10-22T18:41:42.180Z","comments":true,"path":"2019/03/06/SSRDemo/","link":"","permalink":"http://maying.ink/2019/03/06/SSRDemo/","excerpt":"纸上得来终觉浅，我们来实现一个简易的服务端渲染流程，意在体会 SSR 带来的红利","text":"纸上得来终觉浅，我们来实现一个简易的服务端渲染流程，意在体会 SSR 带来的红利 页面源码来自 React 状态管理与同构实战 几个重要的概念实现 SSR 是依靠 React 提供的 ReactDomServer 对象 它主要提供了只能在服务端使用的 renderToString() 与 renderToStaticMarkup() 方法 renderToString()/renderToStaticMarkup()使用方法： ReactDomServer.renderTostring(element)/ReactDomServer.renderToStaticMarkup(element) 共同点： 都接收一个 React Element 并将此 Element 转化为 HTML 字符串，通过浏览器返回，实现了在服务端将页面拼接字符串插入 HTML 文档中并返回给浏览器 完成初步服务端渲染的目的 不同点 renderToString(注：React 15) 生成的 HTML 字符串的每个 Dom 节点都有 data-react-id 属性，根节点会有一个 data-react-checkSum 属性 renderToStaticMarkup 不带 data-react-checkSum 属性 浏览器渲染时必会重新渲染组件 关于 data-react-checkSum： 123如果两个组件有相同的props和Dom结构，这个值是一样的我们知道 服务端渲染完页面内容难过之后，浏览器端也会渲染以完成组件的交互等能力，浏览器端会生成组件的data-react-checkSum值 然后跟服务端渲染组件的值做对比，如果相等，则不再重复渲染 这里有一张草图能大概描述这个过程嘤嘤嘤. ReactDom.hydrate()React 16 以后通过renderToString 渲染的组件不再带有 data-react-* 属性，因此浏览器端的渲染方式无法简单通过 data-react-checksum 来判断是否需要重新渲染 基于这样儿的背景下 ReactDom 提供了一个新的 API ReactDom.hydrate() 用法同 render() 在浏览器端渲染组件 当然，react 是向下兼容的，浏览器端在渲染组件时使用 render () 仍然没有问题，但不论是面向未来，还是基于性能的考虑，都应该采用更好的模式 renderToNodeStream()/renderToStaticNodeStream()React 16 为了优化页面的初始加载速度缩短 TTFB 时间，提供了这两个方法 概念该方法持续产生子节流 返回 Readable stream 最终通过流形式返回的 HTML 字符串这样 服务端处理内容时是实时向浏览器端传输数据而不是一次性处理完成后才开始返回结果的 renderToStaticNodeStream 之于 renderToNodeStream 也是不会产生 data-react-* 属性，对于静态页面 可以采用此方法。 实际开发中可能存在的问题 服务端不存在支持组件挂载的浏览器环境，所以 react 组件只有 componentDidMount 之前的生命周期方法有效，所以在其之前的生命周期方法中不能用到浏览器的特性，比如 window、localStorage. 双端可能都有拉取数据的需求，所以为了实现代码的复用，一种典型的做法就是把请求数据的逻辑放到 React 组件的静态方法中 然后双端共用，双端请求方法不一致的问题可以通过服务端与浏览器端的判断来封装一下 比如根据 window 是浏览器特有对象 React 16 在服务端渲染上的惊喜前面也有混杂说过，在此总结一下 在浏览器渲染组件需要配合服务端使用 hydrate 方法 提供了 stream 方式的接口 与浏览器的新特性相似，除了能处理 React Element 也能处理别的类型，比如 string number 因为在返回结果 Dom 中废除了 data-react-checksum 等属性，所以服务端生成 HTML 更加高效 允许在渲染 Dom 中加入非标准 Dom 属性 好了 测试一下，基于 Node.js 实现一个小 demo Express4.15.3 进行服务端处理 browser: 浏览器端渲染server：服务端逻辑share：同构的部分 运行效果：share/app.js 123456789101112131415161718192021222324252627import React, { Component } from \"react\";import logo from \"./logo.svg\";import \"./App.css\";class App extends Component { constructor(props) { super(props); this.handleClick = this.handleClick.bind(this); } handleClick() { alert('我被触发辣') } render() { return ( &lt;div className=\"App\"&gt; &lt;div className=\"App-header\"&gt; &lt;img src={logo} className=\"App-logo\" alt=\"logo\" /&gt; &lt;h2&gt;Welcome to React in the Server&lt;/h2&gt; &lt;/div&gt; &lt;p className=\"App-intro\"&gt;点击按钮体验&lt;/p&gt; &lt;button onClick={e =&gt; this.handleClick()}&gt; 我是按钮 &lt;/button&gt; &lt;/div&gt; ); }}export default App; browser/index.js 123456import React from \"react\";import { hydrate } from \"react-dom\";import App from \"../shared/App\";hydrate(&lt;App /&gt;, document.getElementById(\"root\")); server/index.js 1234567891011121314151617181920212223242526272829import express from \"express\";import React from \"react\";import { renderToString } from \"react-dom/server\";import App from \"../shared/App\";const app = express();app.use(express.static(\"public\"));app.get(\"*\", (req, res) =&gt; { const htmlMarkup = renderToString(&lt;App /&gt;); res.send(` &lt;!DOCTYPE html&gt; &lt;head&gt; &lt;title&gt;Universal Reacl&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"/css/main.css\"&gt; &lt;script src=\"/bundle.js\" defer&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"root\"&gt;${htmlMarkup}&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; `);});app.listen(process.env.PORT || 3000, () =&gt; { console.log(\"Server is listening\");}); server 端：使用 renderToString 生成的字符串，使用 res.send 发送给浏览器client 端： id 为 root 的 Dom 节点就来自服务端返回的结果，用了 React.hydrate 完成了浏览器端的逻辑处理部分 假设一 client 端渲染仍然使用 render ()测试 123456import React from \"react\";import {render } from \"react-dom\";import App from \"../shared/App\";render(&lt;App /&gt;, document.getElementById(\"root\")); 结果由于实现了向下兼容，所以是可以的，但是会给如下警告⚠️ 结论 尽量使用新特性 假设二 完全依赖服务端渲染会发生什么测试将 browser/index.js 代码注释掉结果页面正常显示，但是点击按钮没有不会弹窗结论 需要双端一起完成页面的展示与交互 假设三 使用 React 16 renderToNodeStream 渲染测试 更改 server/index.js 12345678910111213141516171819202122232425262728import express from \"express\";import React from \"react\";import { renderToNodeStream } from \"react-dom/server\";import App from \"../shared/App\";const app = express();app.use(express.static(\"public\"));app.get(\"*\", (req, res) =&gt; { res.write(` &lt;!DOCTYPE html&gt; &lt;head&gt; &lt;meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\"&gt; &lt;title&gt;Universal Reacl&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"/css/main.css\"&gt; &lt;script src=\"/bundle.js\" defer&gt;&lt;/script&gt; &lt;/head&gt;` ); res.write(\"&lt;div id='root'&gt;\"); const stream = renderToNodeStream(&lt;App/&gt;); stream.pipe(res, { end: false }); stream.on('end', () =&gt; { res.write(\"&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\"); res.end(); });}); 说明： 为了配合返回一个流，使用 res.write 方法代替先前的 res.end 好处使用 renderToString 页面 TTFB 时间 使用 renderToNodeStream 页面 TTFB 时间 结论采用渐进式流渲染可以最大限度的缩短服务器响应水间，从而使浏览器可以更快的接收到信息 假设三 同构应用与浏览器渲染优势对比浏览器渲染： 同构应用： 假设三 react16 比 react15 渲染更加高效React 15React 16 遗留问题 鉴于 renderToNodeStream()/renderToStaticNodeStream() 与renderToString()/renderToStaticMarkup()React 16 之后都不存在 data-react-* 了 双方还有什么区别？ react 16 之后 如何做双端对比？ 官方说是根据 ReactDom.hydrate() 与 renderToString() 结合判断.. 一脸懵逼","categories":[],"tags":[]},{"title":"前后端分离的演进","slug":"FrontBackSeparation","date":"2019-03-04T16:08:59.000Z","updated":"2020-10-22T18:41:42.179Z","comments":true,"path":"2019/03/05/FrontBackSeparation/","link":"","permalink":"http://maying.ink/2019/03/05/FrontBackSeparation/","excerpt":"有幸参与了所在项目的架构升级，初次接触到了 SSR 的概念，就越发感兴趣 我们站在巨人的肩膀上一边享受社区红利，一边躁动不安 鲁迅先生说过 技术上的问题总有技术去解决没错 比如我现在就学会问 为什么为什么会如此发展？为什么会有这个概念？它能解决什么问题？它从哪里来.. 又要到哪里去..emm.. 事实上，任何一项技术的发展 都是由问题推动的，所以 trouble is friends！ 工作时间不短不长，刚好经历了几个阶段.","text":"有幸参与了所在项目的架构升级，初次接触到了 SSR 的概念，就越发感兴趣 我们站在巨人的肩膀上一边享受社区红利，一边躁动不安 鲁迅先生说过 技术上的问题总有技术去解决没错 比如我现在就学会问 为什么为什么会如此发展？为什么会有这个概念？它能解决什么问题？它从哪里来.. 又要到哪里去..emm.. 事实上，任何一项技术的发展 都是由问题推动的，所以 trouble is friends！ 工作时间不短不长，刚好经历了几个阶段. 第一阶段（静态页面万岁）两年前入职的时候，就用的如此神奇的技术，当时 react、vue 等已经热火朝天了，我表示很惊讶，因为刚毕业就加入 react 大军了，当时还用的是蚂蚁金服还在 degugger 阶段的 dva, 对于当时的我来讲，这种歌神奇的技术第一次真正接触，写好页面，就扔给后端小哥哥了，还真的不习惯，比较闹心的一点是 没有 bug 还好，一旦需要调试，会跟后端小哥哥一起看，是真的浪费时间，重点是效率也贼低. 其实现在看来 ，这大概是最初的前后端分离前端负责静态页面和交互，后端可能就要负责数据处理并返回完整的页面一旦涉及到诸如 JSP、PHP smarty 模版的编写，就容易职责不清了.. 以至于互相甩锅！ 缺点明显： 前后端分工不明，难以实现效率最大化 前端会极度依赖后端环境，数据格式的沟通成本过高 不利于前端技术的发展 第二阶段（AJAX 时代）随着前端技术的发展，尤其是 AJAX 和 Node.js 的出现，一种前后端分离的架构模式应运而生，极大的缓解了前后端 RD 会互相撕逼的 bug，前后端分工变得清晰，以 AJAX 接口当作桥梁，各取所需（😂） emm.. 徒手画的还不是特别准确的图来意会一下用户请求页面的过程 优点 分工明确，前后端各司其职，后端专注业务逻辑和功能的实现，前端专注页面设计。 接口明确，并行开发，在后端接口没有实现好之前，前端完全可以自己通过 Node.js 的的 Web 框架模拟接口缺点 数据请求，处理扽好复杂逻辑被移植到浏览器端，js 脚本越来越复杂 不利于 SEO（后面会解释）存在性能问题 这种模式下，用户必须等待 js 脚本加载完成，真正执行时发数据请求，等数据返回，脚本完成页面的渲染，才能看到页面，导致首屏展现时间拉长，特别是在移动互联网下，对首屏加载性能的影响很大 第三阶段（SPA）SPA（single page application）：是一种 网络应用程序 (WebApp) 模型在传统的网站中，不同的页面之间的切换都是直接从服务器加载一整个新的页面，而 SPA 是通过动态重写页面的部分与用户交互，从而避免了过多的数据交换，响应速度更快 目前常见的 SPA 框架 AngularJS React Vue.js 任何技术架构的升级都不可能脱离时代永远存在，技术的演进一定会随着发展愈演愈烈 优点 前后端分离的优点它都有除此之外，它页面之间的切换很快缺点 首屏打开速度很慢，因为用户首次加载需要先下载 SPA 框架及应用程序的代码，然后再渲染页面 不利于 SEO 为什么 SPA 不利于 SEO？目前而言，部分搜索引擎如 Google、bing 等，它们的爬虫虽然已经支持执行 JS 甚至是通过 AJAX 获取数据了，但是对于异步数据的支持也还不足 (也可能是搜索引擎提供商觉得没必要)SPA 应用中，通常通过 AJAX 获取数据，而这里就难以保证我们的页面能被搜索引擎正常收录到。并且有一些搜索引擎不支持执行 JS 和通过 AJAX 获取数据，那就更不用提 SEO 了 第四阶段（服务端渲染 SSR）什么是服务端渲染？服务端渲染会把数据请求过程放在服务端，相对于前后端分离的方式，获取数据提前，页面模版结合数据的渲染处理也会在服务端完成 优点： 当浏览器初次请求页面后，用户第一次拿到的 HTML 文档已经进行了初步的内容渲染，利于 SEO 优化 也解决了首屏的性能问题 总的请求数并没有变，只是把浏览器的一部分数据请求转移到了服务器上 事实上 服务端进行数据拉取的成本要小于浏览器端，传输更加高效，这也是性能提升的关键 更快的响应时间，不用等待所有的 JS 都下载完成，浏览器便能显示比较完整的页面了 更好的 SEO，我们可以将 SEO 的关键信息直接在后台就渲染成 HTML，而保证搜索引擎的爬虫都能爬取到关键数据缺点： 相对于仅仅需要提供静态文件的服务器，SSR 中使用的渲染程序自然会占用更多的 CPU 和内存资源 一些常用的浏览器 API 可能无法正常使用，比如 window、docment 和 alert 等，如果使用的话需要对运行的环境加以判断 服务器端渲染的结果与浏览器端的结果不一致 技术的历史总是惊人的相似，这里的服务端渲染和开始的 smarty 等模版渲染并没有本质上的区别，当然了这并不是倒退，实际开发项目中，依赖 react 实现的服务端渲染并不是简单的渲染内容，也可以实现前后端代码复用 -&gt; 同构 第五阶段（SPA+ SSR 同构）何为同构？服务端渲染出最核心，最基本的信息，浏览器端针对交互完成进一步的渲染，事件绑定等增强功能 但是 两端渲染必定有很对冗余代码逻辑（都有 fetch 数据的过程） 同构：就是前后端共用一套代码逻辑，它就像是服务端与客户端渲染的交集，弥补了服务端和浏览器端的差异 好像很高级的样子 但是优劣也比较明显 优点 更好的性能 渲染更加迅速 首屏展现的时间更快 SEO 优化支持，服务端收到请去后 会返回一个相对完整，包含 html 的文档，所以更有利于搜索引擎爬虫获取信息，同时，更快的加载时间也有利于搜索结果展现排名的提升 实现灵活，服务端渲染做客户端渲染的后续的工作，实现代码复用 可维护性更强（同一套代码逻辑维护成本低） 对于低端机型友好，因为页面内容是在服务端渲染的 不至于出现白屏 弱网有好 不会再等 js 执行完毕再去呈现页面 更好的用户体验 可以将最重要的先渲染次重要的后渲染 缺点 服务端逻辑增多 服务端无法完全复用浏览器端代码 增加了服务器的 TTFB（time to frist byte）时间 总结 合理利用 SSR 结合 SPA 实现同构应用 是我们日后重心下一篇将动手写个同构的 demo 就这样。","categories":[{"name":"web","slug":"web","permalink":"http://maying.ink/categories/web/"}],"tags":[]},{"title":"函数节流与防抖","slug":"throttleAnddebounce","date":"2019-02-19T04:38:17.000Z","updated":"2020-10-22T18:41:42.186Z","comments":true,"path":"2019/02/19/throttleAnddebounce/","link":"","permalink":"http://maying.ink/2019/02/19/throttleAnddebounce/","excerpt":"前言博客中的大部分文章 大部分都有一个引子，要说明的通常是一些零零碎碎或者大多耳熟能详的 “知识点” 我认为遇到了问题 解决了问题 然后才会形成一个知识点而不是为了应用某个知识点去搭建场景，否则 真的是过目即忘解决最近一个问题之前 并没有计划写关于防抖和节流的问题，问题引导你说 需要重视这一块儿了 此文系 不要再问我 XX 系列之 不要再问我函数节流和防抖了","text":"前言博客中的大部分文章 大部分都有一个引子，要说明的通常是一些零零碎碎或者大多耳熟能详的 “知识点” 我认为遇到了问题 解决了问题 然后才会形成一个知识点而不是为了应用某个知识点去搭建场景，否则 真的是过目即忘解决最近一个问题之前 并没有计划写关于防抖和节流的问题，问题引导你说 需要重视这一块儿了 此文系 不要再问我 XX 系列之 不要再问我函数节流和防抖了 引出问题需求：记录用户的浏览深度 一旦你使用了类似 scroll 的浏览器事件，触发频率比较高，若稍处理函数微复杂，需要较多的运算执行时间，响应速度跟不上触发频率，往往会出现延迟，会出现卡顿甚至引发假死 在资源有限的情况下 我们可以想办法只响应部分请求，事实上某些场景下的密集性请求，并不是我们需要的 此时 我并不知道 需要用 “防抖” 这个晦涩的结论去解决，只知道目的是只是在浏览到这辆车的时候打点 那程序中要怎么体现我浏览到这个概念呢？ 先要约定一件事假设用户浏览到某一辆车之后停顿了超过你预设的时间值 就认为是浏览了 利用 setTimeout 实现 123456window.addEventListener('scroll', function(){ var timeout = null; return function() { clearTimeout(timeout); timeout = setTimeout(fn,200);}, false); 通过闭包保存一个定时器的标记 timeout，再次执行的时候 clear 掉之前的，又重新计时 这就保证了 触发非常频繁的 scroll 事件合并成一次执行。当调用动作过 n 毫秒后，才会执行该动作，若在这 n 毫秒内又调用此动作则将重新计算执行时间 所以短时间内的连续动作永远只会触发一次，比如说用手指一直按住一个弹簧，它将不会弹起直到你松手为止 现在的效果 好像受控制了 滑动过程中不会执行，一旦我们停下超过 n 毫秒，会执行一次由此得到一个结论处理此类问题就是要保证函数在特定的时间内（你设置的延迟时间）不被再调用后执行 我们的问题解决了，上网随便一搜，它是一类知识点，越发感兴趣惹 得出结论 引出 防抖 与 节流所以说我们直接接触到了 函数防抖，在此之前 我觉得它是晦涩难懂的，现在越发清晰了说到这儿 不得不提另一个兄弟 函数节流，因为应用场景相似而不相同，所以经常会被拿来比较 概念网上有很多关于两者的概念简单来讲：函数节流：指定时间间隔内只会执行一次任务 1234🌰1一个比较形象的例子是如果将水龙头拧紧直到水是以水滴的形式流出，那你会发现每隔一段时间，就会有一滴水流出🌰2地铁闸机，每个人进入后3秒后门关闭，等待下一个人进入。 函数防抖：任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行 （当一个动作连续触发，只执行最后一次） 12🌰用手指一直按住一个弹簧，它将不会弹起直到你松手为止 看下图 感受一下三种环境对于 mousemove 事件回调的执行情况 竖线的疏密程度代表事件之行的频繁程度可以得到： 正常情况下 函数执行的非常频繁 去抖之后很稀疏 只有当鼠标停止移动时才会执行一次 节流分布的比较均匀 每隔一段时间就会执行一次 demo 示例原生 scroll 函数去抖 函数节流 我们在真实场景中可以感受到无论采取哪种方案都会明显减少了回调的执行，得到了 都是用来控制某个函数在一定时间内执行次数的多少以优化高频率执行 js 代码的一种技巧，两者相似而又不同的结论 那么 我们 如何选择这两种方案？ 优化方案的应用场景选择哪个 取决于应用场景 函数防抖 如果你的需求是连续的时间只需要触发一次回调 比如： 搜索框输入 可能需要等到用户最后一次输入完 再去发送请求 手机号，邮箱等输入检测 浏览器窗口的 resize 你肯定要等到窗口调整完成后再进行渲染 scroll 事件等 函数节流 固定时间间隔执行的 比如： 滚动加载 常常需要滚动到底部加载下一页 表单的重复提交 进度条的更新 高频的点击（比如抽奖） 高频的鼠标移动，游戏射击类的 哦 理解了如何选择 下一个问题就是如何用 实现原理引出问题模块 其实我们已经做到了 防抖 函数防抖（debounce）简单实现 1234567891011window.addEventListener('scroll', this.debounce(this.scrollListener, 500), false); debounce = (fn, wait) =&gt; { var timeout = null; return function() { if(timeout !== null){ clearTimeout(timeout); }; timeout = setTimeout(fn, wait); } } 函数防抖在第一次执行时，有 500ms 的延迟。再次执行时，若前一个定时任务未执行完，则 clear 掉定时任务，重新定时 函数节流（throttle） 定时器版本实现 123456789101112131415const _.throttle = (func, wait) =&gt; { let timer; return () =&gt; { if (timer) { // 判断是否已空闲，如果在执行中，则直接return return; } timer = setTimeout(() =&gt; { func(); timer = null; }, wait); };}; 函数节流的目的，是为了限制函数一段时间内只能执行一次 使用 setTimeout 执行。在延时的时间内，方法若被触发，则直接退出方法。从而达到函数一段时间内只执行一次的目的 时间戳版简单实现 12345678910const throttle = (func, wait) =&gt; { let last = 0; return () =&gt; { const current_time = +new Date(); if (current_time - last &gt; wait) { func.apply(this, arguments); last = +new Date(); } };}; 其实现原理，通过比对上一次执行时间与本次执行时间的时间差与间隔时间的大小关系，来判断是否执行函数。若时间差大于间隔时间，则立刻执行一次函数。并更新上一次执行时间。 函数节流与函数防抖异同其实到这里应该比较能清晰的理解甚至选择适合真实场景的优化方案了 相同点 都可以通过延时器实现 目的都是 降低回调执行频率 节约计算机资源 不同点 其实从两者的概念也能看出来 函数防抖：关注一定时间连续触发，只在最后执行一次 函数节流：一段时间内只执行一次。 写在最后的话很多时候 带着问题来验证结论 更能把自己置身到场景中考虑 参考文章https://jinlong.github.io/2016/04/24/Debouncing-and-Throttling-Explained-Through-Examples/https://github.com/hanzichi/underscore-analysis/issues/20https://segmentfault.com/a/1190000008768202","categories":[{"name":"js","slug":"js","permalink":"http://maying.ink/categories/js/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://maying.ink/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"揭秘 setState 机制","slug":"re_setState","date":"2019-01-27T11:34:45.000Z","updated":"2020-10-22T18:41:42.185Z","comments":true,"path":"2019/01/27/re_setState/","link":"","permalink":"http://maying.ink/2019/01/27/re_setState/","excerpt":"开篇要说 React 设计体现了响应式编程思想 UI=f(state) 程墨 Morgan 的总结真是恰到好处 state 于 React 很重要，setState 作为管理 state 的重要方法自然也是头等公民 当然了，如果只是简单用法，API 足够了，你知道如何设置，如何更新，或许能解决眼前的需求，但是需求稍微复杂一点，可能会被动陷入 setState 怪圈 在哪里跌倒就把哪里买下来，被坑了之后，痛定思痛决定研究下 setState 怪象，最后发现 react 真是博大精深 文章太太太长了，不太感兴趣的话，可以拉到最后总结，也能避免入坑","text":"开篇要说 React 设计体现了响应式编程思想 UI=f(state) 程墨 Morgan 的总结真是恰到好处 state 于 React 很重要，setState 作为管理 state 的重要方法自然也是头等公民 当然了，如果只是简单用法，API 足够了，你知道如何设置，如何更新，或许能解决眼前的需求，但是需求稍微复杂一点，可能会被动陷入 setState 怪圈 在哪里跌倒就把哪里买下来，被坑了之后，痛定思痛决定研究下 setState 怪象，最后发现 react 真是博大精深 文章太太太长了，不太感兴趣的话，可以拉到最后总结，也能避免入坑 引出问题如果面试官问你 setState 是同步的还是异步的？ 它可能是同步的吗？如果可能的话如何实现同步更新 state？ 如果是看这篇文章之前 我的答案可能是这样儿 它是异步的 不能立马拿到结果 emm…. 解决问题 可能会有疑问的几个问题. 1. 为什么要用 setState 更新 state 不能直接修改？先更正一个观点 是可以通过 this.state 对象修改 state 的 也确实能改变状态，但是不能驱动 ui 更新（不走 render）那.. 有什么意义 2. setState 是同步的还是异步的？setState 是同步执行的 但是 state 并不一定会同步更新（异步更新）, 这是结论 针对这个问题 让我们带着问题去源码（基于版本 16.4.1）中寻找答案 场景一（合成事件中调用 setState）点击按钮实现加一的操作 1234567891011121314...onClick = ()=&gt; { this.setState({ val: this.state.val + 1 }) console.log('onClick', this.state.val); } ... render(){console.log('render', this.state.val); &lt;button onClick={this.onClick}&gt;加1&lt;/button&gt; } 首先 这是合成事件中操作 state, 了解什么是合成事件？ react 为了解决跨平台，兼容性问题，自己封装了一套事件机制，代理了原生的事件，像在 jsx 中常见的 onClick、onChange 这些都是合成事件 盯着这张网络盗图，画的完全符合我的预期，先有个概览，下文会跟踪解释 当你点击 onClick 时 第一阶段 （对合成事件的前期处理） react 会在正式 setState 前执行一堆 pre 钩子函数 (大部分都不需要关心), 你可以在 chrome 调试台或者 console.trace() 追踪到像这样儿👇这些都是 react 的前期处理 这个过程你只需要关心👇 得到的信息isBatchingUpdates 默认为 false, 在这里 (某一个 pre 钩子函数中被置为 true 了)，划重点，以后要考的 此时程序走的是 try 分支 至此，前期处理结束 第二阶段（setState 事件的处理） 红框部分是 setState 逻辑的调用栈，执行到 requestWork 方法时会二次判断 如下图👇 二阶段完 第三阶段（重置 post 钩子，更新 state 渲染 ui 操作） 接上文，那么我想知道它会 return 到哪里呢通过追踪发现 会走你主进程里的 console 语句这也就是为什么说 setState 更异步的上文中提到我们现在仍然处在 try 分支中，而在 finally 中才会更新 state 并且渲染到 UI 上，此时我们得到的仍然是更新前的 state 值，这就导致了所谓的\"异步\", 为什么要用 \"\" 号，因为这并不是我们的本意，是 react为了性能着想私自做的处理 接着往下走：最终还会走到这个方法这个方法里面有个 try finally 语法，到这里 我们知道了原来 return 到了这个 fn继续👇 render 之后 合成事件中 setState 的逻辑就结束了 场景二（生命周期中调用 setState）实际上与场景一只在第一阶段不同（没有对合成事件的各种处理）我们可能想在不同的生命周期中聊下 state 的更新状况 我们照例先来个小 demo 再来分析为什么会有这样儿的结果 12345678910111213141516171819202122232425262728293031323334353637state = { val:0, name:'yishu', age:18} componentWillMount(){ this.setState({val:this.state.val+1}); console.log('componentWillMount第一次输出',this.state.val) this.setState({val:this.state.val+1}); console.log('componentWillMount第二次输出',this.state.val) } componentDidMount(){ this.setState({ val: this.state.val + 1, name:'🐶' }); console.log('componentDidMount第一次执行', this.state.val) this.setState({ val: this.state.val + 1, name:'🐱', age:81 }); console.log('componentDidMount第二次输出', this.state.val) } componentDidUpdate(){ console.log('componentDidUpdate执行',this.state.val) }render(){ if(this.state.val !==0){ console.log('render执行',this.state) } &lt;p&gt;当前的值:{this.state.val}&lt;/p&gt; &lt;p&gt;你的名字:{this.state.name}&lt;/p&gt; &lt;p&gt;芳龄:{this.state.age}&lt;/p&gt;} 直接给出结果 其实经过各种 API 的熏陶，不运行也能知道结果，既然摊开来讲，就比较想知道为什么。 按照流程 ，先来一张调用栈鸟瞰图（网图） 还是三个阶段 第一阶段 第二阶段到现在就比较清晰了，与场景一不同的是 走的是 requestWork 中的第一个 if 分支，场景一（第二个 if 分支）不管哪种情况 结果都是一致的 那就是不会走到下面的同步更新分支 并且 两种情况都还只是在 try 模块中执行 再往下的流程参考场景一 第三阶段同场景一 关于这一场景 背着render 之前的生命周期拿到的都是更新之前的值，render 之后执行的才能拿到最新的值 比如 componentDidUpdate 3. setState 可以变成同步更新吗？ 如果可以的话 怎么做才能获取最新的值？面试官这么问的话 通常都是可以 😂那我们如何做实践中一般每个人都有一到两种解决方案，这里列举中处理方案 并将在下面的文章中深入研究 为什么 它 可以. 在原生事件中调用 setState 函数 利用 setState 回调函数 setTimeout 等异步操作中调用 setState 函数 最近刚被种草的函数式 setstate 用法 componentDidUpdate 中获取 名词释义：原生事件：指非 react 合成事件，原生自带的事件监听 addEventListener ，或者也可以用原生 js、jq 直接 document.querySelector().onclick 这种绑定事件的形式 在原生事件中调用 setState 函数一个小 demo 1234567891011121314151617181920state = { val:0}componentDidMount = () =&gt;{ document.querySelector('#btn-raw').addEventListener('click', this.onClick);}onClick = ()=&gt; { this.setState({ val: this.state.val + 1 }); console.log('onClick', this.state.val); } render(){ if(this.state.val !==0){ console.log('render执行',this.state) } &lt;button id=\"btn-raw\"&gt;Increment &lt;/button&gt;} 运行结果意料之中 按理来说还需要张鸟瞰图 在这里 👇 其实应该已经挺清晰了，我们还是在调试器里走一下 第一阶段（setState 逻辑之前的处理） 画风突变，调用栈内不再执行一堆看不懂的 pre 钩子函数了简单的理解为 用原生事件调用时 不受 react 控制了 也就没办法针对它执行一堆函数，直接走 setState 的逻辑了 第二阶段（setState 执行逻辑） 走了第三个 if 分支 同步更新了（执行了 render 再在 click 函数中打印的 所以拿到了最新值） 第三阶段 参考场景一 利用 setState 回调函数API 就不多说了 12345 this.setState({ val:this.state.val + 1 },()=&gt;{ console.log('cllback',this.state.val);}) 原理：回调函数被调用的时候，其实 render 函数已经被调用过了 参考 demo 的执行结果 setTimeout 等异步操作中调用 setState 函数实际上 这并不是一个单独的场景，你可以在合成事件中 调用 setTimeout ，可以在生命周期中调用 setTimeout ，也可以在原生事件 setTimeout，但是不管是哪个场景下，基于 event loop 的模型下， setTimeout 中里去 setState 总能拿到最新的 state 值 一个 demo 👇 12345678910111213141516171819202122232425262728293031323334353637383940414243this.state = { val:0, name:'yishu', age:18 } componentDidMount(){ // // debugger; // // 生命周期中调用--------------- this.setState({ val: this.state.val + 1, name:'🐶' }); console.log('componentDidMount第一次执行', this.state.val) this.setState({ val: this.state.val + 1, name:'🐱', age:81 }); console.log('componentDidMount第二次输出', this.state.val) setTimeout(() =&gt; { console.log('开始setTimeout', this.state.val) this.setState({ val: this.state.val + 1 }); console.log('setTimeout第一次执行', this.state.val) this.setState({ val: this.state.val + 1 }); console.log('setTimeout第二次执行', this.state.val) }, 0) this.setState({ val: this.state.val + 1 }); console.log('componentDidMount第三次输出', this.state.val) }render(){if(this.state.val !==0){ console.log('render执行',this.state) } &lt;p&gt;当前的值:{this.state.val}&lt;/p&gt;} 上述结果，如果你了解 js 事件循环（ event loop）的机制 就太简单了 默认你已经阅读过全文的上半部分 了解了 setState 逻辑都是在 try 模块中执行的，此时当执行到 setTimeout 的时候，把它丢到 ** 定时器触发线程 (浏览器提供的线程)** 去维护，并没有立即执行，先执行的 finally 代码块，等 finally 执行完了， isBatchingUpdates 又变为了 false ，导致最后去执行队列里的 setState 时候， requestWork 走的是和原生事件一样的 expirationTime === Sync if 分支，所以表现就会和原生事件一样，可以同步拿到最新的 state 值。 关于 js 事件循环 又是另一个模块儿的东西 值得单开一章去研究，这里就不再细说了 感兴趣的同学 可移步js 到底是如何工作的 寻找答案 4. 函数式 setState 用法我在想 怎么才能更好引出这个大彩蛋，那便又涉及到另一个问题以上文章中我们为了说明 setState执行的大流程 有一个实际存在却没提及的问题，那就是 setState的批量更新 类似这样儿的代码 12345678//...this.setState({val: this.state.val + 1});console.log('componentDidMount第一次执行', this.state.val)this.setState({val: this.state.val + 1});console.log('componentDidMount第二次执行', this.state.val)this.setState({val: this.state.val + 1});console.log('componentDidMount第三次执行', this.state.val)//... 得到的执行结果 API 告诉我可以接受，但是有点点懵 发生了什么… emm假如这么写 会不会更清晰👇 1234const currentCount = this.state.count;this.setState({count: currentCount + 1});this.setState({count: currentCount + 1});this.setState({count: currentCount + 1}); 对的 你每次设置的都是同一个值setState 多次，re-render 一次，多次同步执行的 setState，会进行合并，类似于 Object.assign, 相同的 key 会被覆盖 所以结果为 1 为了不偏题 实现过程暂时省略，接受这个结论，让我们看函数式 setState 用法 如果传递给 this.setState 的参数不是一个对象而是一个函数 那就完全不一样儿了 一个小🌰体验下神奇的效果 123456789101112131415161718192021componentDidMound = () =&gt;{ console.log('参数为函数第一次执行',this.state.val) this.setState(this.increment); console.log('参数为函数第二次执行',this.state.val) this.setState(this.increment); console.log('参数为函数第三次执行',this.state.val) this.setState(this.increment); console.log('参数为函数第四次执行',this.state.val)} /** * @description increment函数并不去修改组件状态，只是把“希望的状态改变”返回给React，维护状态这些苦力活完全交给React去做。 * params state：当前的state * params props：当前的props * @return 对象代表之前你想给this.setState传递的参数 比如你认为第一次传0 第二次传1 * @memberof SetState */ increment = (state, props) =&gt; { // 计算这个对象的方法有些改变，不再依赖于this.state，而是依赖于输入参数state。 console.log('---state',state) return {val: state.val + 1}; //同样是把状态中的count加1，但是状态的来源不是this.state，而是输入参数state。 } 仔细看下代码中的注释部分结论：对于多次调用函数式 setState 的情况，React 会保证调用每次 increment 时，state 都已经合并了之前的状态修改结果。但是 在 increment 函数被调用时，this.state 并没有被改变，依然要等到 render 函数被重新执行时才被改变，也没有推翻上文的结论 真好。 API 的设计符合函数式编程思想，开发者编写无副作用的函数 increment 并不会去改变组件状态，只是把 “希望的状态改变” 返回给 React，维护状态这些苦力活完全交给 React 去做。也正是 流程的控制权交给了 React，所以 React 才能协调多个 setState 调用的关系。 4. 手动避免 setState 的不当调用带来的性能问题到这里基本上就清楚了 setState 执行机制，那么 我们应该怎样儿利用自己的知识手动优化页面性能呢 这里列举了几条 除了特殊需求 尽量不要在非合成事件中调用 setState 这样儿会失控 变成真的同步更新了 每次更新都会走 render 走 render 就不可避免的涉及到 diff对比.. 更新过程很频繁，也就会导致性能问题。 不要在 shouldComponentUpdate 和 componentWillUpdate 中调用 setState 会造成循环 总结 setState 不会立刻改变 React 组件中 state 的值； setState 通过引发一次组件的更新过程来引发重新绘制； 多次 setState 函数调用产生的效果会合并。 setState 只在合成事件和钩子函数中是 “异步” 的，在原生事件和 setTimeout 中都是同步的，批量更新的策略是基于” 异步” 之上的，在 setTimeout 和原生事件中是没有的，因为此时时不受控的 setState 的 “异步” 并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形成了所谓的 “异步”，但是如果需要，也有解决方案可以直接拿到最新的值 setState 的批量更新优化也是建立在 “异步”（合成事件、钩子函数）之上的，在原生事件和 setTimeout 中不会批量更新，在 “异步” 中如果对同一个值进行多次 setState，setState 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新。 像写受控组件那样儿去操作 setState 参考文章：https://zhuanlan.zhihu.com/p/39512941 https://zhuanlan.zhihu.com/p/25990883","categories":[{"name":"react","slug":"react","permalink":"http://maying.ink/categories/react/"}],"tags":[{"name":"setState","slug":"setState","permalink":"http://maying.ink/tags/setState/"}]},{"title":"不要再问关于缓存的问题了","slug":"不要再问关于缓存的问题了","date":"2019-01-21T13:00:37.000Z","updated":"2020-10-22T18:41:42.188Z","comments":true,"path":"2019/01/21/不要再问关于缓存的问题了/","link":"","permalink":"http://maying.ink/2019/01/21/%E4%B8%8D%E8%A6%81%E5%86%8D%E9%97%AE%E5%85%B3%E4%BA%8E%E7%BC%93%E5%AD%98%E7%9A%84%E9%97%AE%E9%A2%98%E4%BA%86/","excerpt":"背景：前端 er 需要关注的点，缓存它在移动端上尤其严重，因为手机随时随地会缓存你的资源，要想清缓存，不像 PC 使用强制刷新，还要手动找到浏览器的缓存，有时候还要重启等所以 用实践理解缓存机制 写下此文记录 为了对比理解本文会涉及到 DNS 缓存 CDN 缓存 浏览器缓存 (HTTP 缓存)","text":"背景：前端 er 需要关注的点，缓存它在移动端上尤其严重，因为手机随时随地会缓存你的资源，要想清缓存，不像 PC 使用强制刷新，还要手动找到浏览器的缓存，有时候还要重启等所以 用实践理解缓存机制 写下此文记录 为了对比理解本文会涉及到 DNS 缓存 CDN 缓存 浏览器缓存 (HTTP 缓存) 先梳理以下 web 缓存的优缺点缓存的优势 减少网络延迟 加快页面打开速度 降低服务器压力 缓存的缺点 缓存没有清理机制（时间一长 当你不需要浏览之前的这些网页，他们就变成了无用文件） 给开发带来困扰 DNS 缓存什么是 DNS？全称 Domain Name System 域名解析系统 万维网上作为域名和 IP 地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的 IP 数串。DNS 协议运行在 UDP 协议之上，使用端口号 53。 DNS 解析简单的说，通过域名，最终得到该域名对应的 IP 地址的过程叫做域名解析（或主机名解析） 1www.dnscache.com (域名) - DNS解析 -&gt; 11.222.33.444 (IP地址) DNS 缓存有 DNS 的地方，就有缓存。浏览器、操作系统、Local DNS、根域名服务器，它们都会对 DNS 结果做一定程度的缓存。 DNS 查询过程 首先搜索浏览器自身的 DNS 缓存，如果存在，则域名解析到此完成。 如果浏览器自身的缓存里面没有找到对应的条目，那么会尝试读取操作系统的 hosts 文件看是否存在对应的映射关系，如果存在，则域名解析到此完成。 如果本地 hosts 文件不存在映射关系，则查找本地 DNS 服务器 (ISP 服务器，或者自己手动设置的 DNS 服务器), 如果存在，域名到此解析完成。 如果本地 DNS 服务器还没找到的话，它就会向根服务器发出请求，进行递归查询。 CDN 缓存什么是 CDN？全称 Content Delivery Network, 即内容分发网络。类似于火车站代售点 这样儿 乘客不用再去售票大厅去排队买票 减轻了售票大厅的压力（起到分流作用，减轻服务器负载压力） 用户在浏览网站的时候，CDN 会选择一个离用户最近的 CDN 边缘节点来响应用户的请求，这样海南移动用户的请求就不会千里迢迢跑到北京电信机房的服务器（假设源站部署在北京电信机房）上了。 CDN 缓存CDN缓存 , 在浏览器本地缓存失效后，浏览器会向 CDN 边缘节点发起请求。类似浏览器缓存，CDN 边缘节点也存在着一套缓存机制。CDN 边缘节点缓存策略因服务商不同而不同，但一般都会遵循 http 标准协议，通过 http 响应头中的Cache-control: max-age //后面会提到的字段来设置 CDN 边缘节点数据缓存时间。 CDN 边缘节点数据缓存机制 当浏览器向 CDN 节点请求数据时，CDN 节点会判断缓存数据是否过期， 未过期：直接将缓存数据返回给客户端； 过期：CDN 节点向服务器发出回源请求，拉取最新数据同时更新本地缓存，并将最新数据返回给客户端。 CDN 服务商一般会提供基于文件后缀、目录多个维度来指定 CDN 缓存时间，为用户提供更精细化的缓存管理。 CDN 优势 CDN 节点解决了跨运营商和跨地域访问的问题，访问延时大大降低。 大部分请求在 CDN 边缘节点完成，CDN 起到了分流作用，减轻了源服务器的负载。 浏览器缓存（HTTP 缓存）对于一个数据请求来说，可以分为发起网络请求 后端处理 浏览器响应三个步骤浏览器缓存可以 i 帮助我们在第一步和第三步中优化性能比如我们可以直接使用缓存而不发起请求 盯着这张图 什么是浏览器缓存？浏览器缓存其实就是浏览器保存通过 HTTP 获取的所有资源，是浏览器将网络资源存储在本地的一种行为。 我们从两个方面来看浏览器缓存 缓存位置 缓存策略 缓存的资源去哪里了（缓存位置）?你可能会有疑问，浏览器存储了资源，那它把资源存储在哪里呢？ memory cache (存在内存) 12MemoryCache顾名思义，就是将资源缓存到内存中，等待下次访问时不需要重新下载资源，而直接从内存中获取。Webkit早已支持memoryCache。目前Webkit资源分成两类，一类是主资源，比如HTML页面，或者下载项，一类是派生资源，比如HTML页面中内嵌的图片或者脚本链接，分别对应代码中两个类：MainResourceLoader和SubresourceLoader。虽然Webkit支持memoryCache，但是也只是针对派生资源，它对应的类为CachedResource，用于保存原始数据（比如CSS，JS等），以及解码过的图片数据。 disk cache（存在磁盘） 1DiskCache顾名思义，就是将资源缓存到磁盘中，等待下次访问时不需要重新下载资源，而直接从磁盘中获取，它的直接操作对象为CurlCacheManager。 访问缓存优先级 先在内存中查找，如果有，直接加载。 如果内存中不存在，则在硬盘中查找，如果有直接加载。 如果硬盘中也没有，那么就进行网络请求。 请求获取的资源缓存到硬盘和内存。 浏览器缓存的分类（缓存策略）强缓存协商缓存需要说明的是 浏览器会先判断是否命中强缓存 浏览器缓存的优点 减少了冗余的数据传输 节省了网费 减少了服务器的负担，大大提升了网站的性能 加快了客户端加载网页的速度 浏览器在第一次请求发生后，再次请求时： 验证是否命中强缓存，如果命中，就直接使用缓存了。 如果没有命中强缓存，就发请求到服务器检查是否命中协商缓存。 如果命中协商缓存，服务器会返回 304 告诉浏览器使用本地缓存。 否则，返回最新的资源。 强缓存强缓存是利用 http 的返回头中的 Expires 或者 Cache-Control 两个字段来控制的，用来表示资源的缓存时间。 Expires:该字段是 http1.0 时的规范，它的值为一个绝对时间的 GMT 格式的时间字符串，比如 Expires:Mon,18 Oct 2066 23:59:59 GMT。这个时间代表着这个资源的失效时间，在此时间之前，即命中缓存。这种方式有一个明显的缺点，由于失效时间是一个绝对时间，所以当服务器与客户端时间偏差较大时，就会导致缓存混乱。 Cache-Control:Cache-Control 是 http1.1 时出现的 header 信息，主要是利用该字段的 max-age 值来进行判断，它是一个相对时间，例如 Cache-Control:max-age=3600，代表着资源的有效期是 3600 秒。cache-control 除了该字段外，还有下面几个比较常用的设置值： no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在 ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。 no-store：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。 public：可以被所有的用户缓存，包括终端用户和 CDN 等中间代理服务器。 private：只能被终端用户的浏览器缓存，不允许 CDN 等中继缓存服务器对其缓存。 Cache-Control 与 Expires 可以在服务端配置同时启用，同时启用的时候 Cache-Control 优先级高。 协商缓存当强缓存没有命中的时候，浏览器会发送一个请求到服务器，服务器根据 header 中的部分信息来判断是否命中缓存。如果命中，则返回 304 ，告诉浏览器资源未更新，可使用本地的缓存。 header： Last-Modify/If-Modify-Since 和 ETag/If-None-Match. Last-Modify/If-Modify-Since浏览器第一次请求一个资源的时候，服务器返回的 header 中会加上 Last-Modify，Last-modify 是一个时间标识该资源的最后修改时间。当浏览器再次请求该资源时，request 的请求头中会包含 If-Modify-Since，该值为缓存之前返回的 Last-Modify。服务器收到 If-Modify-Since 后，根据资源的最后修改时间判断是否命中缓存。如果命中缓存，则返回 304，并且不会返回资源内容，并且不会返回 Last-Modify。 缺点: 短时间内资源发生了改变 ,Last-Modified 并不会发生变化。 周期性变化 , 如果这个资源在一个周期内修改回原来的样子了，我们认为是可以使用缓存的，但是 Last-Modified 可不这样认为，因此便有了 ETag ETag/If-None-Match与 Last-Modify/If-Modify-Since 不同的是，Etag/If-None-Match 返回的是一个校验码。ETag 可以保证每一个资源是唯一的，资源变化都会导致 ETag 变化。服务器根据浏览器上送的 If-None-Match 值来判断是否命中缓存。与 Last-Modified 不一样的是，当服务器返回 304 Not Modified 的响应时，由于 ETag 重新生成过，response header 中还会把这个 ETag 返回，即使这个 ETag 跟之前的没有变化。 Last-Modified 与 ETag 是可以一起使用的，服务器会优先验证 ETag，一致的情况下，才会继续比对 Last-Modified，最后才决定是否返回 304。 实践检验我讨厌文字记忆，所以毫不犹豫选了理工科～～talk is cheap , show me your code ⚠️ 实践过程控制台不要禁用缓存 利用 koa 启动 server 服务 port：8000 引入静态资源 加载前端模版 去内蒙的航拍 哈哈哈 有我 如图可见 初次访问 正常加载模版页面 cache 与图片资源 1.jpeg 实现强缓存 服务端设置响应头 Cache-Control 资源有效期为 300 秒 1234567app.use(async (ctx, next) =&gt; { ctx.set({ 'Cache-Control': 'max-age=300' }); await next();}); 刷新页面 响应头的 Cache-Control 变成了 max-age=300 验证访问缓存的优先级:第一次的网络请求，浏览器把图片资源缓存到了磁盘和内存里，根据约定 应该会先从内存中找资源 再次刷新页面 确实是从内存获取的 4. 关掉页面再重新打开 （内存是存在进程中的，所以关闭该页面，内存中的资源也被释放掉了，磁盘中的资源是永久性的，所以还存在） from disk cache 从磁盘中获取资源 5. 接下来 有效期 300 秒 后.缓存失效 重新向服务器载入资源 实现协商缓存协商缓存本地测试直接拦截 url 给定 code Cache-Control 取默认值 no-cache 12345678910111213app.use( async(ctx, next) =&gt; {// // 强制缓存// ctx.set({// 'Cache-Control': 'max-age=300' // });// 协商缓存测试if(ctx.url === '/imgs/1.jpeg'){ ctx.status = 304; return;}await next();}); 服务器返回 304 同时 size 变小了很多 因为只返回了必要信息 也可利用 现成的插件帮我们计算文件的 ETagnpm install koa-tag -D npm install koa-conditional-get -D就不演示了 加载资源发生变化（比如换了张图片）ETag 改变 会导致协商缓存策略失效 然后 就行了. 😊 如果你想亲自体验 源码在这里 day day up","categories":[{"name":"web","slug":"web","permalink":"http://maying.ink/categories/web/"}],"tags":[{"name":"缓存","slug":"缓存","permalink":"http://maying.ink/tags/%E7%BC%93%E5%AD%98/"}]},{"title":"2018 写在年终的话","slug":"年终总结","date":"2019-01-21T03:46:41.000Z","updated":"2020-10-22T18:41:42.190Z","comments":true,"path":"2019/01/21/年终总结/","link":"","permalink":"http://maying.ink/2019/01/21/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/","excerpt":"","text":"2018 年终总结","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://maying.ink/categories/%E6%9D%82%E8%B0%88/"}],"tags":[]},{"title":"搭建服务器亲自体验跨域","slug":"COR","date":"2019-01-18T11:07:13.000Z","updated":"2020-10-22T18:41:42.178Z","comments":true,"path":"2019/01/18/COR/","link":"","permalink":"http://maying.ink/2019/01/18/COR/","excerpt":"背景跨域这两个字就像狗皮膏药一样儿粘在每一个前端 er 身上 我遇见了很多开发者一般都是为了应付面试 随便背几个方案 知道概念 但是不知道为什么要这么干到了真正的工作 开发环境有 webpack-dev-server 搞定 线上有运维大哥会配好，配什么我不管 反正不会跨域就是了但是.. 这样儿混日子 你的良心不会痛吗？ 痛定思痛 决心不定时更新 不要再问我 XX 的问题系列 之 不要再问我跨域的问题了 其实团队的小伙伴分享过类似的 但是不动手试一下 跟你面试前的死记硬背本质上没有任何区别","text":"背景跨域这两个字就像狗皮膏药一样儿粘在每一个前端 er 身上 我遇见了很多开发者一般都是为了应付面试 随便背几个方案 知道概念 但是不知道为什么要这么干到了真正的工作 开发环境有 webpack-dev-server 搞定 线上有运维大哥会配好，配什么我不管 反正不会跨域就是了但是.. 这样儿混日子 你的良心不会痛吗？ 痛定思痛 决心不定时更新 不要再问我 XX 的问题系列 之 不要再问我跨域的问题了 其实团队的小伙伴分享过类似的 但是不动手试一下 跟你面试前的死记硬背本质上没有任何区别 你需要了解的几个概念 什么是跨域？ 官方解释跨域资源共享 (CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器 让运行在一个 origin (domain) 上的 Web 应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。 比如，站点 http://domain-a.com 的某 HTML 页面通过 的 src 请求 http://domain-b.com/image.jpg。网络上的许多页面都会加载来自不同域的 CSS 样式表，图像和脚本等资源。 为什么会产生跨域？ 出于安全原因，浏览器限制从脚本内发起的跨源 HTTP 请求（也可能跨站请求可以正常发起，但是返回结果被浏览器拦截了） 跨域的产生来源于现代浏览器所通用的同源策略，所谓同源是指 \"协议+域名+端口\" 三者相同的情况下，才允许访问相同的 cookie、localStorage 或是发送 Ajax 请求等等 常见的跨域场景 1234567891011121314151617181920URL 说明 是否允许通信http://www.domain.com/a.jshttp://www.domain.com/b.js 同一域名，不同文件或路径 允许http://www.domain.com/lab/c.jshttp://www.domain.com:8000/a.jshttp://www.domain.com/b.js 同一域名，不同端口 不允许 http://www.domain.com/a.jshttps://www.domain.com/b.js 同一域名，不同协议 不允许 http://www.domain.com/a.jshttp://192.168.4.12/b.js 域名和域名对应相同ip 不允许 http://www.domain.com/a.jshttp://x.domain.com/b.js 主域相同，子域不同 不允许http://domain.com/c.js http://www.domain1.com/a.jshttp://www.domain2.com/b.js 不同域名 不允许 现代的跨域解决方案 通过 jsonp 跨域 document.domain + iframe 跨域 location.hash + iframe window.name + iframe 跨域 postMessage 跨域 跨域资源共享（CORS） nginx 代理跨域 nodejs 中间件代理跨域 WebSocket 协议跨域 搭建服务尝试还原跨域过程通过 koa 搭建两个本地 server 两个 server 都定义了一个 GET 请求接口 /ajax。除监听 port 不同外，app.js 还设置了静态服务。 app.js port:8000 123456789101112131415161718192021222324252627282930313233343536373839404142434445const Koa = require('koa');const app = new Koa();const index = require('./routes/index')const views = require('koa-views')const serve = require('koa-static');const path = require('path');// 引入静态资源const staticPath = path.resolve(__dirname, '/public');// 设置静态服务const staticServe = serve(staticPath, { setHeaders: (res, path, stats) =&gt; { if (path.indexOf('jpg') &gt; -1) { res.setHeader('Cache-Control', ['private', 'max-age=60']); } }});app.use(staticServe);// 增加模版引擎 默认直接渲染html文件app.use(views(__dirname + '/views'));// 引入路由配置文件app.use(index.routes(), index.allowedMethods())router.get('/ajax', async (ctx, next) =&gt; { console.log('get request', ctx.request.header.referer); ctx.body = 'received';});app.listen(8000,()=&gt;{ console.log('app1 server is listening port 8000');});console.log('demo in run.....')// route.js router.get('/ajax', async (ctx, next) =&gt; { console.log('get request', ctx.request.header.referer); ctx.body = 'received'; }); app2.js port:3000 123456789101112131415161718192021222324const koa = require('koa');const app = new koa();const app2Route = require('./routes/app2Route')const cors = require('koa2-cors');app.use(app2Route.routes(), app2Route.allowedMethods())const main = async function(ctx,next) { ctx.response.body = '3000端口';await next();}app.use(main)app.listen(3000);console.log('app2 server is listening port 3000');// route.js router.get('/ajax', async (ctx, next) =&gt; { console.log('get request', ctx.request.header.referer); ctx.body = 'received'; }); 前端模版 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;cross-origin test&lt;/title&gt;&lt;/head&gt;&lt;body style=\"width: 600px; margin: 200px auto; text-align: center\"&gt; &lt;button onclick=\"getAjax()\"&gt;GET 简单请求&lt;/button&gt; &lt;button onclick=\"getJsonP()\"&gt;JSONP&lt;/button&gt; &lt;button onclick=\"corsWithJson()\"&gt;POST 非简单请求&lt;/button&gt;&lt;/body&gt;&lt;script src=\"http://code.jquery.com/jquery-2.1.1.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; var baseUrl = 'http://localhost:3000';function getAjax() { var xhr = new XMLHttpRequest(); xhr.open('GET', baseUrl + '/ajax', true); xhr.onreadystatechange = function() { // readyState == 4说明请求已完成 if (xhr.readyState == 4 &amp;&amp; xhr.status == 200 || xhr.status == 304) { // 从服务器获得数据 alert(xhr.responseText); } else { console.log(xhr.status); } }; xhr.send(); }&lt;/script&gt;&lt;/html&gt; 很简单 大概长这样儿 AJAX 测试 case 同域下请求 ajax 不涉及跨域 请求接口：baseUrl = 'http://localhost:8000';测试结果👇 跨域 ajax 请求请求接口：baseUrl = 'http://localhost:3000';测试结果👇很明显 跨域了 针对浏览器的 Ajax 请求跨域的主要解决方案有：JSONP、CORS。 JSONP 原理 虽然浏览器同源策略限制了 XMLHttpRequest 请求不同域上的数据。但是，在页面上引入不同域的 js 脚本是可以的，而且 script 元素请求的脚本会被浏览器直接运行 测试 origin.html 添加 123456789 function getJsonP() { var script = document.createElement('script'); script.src = baseUrl + '/jsonp?type=json&amp;callback=onBack'; document.head.appendChild(script);}function onBack(res) { alert('JSONP CALLBACK: ' + JSON.stringify(res) + ''); } getJsonP 方法会在当前页面添加一个 script，src 属性指向跨域的 GET 请求通过 query 格式带上请求的参数。callback 是关键，用于定义跨域请求回调的函数名称，这个值必须后台和脚本保持一致 在 app2.js 添加路由 1234567891011router.get('/jsonp', async (ctx, next) =&gt; { const req = ctx.request.query; console.log(req); const data = { data: req.type } ctx.body = req.callback + '('+ JSON.stringify(data) +')';})app.use(router.routes()); 针对 jsonp 请求，后台要做的是： 获取请求参数中的 callback 值，如本例中的 onBack将 callback 的值以 function (args) 的格式作为 response。 重启服务 触发页面的 JSONP🔘 优点JSONP 方案的兼容性好，IE 浏览器也支持。 缺点 12因为是利用的&lt;script&gt;元素，所以只支持GET请求。缺乏错误处理机制 CORS CORS 即跨域资源分享，是 W3C 制定的标准。 特性CORS 需要浏览器和服务器同时支持。 12大多主流浏览器都支持，IE 10以下不支持。只要服务器端实现了CORS接口，浏览器就能自动实现基于CORS的跨域请求。 两种请求 浏览器将 CORS 请求分成两类：简单请求和非简单请求。 简单请求满足条件：请求类型为 HEAD，GET，POST之一；请求头信息不超出以下几种： 12345AcceptAccept-LanguageContent-LanguageLast-Event-IDContent-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 对于简单请求，浏览器会直接发出，同时在请求头中添加 Origin 字段。 Origin 用来说明请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。如果 Origin 指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含 Access-Control-Allow-Origin 字段（详见下文），就知道出错了，从而抛出一个错误，被 XMLHttpRequest 的 onerror 回调函数捕获。注意，这种错误无法通过状态码识别，因为 HTTP 回应的状态码有可能是 200。 回顾下直接 Ajax 测试跨域的请求报文： 浏览器为这个简单的 GET 请求添加了 Origin，而响应头信息中没有 Access-Control-Allow-Origin，浏览器判断请求跨域，给出错误提示。 非简单请求 非简单请求是那种对服务器有特殊要求的请求，比如请求方法是 PUT 或 DELETE，或者 Content-Type 字段的类型是 application/json。 非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为” 预检” 请求（preflight）。 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的 XMLHttpRequest 请求，否则就报错。 在 origin.html 中添加一个 post 请求： 1234567891011121314function corsWithJson() { $.ajax({ url: baseUrl + '/cors', type: 'post', contentType: 'application/json', data: { type: 'json', }, success: function(data) { console.log(data); } }) } 通过设置 Content-Type 为 appliaction/json 使其成为非简单请求： 启动服务“预检” 请求的方法为 OPTIONS，服务器判断 Origin 为跨域 除了 Origin 字段，” 预检” 请求的头信息包括两个特殊字段。 （1）Access-Control-Request-Method该字段是必须的，用来列出浏览器的 CORS 请求会用到哪些 HTTP 方法，上例是 PUT。（2）Access-Control-Request-Headers该字段是一个逗号分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段，上例是 content-type。 服务端设置 CORS 在 app2.js 引入 koa2-cors： 1234567891011121314app.use(cors({ origin: function (ctx) { if (ctx.url === '/cors') { return \"*\"; // 允许来自所有域名请求 } return 'http://localhost:3201'; }, exposeHeaders: ['WWW-Authenticate', 'Server-Authorization'], maxAge: 5, credentials: true, allowMethods: ['GET', 'POST', 'DELETE'], //设置允许的HTTP请求类型 allowHeaders: ['Content-Type', 'Authorization', 'Accept'],})); 重启服务后，浏览器重新发送 POST 请求。可以看到浏览器发送了两次请求。 （1）Access-Control-Allow-Methods该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次” 预检” 请求。（2）Access-Control-Allow-Headers如果浏览器请求包括 Access-Control-Request-Headers 字段，则 Access-Control-Allow-Headers 字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在” 预检” 中请求的字段。（3）Access-Control-Allow-Credentials该字段可选。它的值是一个布尔值，表示是否允许发送 Cookie。默认情况下，Cookie 不包括在 CORS 请求之中。设为 true，即表示服务器明确许可，Cookie 可以包含在请求中，一起发给服务器。这个值也只能设为 true，如果服务器不要浏览器发送 Cookie，删除该字段即可。（4）Access-Control-Max-Age该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是 20 天（1728000 秒），即允许缓存该条回应 1728000 秒（即 20 天），在此期间，不用发出另一条预检请求。 现在为止 默认你已经完全理解跨域了哦 示例中的源代码","categories":[{"name":"web","slug":"web","permalink":"http://maying.ink/categories/web/"}],"tags":[{"name":"CORS","slug":"CORS","permalink":"http://maying.ink/tags/CORS/"}]},{"title":"前端防刷实现","slug":"前端防刷","date":"2018-12-26T13:40:40.000Z","updated":"2020-10-22T18:41:42.190Z","comments":true,"path":"2018/12/26/前端防刷/","link":"","permalink":"http://maying.ink/2018/12/26/%E5%89%8D%E7%AB%AF%E9%98%B2%E5%88%B7/","excerpt":"前段时间写了前端防刷逻辑 作此记录当时的需求 防刷逻辑 1 24 小时内 一个手机号只能提交三次 第四次提交的时候 提示 已提交成功 请耐心等待 400防刷逻辑 2 24 小时内 提交三个手机号 提交第四个时 提示 401","text":"前段时间写了前端防刷逻辑 作此记录当时的需求 防刷逻辑 1 24 小时内 一个手机号只能提交三次 第四次提交的时候 提示 已提交成功 请耐心等待 400防刷逻辑 2 24 小时内 提交三个手机号 提交第四个时 提示 401 步骤一 页面加载 获取 cookie 中当前的信息 12345 componentDidMount() { // 获取cookie里存的用户信息 let cookieSaveInfo = getCookie(COOKIE_CONFIG.FINANCIAL_SAVE_INFO) || \"{}\"; //todo...} 点击保存按钮 防刷逻辑 1234567891011121314151617181920212223242526saveInfo = () =&gt; { const { userInfoFromCookie, setModal } = this; // 获取手机号列表 let phoneList = Object.keys(userInfoFromCookie); // ['12','21212','212'] // 获取当前存的手机号的个数 let phoneListLength = phoneList.length; // 当前输入的存在手机号列表中 if (phone in userInfoFromCookie) { if (userInfoFromCookie[phone] &gt;= 3) { // 当前的手机号存在手机列表中 看当前是第几次 大于三次提示 setModal(400); //todo... return; //防御式编程 } } else if (phoneListLength &gt;= 3) { // 如果当前列表中已经有三个不同的手机号 则提示401 setModal(401); return; } //可以发起请求 } 请求成功的回调 12345678910111213141516 saveFunc = (resData) =&gt; { let thePhoneCount = userInfoFromCookie[phone] || 1; if (resData.error_code === 200) { // 存cookie 规则 看下当前手机号在不在列表里 在的话 就更新次数 不在的数就设置这个key if (phone in userInfoFromCookie) { userInfoFromCookie[phone] = thePhoneCount + 1; } else { userInfoFromCookie[phone] = thePhoneCount; } // cookie存储 setCookie(COOKIE_CONFIG.FINANCIAL_SAVE_INFO, JSON.stringify(userInfoFromCookie), 24 * 60 * 60); } }","categories":[{"name":"js","slug":"js","permalink":"http://maying.ink/categories/js/"}],"tags":[]},{"title":"addEventListener 中的 passive 用法","slug":"passive","date":"2018-12-21T13:40:40.000Z","updated":"2020-10-22T18:41:42.184Z","comments":true,"path":"2018/12/21/passive/","link":"","permalink":"http://maying.ink/2018/12/21/passive/","excerpt":"","text":"引出问题一个很简单的需求 页面有一张小图 点击是个 swiper 实现的图集 同时有一个灰色的蒙层 蒙层底部页面不可滑动 关闭蒙层 页面可恢复正常 实现方式 12345678910111213function bodyScroll(event){ event.preventDefault();}function _switchTag(type) { if (type === 'on') { window.addEventListener('touchmove', bodyScroll); } else { window.removeEventListener('touchmove', bodyScroll); }}_switchTag(on) 页面不可滑动_switchTag(off) 页面恢复滑动 移动端的效果如下android ios 我不知道为什么无效 直到我在模拟器上看到了 啊哦 报错了🦢 Unable to preventDefault inside passive event listener due to target being treated as passive来自 google 的解释 https://developers.google.com/web/updates/2017/01/scrolling-intervention 大概的意思是说 1234567由于浏览器必须要在执行事件处理函数之后，才能知道有没有调用过 preventDefault() ，这就导致了浏览器不能及时响应滚动，略有延迟。所以为了让页面滚动的效果如丝般顺滑，从 chrome56 开始，在 window、document 和 body 上注册的 touchstart 和 touchmove 事件处理函数，会默认为是 passive: true。浏览器忽略 preventDefault() 就可以第一时间滚动了。举例：wnidow.addEventListener('touchmove', func) 效果和下面一句一样wnidow.addEventListener('touchmove', func, { passive: true }) 这就导致了这个问题 1如果在以上这 3 个元素的 touchstart 和 touchmove 事件处理函数中调用 e.preventDefault() ，会被浏览器忽略掉，并不会阻止默认行为 所以出现了以上视频中问题 解决方案那么我们如何来解决这个问题 即不要让浏览器忽略掉 e.preventDefault ()？ window.addEventListener(‘touchmove’, func, { passive: false }) 设置 passive: false 之后的结果androidios浏览器问题完美解决 12345678910111213你看到这里可以结束了 如果你还想再了解\b一点点👇👇👇👇#### 你可能不知道的addEventListener很久之前addEventListener的参数是这样儿的`addEventListener(type, listener, useCapture)`后来也就是控制监听器是在捕获阶段执行还是在冒泡阶段执行的 useCapture 参数，变成了可选参数`addEventListener(type, listener [,useCapture])`再后来 DOM 规范做了修订addEventListener() 的第三个参数可以是个对象值了，也就是说第三个参数现在可以是两种类型的值了 变成这样儿式儿的 addEventListener(type, listener[, useCapture ])addEventListener(type, listener[, options ]) 123扩展新的选项，从而自定义更多的行为，目前规范中 options 对象可用的属性有三个： addEventListener(type, listener, { capture: false, 等价于 useCapture 默认值 false passive: false, 是否让阻止默认事件失效 true: 失效 false：不失效 once: false // 表明该监听器是一次性的，执行一次后就被自动 removeEventListener 掉，还没有浏览器实现它 默认值 false}) 123还想再说一点 那我设置了 passive的事件 这么移除呢 这里给出了方法 你可以直接省略第三个参数window.removeEventListener(‘touchmove’, func) 如果添加了 第一个参数 capture 可以这样移除 window.removeEventListener(‘touchmove’, func, true)window.removeEventListener(‘touchmove’, func, {capture :true}) 为什么会有 passive 这个概念像这样儿的代码 1234document.addEventListener(\"touchstart\", function(e){ ... // 浏览器不知道这里会不会有 e.preventDefault()}) 由于 touchstart 事件对象的 cancelable 属性为 true，也就是说它的默认行为可以被监听器通过 preventDefault () 方法阻止，那它的默认行为是什么呢，通常来说就是滚动当前页面（还可能是缩放页面），如果它的默认行为被阻止了，页面就必须静止不动。但浏览器无法预先知道一个监听器会不会调用 preventDefault ()，它能做的只有等监听器执行完后再去执行默认行为，而监听器执行是要耗时的，有些甚至耗时很明显，这样就会导致页面卡顿。视频里也说了，即便监听器是个空函数，也会产生一定的卡顿，毕竟空函数的执行也会耗时。 有 80% 的滚动事件监听器是不会阻止默认行为的，也就是说大部分情况下，浏览器是白等了。所以，passive 监听器诞生了，passive 的意思是 “顺从的”，表示它不会对事件的默认行为说 no，浏览器知道了一个监听器是 passive 的，它就可以在两个线程里同时执行监听器中的 JavaScript 代码和浏览器的默认行为了","categories":[{"name":"js","slug":"js","permalink":"http://maying.ink/categories/js/"}],"tags":[]},{"title":"一个问题引出的 pushState 用法","slug":"pushState","date":"2018-11-27T10:40:40.000Z","updated":"2020-10-22T18:41:42.185Z","comments":true,"path":"2018/11/27/pushState/","link":"","permalink":"http://maying.ink/2018/11/27/pushState/","excerpt":"","text":"引出问题为什么有这篇文章.最近的开发中遇到这么一个问题如下图扫码进入网页 点击弹出覆盖整个手机屏幕的层 此时点击浏览器的返回 会直接回退到之前扫码页面其实 这个逻辑很合理 因为它没有历史记录 没有所谓的上一个页面 程序上是合理的但用户体验无疑是差到极致对于用户来讲 可能我只是想把当前的弹层关掉而不是退出网页 那么如何解决呢？ 解决方案没有历史记录 那我们就手动造出来一条 “历史记录”，让程序的返回时 能够有迹可循最终效果 相关代码 123456789101112131415161718192021222324252627282930313233 componentDidMount(){ //监听popstate事件 window.addEventListener('popstate',() =&gt; { this.navLeftClick(); }) } //弹层的返回按钮 navLeftClick = () =&gt; { this.setState({ showBrandContainer: false })}componentWillUnmount() { // 离开页面的时候取消监听popstate window.removeEventListener('popstate',(state) =&gt; { this.back(); }) } selectBrand = () =&gt; { window.history.pushState({page: 1}, \"title 1\", \"?page=1\"); //向history对象push一条state &lt;!-- 实现参数透传---- let search = window.location.search; window.history.pushState({ page: 1 }, \"\", search); 实现参数透传---- --&gt; this.setState({ showBrandContainer: true //开启弹层 }) } HistoryDOM 中的 window 对象通过 window.history 方法提供了对浏览器历史记录的读取，让你可以在用户的访问记录中前进和后退从 HTML5 开始，我们可以开始操作这个历史记录堆栈前进 window.history.forward();后退 window.history.back();向前移动 N 页 window.history.go(-N);向后移动 N 页 window.history.go(N);你甚至可以通过检查浏览器历史记录的 length 属性来找到历史记录堆栈中的页面总数window.history.length HTML5 history 新特性 pushState、replaceStateHTML5 引入了 histtory.pushState () 和 history.replaceState () 这两个方法，他们允许添加和修改 history 实体。同时，这些方法会和 window.onpostate 事件一起工作，关于 window.popstate 可参考 window.popstatepushState：向 history 添加当前页面的记录 使用 history.pushState () 方法来修改 referrerreplaceState：和 pushState 的用法完全一样，区别就是它用于修改当前页面在 history 中的记录 一个🌰 123456假设http://10.70.134.53:3000/opt/financial 控制台执行了JSvar stateObj = { foo: \"test\" }; history.pushState(stateObj, \"page 2\",\"test.html\");url地址栏变为 http://10.70.134.53:3000/opt/test.html，但浏览器不会加载bar.html页面，即使这个页面存在也不会加载。此时 如果你点击浏览器的返回 浏览器就貌似有了前一页如下图： 总结： 关于 popstate 事件 需要注意的几点 调用 history.pushState () 或者 history.replaceState () 不会触发 popstate 事件. popstate 事件只会在浏览器某些行为下触发，比如点击后退、前进按钮 (或者在 JavaScript 中调用 history.back ()、history.forward ()、history.go () 方法). 也就是说 要触发该事件 你需要两步 添加并激活一个历史记录条目 (history.pushState) . 改变历史记录条目 (用户行为，比如后退，前进)","categories":[{"name":"react","slug":"react","permalink":"http://maying.ink/categories/react/"}],"tags":[]},{"title":"揭秘 setState 机制","slug":"揭秘setState机制","date":"2018-11-23T08:40:40.000Z","updated":"2020-10-22T18:41:42.191Z","comments":true,"path":"2018/11/23/揭秘setState机制/","link":"","permalink":"http://maying.ink/2018/11/23/%E6%8F%AD%E7%A7%98setState%E6%9C%BA%E5%88%B6/","excerpt":"前言：state 是 react 中重要的概念， react 是通过管理状态来实现对组件的管理，那么 react 是如何控制组件的状态 又是如何利用状态来管理组件的呢？ 我们所知道的版本 大概是 \b通过 this.state 来访问 state，通过 setState() 方法来更新 state，当 this.state() 被调用的时候 React 会重新调用 render 方法来重新渲染 UI 那好的 先来看一道题吧 123456789101112131415161718192021222324252627282930313233343536export default class SetState extends React.Component { constructor(){ super(); this.state = { val:0 } } componentWillMount(){ this.setState({val:this.state.val+1}); console.log('componentWillMount第一次输出',this.state.val) this.setState({val:this.state.val+1}); console.log('componentWillMount第二次输出',this.state.val) } componentDidMount(){ // debugger; this.setState({val:this.state.val+1}); console.log('componentDidMount第一次输出',this.state.val) this.setState({val:this.state.val+1}); console.log('componentDidMount第二次输出',this.state.val) setTimeout(()=&gt;{ // debugger; console.log('开始setTimeout',this.state.val) this.setState({val:this.state.val+1}); console.log('第三次输出',this.state.val) this.setState({val:this.state.val+1}); console.log('第四次输出',this.state.val) },0) } render(){ return null; } } 这道题的答案是 0 0 1 1 2 3 4 假如结果与你心中的答案并不完全相同，那么你应该感兴趣这背后究竟发生了什么.","text":"前言：state 是 react 中重要的概念， react 是通过管理状态来实现对组件的管理，那么 react 是如何控制组件的状态 又是如何利用状态来管理组件的呢？ 我们所知道的版本 大概是 \b通过 this.state 来访问 state，通过 setState() 方法来更新 state，当 this.state() 被调用的时候 React 会重新调用 render 方法来重新渲染 UI 那好的 先来看一道题吧 123456789101112131415161718192021222324252627282930313233343536export default class SetState extends React.Component { constructor(){ super(); this.state = { val:0 } } componentWillMount(){ this.setState({val:this.state.val+1}); console.log('componentWillMount第一次输出',this.state.val) this.setState({val:this.state.val+1}); console.log('componentWillMount第二次输出',this.state.val) } componentDidMount(){ // debugger; this.setState({val:this.state.val+1}); console.log('componentDidMount第一次输出',this.state.val) this.setState({val:this.state.val+1}); console.log('componentDidMount第二次输出',this.state.val) setTimeout(()=&gt;{ // debugger; console.log('开始setTimeout',this.state.val) this.setState({val:this.state.val+1}); console.log('第三次输出',this.state.val) this.setState({val:this.state.val+1}); console.log('第四次输出',this.state.val) },0) } render(){ return null; } } 这道题的答案是 0 0 1 1 2 3 4 假如结果与你心中的答案并不完全相同，那么你应该感兴趣这背后究竟发生了什么. 了解 setState setState 是同步执行的 但是 state 并不一定会同步更新（异步更新） 1实际上react的异步更新通过一个队列机制来实现，当执行state时 需要将更新的state合并后放入状态队列而不会立刻更新 队列机制可以高效的批量更新state 如果在非构造方法里更改值 类似 this.state.name='yishu' 是不会被放到状态队列中 当下次调用setState并对状态队列进行合并时 将会忽略它而造成无法预知的错误 setState 在 React 生命周期和合成事件中批量覆盖执行 1在React的生命周期钩子和合成事件中，多次执行setState，会批量执行，多次同步执行的setState，会进行合并，类似于Object.assign setState 在原生事件，setTimeout，setInterval，Promise 等异步操作中，state 会同步更新 1当执行到 setTimeout 的时候，把它丢到列队里，并没有去执行，而是先执行的 finally 主进程代码块，等 finally 执行完了， isBatchingUpdates 又变为了 false ，导致最后去执行队列里的 setState 时候， requestWork 走的是和原生事件一样的 expirationTime === Sync if分支，所以表现就会和原生事件一样，可以同步拿到最新的state的值。 关于 setState 这个方法 源码记载 123456789101112131415161718ReactComponent.prototype.setState = function(partialState, callback) { //... this.updater.enqueueSetState(this, partialState); if (callback) { this.updater.enqueueCallback(this, callback, 'setState'); }}; enqueueSetState: function(publicInstance, partialState) { //... var queue =internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []); queue.push(partialState); enqueueUpdate(internalInstance); }, setState 方法实际上会执行 enqueueSetState 方法 通过_pendingStateQueue 更新队列进行合并操作 最终通过 enqueueUpdate 执行 state 更新 setState 调用栈 如图：\b通过变量 isBatchingUpdate 来决定当前是应该走批量更新 还是立即更新 为 true 时 说明当前在批量更新模式 为 false 的话 会立即更新 为了更好的理解 涉及到部分源码 enqueueUpdate 代码如下： 1234567891011function enqueueUpdate(component) { // 如果不处于批量更新模式 更新 if (!batchingStrategy.isBatchingUpdates) {batchingStrategy.batchedUpdates(enqueueUpdate, component); return; } // 如果处于批量更新模式 则将该组件保存在 dirtyComponents 中 dirtyComponents.push(component);}\b 那么这个 batchingStrategy 究竟是做什么的？ 其实它只是一个简单的对象，定义了 isBatchingUpdates 和 batchedUpdates 方法 其中 transaction.perform 的调用 涉及到了事务的概念 123456789101112131415161718// batchedUpdates 方法var ReactDefaultBatchingStrategy = { isBatchingUpdates: false, batchedUpdates: function(callback, a, b, c, d, e) { var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates; ReactDefaultBatchingStrategy.isBatchingUpdates = true; if (alreadyBatchingUpdates) { callback(a, b, c, d, e); } else { transaction.perform(callback, null, a, b, c, d, e); } },}; 事务机制事务就是将需要执行的方法使用 wrapper 封装起来 再通过事务提供的 perform 方法执行执行 perform 之前 先执行 wrapper 中的 init 方法 执行完 perform 之后 再执行 所有的 close 方法假如有一个事务 test 执行顺序表现为 init-&gt;test-&gt;close 揭秘 setState 机制那么 说了这么多，事务是怎么导致前面所述的 setState 的各种不同表现呢. 在整个 React 组件渲染到 Dom 中的过程就处于一个大的事务中 ，在生命周期和合成事件执行前后都会执行 init 和 close，init 会调用 batchedUpdate 方法将 isBatchingUpdates 变量置为 true，开启批量更新，而 close 会将 isBatchingUpdates 置为 false，setState 的更新会被存入队列中，待同步代码执行完后，再执行队列中的 state 更新。 而在原生事件和异步操作中，不会执行 pre 钩子，或者生命周期的中的异步操作之前执行了 pre 钩子，但是 pos 钩子也在异步操作之前执行完了，isBatchingUpdates 必定为 false，也就不会进行批量更新 获取正确的 state 值以下： setState 函数式 放到 setTimeout，Promise 等异步中执行 放到 componentDidUpdate 中 说在最后的话所以 开篇的结果应该可以理解了吧 我们把 didMount 中四次调用归类，前两次一类 因为它们在同一个调用栈中执行 setTimeout 中的两次属于另一类，我们重点看第一类，早在 setState 调用之前 ReactDefaultBatchingStrategy.isBatchingUpdates 已经被设置为 true，所以两次的 setSate 并没有生效 而是被放进了队列中再看 setTimeout 中的两次 state 此时的 isBatchingUpdates 为 false，这也就导致了心的 state 马上生效 没有走到队列的分支（可参考调用栈图）也就是说 第一次执行 setState 时 值就为 1 加 1 之后变为 2 第二次打印同理 参考：深入 react 技术栈一书 希望通过 setState 深入源码 知其然也知其所以然","categories":[{"name":"react","slug":"react","permalink":"http://maying.ink/categories/react/"}],"tags":[]},{"title":"彻底理解 js 是如何工作的","slug":"彻底理解js是如何工作的","date":"2018-11-17T13:23:40.000Z","updated":"2020-10-22T18:41:42.191Z","comments":true,"path":"2018/11/17/彻底理解js是如何工作的/","link":"","permalink":"http://maying.ink/2018/11/17/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3js%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/","excerpt":"曾经 你一定遇到过类似这样儿的题目 12345678910111213141516171819console.log('script start')setTimeout(function() { console.log('timer over')}, 0)Promise.resolve().then(function() { console.log('promise1')}).then(function() { console.log('promise2')})console.log('script end')输出结果：script startscript endpromise1promise2 如果你很轻松的答对并且能说出原理 那么恭喜你，倘若有些疑问，那么读完这篇文章，你一定会彻底搞懂它的运行原理。","text":"曾经 你一定遇到过类似这样儿的题目 12345678910111213141516171819console.log('script start')setTimeout(function() { console.log('timer over')}, 0)Promise.resolve().then(function() { console.log('promise1')}).then(function() { console.log('promise2')})console.log('script end')输出结果：script startscript endpromise1promise2 如果你很轻松的答对并且能说出原理 那么恭喜你，倘若有些疑问，那么读完这篇文章，你一定会彻底搞懂它的运行原理。 首先 先了解几个概念 JavaScript 引擎 js 引擎是执行 js 的程序或者解释器 我们常说的 V8 引擎就是一种 js 引擎的实现，其他的还有基于 java 开发的 Rhin Nashorn 等 V8 引擎 使用在 chrome 和 node 中，它由两部分组成 内存堆 ：这是内存分配发生的地方 调用栈： 这是你的代码执行时的地方 JS 的特性 单线程 异步 非阻塞 js 的单线程由于 js 的单线程 12345678console.log('script start')console.log('do something...')console.log('script end')// script start// do something...// script end 很好理解 那再来看 123456789101112console.log('1')console.log('2')setTimeout(() =&gt; { console.log('3')}, 1000)// 点击页面console.log('4')console.log('5') 那么它的输出是什么呢？ 应该是 1，2，4，5，3 ？ 而不是 1，2，3，4，5\b，js 不是一行一行从上到下执行的吗 为啥会出现这种情况？ 这就是我们接下来要说的问题 为什么不能同步执行？ 如果一个任务的处理耗时（或者是等待）很久的话，如：网络请求、定时器、等待鼠标点击等，后面的任务也就会被阻塞，可能会出现白屏的情况 用户体验极其不友好 \b所幸的是 浏览器给我们提供了很多有用的 webapi 如何优化？ js 的单线程指的是浏览器中负责解释和执行 js 代码的只有一个线程 -js 引擎线程 但是浏览器的渲染进程是提供多个线程的，遇到定时器 Dom 事件或者是网络请求的任务的时候 js 引擎会将他们交给 webapi 也就是浏览器提供的相应线程去处理 而 js 引擎线程继续去处理后面的任务 这样儿实现了异步非阻塞以下是日常线程： js 引擎线程 事件触发线程 定时器触发线程 异步 HTTP 请求线程 GUI 渲染线程 图示的话 大概长下面这样儿所以 这里的 图例中的 setTimeout 会被分配到定时器触发线程去维护 去定时，时间一到 还是会把它的回调塞到消息队列等待 那么 \b到这里 又引出了两个问题1. 什么叫消息队列？2.js 引擎什么时候处理这个定时器 怎么处理？ JavaScript 通过事件循环（ event loop）的机制来解决这些问题猜对了吗？事件循环 机制和 消息队列 的维护是由事件触发线程（浏览器渲染引擎 webapi 之一）控制的 JS 引擎线程 会维护一个 执行栈 同步和异步任务进入不同的执行场所 同步的进入主线程 异步的进入 Event Table 并注册函数 当指定的事情完成时 Event Table 会将这个函数移入 Event Queue 主线程内的任务执行完毕为空，会去 Event Queue 读取对应的函数，进入主线程执行 上述过程会不断重复，也就是常说的 Event Loop(事件循环)。 言语太过苍白 举个🌰～ 所以 这个时候\b来看setTimeout 异步函数对应的回调函数 (() =&gt; {} ) 会在执行栈为空，主代码块执行完了后才会执行 结果就不意外了吧 那么 像这样 123setTimeout(() =&gt; { console.log('timer')}, 0) 0 延时的情况\b是啥意思呢只是 timer 的回调函数会立即加入消息队列而已，回调的执行还是得等执行栈为空（JS 引擎线程空闲）时执行。 还没完～～ ES5 中以上标准就够用了 但是 ES6 中新出了一些 API 引出了一些新概念 宏任务与微任务 先来看一段代码 你能立刻说出它的执行结果吗 12345678910111213141516171819console.log('script start')setTimeout(function() { console.log('timer over')}, 0)Promise.resolve().then(function() { console.log('promise1')}).then(function() { console.log('promise2')})console.log('script end')// script start// script end// promise1// promise2// timer over What？ timer over 会在 promise1 promise2 之后执行？ 好的 不要着急 往下看\b👇所有任务分为 宏任务 和 微任务 宏任务（macrotask）：主代码块、setTimeout、setInterval 等（可以看到，事件队列中的每一个事件都是一个 macrotask，现在称之为宏任务队列 微任务（microtask）：Promise、process.nextTick 等 在 microtask 中 process.nextTick 优先级高于 Promise，它用来调度应在当前执行的脚本执行结束后立即执行的任务 事件（任务）队列和宏任务和微任务的联系： 一个事件循环有一个或者多个任务队列； 每个事件循环都有一个 microtask 队列 macrotask 队列就是我们常说的任务队列，microtask 队列不是任务队列 一个任务可以被放入到 macrotask 队列，也可以放入 microtask 队列 当一个任务被放入 microtask 或者 macrotask 队列后，准备工作就已经结束，这时候可以开始执行任务了 js 的执行规则： 执行一个宏任务（栈中没有就从事件队列中获取） 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行） 当前宏任务执行完毕，开始检查渲染，然后 GUI 线程接管渲染 渲染完毕后，JS 引擎线程继续，开始下一个宏任务（从宏任务队列中获取） 所以 promise1 与 promise1 属于微任务 会在\b第一个宏任务结束之后立即执行 而 setTimeout 即使延时为 0 也是要等到下个事件循环去执行的😊 再简单点的话 那就 macro-task 队列包含任务: a1, a2 , a3micro-task 队列包含任务: b1, b2 , b3 执行顺序为，首先执行 marco-task 队列开头的任务，也就是 a1 任务，执行完毕后，在执行 micro-task 队列里的所有任务，也就是依次执行 b1, b2 , b3，执行完后清空 micro-task 中的任务，接着执行 marco-task 中的第二个任务，依次循环。 再简单点的话 那就.. 上图吧😄 s 好的 理解的话 再来一个栗子 你可能继续懵逼 123456789101112setTimeout(function(){console.log(1)},0);new Promise(function(resolve,reject){ console.log(2); resolve();}).then(function(){console.log(3)}).then(function(){console.log(4)});process.nextTick(function(){console.log(5)});console.log(6);输出 2，6，5 ，3，4，1 定义 promise 的构造部分是同步的如下script (主程序代码)——&gt;process.nextTick——&gt;promise——&gt;setTimeout 关于 process.nextTick ()插入到事件队列尾部，但在下次事件队列之前会执行。也就是说，它指定的任务总是发生在所有异步任务之前，当前主线程的末尾。大致流程：当前” 执行栈” 的尾部–&gt; 下一次 Event Loop（主线程读取” 任务队列”）之前–&gt; 触发 process 指定的回调函数。服务器端 node 提供的办法。用此方法可以用于处于异步延迟的问题。可以理解为：此次不行，预约下次优先执行。 好的 再再来一个😂 123456789101112setTimeout(function(){console.log(1)},0); （\bsetTimeout1）new Promise(function(resolve,reject){ console.log(2); （promise1） setTimeout(function(){resolve()},0) （\bsetTimeout2）}).then(function(){console.log(3) （\bthen1）}).then(function(){console.log(4)}); （\bthen2）process.nextTick(function(){console.log(5)}); （nextTick）console.log(6); （\blog）输出： 2 6 5 1 3 4 区别在于 promise 的构造中，没有同步的 resolve，因此 promise.then 在当前的执行队列中是不存在的，只有 promise 从 pending 转移到 resolve，才会有 then 方法，而这个 resolve 是在一个 setTimout 时间中完成的，因此 3,4 最后输出。 写到这里 想到一个某位大师的很形象的例子 事件循环队列就类似于\b游乐园游戏，玩过了一个游戏之后 你需要到队尾去排队才能再玩一次 \b而任务队列类似 w 玩过了\b这个游戏之后 插队接着玩看到这里 文章开头的题目应该不成问题了 甚至还觉得 so easy 好的 到这里 就完了 下面是两个\bjs 运行时的概念 你可以傲娇的略过 js 执行时 js 调用栈 拥有 LIFO（后进先出）数据结构的栈，被用来存储代码运行时创建的所有执行上下文，记录了我们在程序中的位置 如果我们运行到一个函数 它就会将其放到栈顶 当从这个函数返回的时候，就会将这个函数从栈顶弹出，这就是调用栈做的事情 当 JavaScript 引擎第一次遇到你的脚本时，它会创建一个全局的执行上下文并且压入当前执行栈。每当引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部。 引擎会执行那些执行上下文位于栈顶的函数。当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文 js 执行上下文 执行上下文是评估和执行 js 代码的环境的抽象概念js 代码在执行的时候 它都是在执行上下文中运行 它分为三种类型 全局执行上下文 1它会执行两件事： 创建一个全局window对象 并且设置this的值等于这个全局对象 一个程序中只会有一个全局执行上下文 函数执行上下文 1函数被调用时候 会创建上下文，函数上下文可以有任意多个 每当一个新的执行上下文被创建 它会按定义的顺序 执行一系列步骤 eval 函数执行上下文 1执行在eval函数内部的代码会有他自己的执行上下文 js 如何创建执行上下文 两个阶段 创建阶段 执行阶段 代码执行栈 执行上下文经历创建阶段 会发生 this 值的制定 创建词法环境组件 创建变量环境组件 最后的最后 JavaScript 是单线程语言，决定于它的设计最初是用来处理浏览器网页的交互。浏览器负责解释和执行 JavaScript 的线程只有一个（所以说是单线程），即 JS 引擎线程，但是浏览器同样提供其他线程，如：事件触发线程、定时器触发线程等","categories":[{"name":"js","slug":"js","permalink":"http://maying.ink/categories/js/"}],"tags":[]},{"title":"react 基本概念解析","slug":"读react官网","date":"2018-06-23T16:00:00.000Z","updated":"2020-10-22T18:41:42.193Z","comments":true,"path":"2018/06/24/读react官网/","link":"","permalink":"http://maying.ink/2018/06/24/%E8%AF%BBreact%E5%AE%98%E7%BD%91/","excerpt":"读 react 官网 关于 react 你必须要知道的事情～","text":"读 react 官网 关于 react 你必须要知道的事情～ react 阻止默认事件在 react 阻止默认行为 必须使用 e.preventDefault(); 123456function handleClick(e) { e.preventDefault(); console.log('The link was clicked.');}这里， e 是一个合成的事件。 React 根据 W3C 规范 定义了这个合成事件，所以你不需要担心跨浏览器的兼容性问题。查看 SyntheticEvent 参考指南了解更多。 在 JSX 回调中你必须注意 this 的指向。 在 JavaScript 中，类方法默认没有 绑定 的。如果你忘记绑定 this.handleClick 并将其传递给 onClick，那么在直接调用该函数时，this 会是 undefined 。 这不是 React 特有的行为；这是 JavaScript 中的函数如何工作的一部分。 一般情况下，如果你引用一个后面没跟 () 的方法，例如 onClick={this.handleClick} ，那你就应该 绑定 (bind) 该方法。 12345678910111213141516171819202122232425262728class Toggle extends React.Component { constructor(props) { super(props); this.state = {isToggleOn: true}; // 这个绑定是必要的，使`this`在回调中起作用 this.handleClick = this.handleClick.bind(this); } handleClick() { this.setState(prevState =&gt; ({ isToggleOn: !prevState.isToggleOn })); } render() { return ( &lt;button onClick={this.handleClick}&gt; {this.state.isToggleOn ? 'ON' : 'OFF'} &lt;/button&gt; ); }}ReactDOM.render( &lt;Toggle /&gt;, document.getElementById('root')); 解决方式 12345678910111213141516class LoggingButton extends React.Component { // 这个语法确保 `this` 绑定在 handleClick 中。 // 警告：这是 *实验性的* 语法。 handleClick = () =&gt; { console.log('this is:', this); } render() { return ( &lt;button onClick={this.handleClick}&gt; Click me &lt;/button&gt; ); }} 或者 12345678910111213141516class LoggingButton extends React.Component { handleClick() { console.log('this is:', this); } render() { // 这个语法确保 `this` 被绑定在 handleClick 中 return ( &lt;button onClick={(e) =&gt; this.handleClick(e)}&gt; Click me &lt;/button&gt; ); }}这样不好 问题是这个语法的问题是，每次 LoggingButton 渲染时都创建一个不同的回调。在多数情况下，没什么问题。然而，如果这个回调被作为 prop(属性) 传递给下级组件，这些组件可能需要额外的重复渲染。我们通常建议在构造函数中进行绑定，以避免这类性能问题。 如果需要参数传递给事件处理程序 12&lt;button onClick={(e) =&gt; this.deleteRow(id, e)}&gt;Delete Row&lt;/button&gt;&lt;button onClick={this.deleteRow.bind(this, id)}&gt;Delete Row&lt;/button&gt; 使用逻辑 &amp;&amp; 操作符的内联 if 用法 来进行条件渲染 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162function Mailbox(props) { const unreadMessages = props.unreadMessages; return ( &lt;div&gt; &lt;h1&gt;Hello!&lt;/h1&gt; {unreadMessages.length &gt; 8 ? &lt;h2&gt; You have {unreadMessages.length} unread messages. &lt;/h2&gt; : '' } &lt;/div&gt; );}const messages = ['React', 'Re: React', 'Re:Re: React'];ReactDOM.render( &lt;Mailbox unreadMessages={messages} /&gt;, document.getElementById('root'));==function Mailbox(props) { const unreadMessages = props.unreadMessages; return ( &lt;div&gt; &lt;h1&gt;Hello!&lt;/h1&gt; {unreadMessages.length &gt; 8 &amp;&amp; &lt;h2&gt; You have {unreadMessages.length} unread messages. &lt;/h2&gt; } &lt;/div&gt; );}const messages = ['React', 'Re: React', 'Re:Re: React'];ReactDOM.render( &lt;Mailbox unreadMessages={messages} /&gt;, document.getElementById('root'));条件渲染的一种简便写法（类似于三目运算符）它可以正常运行，因为在 JavaScript 中， true &amp;&amp; expression 总是会评估为 expression ，而 false &amp;&amp; expression 总是执行为 false 。因此，如果条件为 true ，则 &amp;&amp; 后面的元素将显示在输出中。 如果是 false，React 将会忽略并跳过它。最low的一种方式也是借助于元素变量 let button = null; if (isLoggedIn) { button = &lt;LogoutButton onClick={this.handleLogoutClick} /&gt;; } else { button = &lt;LoginButton onClick={this.handleLoginClick} /&gt;; } 这可以帮助您有条件地渲染组件的一部分，而输出的其余部分不会更改。 使用条件操作符的内联 if-else另一个用于条件渲染元素的内联方法是使用 JavaScript 的条件操作符 condition ? true : false 。 12345678render() { const isLoggedIn = this.state.isLoggedIn; return ( &lt;div&gt; The user is &lt;b&gt;{isLoggedIn ? 'currently' : 'not'}&lt;/b&gt; logged in. &lt;/div&gt; );} 防止组件渲染 返回 null1234567891011121314151617181920212223function WarningBanner(props) { if (!props.warn) { return null; } return ( &lt;div className=\"warning\"&gt; Warning! &lt;/div&gt; );} render() { return ( &lt;div&gt; &lt;WarningBanner warn={this.state.showWarning} /&gt; &lt;button onClick={this.handleToggleClick}&gt; {this.state.showWarning ? 'Hide' : 'Show'} &lt;/button&gt; &lt;/div&gt; ); }} react 和 key键（key）键 (Keys) 帮助 React 标识哪个项被修改、添加或者移除了。数组中的每一个元素都应该有一个唯一不变的键 (Keys) 来标识： 12345const numbers = [1, 2, 3, 4, 5];const listItems = numbers.map((number) =&gt; &lt;li key={number.toString()}&gt; {number} &lt;/li&gt; 如何指定 key？如果你提取 一个 ListItem 组件，应该把 key 放置在数组处理的 元素中，不能放在 ListItem 组件自身中的 根元素上。 1234567891011121314151617181920212223242526272829function ListItem(props) { // 正确！这里不需要指定 key ： return &lt;li&gt;{props.value}&lt;/li&gt;;}function NumberList(props) { const numbers = props.numbers; const listItems = numbers.map((number) =&gt; // 正确！key 应该在这里被指定 &lt;ListItem key={number.toString()} value={number} /&gt; ); return ( &lt;ul&gt; {listItems} &lt;/ul&gt; );}const numbers = [1, 2, 3, 4, 5];ReactDOM.render( &lt;NumberList numbers={numbers} /&gt;, document.getElementById('root'));一个好的经验准则是元素中调用 map() 需要 keys 。 组合 继承react 拥有一个强大的组合模型 建议使用组合而不是继承以实现代码的重用 包含 如果你不确定要使用什么组件 在 弹层等通用的容器中比较常见建议这种组件使用特别的 children props 来直接传递 1234567891011121314151617181920function FancyBorder(props) { return ( &lt;div className={'FancyBorder FancyBorder-' + props.color}&gt; {props.children} &lt;/div&gt; );}function WelcomeDialog() { return ( &lt;FancyBorder color=\"blue\"&gt; &lt;h1 className=\"Dialog-title\"&gt; Welcome &lt;/h1&gt; &lt;p className=\"Dialog-message\"&gt; Thank you for visiting our spacecraft! &lt;/p&gt; &lt;/FancyBorder&gt; );} 1234567891011121314151617181920212223242526272829303132333435363738394041424344function Dialog(props) { return ( &lt;FancyBorder color=\"blue\"&gt; &lt;h1 className=\"Dialog-title\"&gt; {props.title} &lt;/h1&gt; &lt;p className=\"Dialog-message\"&gt; {props.message} &lt;/p&gt; {props.children} &lt;/FancyBorder&gt; );}class SignUpDialog extends React.Component { constructor(props) { super(props); this.handleChange = this.handleChange.bind(this); this.handleSignUp = this.handleSignUp.bind(this); this.state = {login: ''}; } render() { return ( &lt;Dialog title=\"Mars Exploration Program\" message=\"How should we refer to you?\"&gt; &lt;input value={this.state.login} onChange={this.handleChange} /&gt; &lt;button onClick={this.handleSignUp}&gt; Sign Me Up! &lt;/button&gt; &lt;/Dialog&gt; ); } handleChange(e) { this.setState({login: e.target.value}); } handleSignUp() { alert(`Welcome aboard, ${this.state.login}!`); }} 自定义组件写法用户自定义的组件必须以大写字母开头 但一个元素类型以小写字母开头 他表示引用一个类似于或者的内置组件以大写字母开头的类型，类似于 ，会被编译成 React.createElement (Foo) ，对应于自定义组件 或者在 JavaScript 文件中导入的组件。 123456789101112import React from 'react';// 错误！这是一个组件，首字母应该大写：function hello(props) { // 正确！这种使用 &lt;div&gt; 是合法的，因为 div 是一个有效的HTML标记： return &lt;div&gt;Hello {props.toWhat}&lt;/div&gt;;}function HelloWorld() { // 错误！React 认为 &lt;hello /&gt; 是一个 HTML 标签，因为它首字母应不是大写的： return &lt;hello toWhat=\"World\" /&gt;;} 字符串字面量 123&lt;MyComponent message=\"hello world\" /&gt;====&lt;MyComponent message={'hello world'} /&gt; props (属性) 默认为 true 123&lt;MyTextBox autocomplete /&gt;===&lt;MyTextBox autocomplete={true} /&gt; jsx 中的 children 字符串变量 12&lt;MyComponent&gt;Hello world!&lt;/MyComponent&gt;这是有效的 JSX ，MyComponent 组件中的 props.children 值为字符串 \"Hello world!\" 。 JSX 会删除每行开头和结尾的空格，并且也会删除空行。邻接标签的空行也会被移除，字符串之间的空格会被压缩成一个空格，因此下面的渲染效果都是相同的 123456789101112131415&lt;div&gt;Hello World&lt;/div&gt;&lt;div&gt; Hello World&lt;/div&gt;&lt;div&gt; Hello World&lt;/div&gt;&lt;div&gt; Hello World&lt;/div&gt; Booleans, Null, 和 Undefined 被忽略false，null，undefined，和 true 都是有效的的 children (子元素) 。但是并不会被渲染，下面的 JSX 表达式渲染效果是相同的： 1234567891011&lt;div /&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;{false}&lt;/div&gt;&lt;div&gt;{null}&lt;/div&gt;&lt;div&gt;{undefined}&lt;/div&gt;&lt;div&gt;{true}&lt;/div&gt; 在有条件渲染的时候非常有用 如果 showheader 为 true 的时候 会被渲染（必须保证 &amp;&amp; 表达式之前总是布尔值） 12345&lt;div&gt; {showHeader &amp;&amp; &lt;Header /&gt;} &lt;Content /&gt;&lt;/div&gt; 如果在输出中想要渲染 false true null 或者 undefined 必须先将其转化为字符串 1234&lt;div&gt; My JavaScript variable is {String(myVariable)}.&lt;/div&gt; 使用 propType 进行类型检查可以通过赋值特定的 default 属性为 pros 定义默认值 1234567891011121314151617181920212223242526272829303132333435class Greeting extends React.Component { render() { return ( &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt; ); }}// 指定 props 的默认值：Greeting.defaultProps = { name: 'Stranger'};// 渲染为 \"Hello, Stranger\":ReactDOM.render( &lt;Greeting /&gt;, document.getElementById('example'));或者 class Greeting extends React.Component { static defaultProps = { name: 'stranger' } render() { return ( &lt;div&gt;Hello, {this.props.name}&lt;/div&gt; ) }}propTypes 的类型检测是在defaultProps 解析之后发生的，因此也会对默认属性 defaultProps 进行类型检测。 ES6 声明 class 组件12345678class Greeting extends React.Component { // ...}Greeting.defaultProps = { name: 'Mary'}; 设置初始化组件1234567class Counter extends React.Component { constructor(props) { super(props); this.state = {count: props.initialCount}; } // ...} 一致性比较（diff 算法的实现）123使用react的时候 任何一个单点时刻可以认为 render（）函数的作用是创建react元素树在下一个state或者props更新的时候 render（）函数将会返回一个不同的react元素树接下来 react将会找出如何高效的更新ui来匹配最近时刻的react元素树 react 基于以下两个假设实现了时间复杂度为 o（n）的算法 不同类型的两个元素将会产生不同的树。 开发人员可以使用一个 key prop 来指示在不同的渲染中那个那些元素可以保持稳定 diff 算法当比较不同的树 react 会首先比较两个根元素 根据根的类型不同 它有不同的行为 元素类型不相同时无论什么时候 当根元素类型不同时，react 将会销毁原先的树并重写构建新的树当销毁原先的树时 之前的 dom 节点将销毁，实例组件执行 componentWillUnmount () 。当构建一个新的树 新的 dom 节点将会插入 dom 中 组件将会执行 componentWillMount () 以及 componentDidMount () 。与之前旧的树相关的 state 都会丢失。 dom 元素类型相同时当元素类型相同 react 会比较检查它们的属性（attributes）保留相同的底层 dom 节点 只更新发生改变的属性 123&lt;div className=\"before\" title=\"stuff\" /&gt;&lt;div className=\"after\" title=\"stuff\" /&gt; 通过比较两个元素，React 会仅修改底层 DOM 节点的 className 属性。在处理完当前 DOM 节点后，React 会递归处理子节点。 相同类型的组件当一个组件更新的时候 组件实例保持不变 以便在渲染中保持 state react 会更新组件实例的属性来匹配新的元素 并在组件实例中调用 componentWillReceiveProps () 和 componentWillUpdate ()。接下来， render () 方法会被调用并且 diff 算法对上一次的结果和新的结果进行递归。 子元素递归1234567891011&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt; &lt;li&gt;third&lt;/li&gt;&lt;/ul&gt;React 会比较两个 &lt;li&gt;first&lt;/li&gt; 树与两个 &lt;li&gt;second&lt;/li&gt; 树，然后插入 &lt;li&gt;third&lt;/li&gt; 树。 1234567891011&lt;ul&gt; &lt;li&gt;Duke&lt;/li&gt; &lt;li&gt;Villanova&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt; &lt;li&gt;Connecticut&lt;/li&gt; &lt;li&gt;Duke&lt;/li&gt; &lt;li&gt;Villanova&lt;/li&gt;&lt;/ul&gt;React 将会改变每一个子节点而没有意识到需要保留 &lt;li&gt;Duke&lt;/li&gt; 和 &lt;li&gt;Villanova&lt;/li&gt; 两个子树。这种低效是一个问题。 怎么解决类似的问题为了解决这个问题 react 支持一个 key 属性 当子节点有了 key react 使用这个 key 去比较原来的树的子节点和之后的子节点 1234567891011&lt;ul&gt; &lt;li key=\"2015\"&gt;Duke&lt;/li&gt; &lt;li key=\"2016\"&gt;Villanova&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt; &lt;li key=\"2014\"&gt;Connecticut&lt;/li&gt; &lt;li key=\"2015\"&gt;Duke&lt;/li&gt; &lt;li key=\"2016\"&gt;Villanova&lt;/li&gt;&lt;/ul&gt;现在 react知道2014的key元素是新的 key为2015和2016的两个元素仅仅只是被移动而已 片段解决痛点 123456789101112131415161718192021222324252627282930313233343536class Table extends React.Component { render() { return ( &lt;table&gt; &lt;tr&gt; &lt;Columns /&gt; &lt;/tr&gt; &lt;/table&gt; ); }}为了渲染有效的 HTML ， &lt;Columns /&gt; 需要返回多个 &lt;td&gt; 元素。如果 &lt;Columns /&gt; 的 render() 函数里面使用一个父级 div ，那么最终生成的 HTML 将是无效的。class Columns extends React.Component { render() { return ( &lt;div&gt; &lt;td&gt;Hello&lt;/td&gt; &lt;td&gt;World&lt;/td&gt; &lt;/div&gt; ); }}最后会渲染成&lt;table&gt; &lt;tr&gt; &lt;div&gt; &lt;td&gt;Hello&lt;/td&gt; &lt;td&gt;World&lt;/td&gt; &lt;/div&gt; &lt;/tr&gt;&lt;/table&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041使用方式class Columns extends React.Component { render() { return ( &lt;React.Fragment&gt; &lt;td&gt;Hello&lt;/td&gt; &lt;td&gt;World&lt;/td&gt; &lt;/React.Fragment&gt; ); }}新的声明方式（看起来像空标签）class Columns extends React.Component { render() { return ( &lt;&gt; &lt;td&gt;Hello&lt;/td&gt; &lt;td&gt;World&lt;/td&gt; &lt;/&gt; ); }}带key的片段function Glossary(props) { return ( &lt;dl&gt; {props.items.map(item =&gt; ( // 没有`key`，将会触发一个key警告 &lt;React.Fragment key={item.id}&gt; &lt;dt&gt;{item.term}&lt;/dt&gt; &lt;dd&gt;{item.description}&lt;/dd&gt; &lt;/React.Fragment&gt; ))} &lt;/dl&gt; );}key 是唯一可以传递给 Fragment 的属性。在将来，我们可能增加额外的属性支持，比如事件处理。 插槽Portals 提供了一种很好的方法，将子节点渲染到父组件 DOM 层次结构之外的 DOM 节点。 ReactDOM.createPortal(child, container) 12第一个参数（child）是任何可渲染的 React 子元素，例如一个元素，字符串或 片段(fragment)。第二个参数（container）则是一个 DOM 元素。 123456789101112131415161718render() { // React 装载一个新的 div，并将 children 渲染到这个 div 中 return ( &lt;div&gt; {this.props.children} &lt;/div&gt; );}然而，有时候将子元素插入到 DOM 节点的其他位置会有用的：render() { // React *不* 会创建一个新的 div。 它把 children 渲染到 `domNode` 中。 // `domNode` 可以是任何有效的 DOM 节点，不管它在 DOM 中的位置。 return ReactDOM.createPortal( this.props.children, domNode, );} 错误边界部分 UI 中的 JavaScript 错误不应该破坏整个应用程序，错误边界是 React 组件，它可以在子组件树的任何位置捕获 JavaScript 错误，记录这些错误，并显示一个备用 UI ** ，而不是使整个组件树崩溃。错误边界 (Error Boundaries) 在渲染，生命周期方法以及整个组件树下的构造函数中捕获错误。 12345678910111213141516171819202122232425class ErrorBoundary extends React.Component { constructor(props) { super(props); this.state = { hasError: false }; } 有这个生命周期方法 证明是错误边界方式 componentDidCatch(error, info) { // Display fallback UI this.setState({ hasError: true }); // You can also log the error to an error reporting service logErrorToMyService(error, info); } render() { if (this.state.hasError) { // You can render any custom fallback UI return &lt;h1&gt;Something went wrong.&lt;/h1&gt;; } return this.props.children; }}调用&lt;ErrorBoundary&gt; &lt;MyWidget /&gt;&lt;/ErrorBoundary&gt; 注意错误边界 (Error Boundaries) 仅可以捕获其子组件的错误。错误边界无法捕获其自身的错误。如果一个错误边界无法渲染错误信息，则错误会向上冒泡至最接近的错误边界。这也类似于 JavaScript 中 catch {} 的工作机制 https://codepen.io/anon/pen/VdyBrE?editors=0010 未捕获错误的新行为这一改变有非常重要的意义。自 React 16 开始，任何未被错误边界捕获的错误将会卸载整个 React 组件树。 时间处理器如何处理错误边界无法捕获事件处理器内部的错误。 因为时间处理器不会在渲染周期内触发因此若他们抛出异常 react 仍然能够知道需要在屏幕中显示什么如果你需要在事件处理器内部捕获错误，使用普通的 JavaScript try /catch 语句： 1234567891011121314151617181920class MyComponent extends React.Component { constructor(props) { super(props); this.state = { error: null }; } handleClick = () =&gt; { try { // Do something that could throw } catch (error) { this.setState({ error }); } } render() { if (this.state.error) { return &lt;h1&gt;Caught an error.&lt;/h1&gt; } return &lt;div onClick={this.handleClick}&gt;Click Me&lt;/div&gt; } 代码拆分 123import { add } from './math';console.log(add(16, 26)); 以后 123import(\"./math\").then(math =&gt; { console.log(math.add(16, 26));}); 当 Webpack 遇到这个语法时，它会自动启动 代码拆分 来拆分你的应用程序。 react component Mounting (装载) 当组件实例被创建并且将其插入 dom 时 z 和谐方法将会被调用 1234constructor()componentWillMount()render()componentDidMount() Updating (更新)改变 props 或者 state 可以触发更新事件，在重新渲染组件时将会调用 123456componentWillReceiveProps()shouldComponentUpdate()componentWillUpdate()render()componentDidUpdate() Unmounting (卸载)当一个组件从 Dom 中删除时 将会调用 1componentWillUnmount() render () 方法render () 函数应该是纯函数，这意味着它不会修改组件状态，每次调用它时返回相同的结果 如果 shouldComponentUpdate () 方法返回 false ，render () 不会被调用。 当被调用时，它会检查 this.props 和 this.state 并返回其中一个类型 12345react元素字符串和数字Portals ReactDOM.createPortal 创建。null:不渲染任何东西布尔值:不渲染任何东西 （通常存在于 return test &amp;&amp; &lt;Child /&gt;写法，其中 test 是布尔值。） 你可以返回 null 或 false 来表示你不想要渲染任何东西 当返回 null 或 false 时，ReactDOM.findDOMNode (this) 将返回 null当你想返回多个元素时 用数组操作 1234567render() { return [ &lt;li key=\"A\"&gt;First item&lt;/li&gt;, &lt;li key=\"B\"&gt;Second item&lt;/li&gt;, &lt;li key=\"C\"&gt;Third item&lt;/li&gt;, ];} constructor () 方法组件被装载前调用，当实现 react.component 时子类的 constructor (构造函数) 时 应该最先调用 super(props) 否则将找不到 this 报错 可以在构造函数中初始化 state 采用this.state={} 的方式而不是使用 setState () 构造函数也经常用于将事件处理程序绑定到类实例 (目前可以用箭头函数解决此类问题)如果 state 需要根据 props 的值来初始化，就是你需要考虑变量提升的时候 如果你没有初始化 状态 (state) ，并且没有绑定方法，不用实现一个构造函数 componentWillMount()在组件装载之前立即被调用的方法 在 render 之前渲染 所以 不会触发 render也是服务端渲染调用的唯一的生命周期的钩子 componentDidMount()组件装载之后立即被调用初始化需要的 dom 节点或从远程加载数据的地方在这里调用 setState() 会触 render ()但会在浏览器更新屏幕之前发生。在这种情况下，即使 render () 会被调用两次， 也可以保证用户不会看到中间状态 componentWillReceiveProps() 在已装载组件接收新 props 之前被调用， 可以在此方法中比较 this.props 和 nextProps 并使用 this.setState () 执行状态转换。 shouldComponentUpdate(nextProps, nextState)让 React 知道组件的输出是否不受 state 或 props 当前变化的影响，默认行为是在每次 state 更改时重新渲染，并且在绝大多数情况下，你应该依赖于默认行为。当接收到新的 props 或 state 时，shouldComponentUpdate () 在渲染之前被调用。 默认返回 true ，对于初始 (第一次) 渲染，不调用此方法，返回 false 不会阻止子组件在 state 更改时重新渲染 但是componentWillUpdate() ，render() 和 componentDidUpdate() 将不会被调用 componentWillUpdate()当接收到 state 或者 props，它会在渲染之前被调用 componentDidUpdate()在更新发生之立即被调用，当组件已经更新时，也可以在这里操作 dom 也可以做网络请求 componentWillUnmount()当组件被卸载和销毁之前 被调用 可以在此执行必要的清理 计时器 网络请求 或者在 didmount 创建的元素 123456789101112componentDidMount() { this.serverRequest = axios.get('/api') .then(posts =&gt; { this.setState({ posts }) })}componentWillUnmount() { this.serverRequest.abort()} componentDidCatch()错误边界 可以在其_子组件树 _中的任何位置捕获 js 错误 显示备用 ui错误边界在渲染过程中，在生命周期方法中，以及整个树下的构造函数中捕获错误。 setState()setState () 总是会导致重新渲染，除非 shouldComponentUpdate () 返回 false setState 是作为一个请求而不是立即命令来更新组件 为了性能考虑 react 可能会批量 或 延迟到后面更新它 然后合并多个 setState () 更新多个组件React 不保证 state 更新就立即应用 (重新渲染)。所以更新之后立即读取可能会有问题你可以使用 componentDidUpdate 或者 setState 回调 （setState(updater, callback)） 12345678910111213141516171819202122例如，假设我们想通过 props.step 在 state 中增加一个值：this.setState((prevState, props) =&gt; { return {counter: prevState.counter + props.step};});setState(stateChange, [callback])这将执行 stateChange 的浅合并到新的 state 这种也是异步的会进行批处理 如果同一时间段需要多次操作 可能会被覆盖Object.assign( previousState, {quantity: state.quantity + 1}, {quantity: state.quantity + 1}, ...)可以这么使用this.setState((prevState) =&gt; { return {counter: prevState.quantity + 1};}); 传递一个更新函数允许你在更新中访问当前的状态值。由于 setState 调用是批处理的，这允许你链式更新并确保它们建立在彼此之上，而不是产生冲突： 1234567891011incrementCount() { this.setState((prevState) =&gt; { return {count: prevState.count + 1} });}handleSomething() { // this.state.count 是 1，然后我们这样做： this.incrementCount(); this.incrementCount(); // count 现在是 3} ReactDOMServerReactDOMServer 对象允许您在服务器上渲染组件。 renderToString()renderToStaticMarkup() 渲染流renderToNodeStream()renderToStaticNodeStream() 渲染流可以减小第一个字节 (TTFB) 渲染时间，在文档的下一个部分生成之前，将文档的开头向下发送到浏览器。所有主流浏览器都会在服务器以这种方式流出内容时开始解析和呈现文档。 节流是阻止函数在给定时间内被多次调用 Debounce（防抖）防抖确保函数上次执行后的一段时间内，不会再次执行。 操作 css1234567render() { let className = 'menu'; if (this.props.isActive) { className += ' menu-active'; } return &lt;span className={className}&gt;Menu&lt;/span&gt;} Virtual DOM and Internals什么是虚拟 dom虚拟 dom 是一种编程概念，是指虚拟的视图被保留在内存中 通过如 reactDom 这样的库与 “真实” 的 dom 保持同步虚拟 DOM 是由 JavaScript 库在浏览器 API 之上实现的一种概念 总结本文为 react 概况，意在对 react 有个整理认知，其中的任意一条都值得深入研究，日后可能会针对某一个知识点单开文章～","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://maying.ink/tags/js/"},{"name":"react","slug":"react","permalink":"http://maying.ink/tags/react/"}]},{"title":"Dom 操作成本 浏览器的重排和重绘","slug":"dom操作成本","date":"2018-05-15T16:00:00.000Z","updated":"2020-10-22T18:41:42.181Z","comments":true,"path":"2018/05/16/dom操作成本/","link":"","permalink":"http://maying.ink/2018/05/16/dom%E6%93%8D%E4%BD%9C%E6%88%90%E6%9C%AC/","excerpt":"","text":"操作 Dom 的成本很高 不要轻易去操作 Dom 这句话从开始入门就听说，那么这里说的成本是指什么？由此引出今天的问题 首先我们要清楚几个概念 什么是 DOM？ DOM 全称 Document Object Model 文档对象模型 它是为 HTML（XML）提供的 API HTML 是一种标记语言 HTML 在 DOM 模型标准中被视为对象 DOM 只提供编程接口却无法实际操作 HTML 里面的内容 在浏览器中 前端工程师可以通过脚本语言（js）通过 DOM 去操作 HTML 内容（不只 js 能调用 DOM 这个 API Python 也可以） ps：也存在 CSSOM：CSS Object Model 浏览器将 CSS 代码解析成树形的数据结构与 DOM 是两个独立的数据机构 浏览器渲染过程讨论 DOM 操作成本 首先要了解下该成本的来源 那么就离不开浏览器渲染浏览器渲染前需要先构建 DOM 和 CSS 树 因此我们需要尽快将 HTML 和 CSS 都提供给浏览器 这里只讨论浏览器拿到 HTML 之后开始解析 渲染 之前的一些另开一篇 解析 HTML 构建 DOM 树 （这里遇到外链 会发起请求） 解析 CSS 生成 CSS 规则树 合并 DOM 树和 CSS 规则 生成 render（渲染）树 布局 render 树（Layout/reflow）负责各元素的尺寸，位置的计算 绘制 render 树（paint）绘制页面像素信息 浏览器会将各层的信息发送给 GPU GPU 将各层合成 (composite) 显示在屏幕上构建 DOM 树HTML 标记转换成文档对象模型 (DOM)DOM 树构建过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点构建 CSSOM 树CSS 标记转换成 CSS 对象模型 (CSSOM)在最终计算各个 2 节点的样式时 浏览器都会先从该节点的普遍属性（比如全局样式）开始 再去应用该节点的具体属性 每个浏览器都有自己的默认样式表因此很多时候这颗 CSSOM 树只是对这张默认样式表的部分替换 DOM 和 CSSOM 都要经过Bytes→characters→tokens→nodes→objectmodel 这个过程DOM 和 CSSOM 是独立的数据结构此处需要一张图片 生成 render（渲染）树 由此 浏览器中会解析并生成两个内部数据结构 Dom 树表示页面结构 DOM 树和 CSSOM 合并生成 render 树（渲染树），渲染树表示 Dom 节点在页面中如何显示（宽高 位置等） 1在dom树中每一个需要显示的节点在渲染树种至少存在一个对应的节点 渲染树中的节点被称之为“帧”或者“盒” 符合css模型的定义 一旦Dom树和渲染树构建完成 浏览器就开始 显示（绘制paint）页面元素 简单描述下 render 的过程 123DOM树从根节点开始遍历可见节点设置了类似 display：none （则该节点不可见） 在render过程中是被跳过的visibility:hidden; opacity:0 这种仍旧占据空间的节点不会被跳过render 保存各个节点的样式信息及其余节点的从属关系 123Layout布局有了各个节点的信息属性 但不知道各个节点的确切位置和大小 所以要通过布局将样式信息和属性转换为实际可视窗口的相对大小和位置（DOM 树捕获文档标记的属性和关系，但并未告诉我们元素在渲染后呈现的外观。那是 CSSOM 的责任） 12Paint绘制最后只要将确定好位置大小的各节点通过GPU渲染到屏幕的实际像素 TIPS： 在上述渲染过程中 前三点可能要多次执行 比如 js 脚本去操作 DOM 更改 CSS 样式 浏览器又要重新构建 DOM CSSOM 树 重新 render 重新 layout paint 因为 layout 在 paint 之前 因此每次 layput 重新布局（reflow 回流）后都要重新触发 paint 渲染 这时又要去消耗 GPU paint 不一定会触发 layout 比如改个颜色改个背景（repaint 重绘） 图片下载完也会重新触发 Layout 和 paint 何时触发 reflow（重排）和 repaint（重绘）reflow (重排)：当 dom 树的变化影响了元素的集合属性 =》 意味着元素的内容，结构 位置或者尺寸发生了变化，同样其他元素的集合属性和位置也会因此受到影响，浏览器会使渲染树（render 树）中受到影响的部分失效 需要重新计算样式和渲染树，这个过程称为重排（reflow） repaint (重绘)： 意味着元素发生的改变只你影响了节点的一些样式（背景色 边框颜色 文字元素等）只需要应用新样式绘制这个元素就可以了 （完成重排后 浏览器会重新绘制受影响的部分到屏幕中 这个过程叫做重绘） 并不是所有的 dom 辩护都会影响几何属性 例如 改变元素的背景色不会影响 宽和高 这种情况下 只会发生一次重绘（不需要重排）因为元素的布局没有改变 重排一定会引起浏览器的重绘 重绘则不一定伴随重排 重排的成本开销要高于重绘一个节点的重排往往导致子节点以及同级节点的重排 触发重排的情况当页面布局的几何属性改变时就需要重排 下列情况会导致重排 123456789页面第一次渲染（初始化）DOM树变化（如：增删节点）元素位置改变元素尺寸改变（外边距 内边距 边框厚度 宽度 高度等）Render树变化（如：padding改变）浏览器窗口resize获取元素的某些属性：当滚动条出现时，会触发整个页面的重排 由于每次重排都会产生计算消耗，大多数浏览器通过队列化修改并批量执行来优化重排的过程 但是 我们经常会不知不觉强制刷新队列并要求计划任务立即执行获取布局信息的操作会到最后队列刷新 比如 12345678offsetTop , offsetLeft , offsetWidth , offsetHeightscrollTop , scrollLeft , scrollWidth , scrollHeightclientTop , clientLeft , clientWidth , clientHeightgetComputedStyle() ( currentStyle in IE ) 当获取以上的属性和方法时 浏览器为了获取最新的布局信息 不得不立即触发重排以返回正确的值 最小化重绘和重排重绘和重排代价很昂贵 因此一个号的提高程序响应熟读的策略就是减少此类操作的发生 优化方式 合并多次对样式属性的操作 1234567891011121314151617思考var el = document.getElementById('mydiv');el.style.borderLeft = '1px';el.style.borderRight = '2px';el.style.padding = '5px';即使有浏览器有重排机制优化 但最坏的情况也是进行三次重排修改后var el = document.getElementById('mydiv');el.style.cssText = 'border-left: 1px; border-right: 2px; padding: 5px;';或者var el = document.getElementById('mydiv');el.className = 'active'; 批量修改 dom当需要对 dom 元素进行一系列的操作时候 可以通过以下的步骤来减少重绘和重排的次数 * 使元素脱离文本流 * 操作元素 * 操作完成后 将元素带回文档中这样儿 只有第一步和第三部触发两次重排 有三种方式可以实现上面的步骤 1. 隐藏元素（display:none）操作元素 重新展示 12345var ul = document.getElementById('mylist');ul.style.display = 'none';appendDataToElement(ul, data);ul.style.display = 'block'; 2. 使用文档片段（document fragment）在当前 DOM 之外构建一个子树，再把它拷贝回文档 123 var fragment = document.createDocumentFragment();appendDataToElement(fragment, data);document.getElementById('mylist').appendChild(fragment); 3. 将原始元素拷贝到一个脱离文档的节点中，修改副本，完成后再替换原始元素 1234var old = document.getElementById('mylist');var clone = old.cloneNode(true);appendDataToElement(clone, data);old.parentNode.replaceChild(clone, old); 总结：推荐尽可能的使用文档片段（第二个方案），因为它们所产生的 DOM 遍历和重排次数最少。唯一潜在的问题是文档片段未被充分利用，很多人可能并不熟悉这项技术。 缓存布局信息 1浏览器获取元素的offsetLeft等属性值时会导致重排 将需要获取的保护局信息的属性值 赋值给变量 然后再操作变量 定位 1将需要多次重排的元素，position 属性设置为 absolute 或 fixed，这样元素就脱离了文档流，它的变化不会影响到其他元素。例如有动画效果的元素就最好设置为绝对定位。 操作 DOM 具体的成本，说到底是造成浏览器重排和重绘，从而消耗 GPU 资源 s","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://maying.ink/tags/js/"}]},{"title":"Express 框架系列 (三) 之方法","slug":"Express框架系列(三)之方法","date":"2018-04-17T16:00:00.000Z","updated":"2020-10-22T18:41:42.179Z","comments":true,"path":"2018/04/18/Express框架系列(三)之方法/","link":"","permalink":"http://maying.ink/2018/04/18/Express%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97(%E4%B8%89)%E4%B9%8B%E6%96%B9%E6%B3%95/","excerpt":"","text":"all 方法和 HTTP 动词方法针对不同的请求，Express 提供了 use 方法的一些别名。比如，上面代码也可以用别名的形式来写。 12345678910111213141516171819202122var express = require(\"express\");var http = require(\"http\");var app = express();app.all(\"*\", function(request, response, next) { response.writeHead(200, { \"Content-Type\": \"text/plain\" }); next();});app.get(\"/\", function(request, response) { response.end(\"Welcome to the homepage!\");});app.get(\"/about\", function(request, response) { response.end(\"Welcome to the about page!\");});app.get(\"*\", function(request, response) { response.end(\"404!\");});http.createServer(app).listen(1337); 除了 get 方法以外，Express 还提供 post、put、delete 方法，即 HTTP 动词都是 Express 的方法，express 允许模式匹配 set 方法用于指定变量的值 123app.set('views',_dirname+'/views')app.set(\"view engine\", \"jade\"); response 对象response.redirect () 允许网址的重定向response.redirect(\"/hello/anime\"); response.sendFile () 用于发送文件response.sendFile(\"/path/to/anime.mp4\") response.render () 用于渲染网页模版 123app.get(\"/\", function(request, response) { response.render(\"index\", { message: \"Hello World\" });}); 使用 render 方法，将 message 变量传入 index 模版，渲染成 HTML 网页 request 对象request.ip: 用于获取 HTTP 请求的 IP 地址request.files 用于获取上传的文件 搭建 HTTPS 服务器使用 express 搭建 https 加密服务器 1234567891011121314151617var fs = require('fs');var options = { key: fs.readFileSync('E:/ssl/myserver.key'), cert: fs.readFileSync('E:/ssl/myserver.crt'), passphrase: '1234'};var https = require('https');var express = require('express');var app = express();app.get('/', function(req, res){ res.send('Hello World Expressjs');});var server = https.createServer(options, app);server.listen(8084);","categories":[{"name":"前端","slug":"前端","permalink":"http://maying.ink/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"node","slug":"node","permalink":"http://maying.ink/tags/node/"}]},{"title":"DomContentLoaded 与 load","slug":"DomContentLoaded 与 load","date":"2018-03-29T16:00:00.000Z","updated":"2020-10-22T18:41:42.178Z","comments":true,"path":"2018/03/30/DomContentLoaded 与 load/","link":"","permalink":"http://maying.ink/2018/03/30/DomContentLoaded%20%E4%B8%8E%20load/","excerpt":"","text":"浏览器渲染原理1当我们在浏览器地址输入url时，浏览器会发送请求到服务器，服务器将请求的html文档发送回浏览器，浏览器将文档下载下来后 便开始从上到下解析，解析完成后 会生成dom，如果页面中有css 会根据css的内容 形成cssdom 然后 dom和css会生成一个渲染树 最后浏览器会根据渲染树的内容计算出各个节点在页面中的确切大小和位置，并将其绘制在浏览器上 1在解析html的过程中 有时候解析会被中断，这是因为javascript会阻塞dom的解析 当解析过程中遇到script标签的时候 便会停止解析过程 抓转而去处理脚本 如果脚本是内联的 浏览器会先去执行这段内联的脚本，如果脚本是外链的 那么先去加载脚本 然后执行 在处理完脚本之后 浏览器便继续解析html文档 如何计算 DomContentLoaded 加载时间当文档中没有脚本时 浏览器解析完成文档便能触发 DomContentLoaded 事件 如果文档包含脚本 则脚本会阻塞文档的解析 而脚本需要等位于前面的 css 加载完才能执行 在任何情况下 DomContentLoaded 的触发不需要等待图片等其他资源加载完成 123456789DOMContentLoaded不同的浏览器对其支持不同，所以在实现的时候我们需要做不同浏览器的兼容。1）支持DOMContentLoaded事件的，就使用DOMContentLoaded事件；2）IE6、IE7不支持DOMContentLoaded，但它支持onreadystatechange事件，该事件的目的是提供与文档或元素的加载状态有关的信息。1) 更低的ie还有个特有的方法doScroll， 通过间隔调用：document.documentElement.doScroll(\"left\");可以检测DOM是否加载完成。 当页面未加载完成时，该方法会报错，直到doScroll不再报错时，就代表DOM加载完成了。该方法更接近DOMContentLoaded的实现。 如何计算 load 加载时间页面上所有的资源（图片，音频，视频等）被加载以后才会触发 load 事件，简单来说，页面的 load 事件会在 DOMContentLoaded 被触发之后才触发。 1234window.onload = function(){} 我们为什么一再强调将 CSS 放在头部 将 js 放在尾部因为浏览器生成 Dom 树的时候是一行一行读 html 代码的 script 标签放在最后面就不会影响前面的页面渲染，那么问题来了既然 Dom 树完全生成好页面才能渲染出来 浏览器又必须读完全部的 html 才能生成完成的 dom 树 script 标签放不放在底部是不是也一样 因为 dom 树的生成需要整个文档解析完成 chrome 页面渲染过程中 会有 firstpaint 的概念，现代浏览器为了更好的用户体验，渲染引擎将尝试尽快在屏幕上显示的内容 他不会等到所有的 html 解析完成才开始构建和布局 dom 树 部分的内容被解析并展示 也就是说 浏览器能够渲染不完整的 dom 树和 cssdom 尽快的减少白屏时间 假如我们将 js 放在 header js 将会阻塞解析 dom dom 的内容会影响到 firstpaint 导致 firstpaint 延后 所以说我们会将 js 放在后面 以减少 firstpaint 时间但是不会减少 DomContentLoaded 被触发的时间","categories":[{"name":"web","slug":"web","permalink":"http://maying.ink/categories/web/"}],"tags":[]},{"title":"深入理解 Javascript 系列二：揭秘命名函数表达式","slug":"深入理解js系列二","date":"2018-03-19T16:00:00.000Z","updated":"2020-10-22T18:41:42.192Z","comments":true,"path":"2018/03/20/深入理解js系列二/","link":"","permalink":"http://maying.ink/2018/03/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3js%E7%B3%BB%E5%88%97%E4%BA%8C/","excerpt":"汤姆大叔的原文链接","text":"汤姆大叔的原文链接 函数表达式 和函数声明函数表达式1function 函数名称（可选）（参数：可选）{函数体} 函数声明1function 函数名称（参数：可选）{函数体} 如何区分两者123456789101112131415161718函数表达式：不声明函数名称和声明了函数名称的其他情况 如果 function foo(){} 是作为赋值表达式的一部分的话 像这样： 1.var bar = function foo(){}; // 表达式，因为它是赋值表达式的一部分 2.new function bar(){}; // 表达式，因为它是new表达式 3.被括号括住的(function foo(){})他是表达式的原因是因为括号 ()是一个分组操作符，它的内部只能包含表达式 (function foo(){}); // 函数表达式：包含在分组操作符内函数声明：声明了函数名称且function foo(){} 被包含在一个函数体内（规则：只能出现在程序或函数体内） 像这样 (function(){ function bar(){} // 声明，因为它是函数体的一部分 })(); 或者位于程序最顶部的话 像这样 function foo(){} // 声明，因为它是程序的一部分 一些特性1函数声明:会在任何表达式被解析和求值之前先被解析和求值 即使你的声明在最后一行 它也会在同作用域内的第一个表达式之前被解析/求值 函数语句12345678910111213141516函数语句不是在变量初始化期间声明的，而是在运行时声明的——与函数表达式一样。不过，函数语句的标识符一旦声明能在函数的整个作用域生效了。标识符有效性正是导致函数语句与函数表达式不同的关键所在// 此刻，foo还没用声明 console.log('typeof foo1',typeof foo)// \"undefined\" if (true) { // 进入这里以后，foo就被声明在整个作用域内了 function foo(){ console.log('11111') } } else { // 从来不会走到这里，所以这里的foo也不会被声明 function foo(){ console.log('222') } } typeof foo; // \"function\" console.log('typeof foo2',typeof foo) 命名函数表达式12345678910命名函数表达式，理所当然，就是它得有名字，前面的例子var bar = function foo(){};就是一个有效的命名函数表达式，但有一点需要记住：这个名字只在新定义的函数作用域内有效， 这就是 与函数语句的区别 var f = function foo(){ return typeof foo; // foo是在内部作用域内有效 }; // foo在外部用于是不可见的 typeof foo; // \"undefined\" f(); // \"function\" 命名函数表达式出现的意义：便于调试 调试器在调试的时候会将它的名字显示在调用的栈上","categories":[{"name":"js","slug":"js","permalink":"http://maying.ink/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://maying.ink/tags/js/"}]},{"title":"深入理解 Javascript 系列一：编写高质量代码的基本要点","slug":"深入理解js系列一","date":"2018-03-19T16:00:00.000Z","updated":"2020-10-22T18:41:42.192Z","comments":true,"path":"2018/03/20/深入理解js系列一/","link":"","permalink":"http://maying.ink/2018/03/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3js%E7%B3%BB%E5%88%97%E4%B8%80/","excerpt":"汤姆大叔的原文链接","text":"汤姆大叔的原文链接 书写可维护的代码1目标：可读的 一致的 可预测的 看上去就像是同一个人写的 js 的变量问题1234567891011121314151617js通过函数管理作用域在任何函数外面上声明的变量 或者 不声明就直接使用的（隐含的全局概念） 均为全局变量var uu; // 显式全局变量function sum(x, y) { // 不推荐写法: 隐式全局变量 result = x + y; return result;}// 创建隐式全局变量 反例，勿使用function foo() { var a = b = 0;发生的原因是 这个从右往左赋值 b = 0 此时 b是未声明的 相当于 var a = (b = 0); 你可以这个定义局部变量（正确写法） var a, b;} 隐式全局变量 与显式全局变量的差异 通过 var 创建的全局变量是不能被删除的 无 var 创建的隐式全局变量 是能被删除的 关于隐式全局变量的解释123456不管一个变量有没有用过，JavaScript解释器反向遍历作用域链来查找整个变量的var声明，如果没有找到var，解释器则假定该变量是全局变量，如果该变量用于了赋值操作的话，之前如果不存在的话，解释器则会自动创建它，这就是说在匿名闭包里使用或创建全局变量非常容易 避免创建式全局变量 方式(function ($, YAHOO) { // 这里，我们的代码就可以使用全局的jQuery对象了，YAHOO也是一样} (jQuery, YAHOO))将全局变量当做一个参数传入匿名函数内使用 jquery源码就用这种方式 12在技术上 隐式全局变量 并不是真正的全局变量 但他们是全局对象的属性属性是可以通过delete 操作符删除的 如何访问全局变量1234567一般情况下 全局对象可以通过window属性在任何位置访问也可以var gobal =function(){return this;}这种方法可以随时获取全局变量 this总是指向全局对象 变量与函数的预解析（变量提升）12345678910111213141516171819202122232425262728function func() { var a = 1, b = 2, sum = a + b, myobject = {}, i, // undefined j; //undefined // function body...}变量初始化可以防止逻辑错误 也解决了var散布的问题// 反例myname = \"global\"; // 全局变量function func() { alert(myname); // \"undefined\" var myname = \"local\"; // 声明myname的变量被当做局部变量预解析了 alert(myname); // \"local\"}相当于myname = \"global\"; // 全局变量function func() { var myname； // === var myname == undefined alert(myname); // \"undefined\" myname = \"local\"; alert(myname); // \"local\"} 【延伸】js 是如何执行的123代码处理 分为两个阶段1.变量 函数声明 以及 正常格式的参数创建 这是一个解析和进入上下文的阶段2.代码执行 函数表达式和 声明的变量被创建 js 的循环问题for 循环12345678910111213141516171819202122232425262728293031323334353637缓存 数组 以及 HTMLCollection 的长度当要循环的是一个集合对象时候 如果不缓存长度 你要实时查询Dom 而Dom操作一般来讲比较昂贵像这样for (var i = 0, max = myarray.length; i &lt; max; i++) { // 使用myarray[i]做点什么}尽量不要使用i++像这样儿i = i + 1i += 1还有两种改进形式（参考）少了一个变量(无max)向下数到0，通常更快，因为和0做比较要比和数组长度或是其他不是0的东西作比较更有效率像这样//第一种变化的形式：var i, myarray = [];for (i = myarray.length; i–-;) { //....}//第二种使用while循环：var myarray = [], i = myarray.length;while (i–-) { // ....} for-in 循环1234567891011121314151617181920212223242526272829303132333435也称 ‘枚举’ 应该用在非数组对象的遍历上 不推荐用来循环数组（数组也是对象 但是 for-in中 属性列表的顺序是不能保证的）值得说明的是 我们平常老是忽略一个很重要的方法hasOwnProperty() 遍历对象属性的时候可以过滤掉从原型链上下来的属性 var man = { hands:2, legs:2, heads:1 } if (typeof Object.prototype.clone === 'undefined'){ Object.prototype.clone = function(){ //。。。。 } }// 为了避免枚举 出现clone方法 for (var i in man) {// 方式一 过滤原型属性 if (man.hasOwnProperty(i)) {// console.log(i, \"1:\", man[i]); }// 方式二 取消Object。prototype上的方法 if (Object.prototype.hasOwnProperty.call(man,i)){// console.log(i, \"1:\", man[i]); } //或者 避免长属性查找 var hasOwn = Object.prototype.hasOwnProperty; if (hasOwn.call(man,i)){// console.log(i, \"1:\", man[i]); } } 给原型自定义添加方法12345if (typeof Object.prototype.myMethod ！==\"function\"){ Object.prototype.myMethod = function(){ //.... }} 避免隐式类型转换123js变量在比较时会隐式类型转换为了避免引起混乱的隐式类型转换 比较值和表达式类型的时候始终使用=== 和 !== 操作符 避免 eval () 不给 给 setInterval (), setTimeout () 和 Function () 构造函数传递字符串12345678910// 反面示例setTimeout(\"myFunc()\", 1000);setTimeout(\"myFunc(1, 2, 3)\", 1000);// 更好的setTimeout(myFunc, 1000);setTimeout(function () { myFunc(1, 2, 3);}, 1000); parseInt () 数值转换不应该忽略第二个参数1234567在ECMAScript 3中，开头为”0″的字符串被当做8进制处理了，但这已在ECMAScript 5中改变了。为了避免矛盾和意外的结果，总是指定基数参数var month = \"06\", year = \"09\";month = parseInt(month, 10);year = parseInt(year, 10); 编码规范 编码规范 代码缩进 技术上可以省略的花括号 (只有一条语句的 for 循环 {}) 也不要省略 不要省略分号； 左花括号的位置 适当的地方使用空格 – 列表模样表达式（相当于逗号）和结束语句（相对于完成了 “想法”）后面添加间隔 命名规范 注释 123456789101112131415161718192021222324252627282930313233343536373839404142if (true) { alert(\"It's TRUE!\");}或者if (true){ alert(\"It's TRUE!\");}但是如果要返回一个对象自变量的话function func() { return // === return undefined; // 下面代码不执行 { name : \"Batman\" }}结论总之，总是使用花括号，并始终把在与之前的语句放在同一行：使用空格for循环分号分开后的的部分：如for (var i = 0; i &lt; 10; i += 1) {...}for循环中初始化的多变量(i和max)：for (var i = 0, max = 10; i &lt; max; i += 1) {...}分隔数组项的逗号的后面：var a = [1, 2, 3];对象属性逗号的后面以及分隔属性名和属性值的冒号的后面：var o = {a: 1, b: 2};限定函数参数：myFunc(a, b, c)函数声明的花括号的前面：function myFunc() {}匿名函数表达式function的后面：var myFunc = function () {};花括号的间距 最好使用空格有一个经常被忽略的代码可读性方面是垂直空格的使用。你可以使用空行来分隔代码单元，就像是文学作品中使用段落分隔一样。命名规范以大写字母写构造函数(Capitalizing Constructors)getName() 公共方法_getFirst() 私有方法","categories":[{"name":"js","slug":"js","permalink":"http://maying.ink/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://maying.ink/tags/js/"}]},{"title":"js 冷知识","slug":"javascript冷知识","date":"2018-01-15T16:00:00.000Z","updated":"2020-10-22T18:41:42.182Z","comments":true,"path":"2018/01/16/javascript冷知识/","link":"","permalink":"http://maying.ink/2018/01/16/javascript%E5%86%B7%E7%9F%A5%E8%AF%86/","excerpt":"去除 input [type=’number’] 时的右侧上下箭头 / 在 chrome 下：/ input::-webkit-outer-spin-button, input::-webkit-inner-spin-button{ -webkit-appearance: none !important; margin: 0; padding-left:5px; } /*Firefox下：*/ input[type=\"number\"]{-moz-appearance:textfield;} 判断小数不能大于两位 var hopePriceLength = hopePrice.toString().split(\".\")[1].length; if(hopePriceLength&gt;2){ notify('请输入正数，最多两位小数','error'); $(`#${mid}jp-hope-price`).focus(); return false; }","text":"去除 input [type=’number’] 时的右侧上下箭头 / 在 chrome 下：/ input::-webkit-outer-spin-button, input::-webkit-inner-spin-button{ -webkit-appearance: none !important; margin: 0; padding-left:5px; } /*Firefox下：*/ input[type=\"number\"]{-moz-appearance:textfield;} 判断小数不能大于两位 var hopePriceLength = hopePrice.toString().split(\".\")[1].length; if(hopePriceLength&gt;2){ notify('请输入正数，最多两位小数','error'); $(`#${mid}jp-hope-price`).focus(); return false; } 3. 去掉 ios 手机上 tap 时的黑色背景 12345a,img,button,input,textarea{-webkit-tap-highlight-color:rgba(255,255,255,0);}2.另外，如何去掉textarea,input的默认样式：input,textarea{-webkit-appearance:none;} 4. 判断数据的类型 1234567891011var isType = function( type ){ return function( obj ){ return Object.prototype.toString.call( obj ) === '[object '+ type +']'; }}; var isString = isType( 'String' ); var isArray = isType( 'Array' ); var isNumber = isType( 'Number' );console.log( isArray( [ 1, 2, 3 ] ) ); 4.HTML5 去除 input [type=search] 的默认边框和删除按钮 x-webkit-speech 属性：在 GOOGLE 浏览器上 还会显示一个小话筒 autocomplete=”off” 属性 关闭浏览器自动记录之前输入的值 webkit 内核浏览器里 input 框类型如果是 type=”search”那么将会有边框问题，border:0px 也不能起到作用； 解决方案 1input[type=\"search\"]{-webkit-appearance:none;} 移除 重置默认的 Webkit 引擎下的 Input 样式 12345678910input[type=search] {-webkit-appearance: textfield;-webkit-box-sizing: content-box;font-family: inherit;font-size: 100%;}input::-webkit-search-decoration,input::-webkit-search-cancel-button {display: none;} 5. 禁止 ios 和 android 用户选中文字 1css{-webkit-touch-callout: none}","categories":[{"name":"js","slug":"js","permalink":"http://maying.ink/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://maying.ink/tags/js/"},{"name":"issue","slug":"issue","permalink":"http://maying.ink/tags/issue/"}]},{"title":"JavaScript 下的 setTimeout (fn,0) 意味着什么？[转]","slug":"setTimeout(fn,0)","date":"2018-01-15T16:00:00.000Z","updated":"2020-10-22T18:41:42.186Z","comments":true,"path":"2018/01/16/setTimeout(fn,0)/","link":"","permalink":"http://maying.ink/2018/01/16/setTimeout(fn,0)/","excerpt":"近期在研究异步编程的我对于 setTimeout 之类的东西异常敏感。在 SegmentFault 上看到了一个问题《关于 SetTimeout 时间设为 0 时》：提问者读了一篇文章，原文解释 setTimeout 延迟时间为 0 时会发生的事情，提问者提出了几个文章中的几个疑点。读了那篇文章之后发现原文的作者对于 setTimeout 的理解和自己的认知有点出入，于是编写了相关测试的代码以求答案。最终编写了这篇文章。 本文内容如下： 起因单线程的 JavaScriptsetTimeout 背后意味着什么","text":"近期在研究异步编程的我对于 setTimeout 之类的东西异常敏感。在 SegmentFault 上看到了一个问题《关于 SetTimeout 时间设为 0 时》：提问者读了一篇文章，原文解释 setTimeout 延迟时间为 0 时会发生的事情，提问者提出了几个文章中的几个疑点。读了那篇文章之后发现原文的作者对于 setTimeout 的理解和自己的认知有点出入，于是编写了相关测试的代码以求答案。最终编写了这篇文章。 本文内容如下： 起因单线程的 JavaScriptsetTimeout 背后意味着什么 起因上午在 SegmentFault 上看到了这个问题《关于 SetTimeout 时间设为 0 时》（注：SegmentFault 正在调整备案，如不能访问，请点击这里），原提问者注明了问题来源：《JS setTimeout 延迟时间为 0 的详解》。这个问题来源也是转载的，我后来找到了出处。在问题来源的那篇的文章中（后者），讲述了 JS 是单线程引擎：它把任务放到队列中，不会同步去执行，必须在完成一个任务后才开始另外一个任务。而后，转载的那篇文章列出并补充了原文的栗子： setTimeout function get(id) { return document.getElementById(id); } window.onload = function () { //第一个例子：未使用setTimeout get('makeinput').onmousedown = function () { var input = document.createElement('input'); input.setAttribute('type', 'text'); input.setAttribute('value', 'test1'); get('inpwrapper').appendChild(input); input.focus(); input.select(); } //第二个例子：使用setTimeout get('makeinput2').onmousedown = function () { var input = document.createElement('input'); input.setAttribute('type', 'text'); input.setAttribute('value', 'test1'); get('inpwrapper2').appendChild(input); //setTimeout setTimeout(function () { input.focus(); input.select(); }, 0); } //第三个例子，onkeypress输入的时候少了一个值 get('input').onkeypress = function () { get('preview').innerHTML = this.value; } } setTimeout 1、未使用 setTimeout 生成 input &lt;h2&gt;2、使用 &lt;code&gt;setTimeout&lt;/code&gt;&lt;/h2&gt; &lt;button id=\"makeinput2\"&gt;生成 input&lt;/button&gt; &lt;p id=\"inpwrapper2\"&gt;&lt;/p&gt; &lt;h2&gt;3、另一个例子&lt;/h2&gt; &lt;p&gt; &lt;input type=\"text\" id=\"input\" value=\"\" /&gt;&lt;span id=\"preview\"&gt;&lt;/span&gt; &lt;/p&gt; 代码运行实例请戳这里。 原文中有这么一段话，描述的有点抽象： JavaScript 引擎在执行 onmousedown 时，由于没有多线程的同步执行，不可能同时去处理刚创建元素的 focus 和 select 方法，由于这两个方法都不在队列中，在完成 onmousedown 后，JavaScript 引擎已经丢弃了这两个任务，正如第一种情况。而在第二种情况中，由于 setTimeout 可以把任务从某个队列中跳脱成为新队列，因而能够得到期望的结果。 我看到这里就觉得非常不对劲了。因为按照这种任务会被丢弃的说法，那么只要在事件触发的函数中再触发其他的事件都会被丢弃，浏览器是绝对不会这么做的，于是我编写了测试代码： window.onload = function () { //第一个例子：未使用setTimeout get('makeinput').onmousedown = function () { var input = document.createElement('input'); input.setAttribute('type', 'text'); input.setAttribute('value', 'test1'); get('inpwrapper').appendChild(input); //按照文中的理论，这里的click不会被触发，但它却成功触发了 get('inpwrapper').click();//触发了inpwrapper的onclick事件 } get('inpwrapper').onclick = function () { alert('linkFly'); }; } 下面的 onclick () 最终是执行了：弹出了”linkFly”。 而在转载的文中为了引人深思，又提出了第三个例子： 在此，你可以看看例子 3，它的任务是实时更新输入的文本，现在请试试，你会发现预览区域总是落后一拍，比如你输 a, 预览区并没有出现 a, 在紧接输入 b 时，a 才不慌不忙地出现。 而文中最后留给大家的思考的问题，解决方案就是使用 setTimeout 再次调整浏览器的代码任务运行队列。 var domInput = get('input'); domInput.onkeypress = function () { setTimeout(function () { //第三个例子的问题就这样就会被解决 get('preview').innerHTML = domInput.value; }) } 原文和转载的文章中都对 setTimeout (fn,0) 进行了思考，但原文指出的问题本质漏洞百出，所以才出了这篇文章，我们的正文，现在开始。 单线程的 JavaScript首先我们来看浏览器下的 JavaScript： javascriipt 引擎线程 GUI 渲染线程 浏览器事件触发线程 javascript 引擎是基于事件驱动单线程执行的，JS 引擎一直等待着任务队列中任务的到来，然后加以处理，浏览器无论什么时候都只有一个 JS 线程在运行 JS 程序。GUI 渲染线程负责渲染浏览器界面，当界面需要重绘（Repaint）或由于某种操作引发回流 (reflow) 时，该线程就会执行。但需要注意 GUI 渲染线程与 JS 引擎是互斥的，当 JS 引擎执行时 GUI 线程会被挂起，GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行。事件触发线程，当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理。这些事件可来自 JavaScript 引擎当前执行的代码块如 setTimeOut、也可来自浏览器内核的其他线程如鼠标点击、AJAX 异步请求等，但由于 JS 的单线程关系所有这些事件都得排队等待 JS 引擎处理。（当线程中没有执行任何同步代码的前提下才会执行异步代码）js 的单线程在这一段面试代码中尤为明显（理解即可，请不要尝试… 浏览器会假死的）： var isEnd = true; window.setTimeout(function () { isEnd = false;//1s后，改变isEnd的值 }, 1000); //这个while永远的占用了js线程，所以setTimeout里面的函数永远不会执行 while (isEnd); //alert也永远不会弹出 alert('end'); 在我工作中对 js 的认识，个人认为 js 的任务单位是函数。即，一个函数表示着一个任务，这个函数没有执行结束，则在浏览器中当前的任务即没有结束。上面的代码中，当前任务因为 while 的执行而造成永远无法执行，所以后面的 setTimeout 也永远不会被执行。它在浏览器的任务队列中如图所示： Browser Event setTimeout 背后意味着什么这篇文章一直在使用 setTimeout 为我们展现和理解 js 单线程的设计，只是它错误的使用了 Event 来进行演示，并过度解读了 Event。这里原文和转载的文章忽略了这些基础的事件触发，而且也偏偏挑了两套本身设计就比较复杂的 API：onmouseXXX 系和 onkeyXXX 系。 onKeyXXX 系的 API 触发顺序如图： onKeyXXX 而我个人所理解它们对应的功能： onkeydown - 主要获取和处理当前按下按键，例如按下 Enter 后进行提交。在这一层，并没有更新相关 DOM 元素的值。onkeypress - 主要获取和处理长按键，因为 onkeypress 在长按键盘的情况下会反复触发直到释放，这里并没有更新相关 DOM 元素的值，值得注意的是：keypress 之后才会更新值，所以在长按键盘反复触发 onkeypress 事件的时候，后一个触发的 onkeypress 能得到上一个 onkeypress 的值。所以出现了 onkeypress 每次取值都会是上一次的值而不是最新值。onkeyup - 触发 onkeyup 的 DOM 元素的值在这里已经更新，可以拿到最新的值，所以这里主要处理相关 DOM 元素的值。流程就是上面的图画的那样： onkeydown =&gt; onkeypress =&gt; onkeyup 使用了 setTimeout 之后，流程应该是下面这样子的： onkeydown =&gt; onkeypress =&gt; function =&gt; onkeyup 使用 setTimeout (fn,0) 之后，在 onkeypress 后面插入了我们的函数 function。上面所说，浏览器在 onkeypress 之后就会更新相关 DOM 元素的状态（input [type=text] 的 value），所以我们的 function 里面可以拿到最新的值。所以我们在 onkeypress 里面挂起 setTimeout 能拿到正确的值，下面的代码可以测试使用 setTimeout (fn,0) 之后的流程： window.onload = function () { var domInput = get('input'), view = get('preview'); //onkeypress兼容性和说明：http://www.w3school.com.cn/jsref/jsref_events.asp domInput.onkeypress = function () { setTimeout(function () { //这个函数在keypress之后，keyup之前执行 console.log('linkFly'); }); }; domInput.onkeyup = function () { console.log('up'); }; }; 然后我们再来谈谈原代码中的示例 1 和示例 2，示例 1 和示例 2 的区别在这里： //示例1 input.focus(); input.select(); //示例2 setTimeout(function () { input.focus(); input.select(); }, 0); 原文章中说示例 1 的 focus () 和 select () 在 onmousedown 事件中被丢弃，从而导致了没有选中，但原文的作者忽略了他注册的事件是：onmousedown。我们暂且不讨论 onmouseXXX 系的其他 API，我们仅关注和点击相关的，它们的执行顺序是： mousedown - 鼠标按钮按下mouseup - 鼠标按钮释放click - 完成单击我们在 onmousedown 里面新建了 input，并且选中 input 的值（调用了 input.focus (),input.select ()）。那么为什么没有被选中呢？这样，我们来做一次测试，看看我们的 onfocus 到底是被丢弃了，还是触发了。我们把原文的代码进行改写： window.onload = function () { var makeBtn = get('makeinput'); //观察onmouseXXX系完成整个单击的顺序 makeBtn.onmousedown = function (e) { console.log(e.type); var input = document.createElement('input'); input.setAttribute('type', 'text'); input.setAttribute('value', 'test1'); get('inpwrapper').appendChild(input); input.onfocus = function () {//观察我们新生成的input什么时候获取焦点的，或者它有没有像原文作者说的那样被丢弃了 console.info('input focus'); }; input.focus(); input.select(); } makeBtn.onclick = function (e) { console.log(e.type); }; makeBtn.onmouseup = function (e) { console.log(e.type); }; makeBtn.onfocus = function () {//观察我们生成按钮什么时候获取焦点的 console.log('makeBtn focus'); } }; 代码运行的结果是这样的：onmouseXXX &amp; focus 我们的 input focus 执行了 —— 那么它为什么没有获取到焦点呢？我们再看看后面执行的函数：我们点击的按钮，在 mousedown 之后，才获得焦点，也就是说：我们的 input 本来已经得到了 focus ()，但在 onmousedown 之后，我们点击的按钮才迟迟触发了自己的 onfocus ()，导致我们的 input 被覆盖。我们再加上 setTimeout 进行测试： window.onload = function () { var makeBtn = get('makeinput'); makeBtn.onmousedown = function (e) { console.log(e.type); var input = document.createElement('input'); input.setAttribute('type', 'text'); input.setAttribute('value', 'test1'); get('inpwrapper').appendChild(input); input.onfocus = function () { console.info('input focus'); }; //我们加上setTimeout，看看会发生什么 setTimeout(function () { input.focus(); input.select(); }); } makeBtn.onclick = function (e) { console.log(e.type); }; makeBtn.onmouseup = function (e) { console.log(e.type); }; makeBtn.onfocus = function () { console.log('makeBtn focus'); } }; 执行结果是这样：onmouseXXX and settimeout 可以看见当我们点击” 生成” 按钮的时候，按钮的 focus 正确的执行了，然后才执行了 input focus。在示例 1 中，我们在 onmousedown () 中执行了 input.focus () 导致 input 得到焦点，而 onmousedown 之后，我们点击的按钮才迟迟得到了自己的焦点，造成了我们 input 刚拿到手还没焐热的焦点被转移。而示例 2 中的代码，我们延迟了焦点，当按钮获得焦点之后，我们的 input 再把焦点抢过来，所以，使用 setTimeout (fn,0) 之后，我们的 input 可以得到焦点并选中文本。这里值得思考的 focus () 的执行时机，根据这次测试观察，发现 focus 事件好像挂载在 mousedown 之内的最后面，而不是直接挂在 mousedown 的后面。它和 mousedown 仿佛是一体的。我们使用 setTimeout 之前的任务流程是这样的（-&gt; 表示在上一个任务中，=&gt; 表示在上一个任务后）： onmousedown -&gt; onmousedown中执行了input.focus() -&gt; button.onfocus =&gt; onmouseup =&gt; onclick onmouseXXX 事件流程 而我们使用了 setTimeout 之后的任务流程是这样的： onmousedown -&gt; button.onfocus =&gt; input.focus =&gt; onmouseup =&gt; onclick onmouseXXX+setTimeout 事件流程 而从上面的流程上我们得知了另外的消息，我们还可以把 input.focus 挂在 mouseup 和 click 下，因为在这些事件之前，我们的按钮已经得到过焦点了，不会再抢我们的焦点了。 makeBtn.click = function (e) { console.log(e.type); var input = document.createElement('input'); input.setAttribute('type', 'text'); input.setAttribute('value', 'test1'); get('inpwrapper').appendChild(input); input.onfocus = function () {//观察我们新生成的input什么时候获取焦点的 console.info('input focus'); }; input.focus(); input.select(); } 我们应该认识到，利用 setTimeout (fn,0) 的特性，可以帮助我们在某些极端场景下，修正浏览器的下一个任务 总结：意思就是说 input 的 focus 有执行， 只是被 button 的 mouseup 影响了，所以要要把 focus () 放到后面执行页面上只有一个元素能获得焦点，就这样而已。。 参考和引用JavaScript 异步机制什么是 Event Loopjavascript 线程解释JavaScript - 前端开发交流群：377786580 作者：linkFly原文：http://www.cnblogs.com/silin6/p/4333999.html出处：www.cnblogs.com/silin6/","categories":[{"name":"前端","slug":"前端","permalink":"http://maying.ink/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"http://maying.ink/tags/js/"}]},{"title":"Javascript 设计模式系列","slug":"js设计模式","date":"2018-01-15T16:00:00.000Z","updated":"2020-10-22T18:41:42.183Z","comments":true,"path":"2018/01/16/js设计模式/","link":"","permalink":"http://maying.ink/2018/01/16/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"面向对象的 Javascript不同于传统面向对象语言中的类式继承 js 通过 原型委托 的方式实现对象与对象之间的继承 编程语言分为 ：静态类型语言：编译时已确定变量的类型 优点：在编译时就能发现类型不匹配的错误，编译器可以针对不同的数据类型对程序做一些优化工作 提高程序之心速度 缺点：程序员依照契约来编写程序动态类型语言：要到程序运行的时候 待变量被赋予某个值之后 才会具有某种类型 优点：代码数量少 缺点：程序在运行期间有可能发生跟类型相关的错误 Javascript 是一门典型的动态类型语言 多态：给不同的对象发送同一条消息的时候 这些对象会根据这个消息分别给出不同的反馈 多态： 多种形态 在面向对象语言中，接口的多种不同的实现方式即为多态 多态指同一个实体同时具有多种形式 思想：把做什么 和 谁去做 分开 同一个函数 传入不同的参数 可以实现不同的结果 js 的多态是与生俱来的 它作为一门动态类型语言 他在编译时没有类型检查的类型 多态的好处：你不必再向对象询问‘你是什么类型’而后根据得到的答案 调用对象的某个行为 你只管调用该行为就是了 最根本的作用就是通过把过程话的条件分支语句转化为对象的多态性 从而消除这些条件分支语句 面向对象编程的优点 将行为分布在各个对象中，并且让这些对象各自负责自己的行为 当我们对一些函数发出 调用的指令时 这些函数会返回不同的结果 这也是多态的一些体现 封装：封装的目的是将信息隐藏 封装数据 封装实现 封装类型 封装变化 把系统中不变的和变的分离开 只替换变化的 如果变化的也是封装好的 就好替换多了 保证程序的稳定性和可扩展性 隐藏数据 隐藏实现细节 设计细节以及隐藏对象的类型 其他对象或者用户不关心他的具体实现 封装使对象之前的耦合变得松散 对象之间只暴露 APi 接口来通信 原型模式和基于原型继承的 Javascript 对象系统使用克隆的原型模式12345678910111213141516171819202122var Plane = function(){ this.blood=100; this.ss = 11; this.tt =2;}var plane = new Plane(); Object.create = Object.create ||function(value){ var F = function(){}; F.prototype= value; return new F(); } var clonePlane = Object.create(plane) console.log('clonePlane',clonePlane) console.log('clonePlane',clonePlane.blood) 100 console.log('clonePlane',clonePlane.ss) 11 console.log('clonePlane',clonePlane.tt) 2","text":"面向对象的 Javascript不同于传统面向对象语言中的类式继承 js 通过 原型委托 的方式实现对象与对象之间的继承 编程语言分为 ：静态类型语言：编译时已确定变量的类型 优点：在编译时就能发现类型不匹配的错误，编译器可以针对不同的数据类型对程序做一些优化工作 提高程序之心速度 缺点：程序员依照契约来编写程序动态类型语言：要到程序运行的时候 待变量被赋予某个值之后 才会具有某种类型 优点：代码数量少 缺点：程序在运行期间有可能发生跟类型相关的错误 Javascript 是一门典型的动态类型语言 多态：给不同的对象发送同一条消息的时候 这些对象会根据这个消息分别给出不同的反馈 多态： 多种形态 在面向对象语言中，接口的多种不同的实现方式即为多态 多态指同一个实体同时具有多种形式 思想：把做什么 和 谁去做 分开 同一个函数 传入不同的参数 可以实现不同的结果 js 的多态是与生俱来的 它作为一门动态类型语言 他在编译时没有类型检查的类型 多态的好处：你不必再向对象询问‘你是什么类型’而后根据得到的答案 调用对象的某个行为 你只管调用该行为就是了 最根本的作用就是通过把过程话的条件分支语句转化为对象的多态性 从而消除这些条件分支语句 面向对象编程的优点 将行为分布在各个对象中，并且让这些对象各自负责自己的行为 当我们对一些函数发出 调用的指令时 这些函数会返回不同的结果 这也是多态的一些体现 封装：封装的目的是将信息隐藏 封装数据 封装实现 封装类型 封装变化 把系统中不变的和变的分离开 只替换变化的 如果变化的也是封装好的 就好替换多了 保证程序的稳定性和可扩展性 隐藏数据 隐藏实现细节 设计细节以及隐藏对象的类型 其他对象或者用户不关心他的具体实现 封装使对象之前的耦合变得松散 对象之间只暴露 APi 接口来通信 原型模式和基于原型继承的 Javascript 对象系统使用克隆的原型模式12345678910111213141516171819202122var Plane = function(){ this.blood=100; this.ss = 11; this.tt =2;}var plane = new Plane(); Object.create = Object.create ||function(value){ var F = function(){}; F.prototype= value; return new F(); } var clonePlane = Object.create(plane) console.log('clonePlane',clonePlane) console.log('clonePlane',clonePlane.blood) 100 console.log('clonePlane',clonePlane.ss) 11 console.log('clonePlane',clonePlane.tt) 2 javascript 的原型继承所有的 js 对象都是从某个对象上克隆而来的 原型编程范程的规则 所有的数据都是对象 javascript 根对象是 Object.prototype 空对象 123var obj1 = new Object();var obj2 = {}; 要得到一个对象 不是通过实例化类 而是找到一个对象作为一个原型并克隆他 当我们调用 var obj1 = new Object(); 引擎内部会从 Object.prototype 克隆一个对象出来 12345678910111213 function Person(name){ this.name =name }Person.prototype.getName = function(){ return this.name;}; var p = new Person('maying'); console.log(p.name) console.log(p.getName()) js 没有类的概念 但是为什么还调用了 new Person('maying'); 12345在这里Person 并不是类 而是函数构造器Javascript的函数既可以作为普通函数被调用 也可以作为函数构造器被调用当使用 new 运算符来调用函数时 此时的函数就是一个构造器用new运算符来创建对象的过程 实际上也是先克隆 Object.prototype 对象 抛出问题：js 通过 Object.prototype 得到一个新的对象 但实际上并不是每次都真正的克隆了一个对象 对象会记住他的原型 123456789101112131415161718192021222324252627282930313233343536373839就javascript 真正实现来说并不能说对象有原型 而只能说是对象的构造器有原型 对于对象把请求委托给它自己的原型 更好的说法是对象把请求委托给它的构造器的原型。 那么对象是如何委托给它的构造器的原型呢 对象通过 _proto_的隐藏属性指向 {Constructor}.prototype _proto_就是跟构造器的原型联系起来的纽带 js的对象最初都是由object.prototype创建的 但是对象构造器的原型并不局限于object.prototype上 二是可以动态指定其他对象 应用 当对象a需要借用对象b的能力时 可以有选择性的把对象a的构造器的原型指向对象b 从而达到继承的效果 var A = function(){ this.name=\"buyiyang\" } A.prototype = { constructor: A, //手动指定 不指定的话 console.log(A.prototype.constructor)=object() name:'maying' } var B = function(){} B.prototype = new A() var a = new A(); console.log('a',a.name) console.log(A.prototype.constructor) // function(){ // this.name=\"buyiyang\" // } console.log(a.__proto__) // {name: \"maying\", constructor: ƒ} console.log(A.prototype) // {name: \"maying\", constructor: ƒ}原型链并不是无限长的当请求达到 A.prototype，并且在 A.prototype 中也没有找到 address 属性的时候， 请求会被传递给 A.prototype 的构造器原型 Object.prototype，显然 Object.prototype 中也没有 address 属性，但 Object.prototype 的原型是 null，说明这时候原型链的后面已经没有别的节点了。 所以该次请求就到此打住，a.address 返回 undefined。通过 Object.create(null) 可以创建出没有原型的对象 1234567891011121314151617181920212223242526272829通过ES6 class 创建对象 class Animal { constructor(name){ this.name = name } getName(){ return this.name } } class Dog extends Animal{ constructor(name){ // console.log('this',this) console.log('super',super()) //不调用 super() 就没有绑定this super()只能调用一次 // Dog {name: undefined} console.log('this',this) // Dog {name: undefined} console.log('name',name) // super(name) } speak(){ return 'woof' } } var dog = new Dog('scamp') console.log(dog.getName()+'----say-----'+dog.speak()) //undefined----say-----woof 如果对象无法响应某个请求 它会把这个请求委托给自己的原型 this call applythisjs 的 this 总是指向一个对象 在运行时基于函数的执行环境动态绑定的 而非函数被声明时的环境 this 的指向可以分为下面四种 作为对象的方法调用 1this指向当前对象 作为普通函数调用 1this指向window 1234567891011121314151617181920212223242526272829window.name='maying'; var getName = function(){ return this.name } console.log(getName()) //maying 或者 window.name='maying'; var myObject = { name:'stven', getName :function(){ console.log('this',this) return this.name; } } var a = myObject.getName; console.log(a()) //maying 此时用另外一个变量a来引用myObject.getName 并且调用 a() 时 此时是普通函数的调用函数 this是指向全局的 console.log(myObject.getName()) // stven getName是作为对象的属性被调用的 此时的this指向 myObject 在ES5 的 strict模式下 this已经被规定为不会指向全局对象 而是undefined function func(){ \"use strict\" alert ( this ); func(); 构造器调用当使用 new 运算符调用函数时 该函数总会返回一个对象通常情况下 构造器里的 this 就指向返回的这个对象如果 构造器显示返回了一个 object 类型的对象 那么此次元算结果最终会返回这个对象 12345678910111213141516171819var Preson = function(){ this.name='maying' return { name:'anne' } } var p =new Preson() console.log('p',p.name) //anne 如果不显示返回数据会这返回一个非对象的类型 构造器里的this就指向返回的这个对象 var Preson = function(){ this.name='maying' return 'swe' } var p =new Preson() console.log('p',p.name) //maying Function.prototype.call 或者 Function.prototype.apply 调用 作用：可以动态地改变传入函数的 this ES3 给 Function 原型定义的两个方法 call 和 apply 区别只是在传递参数的不同 123456var func = function( a, b, c ){alert ( [ a, b, c ] ); // 输出 [ 1, 2, 3 ]};func.apply( null, [ 1, 2, 3 ] );第一个参数：函数体内this的指向 传null时 指向 默认的宿主对象 浏览器默认window第二个参数： 数组或者类数组 apply方法把这个集合中的元素作为参数传递给被调用的函数 1234567var func = function( a, b, c ){alert ( [ a, b, c ] ); // 输出 [ 1, 2, 3 ]};func.call( null, 1, 2, 3 );第一个参数：函数体内this的指向第二个参数：第二个参数开始往后，每个参数被依次传入函数 123456789101112131415161718192021222324var obj1 = { name:'maying', getInfo :function(){ return this.name } } var obj2 = { name:'anne' } console.log('obj1',obj1.getInfo()) //maying console.log('obj2',obj1.getInfo.call(obj2)) //anne 此刻getInfo函数体内的this指向obj2对象 相当于 var obj1 = { name:'maying', getInfo :function(){ return obj2.name } } Math.max.apply( null, [ 1, 2, 5, 3, 4 ] ) // 输出:5 Function.prototype.bind() 用来指定函数内部的 this 指向 123456789101112131415161718192021222324 // js原生模拟 Function.prototype.bind 函数实现 Function.prototype.bind = function(context){ var self = this //this当前指向 fun函数 console.log('self',self) return function(){ return self.apply(context,arguments) // 将fun函数内部的this指向obj // 相当于 function(){ // console.log('obj1.name',obj1.name) // } } }var obj1 = { name:'maxiaoyin'}var fun = function(){ console.log('this.name',this.name)}.bind(obj1) fun(); //maxiaoyin 借用其他对象的方法实现继承 123456789101112131415function A (){ this.name='maying' } function B(){ A.apply(this,arguments) this.getName = function(){ return this.name } } var b = new B(); console.log('b',b.getName()) //maying 想往 arguments 中添加一个新的元素 123456789101112131415161718192021222324252627 (function abc (){ // arguments.push('1') 因为arguments不是数组 没办法执行数组有的push方法 // [].push.call(arguments,'1') 或者 Array.prototype.push.call(arguments,'7') console.log('arguments',arguments) } 再操作 arguments 时候 我们通常会借用Array.prototype的各种方法Array.prototype.push 实际上是属性复制的过程 可以推断 我们可以把**任意**的对象 传入 Array.prototype.push 这个任意的限制 对象本身可以存取书香 对象的length可读写 var a= {} Array.prototype.push.call(a,'first') console.log(a) //{0: \"first\", length: 1} console.log(a instanceof Object) //true console.log(a[0]) // 并非数组的用法 first 闭包和高阶函数js 的函数作用域 就像一层半透明的玻璃 从里面可以看到外面 从外面不能看到里面变量的搜索是从内往外而不是从外往内的 带有 var 关键字的局部变量 会随着函数调用的结束而销毁 12345678910111213141516171819202122232425262728293031一个有趣的问题 &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt;&lt;script&gt; var nodes = document.getElementsByTagName( 'div' ); for ( var i = 0, len = nodes.length; i &lt; len; i++ ){ nodes[ i ].onclick = function(){ alert ( i ); } };&lt;/script&gt;结果是每次都是5原因是： div的click是被异步触发的 当for循环被触发的时候 for循环早已经结束 此时i变量的值已经是5了 这个时候 click事件的函数顺着作用域链向上找变量i的时候 找到的始终是5解决方式 for ( var i = 0, len = nodes.length; i &lt; len; i++ ){ (function(i){ console.log('i',i) nodes[ i ].onclick = function(){ alert ( i ); } })(i) }; 闭包的作用 封装变量闭包可以把一些不需要暴漏在全局的变量封装成私有变量 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152改造之前var cache = {};var mult = function(){ var args = Array.prototype.join.call( arguments, ',' ); if ( cache[ args ] ){ return cache[ args ]; } var a = 1; for ( var i = 0, l = arguments.length; i &lt; l; i++ ){ a = a * arguments[i]; }return cache[ args ] = a;};alert ( mult( 1,2,3 ) );alert ( mult( 1,2,3 ) );改造原理：如果大函数里面又可以复用的小函数 可以提炼出来 但是这些小函数不需要在其他地方调用的话最好用闭包封闭起来改造之后 var mult = (function (){ var cache={} var calculate = function(){ var a =1; for(var i = 0;i&lt;arguments.length; i++){ a = a *arguments[i]; } return a; } return function(){ var args = Array.prototype.join.call(arguments,',') // 如果存在的话 if(cache[args]){ return cache[args] } return cache[args] = calculate.apply(window,arguments) }})(); console.log(mult(1,2,3)) 2. 延续局部变量的寿命 闭包和面向对象的设计 12345678910111213141516171819202122232425262728293031 // 用闭包实现一个面向对象系统 var extent = function(){ var value = 0; return { call: function(){ value++; console.log( value ); } // 面向对象的写法 var extend = { this.value = 0; this.call = function(){ this.value ++; console.log('this.value',this.value) } }// 或者var Extend = function(){ this.value = 0};Extend.prototype.call=function(){ this.value ++; console.log('this.value',this.value)} 高阶函数满足下列条件之一函数可以作为参数被传递函数可以作为返回值输出 判断数据的类型 Object.prototype.toString.call对象的原生扩展函数 更精确的区分数据类型 15.2.4.2 Object.prototype.toString()在 toString 方法被调用时，会执行下面的操作步骤: 获取 this 对象的 [[Class]] 属性的值。 计算出三个字符串”[object “, 第一步的操作结果 Result (1), 以及 “]” 连接后的新字符串。 返回第二步的操作结果 Result (2)。[[Class]] 是一个内部属性，所有的对象 (原生对象和宿主对象) 都拥有该属性。在规范中，[[Class]] 是这么定义的:内部属性 描述[[Class]] 一个字符串值，表明了该对象的类型。其过程简单说来就是：1、获取对象的类名（对象类型）。2、然后将 [object、获取的类名、] 组合并返回。 12 Object.prototype.toString.call( [1,2,3] )\"[object Array]\" 判断数据的类型 1234567891011var isType = function( type ){ return function( obj ){ return Object.prototype.toString.call( obj ) === '[object '+ type +']'; }};var isString = isType( 'String' ); var isArray = isType( 'Array' ); var isNumber = isType( 'Number' );console.log( isArray( [ 1, 2, 3 ] ) ); 高阶函数实现 AOP（AOP）面向切面编程 主要作用是把一些跟核心业务逻辑的代码抽离出来 函数节流 函数被频繁调用的场景window.onresize 事件mousemove 事件图片或者视频的上传进度 函数节流的原理 setTimeout 来完成这件事情 分时函数 惰性加载函数 ** 设计模式 **单例模式定义：保证一个类仅有一个实例，并且提供一个访问他的全局访问点 实现单例模式 原理： 用一个对象来表示当前是否已经为这个类创建过对象，如果是 则在下一次获取该类的实例的时 直接返回之前创建的对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 var Singleton = function(name){ this.name=name, this.create = null; }Singleton.prototype.sayName = function(){ console.log(this.name)}var sayFn = function(name){ if(!this.create){ this.create = new Singleton(name) } return this.create}var a = sayFn('maxiaoying').sayName(); //maxiaoyingvar b = sayFn('lujing').sayName() //maxiaoyingconsole.log(a ===b). //true另一种闭包的实现方式var Sngal = function(name){ this.name=name;}Sngal.prototype.sayname =function(){ consoel.log('this.name',this.name)}// var getName= function(){// var instance = null;// return function(name){// if(!instance){// instance = new Sngal(name)// }// return instance// }// }(name);// 或者var getName= function(){ var instance = null; return function(name){ if(!instance){ instance = new Sngal(name) } return instance }}();先让getName 自执行才能得到 然后接收参数 理解闭包 -------------------------------------return function(name){ if(!instance){ instance = new Sngal(name) } return instance } -------------------------------------var a = getName('maxiaogiou');console.log('a',a)var b = getName('xiaoxioamao');console.log('b',b)console.log('a ===b',a===b)","categories":[{"name":"web","slug":"web","permalink":"http://maying.ink/categories/web/"}],"tags":[{"name":"js","slug":"js","permalink":"http://maying.ink/tags/js/"},{"name":"design_mode","slug":"design-mode","permalink":"http://maying.ink/tags/design-mode/"}]},{"title":"网易与淘宝移动端适配工作流思考一","slug":"网易与淘宝移动端适配工作流","date":"2017-08-08T16:00:00.000Z","updated":"2020-10-22T18:41:42.192Z","comments":true,"path":"2017/08/09/网易与淘宝移动端适配工作流/","link":"","permalink":"http://maying.ink/2017/08/09/%E7%BD%91%E6%98%93%E4%B8%8E%E6%B7%98%E5%AE%9D%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E5%B7%A5%E4%BD%9C%E6%B5%81/","excerpt":"最近尝试了解了一些移动端的概念得空总结了网易与淘宝的一些适配方案，为后续工作记录一下","text":"最近尝试了解了一些移动端的概念得空总结了网易与淘宝的一些适配方案，为后续工作记录一下 ## 网易移动端适配方案要点： 12* 网易页面上html的font-size不是预先通过媒介查询在css里定义好的，而是通过js计算出来的* 为了方便，取一个100px的font-size为参照 步骤： 12345678910111213141516171819202122232425261.拿设计稿竖着的横向分辨率除以100得到body的宽度 eg： iphone6，横向分辨率为750，width =750 / 100 = 7.5rem iphone4/5，横向分辨率为640，width为640 / 100 = 6.4rem 2.布局时 css尺寸 = 设计稿标注尺寸／100 eg：210px = 210/100 = 2.1rem 3. Dom ready以后获取html的font-size ⚠️ 当设备宽度（deviceWidth大于设计稿的横向分辨率时 html的font-size始终等于横向分辨率/body元素宽） 代码体现 var deviceWidth = document.documentElement.clientWidth; if(deviceWidth &gt; 640) deviceWidth = 640; document.documentElement.style.fontSize = deviceWidth / 7.5 + 'px';4.font-size 可能需要额外的媒体查询 而且不要用rem @media screen and (max-width:321px){ .m-navlist{font-size:15px} } @media screen and (min-width:321px) and (max-width:400px){ .m-navlist{font-size:16px} } @media screen and (min-width:400px){ .m-navlist{font-size:18px} }5.关于视口的设置 &lt;meta name=\"viewport\" content=\"initial-scale=1,maximum-scale=1, minimum-scale=1\"&gt; #淘宝移动端适配方案要点： 123451.设置视口标签 &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no\"&gt;使得整个网页在设备内显示时页面的宽度始终等于设备宽度（device-width）scale =1 时 device-width = 设备的物理分辨率／devicePixelRatio（设备像素比） 手淘的布局前提是 动态设置 viewport 的 scale 目的就是为了保证页面大小与设计稿大小一致 12比如设计稿是750的横向分辨率 那么实际页面的device-width 以iphone6来说 也等于750这样的话设计稿上标注的尺寸只要除以某一个值就能够转换成rem了 2. 那么 如何动态设置？ 12var scale = 1 / devicePixelRatio;document.querySelector('meta[name=\"viewport\"]').setAttribute('content','initial-scale=' + scale + ', maximum-scale=' + scale + ', minimum-scale=' + scale + ', user-scalable=no'); 3. 手淘布局的第二个要点就是关于 html 元素的 font-size 计算公式 1font-size = deviceWidth/10; 可能会需要额外的媒体查询 同网易 不使用 rem但是呢 淘宝的 rem 不太好计算 如果借助 less 就好算多了类似： 12345678910111213//定义一个变量和一个mixin@baseFontSize: 75;//基于视觉稿横屏尺寸/100得出的基准font-size.px2rem(@name, @px){ @{name}: @px / @baseFontSize * 1rem;}//使用示例：.container { .px2rem(height, 240);}//less翻译结果：.container { height: 3.2rem;} 4. 元素的 css 尺寸如何计算？ 1234比如一个设计稿上某一个元素的高是 150pxcss尺寸 = 设计稿标记尺寸/该设计稿对应的html的font-size也就是说 设计稿是750 所以 font-size = 750/10 =75px 150/75 = 2rem 关于这种做法的具体实现，淘宝已经给我们提供了一个开源的解决方案 淘宝移动端布局方案 比较网易与淘宝的做法共同点：都能适配所有的手机设备，对于 pad，网易与淘宝都会跳转到 pc 页面，不再使用触屏版的页面都需要动态设置 html 的 font-size布局时各元素的尺寸值都是根据设计稿标注的尺寸计算出来，由于 html 的 font-size 是动态调整的，所以能够做到不同分辨率下页面布局呈现等比变化容器元素的 font-size 都不用 rem，需要额外地对 font-size 做媒介查询都能应用于尺寸不同的设计稿，只要按以上总结的方法去用就可以了 不同点：淘宝的设计稿是基于 750 的横向分辨率，网易的设计稿是基于 640 的横向分辨率，还要强调的是，虽然设计稿不同，但是最终的结果是一致的，设计稿的尺寸一个公司设计人员的工作标准，每个公司不一样而已淘宝还需要动态设置 viewport 的 scale，网易不用最重要的区别就是：网易的做法，rem 值很好计算，淘宝的做法肯定得用计算器才能用好了 。不过要是你使用了 less 和 sass 这样的 css 处理器，就好办多了","categories":[],"tags":[{"name":"mobile","slug":"mobile","permalink":"http://maying.ink/tags/mobile/"}]},{"title":"viewports 剖析一","slug":"viewports剖析一","date":"2017-08-02T16:00:00.000Z","updated":"2020-10-22T18:41:42.187Z","comments":true,"path":"2017/08/03/viewports剖析一/","link":"","permalink":"http://maying.ink/2017/08/03/viewports%E5%89%96%E6%9E%90%E4%B8%80/","excerpt":"","text":"因为工作的原因，很少有机会接触移动 web 开发，一直都还挺遗憾的，偶尔写几个页面也都是 “按照套路” 出牌，最近终于有空了解一些概念性的东西，记录一下文中的图片为了说明问题均为盗图，具体出处会在文末注明 本文大概将以下几个概念以做对比 PC 设备的 pixels 和 CSS 的 pixels 所谓的 100% 缩放 屏幕尺寸和浏览器尺寸 页面的滚动移位 viewport 以及度量 viewport html 元素以及度量 html 关于事件坐标 媒体查询 width/height 与 device-width/height mobile mobile 浏览器 两种 viewport layoutviewport visualviewport 缩放 Zooming 屏幕尺寸 页面的滚动移位 html 元素以及度量 html 关于事件坐标 媒体查询 width/height 与 device-width/height viewport 的 meta 标签 设备的 pixels 和 CSS 的 pixels **设备的pixels** 设备像素是我们直觉上觉得「靠谱」的像素。这些像素为你所使用的各种设备都提供了正规的分辨率 大多数情况下能从`screen.width/height` 取出具体值 当然了 设备的pixels对web开发人员几乎毫无用处 这里只需要知道它的概念即可 **CSS的pixels** 这些就是那些控制你的样式表如何被渲染的像素 现代浏览器上的缩放是基于伸展 pixels所以 html 元素上的宽度不会因为你缩放了 200% 而变成了两倍宽，它在形式上还是一倍宽 只不过占用了两倍的设备 pixels如下图 1-1 有 4 个 1pixels，缩放为 100% 的 html 元素 此时 css pixels 和设备的 pixels 完全重合此时我们如果缩小浏览器 css 的 pixels 开始收缩，导致 1 单位的设备 pixels 上重叠了多个 css 的 pixels 如下图 1-2如果放大浏览器 css 的 pixels 就会放大 导致 1 单位的 css pixels 上重叠了多个设备 pixels 如图 1-3总而言之 你只需要关注 CSS 的 pixels 这些 pixels 将指定你的样式被如何渲染就像上面所说的 设备的 pixels 对开发人员无用 但是对用户有用，因为用户回手动缩放页面，这些开发人员不用关注 浏览器会自动保证你的 css pixels 会被伸展还是被收缩 所谓的 100% 缩放 100% 缩放的情况下 1 单位的的 CSS pixels 严格等于 1 单位的设备 pixels 屏幕尺寸和浏览器尺寸 **屏幕尺寸（Screen size）** 含义：用户的屏幕的完整大小 度量：设备的pixels 不会因为缩放而改变 是显示器的特征 对我们来说没用 获取方式 如下图1-4 ![](/images/viewports/4.jpg) 浏览器尺寸（Window size）含义：包含滚动条尺寸的浏览器完整尺寸度量：CSS pixels浏览器内部尺寸，它定义了当前用户有多大区域。可供你的 css 布局占用如下图 1-5 页面的滚动移位 含义：页面的移位 度量：CSS pixels 定义了页面（document）的相对于窗口远点的位移，可以利用这个特性获取用户滚动了多少的滚动条距离 如下图1-6 ![](/images/viewports/6.jpg) viewport 以及度量 viewport **viewport** 啊啊啊 终于提到viewport了 鸡冻 划重点 `viewport`是控制``元素的容器 是``的爹 你发现了么？百分比布局时 你定义的一个侧边栏宽度为 10% 当你改变大小时 它的宽度会自动扩张和收缩 原理是啥当然了 它的宽度是依赖父元素 假如它父元素就是 &lt;body&gt; 那么 &lt;body&gt; 多宽？向上类推 &lt;body&gt; 的宽度取决于它的父元素 &lt;html&gt;呃.. 废话好多 &lt;html&gt; 宽度取决于它的父元素 &lt;html&gt; 恰好等于浏览器的宽度 所以你的 10% 会占用浏览器宽度的 10% 我们都是这么用的 今天深扒发现&lt;html&gt; 宽度受 viewport 限制 ，等于 viewport 宽度的 100%也就是说viewport 严格等于浏览器窗口需要注意的是：viewport 不是一个 html 的概念 所以不能通过 CSS 修改它 真实页面宽度概念如果你放大页面几倍 如何标识页面宽度（此时已经有横向滚动条了，也就是说页面的内容溢出了 &lt;html&gt; 元素）使用 document width如图 1-7如图 1-8度量 viewport含义：viewport 尺寸度量：CSS pixels如下图 1-9document.documentElement 代表 HTML 文档根元素&lt;html&gt;来 先看张图这张图是在为 &lt;html&gt; 元素赋值 25% 但是 document.documentElement.clientWidth 值仍然不变说明 document. documentElement. clientWidth/Height 只会给出 viewport 的尺寸，而不管元素尺寸如何改变那么问题来了我是不是也可以用 window.innerWidth 来定义 viewport呃.他与 document.documentElement.clientWidth 有一点细微的差别前者不包含滚动条 html 元素以及度量 html **html** ta爹(`viewport`)如果`document.documentElement.clientWidth`表示那么``这样获取 `document.documentElement.offsetWidth` ![](/images/viewports/11.jpg) 如果给``元素赋值了宽度 那么`offsetWidth`就会真实的反映出来 关于事件坐标 **pageX/Y, clientX/Y, screenX/Y** pageX/Y：从原点到事件触发点的 CSS 的 pixels clientX/Y：从 viewport 原点（浏览器窗口）到事件触发点的 CSS 的 pixels screenX/Y：从用户显示器窗口原点到事件触发点的设备 的 pixels。上图 媒体查询 width/height 与 device-width/height * `device-width/height`使用`screen.width/height`来做为的判定值。该值以设备的pixels来度量 * `width/height`使用`documentElement.clientWidth/Height`即viewport的值。该值以CSS的pixels来度量 ![](/images/viewports/16.jpg) 桌面浏览器上使用width mobile 浏览器 移动设备的屏幕宽度比桌面浏览器小（好多废话.） 试想一下 如果我们只是copy桌面的样式到移动设备 该有多丑 如下图 移动设备浏览器在初始默认打开以最小缩放模式打开网站。（即在手机屏幕上展示完整宽度的页面） 假设当前设备的宽度是 400px 还是之前说过的 10% 侧边栏，如果移动设备上做同样的处理，会显示 40px 的宽 太窄了，布局会变得非常可怕那么 如何处理？ 两种 viewport 因为viewport太窄，最显然的解决方式就是将它变宽 由此 引出了 虚拟视口 （`viewportvisualviewport`） 与 布局视口（`viewportlayoutviewport`） 关于它们 有一个很好的解释 123456 想象一下viewportlayoutviewport是一张大的不能改变大小和角度的图片 现在你有个更小的框来观看这张大图片这个框被不透明的材料包围 因而你只能看到大图片的一部分 你通过这个框子看到的大图片的那部分就叫做虚拟视口（viewportvisualviewport）你拿着这个框拿着站的离大图原点（用户的缩小页面功能）以一次性看到这个大图片你站的离的近一点（用户的放大页面功能）以看到一部分你能改变这个框框的远近 但是这张大图片的大小和形状都不会改变 visualviewport 是当前显示在屏幕上的部分页面。用户会滚动页面来改变可见部分，或者缩放浏览器来改变 visualviewport 的尺寸。如下图但是 CSS 布局 通常是按照 layoutviewport 定义的，这要比 visualviewport 宽很多 元素的宽度继承于layoutviewport 缩放 Zooming 两种viewports都以CSS的 pixels来度量。当你通过缩放改变visualviewport时，layoutviewport保存不变。 屏幕尺寸 **理解layout viewport** 许多移动设备浏览器在初始默认打开以最小缩放模式打开网站（也就是在手机屏幕上展示完整宽度的页面） 此时浏览器已经选择好他们的 layoutviewport 的尺寸 它完整覆盖了最小缩放模式下的移动浏览器的屏幕，这个时候 layoutviewport 的宽度高度和最小缩放模式下能在页面上显示的内容的宽度和高度一致。那么移动端如何计算 layoutviewport 的尺寸？document. documentElement. clientWidth/Height 理解 visual viewport那么移动端如何计算 visualviewport 的尺寸？window.innerWidth/Height 随着用户的缩放浏览器 值会改变 更多 更少的 CSS pixels 放进了屏幕屏幕尺寸 screen和 pc 浏览器一样 screen.width/height 标示了设置屏幕的尺寸 以设备的 pixels 显然 这跟开发人员没有什么关系 页面的滚动移位 你同样需要知道当前的虚拟视口相对于布局视口的距离 这叫做`滚动位移` ，它像在pc端获取一样 使用**window.pageX/YOffset** html 元素以及度量 html html元素的整体尺寸，和pc端一致 使用`document.documentElement.offsetWidth/Height`，元素以CSS pixels度量 关于事件坐标 同pc浏览器 只需要关注 pageX/Y 媒体查询 width/height 与 device-width/height 也如同pc浏览器 `width/height `使用css的pixels度量layoutviewport 即`document. documentElement. clientWidth/Height ` `device-width/height `使用设备的pixels 即 `screen.width/height. ` 所有浏览器都遵循这个原理 viewport 的 meta 标签 1&lt;meta name=\"viewport\" content=\"width=320\"&gt; 最初这是apple的一个html扩展标签，被很多浏览器复用 设置 `虚拟视口`的宽度 假设你现在创建一个页面 并不为它设置宽度 那么它会伸展开来占据 100% 的 viewlayout 的宽度 绝大多数浏览器缩小这个页面在一屏的宽度上显示这个 layoutviewport 当用户放大页面 绝大多数会保存元素的宽度（保持元素的定位不变）而导致文字超出屏幕当你设置 1&lt;meta name=\"viewport\" content=\"width=320\"&gt; 你网站的 layoutviewport 变成了 320px。页面的初始状态就很正确了 Part1:http://www.quirksmode.org/mobile/viewports.html Part2:http://www.quirksmode.org/mobile/viewports2.html","categories":[],"tags":[{"name":"mobile","slug":"mobile","permalink":"http://maying.ink/tags/mobile/"}]},{"title":"记梦一","slug":"记梦","date":"2017-07-30T16:00:00.000Z","updated":"2020-10-22T18:41:42.192Z","comments":true,"path":"2017/07/31/记梦/","link":"","permalink":"http://maying.ink/2017/07/31/%E8%AE%B0%E6%A2%A6/","excerpt":"","text":"此时此刻 ，反复思索着昨晚的梦，人生充满无奈，珍惜眼前人 具体的故事背景记不清了 大概是朋友的奶奶蹊跷去世了，我去她家安慰她并试图查事故原因，结果等我回去找他们的时候发现自己已经变成了隐形人 其实就是已经死掉了，显然我自己也不知道自己发生了什么事情，事实就是我还在人间，就是我能看世人，世人再也看不到我了 第一反应是： 我要回家我不知道他们是怎么处理世间的我，我只知道我的灵魂回家了我也记不清爸妈是否知不知道我已经不在了，我用力的跟他们讲话 只可惜他们大大小小全都对我视而不见，我来不及思考 依然用力呼唤他们，追着拉着，全都没有用， 我好无力… 想到多年前看过一部日本的温情电影，讲的也是主人公意外身故 化身隐形人回家，发现自己没办法让家人注意到也是很痛苦 不过电影就是电影 有一个巫婆是阴阳眼 成了 家人跟 “隐形人” 沟通的桥梁，必要的时候还会帮助家人度过难关 影片最后是巫婆帮助隐形人附身于自己身上，与妻子做最后的告别，最后安稳投胎印象中这才是鬼魂的正确打开方式 国产剧中的鬼魂仿佛都很厉害的样子，有仇报仇，有冤报冤，一言不合就施法 也是～ 我当时想起来银行账户还有钱 就想给他们转过去，但是负责管我的警察，暂且叫他 灵魂摆渡人 （404 号便利店), 对耶 我为什么没去 404 号便利店找夏冬青帮我实现愿望，大概我遇见的是赵吏 笑 cry 他说 我可以往人间账户汇款，就是有损耗 1W 只能到账 1k 这尼玛是跨行手续费吗😢 不记得最后是咋解决的， 反正世界就再也没有我了，就算再挣扎我开始回忆一生，那些活过的平淡日子，能记起来的只有桩桩件件的遗憾 我还没有孝顺父母 上次电话里没有喊一嗓子 爸妈我爱你 我应该再回一次家的 想在老家给爹妈买房子的钱还没存够 家庭旅行的计划家门口还没出 想起来这些碎碎念 突然我就开始怀念了 我想，如果我在世的时候能有这些危机感 现在也不会有这么多遗憾了 私人一点的是 恋爱记有这么多点滴 另一半还没添加这世上 除了爸妈亲人 连个记挂我的人都没有 好悲哀 早上被闹钟叫醒 发现自己还活着 感谢上帝 有些事只有失去过才知道 我拥有的还很多 致每一个空虚的你","categories":[],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://maying.ink/tags/%E6%9D%82%E8%B0%88/"}]},{"title":"从不规范生产套路看效率","slug":"从不规范团队看效率","date":"2017-07-21T16:00:00.000Z","updated":"2020-10-22T18:41:42.189Z","comments":true,"path":"2017/07/22/从不规范团队看效率/","link":"","permalink":"http://maying.ink/2017/07/22/%E4%BB%8E%E4%B8%8D%E8%A7%84%E8%8C%83%E5%9B%A2%E9%98%9F%E7%9C%8B%E6%95%88%E7%8E%87/","excerpt":"","text":"标题好像是句废话，” 不规范” 何谈 效率 呢？ 何为效率 从产品看效率 从 UI 看效率 从开发看效率 从测试看效率 何为效率？ 百度百科上大概是这么定义的：是指在给定投入和技术等条件下，最有效地使用资源以满足设定的愿望和需要的评价方式 对我来说最直观的判断方式就是 项目是否有延期 线上是否有 bug 效率有多重要？ 大部分的电子厂工资都是按件计费的，多劳多得，单位时间产出与收入能正比，所以工人们都非常努力 这是自发性行为 所以也是最任怨的。 对我而言 效率能带来好心情 好状态以及好的生活态 废话 大家都一样 – 从产品看效率一款产品的成功与否 有多方便的决定因素 产品最终都是面向用户的 一个不能为用户创造价值的产品应该是没有使用价值的，产品本就是提升效率的一种方式 那么 接下来 我要开始吐槽了 如果产品需求不明确或者需求不完整 项目要不要开始做？一般来说 不要 绝对不要 除非是两个完全不相干的模块 昂 基本也不太可能但是尼 为了所谓的工期 产品大大一般会这么说 做呗 先做着 我这么单（wu）纯（nai）的 每次都被套路住🤡 然后后来计算工时的时候 ： 哦 你不是从那个什么什么时候就开始了吗？👐🏽这还不是最主要的，毕竟 时间就像海绵里的水 挤一挤总会有的😂 最主要的当然是改需求啦 这大概是所有产品最擅长的 这两者本质上是没有矛盾的，只不过产品更多的以目标为导向，需求只是手段，而对开发来说 技术是手段 需求是目标 只不过产品更容易主观，比如需求，比如说功能，比如说交互，这些都受到个人经验，眼界，学识很大影响。朝三暮四，朝令夕改，是常有的事情。 说真的产品的功能、质量、发布时间和需要投入的资源这四者不能都是封闭条件，否则可能无解 而且现在的产品很是聪明啊 需求给了，开始做了，做到最后发现这种情况下不是很合理，简单啊 改呗 反正做到这里我逻辑也捋清楚了，也知道该咋办了产品默想到 呃.. 这两天刚遇到个类似的情况 哦 不好意思，是经常遇到，提测一周也测了一周了，代码上体验版（预上线）了 1234567891011产品：咦？这块不是那样儿的吗？怎么是这样的？开发：？ 前两天不是专门讨论过这个问题吗，这个就是这样儿的！产品：哦？是吗？ 但是这样儿看起来好诡异啊！就应该是那样儿的 改一下吧开发：...当初接口设计的就是这样儿的，怎么不早说？这都要上线啦！😩产品：\"之前流程没走通 不太清楚这块儿的逻辑，现在改一下吧\" 然后就走了开发：... 还有就是排期 产品经常这么一句话：因为我们的上线时间是 XX 号 测试需要 XX 天 所以 开发排下期吧 ？ ….. 排完期之后.. 12345678910111213产品：昂昂，你这儿不行啊 时间太长了 能不能缩短点开发：我按工时算的 每一项 都列出来了 不会差太多产品：这不行啊 因为我们要XX提审 测试需要XX天 所以你必须 XX天提测开发：这等于 XX 天的工期 你给我压到 XX／2 天产品：嘿嘿😉开发：...开发OS：\"赶紧开发 为了给测试腾时间😂😭🙈，尼萌给开发时间充足了 问题自然就会少很多好吗 测试好像是最重要的噻\" 百度过类似的问题 最好的办法是让产品也学会基础的编程，了解每一个实现都是需要耗费资源的，这样才能基于对有限资源的理解，做出更谨慎的规划。然而，这基本不可能，所以.. 实际上 那些非常紧急的需求，这么一搞成了拖延的第一个关键点 从 UI 看效率 呃。对于用户来说 一个产品能不能吸引到你，最浅显也最重要的是眼缘，说俗气点就是颜值而且 UI 链接 产品与开发 自然也是马虎不得的 深刻理解原型的精髓 然后利用智慧的小脑瓜设计成用户想要的样子，上面说了 他们最重要的工作是 深刻理解原型的精髓，因为 对于美，设计师总是有不一样的定义，就比如 情人眼里出西施 非常不幸 我们 UI 也是必须要吐槽的对象 直接上日常 12345678910111213141516171819202122232425262728293031开发：设计小哥，对比原型 是不是缺了一张图设计：？开发：搜索中状态设计：沉默产品：哦 那个不就是在未搜索的状态基础上把导航去掉吗？还用出图吗？一分钟后～～设计：突然扔出来一张图 @开发:好了开发：瞅了一眼 @设计：嗯 ？不是这样儿的吧设计：？开发：把产品的话 @设计：“哦 那个不就是在未搜索的状态基础上把导航去掉吗？还用出图吗？”设计：沉默两分钟后～～设计：扔出来一张图 呐 上传了开发：嗯 现在才是对的设计：嗯 类似的事情简直日常 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566上午～产品：今天周五 需要把UI提的问题都改完开发：ok设计：ok下午～开发：什么时候有空，当面改设计：嗯下午四点～开发：什么时候有空设计：现在过去开发：嗯改了大概有两个之后 设计被叫走又过了一个小时～开发：快下班了 啥时候改尼设计：今天比较忙 现在可以开始了开发： 嗯？我看了一下 你拿到的不是最新版吧 好些问题现在不能复现了设计：哦一个小时之后开发：改完了 我下班了啊 今天有点事儿设计：嗯 好的 下班吧开发 走了两个小时后 忙完 开发都到家了～～产品：@开发：在哪里呢 啥时候回来开发：？我到家了啊产品：你咋走了？设计小哥还在等你呢开发：？我走的时候跟他说了啊 他知道啊产品：我不是说了今天要改完吗 设计review了 还有一点问题开发：... 那我明天去加班吧第二天，到公司之后开发：在群里@设计@产品 ：这个只有截图看不出来哪有问题噻设计：沉默产品：沉默开发：... 从开发看效率 开发效率无疑存在于两方面 强健的框架支撑与准确的拆分估期 一般情况下是不会延期的 也算是这几个环节当中最可控的 从测试看效率 你理解一个开发只用了一天的功能测试测了四天的心情吗 你理解一个开发用了一周 测试用了 9 个工作日的心痛吗 🙊 结语：💊","categories":[],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://maying.ink/tags/%E6%9D%82%E8%B0%88/"}]},{"title":"微信小程序开发常见问题","slug":"开发常见问题","date":"2017-07-18T16:00:00.000Z","updated":"2020-10-22T18:41:42.191Z","comments":true,"path":"2017/07/19/开发常见问题/","link":"","permalink":"http://maying.ink/2017/07/19/%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","excerpt":"","text":"场景一：首页增加下拉刷新功能无效？经过各种尝试 问题定位到了是因为 在 scroll-view 中使用了 onPullDownRefresh，最后通过改首页的代码结构达到了预期结果 结论：在滚动 scroll-view 时会阻止页面回弹，所以在 scroll-view 中滚动，是无法触发 onPullDownRefresh 如果非要在 scroll-view 使用下拉刷新，官方给出的解决方案是监听页面的滚动事件 bindscroll 厄.. 也是一种方法 只不过我的更粗鲁一些 其他需要注意的： 不要在 scroll-view 中使用 textarea、map、canvas、video 组件 目前只验证过 textarea 暂且放到场景二吧 scroll-into-view 的优先级高于 scroll-top 场景二：无法在 scroll-view 中使用 textarea？这是个只有在真机上才会出现的 bug 刚开始以为是不能在某些特定的组件内使用textarea 几番尝试 发现是因为 textarea组件与其他组件的层级关系 后来发现 文档在最下方用最小号的字体给标注出来了已经！吐血 结论：textarea组件是由客户端创建的原生组件，他的层级是最高的，在实际项目中 要保证本页面中 无 弹层之类一切可能会覆盖到页面的鬼。 其他需要注意的： 不要在 scroll-view 中使用 textarea 组件。 css 动画对 textarea 组件无效 textarea 的 blur 事件会晚于页面上的 tap 事件，如果需要在 button 的点击事件获取 textarea，可以使用 form 的 bindsubmit。 官方遗留 bug: textarea 在列表渲染时，新增加的 textarea 在自动聚焦时的位置计算错误。场景三：textarea 的 placeholder 不固定的问题 当把textarea放到一个 position：fixed 中的元素中时，会发现这个textarea也会跟着固定位置，但是textarea的 placeholder 内容不会固定，当滚动页面时，placeholder 的内容会跟着滚动 解决方式：给textarea组件增加属性 fixed 结论：踩坑大法好 场景四：微信小程序的兼容问题wx.request() 返回的状态码 res.statusCode 的值 在 IOS 下是 init 型的数据 但是在 Android 6.0.1 上却是 String 型数据要特别注意判断状态码的方式 12345678910111213Xwx.request({ url: 'http://api.example.com', success: function (res) { if (res.statusCode === 200) { // success } else { // server failure } }})像这样使用 === 就错了 不要判断类型使用 ==即可 小程序的 WXML 没有 HTML 的宽容度​那么高，单标签必需是 /&gt; 结尾的 不然会报错。 场景五：小程序版本的兼容问题无论用哪个组件 必须时刻注意当前兼容的版本 做低版本兼容 12345678 wx.openBluetoothAdapter()} else { // 如果希望用户在最新版本的客户端上体验您的小程序，可以这样子提示 wx.showModal({ title: '提示', content: '当前微信版本过低，无法使用该功能，请升级到最新微信版本后重试。' })} Fundebug 能够实时监测小程序，捕获小程序 Bug，然后反馈给开发者Fundebug 场景六：小程序版本的兼容问题绑定事件的时候，当两个方法重名时，后面的方法会覆盖前面的方法，并且 IDE 不报错 场景七：image小程序的 image 与 HTML5 的 img 最大的区别在于：小程序的 image 是按照 background-image 来实现的。默认 image 的高宽是 320*240。必须通过样式定义去覆盖这个默认高宽，auto 在这里不生效。开发者说这样设置的原因是：如果设置 auto ，页面布局会因为图片加载的过程有一个闪的现象（例如高度从 0 到 height ），所以要求一定要设置一个宽度和高度。 图片包括三种缩放模式 scaleToFill、aspectFit、aspectFill 和 9 种裁剪模式，三种缩放模式的实现原理对应如下： 123456789101112131415161718scaleToFill{background-size:100% 100%;//不保持纵横比缩放图片，使图片的宽高完全拉伸至填满 image 元素}aspectFit{background-size:contain;//保持纵横比缩放图片，使图片的长边能完全显示出来。也就是说，可以完整地将图片显示出来。}aspectFill{background-size:cover;//保持纵横比缩放图片，只保证图片的短边能完全显示出来。也就是说，图片通常只在水平或垂直方向是完整的，另一个方向将会发生截取。} 场景八：navigatornavigator 支持相对路径和绝对路径的跳转，默认是打开新页面，当前页面打开需要加 redirect；navigator 仅支持 5 级页面的跳转；navigator 不可跳转到小程序外的链接地址； 1&lt;navigator class=\"navigator\" redirect url=\"../login/index\" &gt;登录页&lt;/navigator&gt; 在小程序开发工具里，默认打开新页面，工具左上角有返回按钮。加上 redirect，当前页打开，不出现返回按钮。 场景八：大胆使用 flex 布局在做传统 H5 的时候，为了兼容各种低端设备的机型，通常不太敢轻易尝试 flex，但在小程序里就可以大胆的使用了。 1234567891011121314.media {display: flex;justify-content:center;align-items:center;}.media .content {flex: 1;} 场景八：大胆使用 flex 布局在做传统 H5 的时候，为了兼容各种低端设备的机型，通常不太敢轻易尝试 flex，但在小程序里就可以大胆的使用了。 1234567891011121314.media {display: flex;justify-content:center;align-items:center;}.media .content {flex: 1;} 场景八：页面最后一个 view 组件 设置 margin-bottom 属性 IOS 机型 失效的问题解决方式：当前 view 当前组件下加一个同级 view 123456789101112wxml &lt;view&gt;这是个按钮&lt;/view&gt; &lt;view class=\"marginB\"&gt;&lt;/view&gt; css .marginB{ height: 0rpx; font-size: 0rpx; } 场景九：实现长按保存图片 短按图片隐藏现有问题 用户体验不佳 长按需要抬起才能弹出 sheetAction 菜单 理想状态下是长按开始计时 350 秒之后自动弹操作菜单 利用 bindtouchstart 与 bindtouchend 事件结合 bindtap 实现 12345678910111213141516171819202122232425262728293031323334353637383940414243问题代码一WXML&lt;view bindtouchstart=\"mytouchstart\" bindtouchend=\"mytouchend\" bindtap=\"editAddress\" &gt;JSeditAddress: function (event) { let that = this; //触摸时间距离页面打开的毫秒数 var touchTime = that.data.touch_end - that.data.touch_start; console.log(touchTime); //如果按下时间大于350为长按 if (touchTime &gt; 350) { //TODO.. } else { //TODO.. } }, //按下事件开始 mytouchstart: function (e) { let that = this; that.setData({ touch_start: e.timeStamp }) console.log(e.timeStamp + '- touch-start') }, //按下事件结束 mytouchend: function (e) { let that = this; that.setData({ touch_end: e.timeStamp }) console.log(e.timeStamp + '- touch-end') } 改进 小程序的事件触发顺序 单击 touchstart → touchend → tap双击 touchstart → touchend → tap → touchstart → touchend → tap长按 touchstart → longtap → touchend → tap 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990问题代码二wxml&lt;view bindlongtap=\"longPress\" bindtap=\"tapFun\" style=\"width: 100%;height:100%\" mode=\"scaleToFill\" src=\"{{img_url}}\"&gt;&lt;/view&gt;jslongPress(e){ var that = this; console.log('你点击了长按时间',e) // 可以通过 wx.getSetting 先查询一下用户是否授权了 \"scope.record\" 这个 scope wx.getSetting({ success(res) { console.log('222222222222222222') if (!res['scope.writePhotosAlbum']) { wx.authorize({ scope: 'scope.writePhotosAlbum', success() { // 调起操作菜单 console.log('33333333333333333333') console.log('wx.showActionSheet()',wx.showActionSheet) wx.showActionSheet({ itemList: ['保存到本地'], success: function(res) { console.log('操作菜单弹出成功','第'+res.tapIndex+'个操作菜单弹出成功') // 下载文件资源到本地。客户端直接发起一个 HTTP GET 请求，返回文件的本地临时路径。 if(res.tapIndex ==0){ console.log('wx.downloadFile',wx.downloadFile) wx.downloadFile({ url: that.data.img_url, //仅为示例，并非真实的资源 success: function(res) { wx.playVoice({ filePath: res.tempFilePath }); console.log('wx.playVoice()',wx.playVoice) console.log('将图片先保存到本地--res.tempFilePath',res.tempFilePath); // 用户已经同意小程序使用功能，后续调用 wx.startRecord 接口不会弹窗询问 console.log('wx.saveImageToPhotosAlbum()',wx.saveImageToPhotosAlbum) wx.saveImageToPhotosAlbum({ filePath:res.tempFilePath, success(res) { wx.showToast({ title: '保存成功', icon: 'success' }); setTimeout(function(){ wx.hideToast(); },3000) }, fail(res){ wx.showToast({ title: '保存失败', icon: 'success' }); setTimeout(function(){ wx.hideToast(); },3000) } }) } }) } }, fail: function(res) { console.log('操作菜单弹出失败',res.tapIndex) } }) } }) } } })},tapFun: function(event) { that.setData({ qrShow:false })}很显然 这也是有问题的因为事件机制。总会触发 tap事件 表现形式比 问题一还难以接受 好了，结合前两种 解决办法如下 123456789101112131415161718192021222324252627282930313233343536373839WXml &lt;image wx:if=\"{{img_url !=''}}\" bindlongtap=\"editAddress1\" bindtouchstart=\"mytouchstart\" bindtouchend=\"mytouchend\" style=\"width: 100%;height:100%\" mode=\"scaleToFill\" src=\"{{img_url}}\"&gt;&lt;/image&gt;js//按下事件开始mytouchstart:function(e){ let that = this; that.setData({ touch_start: e.timeStamp }) console.log(e.timeStamp + '- touch-start')},//按下事件结束mytouchend:function(e){ let that = this; that.setData({ touch_end: e.timeStamp }) console.log(e.timeStamp + '- touch-end') that.editAddress(e);},// 判断是长按操作还是短按操作editAddress: function(event) { var that = this; if(that.data.touch_end - that.data.touch_start &lt; 350){ that.setData({ qrShow:false }) }},editAddress1(e){} // 同问题二 longPress（） 场景十：第二次扫码进入小程序的缓存问题","categories":[],"tags":[{"name":"issue","slug":"issue","permalink":"http://maying.ink/tags/issue/"},{"name":"wechat","slug":"wechat","permalink":"http://maying.ink/tags/wechat/"}]},{"title":"微信小程序 初见篇","slug":"微信小程序 初见篇","date":"2017-07-18T16:00:00.000Z","updated":"2020-10-22T18:41:42.191Z","comments":true,"path":"2017/07/19/微信小程序 初见篇/","link":"","permalink":"http://maying.ink/2017/07/19/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%20%E5%88%9D%E8%A7%81%E7%AF%87/","excerpt":"题外话 关于微信小程序 小程序与传统 HTML5 的区别 框架 目录结构与配置 逻辑层 视图层 运行机制","text":"题外话 关于微信小程序 小程序与传统 HTML5 的区别 框架 目录结构与配置 逻辑层 视图层 运行机制 关于微信小程序 小程序是什么？它有着什么样的功能？ A：小程序是一种不需要下载安装即可使用的应用，用户扫一扫或者搜一下即可打开应用。也体现了 “用完即走” 的理念，通过公众号关联，用户可以实现公众号与小程序之间相互跳转。 小程序可以和现有的 App 打通吗？ A：小程序可以借助微信联合登录，和开发者已有的 App 后台的用户数据进行打通，但不会支持小程序和 App 直接的跳转，现在最新版已经支持小程序跳转到另一个小程序了 小程序与传统 HTML5 的区别 开发工具不同区别于 H5 的开发工具 + 浏览器 Device Mode 预览的模式，小程序的开发基于自己的开发者工具，可以实现同步本地文件 + 开发调试 + 编译 + 预览 + 上传 + 发布等一整套流程。 开发语言不同小程序自己开发了一套 WXML 标签语言和 WXSS 样式语言，并非直接使用标准的 HTML5+css3。 组件封装不同小程序独立出来了很多原生 APP 的组件，在 HTML5 需要模拟才能实现的功能，小程序里可以直接调用组件。 传统 HTML5 在加载的时候受限于网络环境，需要顺序加载 HTML、CSS、JS，然后返回数据，最后渲染页面显示在浏览器中 小程序的两个线程：逻辑层和视图层会同时进行、并行加载，甚至视图层会更早执行，当视图线程加载完，通知逻辑层，逻辑层会把准备好的数据用 setData 的方法返回给视图线程 目录结构与配置 官方框架配置 小程序包含一个描述整体程序的 app 和多个描述各个页面的 page小程序的主体部分由三个文件组成 必须放在项目的根目录下 1234app.js 小程序入口逻辑app.json 小程序的公共设置对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等app.wxss 小程序的公共样式表 一个程序页面由四个页面组成 1234wxml 页面结构wxss 页面的样式表 （不必填）json 页面的配置 （不必填）js 页面逻辑 为了方便开发者减少配置项，我们规定描述页面的这四个文件必须具有相同的路径与文件名。 逻辑层 小程序开发框架的逻辑层是由 Javascript 编写的逻辑层将数据进行处理后发送给视图层，同时接收视图层的反馈，为了方便开发 小程序做了以下更改 增加 APP 和 Page 方法，进行程序和页面的注册 APP () 函数用来注册一个小程序 接受一个 object 参数 也就是小程序的生命周期函数 123456789onLaunch 监听小程序初始化 当小程序初始化完成时，会触发 onLaunch（全局只触发一次）onShow 生命周期函数--监听小程序显示 当小程序启动，或从后台进入前台显示，会触发 onShowonHide 生命周期函数--监听小程序隐藏 当小程序从前台进入后台，会触发 onHide前台、后台定义： 当用户点击左上角关闭，或者按了设备 Home 键离开微信，小程序并没有直接销毁，而是进入了后台；当再次进入微信或再次打开小程序，又会从后台进入前台。需要注意的是：只有当小程序进入后台一定时间，或者系统资源占用过高，才会被真正的销毁。onError 错误监听函数 当小程序发生脚本错误，或者 api 调用失败时，会触发 onError 并带上错误信息当然了 开发者也可以添加任意的函数或数据到 Object 参数中，用 this 可以访问比如点击 长按 事件等 Page () 函数用来注册一个页面 接受一个 object 参数 其指定页面的初始数据、生命周期函数、事件处理函数等。 12345678910data 页面的初始数据onLoad(query) 生命周期函数--监听页面加载onReady 生命周期函数--监听页面初次渲染完onShow 生命周期函数--监听页面显示onHide 生命周期函数--监听页面隐藏onUnload 生命周期函数--监听页面卸载onPullDownRefresh 页面相关事件处理函数--监听用户下拉onReachBottom 页面上拉触底事件的处理函数onShareAppMessage 用户点击右上角转发onPageScroll(scrollTop) 页面滚动触发事件的处理函数 参数代表页面垂直方向已经滚动的距离 12345678910111213141516route 字段可以获取到当前页面的路径。注册函数里 console.log('this.route',this.route)setData 函数以key value 的形式接收一个对象 用于将数据从逻辑层发送到视图层，改变对应的 this.data中相应key的值。set的值不需要在this.data中预先定义 this.setData({ name:'马莹' }) console.log('this.data',this.data)注意： 直接修改 this.data 而不调用 this.setData 是无法改变页面的状态的，还会造成数据不一致 单次设置的数据不能超过1024kB，请尽量避免一次设置过多的数据。 增加 getAPP 和 getCurrentPages 方法，分别用来获取 App 实例和当前技术栈 可以根据全局函数获取到小程序的实例 12345var appInstance = getApp()console.log(appInstance.globalData)console.log('getCurrentPages()',getCurrentPages()) 小 tips： App() 必须在 app.js 中注册，只能注册一次 在定义在 APP() 的函数中想获取 app 实例，不要用 getApp() 的方式 直接用 this 就行 不要在 onLaunch 的时候调用 getCurrentPages()，此时 page 还没有生成 3 . 每个页面有独立的作用域，并提供模块化的能力 在 javascript 文件中声明的变量和函数只是在该文件中有效 我们可以将一些公共的代码抽离成为一个单独的 js 文件，作为一个模块。模块只有通过 module.exports 或者 exports 才能对外暴露接口。 需要注意的是： exports 是 module.exports 的一个引用，因此在模块里边随意更改 exports 的指向会造成未知的错误。所以我们更推荐开发者采用 module.exports 来暴露模块接口，除非你已经清晰知道这两者的关系。 小程序目前不支持直接引入 node_modules , 开发者需要使用到 node_modules 时候需要拷贝出相关的代码到小程序的目录中。 123456789101112131415161718192021function sayHello(name) { console.log(`Hello ${name} !`)}function sayGoodbye(name) { console.log(`Goodbye ${name} !`)}module.exports.sayHello = sayHelloexports.sayGoodbye = sayGoodbye引用var common = require('common.js') require 暂时不支持绝对路径Page({ helloMINA: function() { common.sayHello('MINA') }, goodbyeMINA: function() { common.sayGoodbye('MINA') }}) 4 . 由于框架并非运行在浏览器中，所以 JavaScript 在 web 中一些能力都无法使用，如 document，window 等。 5 . 开发者写的所有代码最终将会打包成一份 JavaScript，并在小程序启动的时候运行，直到小程序销毁， 页面路由在小程序中所有页面的路由全部由框架进行管理。框架以栈的形式维护了当前的所有页面。 当发生路由切换的时候，页面栈的表现如下： 123456初始化-&gt; 新页面入栈打开新页面-&gt; 新页面入栈页面重定向-&gt; 当前页面出栈 新页面入栈页面返回-&gt; 页面不断出栈，直到目标返回页，新页面入栈Tab切换-&gt; 页面全部出栈 只留下新的Tab页面重加载-&gt; 页面全部出栈 只留下新的页面 小 tips： navigateTo, redirectTo 只能打开非 tabBar 页面。 switchTab 只能打开 tabBar 页面 reLaunch 可以打开任意页面 页面底部的 tabBar 由页面决定，即只要是定义为 tabBar 的页面，底部都有 tabBar。 视图层 **WXml **WXML（WeiXin Markup Language）是框架设计的一套标签语言，结合基础组件、事件系统，可以构建出页面的结构。WXML 在语法上更接近 XML 语言，遵循 SGML 规范，区别于 HTML 语言随意的标签闭合方式，WXML 语言必须包括开始标签和结束标签 基本语法WXML 中的动态数据均来自对应 Page 的 data。不同于 Vue 它是单向绑定 必须通过调用事件来 setData 新的数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;view&gt; {{ message }} &lt;/view&gt;Page({ data: { message: 'Hello MINA!' }})花括号和引号之间不能留空，否则将最终被解析成为字符串&lt;view wx:for=\"{{[1,2,3]}} \"&gt; {{item}}&lt;/view&gt;等同于&lt;view wx:for=\"{{[1,2,3] + ' '}}\" &gt; {{item}}&lt;/view&gt;当 wx:for 的值为字符串时，会将字符串解析成字符串数组&lt;view wx:for=\"yishu\"&gt; {{item}}&lt;/view&gt;===&lt;view wx:for=\"{{['y','i','s','h','u']}}\"&gt; {{item}}&lt;/view&gt;&lt;view wx:if=\"{{condition}}\"&gt; &lt;/view&gt;&lt;view wx:if=\"{{length &gt; 5}}\"&gt; &lt;/view&gt;关键字 需要在双引号之内 checked=\"false\"，其计算结果是一个字符串，转成 boolean 类型后代表真值。&lt;checkbox checked=\"{{false}}\"&gt; &lt;/checkbox&gt;&lt;view hidden=\"{{flag ? true : false}}\"&gt; Hidden &lt;/view&gt;条件渲染&lt;view wx:if=\"{{length &gt; 5}}\"&gt; 1 &lt;/view&gt;&lt;view wx:elif=\"{{length &gt; 2}}\"&gt; 2 &lt;/view&gt;&lt;view wx:else&gt; 3 &lt;/view&gt;如果想一次性判断多个组件标签 可以这么写&lt;block wx:if=\"{{true}}\"&gt; &lt;view&gt; view1 &lt;/view&gt; &lt;view&gt; view2 &lt;/view&gt;&lt;/block&gt; 是一个包装元素，不会在页面中做任何渲染，只接受控制属性。当然了 我是经常用View标签包裹的 关于 wx:if 与 hidden 简单来说 hidden为true的组件始终被渲染 只是切换 display与none状态 而 wx:if只有在条件成立的情况下才会被真的渲染 使用模版 模板拥有自己的作用域，只能使用 data 传入的数据。 12345678&lt;template name=\"msgItem\"&gt; &lt;view&gt; &lt;text&gt; {{index}}: {{msg}} &lt;/text&gt; &lt;text&gt; Time: {{time}} &lt;/text&gt; &lt;/view&gt;&lt;/template&gt;引用&lt;template is=\"msgItem\" data=\"{{...item}}\"/&gt; 事件 （冒泡 非冒泡）事件 API事件是视图层到逻辑层的通讯方式，当组件触发事件时，逻辑层绑定该事件的处理函数会收到一个事件对象。冒泡事件touchstart 手指触摸动作开始touchmove 手指触摸后移动touchcancel 手指触摸动作被打断，如来电提醒，弹窗touchend 手指触摸动作结束tap 手指触摸后马上离开longtap 手指触摸后，超过 350ms 再离开 bind 事件绑定不会阻止冒泡事件向上冒泡，catch 事件绑定可以阻止冒泡事件向上冒泡。 12345678视图层&lt;view id=\"tapTest\" data-hi=\"WeChat\" bindtap=\"tapName\"&gt; Click me! &lt;/view&gt;逻辑层Page({ tapName: function(event) { console.log(event) }}) 文件引入WXML 提供两种文件引用方式 import 和 include。 import 可以在该文件中使用目标文件定义的 template 1234567&lt;!-- item.wxml --&gt;&lt;template name=\"item\"&gt; &lt;text&gt;{{text}}&lt;/text&gt;&lt;/template&gt;引入模版&lt;import src=\"item.wxml\"/&gt;&lt;template is=\"item\" data=\"{{text: 'forbar'}}\"/&gt; import 有作用域的概念，即只会import 目标文件中定义的 template，而不会 import 目标文件 import 的 template。 include 可以将目标文件除了 &lt;template/&gt; 的整个代码引入 也就是说 copy 到了当前引入的位置 WXSSWXSS (WeiXin Style Sheets) 是一套样式语言，用于描述 WXML 的组件样式。 WXSS 支持的单位有 px、rem和rpx，其中 rem 和 rpx 可以针对屏幕容器进行适配，px 则为固定尺寸。其中 1rpx=0.5px，在 WXSS 和 WXML 中定义的 rpx 单位最终会转换为在手机端可以识别的 rem 单位。 建议：开发微信小程序时设计师可以用 iPhone6 作为视觉稿的标准。我们拿到 750 的设计稿，在 PS 中量取的容器大小，可以直接定义为 rpx，不需要进行 2 倍尺寸的换算，rpx 的单位不光在样式中会自适应，写在 WXML 的 style 里也会根据屏幕自适应。 像 CSS 一样 可以使用 @import 语句可以导入外联样式表，@import 后跟需要导入的外联样式表的 相对路径 import \"../../wxss/common.wxss\"; 为了提高渲染速度尽量避免静态样式存在于 style 中，除非需要接收动态样式才应该写在行内（貌似说了一句废话） &lt;view style=\"color:{{color}};\" /&gt; 全局样式与局部样式全局样式都在 app.wxss 中定义 page 里的 wxss 文件定义的是局部样式 局部样式可以覆盖同名的全局样式 运行机制 小程序没有重启的概念 当小程序进入后台，客户端会维持一段时间的运行状态，超过一定的时间后会自动销毁（目前是五分钟） 置顶的小程序不会被微信主动销毁 当收到内存警号时小程序会销毁","categories":[],"tags":[{"name":"wechat","slug":"wechat","permalink":"http://maying.ink/tags/wechat/"}]},{"title":"React 陷阱","slug":"React陷阱","date":"2017-07-01T16:00:00.000Z","updated":"2020-10-22T18:41:42.180Z","comments":true,"path":"2017/07/02/React陷阱/","link":"","permalink":"http://maying.ink/2017/07/02/React%E9%99%B7%E9%98%B1/","excerpt":"","text":"不要改变 props 错误例子： 123var component = &lt;Component /&gt;;component.props.foo = x; // badcomponent.props.bar = y; // also bad 这样写是错误的，因为我们手动直接添加的属性 React 后续没办法检查到属性类型错误，也就是说，当我们手动添加的属性发生类型错误时，在控制台是看不到错误信息的 在 React 的设定中，初始化完 props 后，props 是不可变的。改变 props 会引起无法想象的后果 正确写法： 1234var props = {};props.foo = x;props.bar = y;var component = &lt;Component {...props} /&gt;; 当需要拓展我们的属性的时候，定义个一个属性对象，并通过 {…props} 的方式引入，React 会帮我们拷贝到组件的 props 属性中。重要的是 — 这个过程是由 React 操控的，不是手动添赋值的属性 需要覆盖的时候可以这么写 123var props = { foo: 'default' };var component = &lt;Component {...props} foo={'override'} /&gt;; React 默认会进行 HTML 的转义如下 输入： 123456var content='&lt;strong&gt;content&lt;/strong&gt;';React.render( &lt;div&gt;{content}&lt;/div&gt;, document.body); 输出： 1&lt;stonrg&gt;content&lt;/strong&gt; 避免转义： 123456var content='&lt;strong&gt;content&lt;/strong&gt;'; React.render( &lt;div dangerouslySetInnerHTML={{__html: content}}&gt;&lt;/div&gt;, document.body); 如果在编写时使用了 react 自定义属性 react 是不会渲染的 错误做法： 1234React.render( &lt;div dd='xxx'&gt;content&lt;/div&gt;, document.body); 正确做法： 12345React.render( &lt;div data-dd='xxx' aria-dd='xxx'&gt;content&lt;/div&gt;, document.body);","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://maying.ink/tags/js/"},{"name":"react","slug":"react","permalink":"http://maying.ink/tags/react/"}]},{"title":"js 模块化编程系列（二）","slug":"js模块化编程系列（二）require.js","date":"2017-04-23T16:00:00.000Z","updated":"2020-10-22T18:41:42.182Z","comments":true,"path":"2017/04/24/js模块化编程系列（二）require.js/","link":"","permalink":"http://maying.ink/2017/04/24/js%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89require.js/","excerpt":"","text":"require.js 出现背景：所有的 javascript 代码都在一个文件中，代码越来越多时必须分成多个文件，依次加载，问题：加载 js 的时候浏览器停止渲染，加载文件越多，网页的响应时间就越长，由于 js 之间有依赖关系，因此必须严格保证加载顺序，当依赖关系变的复杂时，代码的编写和维护都会变的异常困难 加载 require.js 1234567891011&lt;script src=\"js/require.js\" defer async='true'&gt;&lt;/script&gt;async 表明这个文件需要异步加载在require.js的基础上加载自己的 main.js&lt;script src=\"require.js\" data-main=\"js/main\"&gt;&lt;/script&gt;ata-main:指定程序的主模块，这个人间会第一个被require.js加载，由于require.js默认的文件后缀名是js，所以可以把main.js 简写成main//main.jsrequire(['moduleA', 'moduleB', 'moduleC'], function (moduleA, moduleB, moduleC){ // some code here })`` 模块的加载当加载不同路径下的模块可以使用 require.config () 可以对模块的加载进行自定义， require.config () 就写在主模块 (main.js) 的头部，参数就是一个对象，这个对象的 path 属性指定各个模块的加载路径 12345678910111213141516171819202122232425 require.config({ paths: { \"jquery\": \"lib/jquery.min\", \"underscore\": \"lib/underscore.min\", \"backbone\": \"lib/backbone.min\" } }); 另一种形式 require.config({ baseUrl: \"js/lib\", paths: { \"jquery\": \"jquery.min\", \"underscore\": \"underscore.min\", \"backbone\": \"backbone.min\" } }); 再或者 require.config({ paths: { \"jquery\": \"https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min\" } }); AMD 模块的写法require.js 加载的模块采用 AMD 规范具体来说，就是模块必须采用特定的 define () 函数来定义，如果一个模块不依赖其他模块，那么可以直接定义在 define 函数中 1234567891011121314151617181920212223242526272829//math.js 定义了一个math模块define(function(){var add = function(){ return x+y;};return { add:add}})加载方法：// main.js require(['math'], function (math){ alert(math.add(1,1)); }); 如果这个模块还依赖其他模块，那么那么define()函数的第一个参数，必须是一个数组，指明该模块的依赖性。 define(['myLib'], function(myLib){ function foo(){ myLib.doSomething(); } return { foo : foo }; }); 当require()函数加载上面这个模块的时候，就会先加载myLib.js文件。 AMD 模块的写法加载非规范的模块理论上 require.js 加载的模块，必须是按照 AMD 规范、用 define () 函数定义的模块加载非规范模块，必须先用 require.config () 方法定义它们的一些特征 1234567891011121314151617181920212223242526eg：加载非AMD规范模块 underscore，backbone require.config({ shim: { 'underscore':{ exports: '_' }, 'backbone': { deps: ['underscore', 'jquery'], exports: 'Backbone' } } }); shim属性：专门用来配置不兼容的模块。具体来说，每个模块要定义 （1）exports值（输出的变量名），表明这个模块外部调用时的名称； （2）deps数组，表明该模块的依赖性。 eg： jQuery的插件可以这样定义： shim: { 'jquery.scroll': { deps: ['jquery'], exports: 'jQuery.fn.scroll' } } require 插件domready 插件，可以让回调函数在页面 DOM 结构加载完成后再运行。 1234require(['domready!'], function (doc){ // called once the DOM is ready }); text 和 image 插件，则是允许 require.js 加载文本和图片文件。 12345678910define([ 'text!review.txt', 'image!cat.jpg' ], function(review,cat){ console.log(review); document.body.appendChild(cat); } ); 类似的插件还有 json 和 mdown，用于加载 json 文件和 markdown 文件","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://maying.ink/tags/js/"}]},{"title":"js 模块化编程系列（一）","slug":"js模块化编程系列（一）","date":"2017-04-22T16:00:00.000Z","updated":"2020-10-22T18:41:42.182Z","comments":true,"path":"2017/04/23/js模块化编程系列（一）/","link":"","permalink":"http://maying.ink/2017/04/23/js%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"原始写法 12function m1(){}function m2(){} 缺点：污染了全局变量，容易与其它模块发生命名冲突，而且模块之间看不出直接关系 对象写法 12345var moudle = new Object({ _count = 0; m1:function(){}, m2:function(){}}) 缺点：会暴露所有模块成员，内部状态可以被外部改写 立即执行函数的写法 (达到不暴露私有成员的目的) 1234567891011121314var moudle1 = (function(){var count = 0;var m1 = function(){//...};var m2 = function(){//...};return { m1:m1, m2:m2 }})(); moudle1 就是 javascript 模块的基本写法 放大模式背景：如果一个模块很大必须分为几个部分，或者一个模块需要继承另外一个模块时 123456var moudle1 = (function(mod){ mod.m3 = function(){ //... } return mod; })(moudle1); 上面的代码为 moudle1 添加了一个新方法 m3，然后返回新的 moudle1 模块 宽放大模式背景：在浏览器环境中，模块的各个部分都是从网上获取的，有时候无法知道哪个部分会先加载，如果单纯采用放大模式，第一个执行的 部分有可能加载一个不存在的空对象 123456var moudle1 = (function(mod){ mod.m3 = function(){ //... } return mod; })(window.moudle1 || {}); 输入全局变量背景：保持模块独立性，内部最好不要与程序的其他部分直接交互 123var moudle1 = (function($,YAHOO){ //... })(jQuery, YAHOO); 保持独立的同时，模块的依赖关系变的更明显 模块的规范CommonJS 和 AMDCommonJS：nodejs 的模块系统，是参照 CommonJS 规范实现的，在 CommonJS 中，有一个全局方法 require ()，用于加载模块 1234eg:var math = require('math'); 调用math模块提供的方法： math.add(2,3); // 5 浏览器环境局限使 CommonJS 规范不适用于浏览器环境 12var math = require('math');math.add(2,3); // 5 在浏览器中运行，第二行在第一行之后运行，也就是说必须得等到 math 模块加载完成，如果加载时间很长，整个应用都会停在那里等，对于服务器端来说，所有模块都放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间，但是对于浏览器，这就是致命的问题，取决于网速， 所以，浏览器端的模块不能采用同步加载，要采用异步加载 AMD‘异步模块定义’，采用异步方式加载模块，所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，回调函数才执行AMD 也采用 require () 语句加载模块，不同于 CommonJS，它要求两个参数 1234require([module], callback)require(['math'], function (math) { math.add(2, 3); });","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://maying.ink/tags/js/"}]},{"title":"js 面向对象","slug":"js面向对象","date":"2017-04-20T16:00:00.000Z","updated":"2020-10-22T18:41:42.183Z","comments":true,"path":"2017/04/21/js面向对象/","link":"","permalink":"http://maying.ink/2017/04/21/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"工厂模式解决了重复实例化的问题 123456789101112function createObject(name,age){var obj = new Object();obj.name= name;obj.age = age;obj.run = function(){ return this.name + this.age + '运行中'}return obj;}var box1 = createObject（‘lee’,100）var box2 = createObject（‘jack’,200） 工厂模式的缺点：无法区分实例是哪个对象的实例 构造函数模式 123456789function Box(name,age){ this.name= name; this.age = age; this.run = function(){ return this.name + this.age + '运行中' }}var box3 = new Box（‘lee’,100）var box4 = new Box（‘jack’,200） 如何识别了对象？构造函数没有 new Object，但是它后台回自动 var obj = new Object ();this 指的就是 obj没有返回值 console.log(box4 instanceof Box) 对象冒充把 o 冒充成 box 对象 12var o = new Object();Box.call(o,'Lee',100) 原型 prototype 原型属性是一个对象 1function Box(){} 这里如果有属性或者方法 叫做实例属性和实例方法 12Box.prototypr.name 原型属性Box.prototypr.run=function(){} 原型方法 _proto_： 实际上是一个指向原型对象的一个指针，它的作用就是指向构造函数的原型属性 constructor 123var box1 = new Box()box1.constructor 指向构造函数box1._proto_指向原型对象 判断一个对象实例是不是指向了对象的原型对象，实例化之后是自动指向的 1Box.prototype.isPrototypeOf(box1) 什么叫闭包？ 有什么用 闭包是指有权访问另一个作用域中的变量和函数，常见的形式是在某个作用域中定义的函数 闭包的作用域链包括三部分： 函数本身作用域 闭包定义的作用域 全局作用域 闭包的常见用途？ 读取函数内部的变量 将变量始终保持在内存中 模拟面向对象的代码风格 匿名执行函数 不加 var 关键字 默认回呗添加到全局对象的属性中去，类似的临时变量的属性加入全局对象有很多坏处比如：别的函数可能误用这些变量 造成全局变量过于庞大，影响访问速度（因为变量的取值是需要从圆形链上遍历的） 123456789101112131415161718var datamodel = { table : [], tree : {} }; (function(dm){ for(var i = 0; i &lt; dm.table.rows; i++){ var row = dm.table.rows[i]; for(var j = 0; j &lt; row.cells; i++){ drawCell(i, j); } } //build dm.tree })(datamodel); 创建了一个匿名的函数并立即执行它，由于外部无法引用它内部的变量，因此在执行之后很快就会被释放 不会污染全局对象 缓存 设想我们有一个处理过程很耗时的函数对象，每次调用都会花费很长时间，那么我们就需要将计算出来的值存储起来，当调用这个函数的时候，首先在缓存中查找，如果找不到，则进行计算，然后更新缓存并返回值，如果找到了，直接返回查找到的值即可。闭包正是可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得以保留。 实现封装 123456789101112131415161718var person = function(){ //变量作用域为函数内部，外部无法访问 var name = \"default\"; return { getName : function(){ return name; }, setName : function(newName){ name = newName; } } }(); print(person.name);//直接访问，结果为undefined print(person.getName()); person.setName(\"abruzzi\"); print(person.getName());","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://maying.ink/tags/js/"}]},{"title":"ES6 系列 (一)","slug":"ES6","date":"2017-04-19T16:00:00.000Z","updated":"2020-10-22T18:41:42.178Z","comments":true,"path":"2017/04/20/ES6/","link":"","permalink":"http://maying.ink/2017/04/20/ES6/","excerpt":"","text":"数组的扩展Array.form () 将两类对象转换为数组1. 类似数组的对象2. 可遍历的对象 123456let arrayLike = {'0':'a','1':'b','2':'c','3':'d'} ES5 写法 1var arr1 = [].slice.call(arrayLike) ES6 写法 1let arr2 = Array.form(arrayLike) 任何有 length 属性的对象，都可以通过 Array.from 方法转为数组，而此时扩展运算符就无法转换。 值得提醒的是，扩展运算符（…）也可以将某些数据结构转为数组。 12345678910111213141516171819202122232425// arguments对象function foo() { var args = [...arguments];}// NodeList对象[...document.querySelectorAll('div')]Array.from还可以接受第二个参数，作用类似于数组的map方法Array.from(arrayLike, x =&gt; x * x);// 等同于Array.from(arrayLike).map(x =&gt; x * x);Array.of()Array.of方法用于将一组值，转换为数组。Array.of(3, 11, 8) // [3,11,8]Array.of(3) // [3]Array.of(3).length // 1[1, 5, 10, 15].find(function(value, index, arr) { return value &gt; 9;}) // 10 fill 方法使用给定值，填充一个数组。 1['a', 'b', 'c'].fill(7) ES6 提供三个新的方法 ——entries()**，keys() 和 values ()**—— 用于遍历数组 1[1, 2, 3].includes(2); // true for of 循环 ES6 引入 rest 参数（形式为 “… 变量名”），用于获取函数的多余参数 扩展运算符（spread）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。console.log(…[1, 2, 3])// 1 2 3 函数的 name 属性，返回该函数的函数名。 12function foo() {}foo.name // \"foo\" （1）函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。 对象的扩展var bax= {bac} = var baz = {bac:bac} 123456var o = {method:function(){}} ==var o = { method(){}} let propKey = ‘foo’; let obj = { [propKey]: true, [‘a’ + ‘bc’]: 123}; const person = { sayName() { console.log(‘hello!’); },}; person.sayName.name // “sayName” Object.is（）用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。 123456Object.is('foo', 'foo')// trueObject.is({}, {})// false不同之处只有两个：一是+0不等于-0，二是NaN等于自身 Object.is(+0, -0) // false Object.is(NaN, NaN) // true Object.assign () 实行的是浅拷贝不是深拷贝如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。 例子 123456789101112131415161718192021222324252627282930313233var obj1 = {a: {b: 1}};var obj2 = Object.assign({}, obj1);obj1.a.b = 2; 如果值更改 则拷贝之后的值也是变化的obj2.a.b // 2如果该参数不是对象，则会先转成对象，然后返回。typeof Object.assign(2) // \"object\"Object.assign可以用来处理数组，但是会把数组视为对象。Object.assign([1, 2, 3], [4, 5])// [4, 5, 3]Object.assign(someClass.prototype,{someMethod(){...},antherMethod(){...}})===// 等同于下面的写法SomeClass.prototype.someMethod = function (arg1, arg2) { ···};SomeClass.prototype.anotherMethod = function () { ···}; 克隆对象只能可通他自身的值而不能可通它继承的值 123function clone(origin){ return Object.assign({},origin)} 1234function clone(origin) { let originProto = Object.getPrototypeOf(origin); return Object.assign(Object.create(originProto), origin);} 123456789Object.getOwnPropertyDescriptor 获取该属性的描述对象let obj = { foo: 123 };Object.getOwnPropertyDescriptor(obj, 'foo')// {// value: 123,// writable: true,// enumerable: true,// configurable: true// } Object.keys 方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。 123var obj = { foo: 'bar', baz: 42 };Object.keys(obj)// [\"foo\", \"baz\"] 123var obj = { foo: 'bar', baz: 42 };Object.values(obj)// [\"bar\", 42] 1234var obj = { foo: 'bar', baz: 42 };Object.entries(obj)// [ [\"foo\", \"bar\"], [\"baz\", 42] ] ES6 中遍历对象的属性 for…in 循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性） Object.keys 返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）。 Object.getOwnPropertyNames 返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性） Object.getOwnPropertySymbols 返回一个数组，包含对象自身的所有 Symbol 属性。 __proto__属性（前后各两个下划线），用来读取或设置当前对象的 prototype 对象。目前，所有浏览器（包括 IE11）都部署了这个属性。 12345// es6的写法var obj = { method: function() { ... }};obj.__proto__ = someOtherObj; 1234567891011let proto = {};let obj = { x: 10 };Object.setPrototypeOf(obj, proto);proto.y = 20;proto.z = 40;obj.x // 10obj.y // 20obj.z // 40上面代码将proto对象设为obj对象的原型，所以从obj对象可以读取proto对象的属性。 ES6 引入的原始类型 “Symbol凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。Symbol 函数前不能使用 new 命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。Symbol 值不能与其他类型的值进行运算，会报错。但是，Symbol 值可以显式转为字符串。另外，Symbol 值也可以转为布尔值，但是不能转为数值。 let s = Symbol(); typeof s 数组去重 新增的数据结构 Set Map 123const s = new Set();[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x)); 12var set = new Set([1, 2, 3, 4, 4]);[...set] // 去除数组的重复成员在 Set 内部，两个 NaN 是相等。 123[...new Set(array)]var set = new Set([1,1,2,2,3,4,5,5,6])[...set] 1234let map = new Map([ ['F', 'no'], ['T', 'yes'],]); 123for (let key of map.keys()) { console.log(key);} Proxy（代理器） 元编程（对编程语言进行编程） 在目标对象之前设置一层拦截 外界对它的访问必须先通过这一层拦截 1234567891011var obj = new Proxy({}, { get: function (target, key, receiver) { console.log(`getting ${key}!`); return Reflect.get(target, key, receiver); }, set: function (target, key, value, receiver) { console.log(`setting ${key}!`); return Reflect.set(target, key, value, receiver); }}); 重写了 get 和 set 方法 12345678910111213var proxy = new Proxy(target, handler);var proxy = new Proxy({}, { get: function(target, property) { return 35; }});proxy.time // 35proxy.name // 35proxy.title // 35 Promise (承诺) 所谓 Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 123456789101112131415var promise = new Promise(function(resolve,reject){if('异步操作成功'){resolve(value)}else{reject(error)}})promise.then(function(value){成功},function(error){失败}) 遍历器对象本质上，就是一个指针对象。 回调函数事件监听发布 / 订阅Promise 对象 Generator 函数yield 表示执行到此处执行权将交给其它协程也就是说 yield 命令部两个阶段的分界线 Generator 函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象 12345678function* gen(x){ try{ var y = yield x +2; }catch(e){ console.log(e) } return y } 1234567var fetch = require('node-fetch'); function* gen(){ var url = 'http://api.github.com/users/github'; var result = yield fetch (url); console.log('ds') } Thunk 函数是自动执行 generator 函数的一种方法 传名调用 123 f(x + 5)// 传名调用时，等同于f(x + 5) 传值调用 123 f(x + 5)// 传值调用时，等同于f(6) Thunk 是传名调用的实现，将参数放到一个临时的函数中，再将这个临时函数传入函数体 这个临时函数叫做 Thunk 函数 12345678910111213141516var x = 1;function f(m){ return m*2;}f(x+5)等同于var thunk = function(){ return x+5}function (thunk){return thunk()*2} async ：Generator 函数的语法糖 123456var asyncReadFile = async function () { var f1 = await readFile('/etc/fstab'); var f2 = await readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString());}; async 🌧️generator 比较 async 有内置执行器 不需要调用 next 方法拥有更好的语义（比起星号和 yield 语义更清楚了） async 函数返回的是 promise 对象比 Generator 函数返回值是 Iterator 对象方便多了 可以用 then 方法指定下一步操作 async 和 await async 表示函数中有异步操作 await 表示紧跟在后面的表达式需要等待结果 async 函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而 await 命令就是内部 then 命令的语法糖。 async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。当函数执行的时候，一旦遇到 await 就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。 错误处理 12345678910111213141516171819202122232425262728async function f() { await new Promise(function (resolve, reject) { throw new Error('出错了'); });}async function main() { try { var val1 = await firstStep(); var val2 = await secondStep(val1); var val3 = await thirdStep(val1, val2); console.log('Final: ', val3); } catch (err) { console.error(err); }}async function myFunction() { try { await somethingThatReturnsAPromise(); } catch (err) { console.log(err); }} class基本形式 1234567891011121314class Point{constructor(x,y){this.x = x;this.y = y}toString(){ return '(' + this.x + ', ' + this.y + ')';}} Class 不存在变量提升（hoist），这一点与 ES5 完全不同。 12345const MyClass = class Me { getClassName() { return Me.name; }}; 类名是 MyClass 而不是 me Me 只在 Class 的内部代码可用，指代当前类。 const MyClass = class { /* … */ }; 模块加载方案 CommonJs 应用于服务器 AMD 应用于浏览器 ES6 提供模块功能 尽量的静态化) 1import {stat，exut，readFile} from 'fs' Es6 模块是编译时加载 ES6 的模块自动采用严格模式 12function f(){} export {f} 12import {lastName as surname} from './profile'import命令具有提升效果 123456导出export default引入import * as circle from './circle'; 模块的整体加载 使用 import 命令的时候用户不需要知道所加载的变量名或者函数名 用这个语法可以为模块指定默认输出 123export default function (){ console.log('foo') } 引入的时候 import 可以为该匿名函数指定任意的名字，这个时候 import 的后面不使用大括号 123456789101112import customName from .. export default function ee (){ console.log('foo')}==function foo (){console.log('ee')}export default foo; foo 的函数名 foo 在模块外部时无效的 视同匿名函数加载 使用 export 时，对应的 import 语句需要使用大括号。 使用 export default 对应的 import 语句不需要大括号 12345678910111213141516 // 第一组export default function crc32() { // 输出 // ...}import crc32 from 'crc32'; // 输入import { default as xxx } from 'modules';// 第二组export function crc32() { // 输出 // ...};import {crc32} from 'crc32'; // 输入 本质上，export default 就是输出一个叫做 default 的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。 import { default as xxx } from ‘modules’ 1export {add as default}; // 等同于 1// export default add; ES6 模块 12&lt;script type=\"module\" src=\"foo.js\"&gt;&lt;/script&gt; 都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了标签的defer属性。 拷贝数组 1234const itemCopy &#x3D; [];const item &#x3D; [1,2,3]itemCopy &#x3D; [...item]console.log(itemCopy)","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://maying.ink/tags/js/"},{"name":"es6","slug":"es6","permalink":"http://maying.ink/tags/es6/"}]},{"title":"Express 框架系列 (二) 之运行原理","slug":"Express框架系列(二)之运行原理","date":"2017-04-17T16:00:00.000Z","updated":"2020-10-22T18:41:42.179Z","comments":true,"path":"2017/04/18/Express框架系列(二)之运行原理/","link":"","permalink":"http://maying.ink/2017/04/18/Express%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97(%E4%BA%8C)%E4%B9%8B%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/","excerpt":"","text":"底层 HTTP 模块Express 框架建立在 node.js 内置的 http 模块上，框架的核心是对 HTTP 模块的再包装http 模块生成服务器的原始代码如下： 12345678var http = require(\"http\");var app = http.createServer(function(request, response) { response.writeHead(200, {\"Content-Type\": \"text/plain\"}); response.end(\" express hahahah\");});app.listen(4040, \"localhost\"); 上面的代码关键是 http 模块的 createServer 方法，表示生成一个 http 服务器实例，该方法接受一个回调函数，回调函数的两个参数分别代表 HTTP 请求和 HTTP 响应的 request 对象和 response 对象 上面的代码用 Express 改写如下 12345678var express = require('express');var app = express();app.get('/', function (req, res) { res.send('Hello world!');});app.listen(7000); 可以发现两端代码特别相似，原来是用 http.createServer 方法新建一个 app 实例，现在则是用 Express 的构造方法，生成一个 Epress 实例，两种方法的回调函数都是相同的，Express 等于在 HTTP 模块之上，加了一个中间层 什么是中间件中间件就是处理 HTTP 请求的函数，特点：一个中间件处理完再传递给下一个中间件，APP 实例在运行中会调用一系列的中间件 每个中间件可以从 APP 实例接收三个参数 request (代表 HTTP 请求)，response (代表 HTTP 响应),next 回调函数 (代表下一个中间件)，每一个中间件都可以对 HTTP 请求 (request 对象) 进行加工，并且决定是否调用 next 方法，将 request 对象再传给下一个中间件 最简单的中间件 123456789101112function uselessMiddleware(req,res,next){next()}上面代码的next就是下一个中间件。如果它带有参数，则代表抛出一个错误，参数为错误文本。function uselessMiddleware(req, res, next) { next('出错了！');}抛出错误以后，后面的中间件将不再执行，直到发现一个错误处理函数为止。 use 方法use 是 express 注册中间件的方法，使用 app.use 方法，注册了两个中间件，收到 HTTP 请求后，先调用第一个中间件，根据 next () 确定是否把 request 对象传递到下一个中间件 12345678910111213141516var express = require(\"express\");var http = require(\"http\");var app = express();app.use(function(request, response, next) { console.log(\"In comes a \" + request.method + \" to \" + request.url); next();});app.use(function(request, response) { response.writeHead(200, { \"Content-Type\": \"text/plain\" }); response.end(\"Hello world!\\n\");});http.createServer(app).listen(1337); use 方法内部通过 request.url 的属性可以根据访问路径进行判断，据此就能实现简单的路由， 123456789101112131415161718192021222324252627var express = require(\"express\");var http = require(\"http\");var app = express();app.use(function(request,response,next){ if(request.url == \"/\"){ response.writeHead(200, { \"Content-Type\": \"text/plain\" }); response.end(\"Welcome to the homepage!\\n\"); }else{ next(); }})app.use(function(request, response, next) { if (request.url == \"/about\") { response.writeHead(200, { \"Content-Type\": \"text/plain\" }); } else { next(); }});app.use(function(request, response) { response.writeHead(404, { \"Content-Type\": \"text/plain\" }); response.end(\"404 error!\\n\");});http.createServer(app).listen(1337); 另外一种比较清晰的方式（上面代码表示，只对根目录的请求，调用某个中间件。）app.use('/path', someMiddleware);按照这个思想，改造中间件 123456789101112131415161718192021var express = require(\"express\");var http = require(\"http\");var app = express();app.use(\"/home\", function(request, response, next) { response.writeHead(200, { \"Content-Type\": \"text/plain\" }); response.end(\"Welcome to the homepage!\\n\");});app.use(\"/about\", function(request, response, next) { response.writeHead(200, { \"Content-Type\": \"text/plain\" }); response.end(\"Welcome to the about page!\\n\");});app.use(function(request, response) { response.writeHead(404, { \"Content-Type\": \"text/plain\" }); response.end(\"404 error!\\n\");});http.createServer(app).listen(1337);","categories":[],"tags":[{"name":"node","slug":"node","permalink":"http://maying.ink/tags/node/"}]},{"title":"Express 框架系列 (一) 之概述","slug":"Express框架系列(一)之概述","date":"2017-04-16T16:00:00.000Z","updated":"2020-10-22T18:41:42.179Z","comments":true,"path":"2017/04/17/Express框架系列(一)之概述/","link":"","permalink":"http://maying.ink/2017/04/17/Express%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97(%E4%B8%80)%E4%B9%8B%E6%A6%82%E8%BF%B0/","excerpt":"","text":"参考文档：http://javascript.ruanyifeng.com/nodejs/express.htmlExpress 是目前最流行的基于 Node.js 的 Web 开发框架，可以快速地搭建一个完整功能的网站。 创建测试项目mkdir hello-world 进入该目录，新建一个 package.json 文件，内容如下。 12345678910{ \"name\": \"hello-world\", \"description\": \"hello world test app\", \"version\": \"0.0.1\", \"private\": true, \"dependencies\": { \"express\": \"4.x\" }} 安装 expressnpm install执行上面的命令以后，在项目根目录下，新建一个启动文件，假定叫做 index.js。 123456var express = require('express');var app = express();app.use(express.static(__dirname + '/public'));app.listen(8080); 运行启动脚本node index访问 http://localhost:8080它会在浏览器中打开当前目录的 public 子目录（严格来说，是打开 public 目录的 index.html 文件）。如果 public 目录之中有一个图片文件 my_image.png，那么可以用 http://localhost:8080/my_image.png 访问该文件。 目录结构 执行结果也可以 http://localhost:8080/WX.jpeg 也可以生成动态网页 express 12345var app = express();app.get('/', function (req, res) { res.send('Hello world!');});app.listen(3000); 运行启动脚本node index 启动脚本 index.js 的 app.get 方法，用于指定不同的访问路径所对应的回调函数，这叫做 “路由”（routing）。上面代码只指定了根目录的回调函数，因此只有一个路由记录。实际应用中，可能有多个路由记录。 12345678910111213141516比如：var express = require('express');var app = express();app.get('/', function (req, res) { res.send('Hello world!');});app.get('/customer', function(req, res){ res.send('customer page');});app.get('/admin', function(req, res){ res.send('admin page');});app.listen(3000); 比较庞大的时候可以单独存放eg： 12345678910111213// routes/index.jsmodule.exports = function (app) { app.get('/', function (req, res) { res.send('Hello world'); }); app.get('/customer', function(req, res){ res.send('customer page'); }); app.get('/admin', function(req, res){ res.send('admin page'); });}; 原先的 index 引入 12345// index.jsvar express = require('express');var app = express();var routes = require('./routes')(app);app.listen(3000);","categories":[],"tags":[{"name":"node","slug":"node","permalink":"http://maying.ink/tags/node/"}]},{"title":"Node.js 系列 (一) 之安装","slug":"nodeJs系列一","date":"2017-04-12T16:00:00.000Z","updated":"2020-10-22T18:41:42.184Z","comments":true,"path":"2017/04/13/nodeJs系列一/","link":"","permalink":"http://maying.ink/2017/04/13/nodeJs%E7%B3%BB%E5%88%97%E4%B8%80/","excerpt":"","text":"node 简介node 是 javascript 语言的服务器运行环境所谓的运行环境有两层意思： javascript 语言通过 node 在服务器运行，在这个意义上，node 是 javascriprt 的虚拟机 node 提供大量的工具库，使得 javascript 语言与操作系统互动（比如读写文件，新建子进程），在这个意义上，node 又是 javascrip 的工具库Node 内部采用 Google 公司的 V8 引擎，作为 JavaScript 语言解释器；通过自行开发的 libuv 库，调用操作系统资源。什么是 Google V8 JavaScript 引擎V8 是一个由丹麦 Google 开发的开源 JavaScript 引擎，V8 就是 chrome 浏览器用的 js 解释引擎，主要是 C 编写的V8 在执行之前将 JavaScript 编译成了机器码，而非位元组码或是直译它，以此提升效能。更进一步，有了这些功能，JavaScript 程序与 V8 引擎的速度媲美二进制编译。[4]安装相关访问官方网站 nodejs.org安装完成查看 node 版本 123$ node --version 或者$ node -v 更新 node 版本，可以通过 node.js 的 n 模块完成，更新为最新发布的稳定版。 12$ sudo npm install n -g$ sudo n stable 1$ sudo n 0.10.21 安装版本管理工具 nvm如果想在同一台机器同时安装多个版本的 node，就需要用到嗯本管理工具 nvm，nvm 全称 Node Version Manager，它与 n 的实现方式不同，其是通过 shell 脚本实现的。 12$ git clone https://github.com/creationix/nvm.git ~/.nvm$ source ~/.nvm/nvm.sh 安装最新版本1$ nvm install node 安装指定版本1$ nvm install 0.12.1 ###### 使用已安装的最新版本 1$ nvm use node 使用指定版本的 node1$ nvm use 0.12 查看本地安装的所有版本1$ nvm ls 退出已经激活的 nvm，使用 deactivate 命令。1$ nvm deactivate ###### 卸载 nvm 1rm -rf ~/.nvm ###### 查看 nvm 帮助 1nvm -h 详细文档请参考官方文档https://github.com/creationix/nvm","categories":[],"tags":[{"name":"node","slug":"node","permalink":"http://maying.ink/tags/node/"}]}],"categories":[{"name":"前端","slug":"前端","permalink":"http://maying.ink/categories/%E5%89%8D%E7%AB%AF/"},{"name":"web","slug":"web","permalink":"http://maying.ink/categories/web/"},{"name":"js","slug":"js","permalink":"http://maying.ink/categories/js/"},{"name":"CSS","slug":"CSS","permalink":"http://maying.ink/categories/CSS/"},{"name":"react","slug":"react","permalink":"http://maying.ink/categories/react/"},{"name":"杂谈","slug":"杂谈","permalink":"http://maying.ink/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://maying.ink/tags/Node-js/"},{"name":"前端体系","slug":"前端体系","permalink":"http://maying.ink/tags/%E5%89%8D%E7%AB%AF%E4%BD%93%E7%B3%BB/"},{"name":"Vue","slug":"Vue","permalink":"http://maying.ink/tags/Vue/"},{"name":"组件设计","slug":"组件设计","permalink":"http://maying.ink/tags/%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1/"},{"name":"this","slug":"this","permalink":"http://maying.ink/tags/this/"},{"name":"clone","slug":"clone","permalink":"http://maying.ink/tags/clone/"},{"name":"作用域","slug":"作用域","permalink":"http://maying.ink/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"name":"闭包","slug":"闭包","permalink":"http://maying.ink/tags/%E9%97%AD%E5%8C%85/"},{"name":"promise","slug":"promise","permalink":"http://maying.ink/tags/promise/"},{"name":"flex","slug":"flex","permalink":"http://maying.ink/tags/flex/"},{"name":"call","slug":"call","permalink":"http://maying.ink/tags/call/"},{"name":"apply","slug":"apply","permalink":"http://maying.ink/tags/apply/"},{"name":"bind","slug":"bind","permalink":"http://maying.ink/tags/bind/"},{"name":"前端","slug":"前端","permalink":"http://maying.ink/tags/%E5%89%8D%E7%AB%AF/"},{"name":"setState","slug":"setState","permalink":"http://maying.ink/tags/setState/"},{"name":"缓存","slug":"缓存","permalink":"http://maying.ink/tags/%E7%BC%93%E5%AD%98/"},{"name":"CORS","slug":"CORS","permalink":"http://maying.ink/tags/CORS/"},{"name":"js","slug":"js","permalink":"http://maying.ink/tags/js/"},{"name":"react","slug":"react","permalink":"http://maying.ink/tags/react/"},{"name":"node","slug":"node","permalink":"http://maying.ink/tags/node/"},{"name":"issue","slug":"issue","permalink":"http://maying.ink/tags/issue/"},{"name":"design_mode","slug":"design-mode","permalink":"http://maying.ink/tags/design-mode/"},{"name":"mobile","slug":"mobile","permalink":"http://maying.ink/tags/mobile/"},{"name":"杂谈","slug":"杂谈","permalink":"http://maying.ink/tags/%E6%9D%82%E8%B0%88/"},{"name":"wechat","slug":"wechat","permalink":"http://maying.ink/tags/wechat/"},{"name":"es6","slug":"es6","permalink":"http://maying.ink/tags/es6/"}]}